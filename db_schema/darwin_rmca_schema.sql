--
-- PostgreSQL database dump
--

-- Dumped from database version 12.9 (Ubuntu 12.9-0ubuntu0.20.04.1)
-- Dumped by pg_dump version 14.4

-- Started on 2022-09-09 19:06:49

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- TOC entry 17 (class 2615 OID 18660)
-- Name: clean; Type: SCHEMA; Schema: -; Owner: darwin2
--

CREATE SCHEMA clean;


ALTER SCHEMA clean OWNER TO darwin2;

--
-- TOC entry 15 (class 2615 OID 18661)
-- Name: darwin2; Type: SCHEMA; Schema: -; Owner: darwin2
--

CREATE SCHEMA darwin2;


ALTER SCHEMA darwin2 OWNER TO darwin2;

--
-- TOC entry 34 (class 2615 OID 18662)
-- Name: drosera_import; Type: SCHEMA; Schema: -; Owner: darwin2
--

CREATE SCHEMA drosera_import;


ALTER SCHEMA drosera_import OWNER TO darwin2;

--
-- TOC entry 16 (class 2615 OID 18663)
-- Name: eod; Type: SCHEMA; Schema: -; Owner: darwin2
--

CREATE SCHEMA eod;


ALTER SCHEMA eod OWNER TO darwin2;

--
-- TOC entry 33 (class 2615 OID 18664)
-- Name: fdw_113; Type: SCHEMA; Schema: -; Owner: darwin2
--

CREATE SCHEMA fdw_113;


ALTER SCHEMA fdw_113 OWNER TO darwin2;

--
-- TOC entry 5 (class 3079 OID 18608)
-- Name: fuzzystrmatch; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS fuzzystrmatch WITH SCHEMA public;


--
-- TOC entry 6764 (class 0 OID 0)
-- Dependencies: 5
-- Name: EXTENSION fuzzystrmatch; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION fuzzystrmatch IS 'determine similarities and distance between strings';


--
-- TOC entry 8 (class 3079 OID 18395)
-- Name: hstore; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA public;


--
-- TOC entry 6765 (class 0 OID 0)
-- Dependencies: 8
-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION hstore IS 'data type for storing sets of (key, value) pairs';


--
-- TOC entry 2 (class 3079 OID 1880448)
-- Name: intarray; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS intarray WITH SCHEMA public;


--
-- TOC entry 6766 (class 0 OID 0)
-- Dependencies: 2
-- Name: EXTENSION intarray; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION intarray IS 'functions, operators, and index support for 1-D arrays of integers';


--
-- TOC entry 7 (class 3079 OID 18520)
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- TOC entry 6767 (class 0 OID 0)
-- Dependencies: 7
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'text similarity measurement and index searching based on trigrams';


--
-- TOC entry 4 (class 3079 OID 18619)
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;


--
-- TOC entry 6768 (class 0 OID 0)
-- Dependencies: 4
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- TOC entry 9 (class 3079 OID 17386)
-- Name: postgis; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA public;


--
-- TOC entry 6769 (class 0 OID 0)
-- Dependencies: 9
-- Name: EXTENSION postgis; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION postgis IS 'PostGIS geometry, geography, and raster spatial types and functions';


--
-- TOC entry 3 (class 3079 OID 18656)
-- Name: postgres_fdw; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgres_fdw WITH SCHEMA public;


--
-- TOC entry 6770 (class 0 OID 0)
-- Dependencies: 3
-- Name: EXTENSION postgres_fdw; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION postgres_fdw IS 'foreign-data wrapper for remote PostgreSQL servers';


--
-- TOC entry 6 (class 3079 OID 18597)
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;


--
-- TOC entry 6771 (class 0 OID 0)
-- Dependencies: 6
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- TOC entry 2163 (class 1247 OID 18667)
-- Name: rmca_taxon_report; Type: TYPE; Schema: darwin2; Owner: darwin2
--

CREATE TYPE darwin2.rmca_taxon_report AS (
	domain character varying,
	kingdom character varying,
	super_phylum character varying,
	phylum character varying,
	sub_phylum character varying,
	infra_phylum character varying,
	super_cohort_botany character varying,
	cohort_botany character varying,
	sub_cohort_botany character varying,
	infra_cohort_botany character varying,
	super_class character varying,
	class character varying,
	sub_class character varying,
	infra_class character varying,
	super_division character varying,
	division character varying,
	sub_division character varying,
	infra_division character varying,
	super_legion character varying,
	legion character varying,
	sub_legion character varying,
	infra_legion character varying,
	super_cohort_zoology character varying,
	cohort_zoology character varying,
	sub_cohort_zoology character varying,
	infra_cohort_zoology character varying,
	super_order character varying,
	"order" character varying,
	sub_order character varying,
	infra_order character varying,
	section_zoology character varying,
	sub_section_zoology character varying,
	super_family character varying,
	family character varying,
	sub_family character varying,
	infra_family character varying,
	super_tribe character varying,
	tribe character varying,
	sub_tribe character varying,
	infra_tribe character varying,
	genus character varying,
	sub_genus character varying,
	section_botany character varying,
	sub_section_botany character varying,
	serie character varying,
	sub_serie character varying,
	super_species character varying,
	species character varying,
	sub_species character varying,
	variety character varying,
	sub_variety character varying,
	form character varying,
	sub_form character varying,
	abberans character varying
);


ALTER TYPE darwin2.rmca_taxon_report OWNER TO darwin2;

--
-- TOC entry 708 (class 1255 OID 18668)
-- Name: array_sort(anyarray); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.array_sort(anyarray) RETURNS anyarray
    LANGUAGE sql
    AS $_$
SELECT ARRAY(SELECT unnest($1) ORDER BY 1)
$_$;


ALTER FUNCTION darwin2.array_sort(anyarray) OWNER TO darwin2;

--
-- TOC entry 709 (class 1255 OID 18669)
-- Name: check_auto_increment_code_in_loan(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.check_auto_increment_code_in_loan() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE 
   col collections;
  loan RECORD;
  number text ;
  colcode varchar;

BEGIN
loan = NEW ;
SELECT parse[1], parse[3] into colcode,number FROM (SELECT regexp_matches(loan.name, '(.+)(_)([1-9]+)') as parse) AS a;
SELECT c.* INTO col FROM collections c JOIN specimens s ON s.collection_ref=c.id  WHERE TRIM(code)=TRIM(colcode);
  IF (col.id IS NOT NULL) AND isnumeric(number) THEN
    IF col.loan_auto_increment = TRUE  THEN 
      IF number::int > col.loan_last_value THEN
        UPDATE collections set loan_last_value = number::int WHERE id=col.id ;
      END IF;
    END IF;
  --ELSE
	--RAISE EXCEPTION 'COLLECTION NOT FOUND OR HAS NO SPECIMEN';
  END IF ;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.check_auto_increment_code_in_loan() OWNER TO darwin2;

--
-- TOC entry 716 (class 1255 OID 18670)
-- Name: check_auto_increment_code_in_spec(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.check_auto_increment_code_in_spec() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  col collections%ROWTYPE;
  number BIGINT ;
BEGIN
  IF TG_OP != 'DELETE' THEN
    IF NEW.referenced_relation = 'specimens' THEN
      SELECT c.* INTO col FROM collections c INNER JOIN specimens s ON s.collection_ref=c.id WHERE s.id=NEW.record_id;
      IF FOUND THEN
        IF NEW.code_category = 'main' THEN
          IF isinteger(NEW.code) AND strpos(NEW.code, 'E') = 0 THEN
            number := NEW.code::bigint;
            IF number > col.code_last_value THEN
              UPDATE collections set code_last_value = number WHERE id=col.id ;
            END IF;
          ELSE
            UPDATE collections
            SET code_last_value = (SELECT max(code_num)
                                   FROM codes inner join specimens
                                     ON codes.referenced_relation = 'specimens'
                                     AND codes.record_id = specimens.id
                                   WHERE codes.code_category = 'main'
                                     AND specimens.collection_ref = col.id
                                     AND codes.code_num IS NOT NULL
                                  )
            WHERE id = col.id
              AND EXISTS (SELECT 1
                          FROM codes inner join specimens
                            ON codes.referenced_relation = 'specimens'
                            AND codes.record_id = specimens.id
                          WHERE codes.code_category = 'main'
                            AND specimens.collection_ref = col.id
                            AND codes.code_num IS NOT NULL
                          LIMIT 1
                         );
            IF NOT FOUND THEN
              UPDATE collections
              SET code_last_value = DEFAULT
              WHERE id=col.id;
            END IF;
          END IF;
        ELSEIF TG_OP = 'UPDATE' THEN
          IF OLD.code_category = 'main' THEN
            IF isinteger(OLD.code) AND strpos(OLD.code, 'E') = 0 THEN
              number := OLD.code::bigint;
              IF number = col.code_last_value THEN
                UPDATE collections
                SET code_last_value = (SELECT max(code_num)
                                       FROM codes inner join specimens
                                         ON codes.referenced_relation = 'specimens'
                                         AND codes.record_id = specimens.id
                                       WHERE codes.code_category = 'main'
                                         AND specimens.collection_ref = col.id
                                         AND codes.code_num IS NOT NULL
                                      )
                WHERE id = col.id
                  AND EXISTS (SELECT 1
                              FROM codes inner join specimens
                                ON codes.referenced_relation = 'specimens'
                                AND codes.record_id = specimens.id
                              WHERE codes.code_category = 'main'
                                AND specimens.collection_ref = col.id
                                AND codes.code_num IS NOT NULL
                              LIMIT 1
                             );
                IF NOT FOUND THEN
                  UPDATE collections
                  SET code_last_value = DEFAULT
                  WHERE id=col.id;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF ;
    RETURN NEW;
  ELSE
  raise notice 'delete';
    IF OLD.referenced_relation = 'specimens' AND OLD.code_category = 'main' THEN
      SELECT c.* INTO col FROM collections c INNER JOIN specimens s ON s.collection_ref=c.id WHERE s.id=OLD.record_id;
      IF col.id Is NOT NULL AND isnumeric(OLD.code) AND strpos(OLD.code, 'E') = 0 THEN
      		raise notice 'reinit';
        UPDATE collections
        SET code_last_value = (SELECT max(code_num)
                               FROM codes INNER JOIN specimens
                                 ON  codes.referenced_relation = 'specimens'
                                 AND codes.record_id = specimens.id
                               WHERE codes.code_category = 'main'
                                 AND specimens.collection_ref = col.id
                                 AND codes.code_num IS NOT NULL
                              )
        WHERE id=col.id
          AND EXISTS (SELECT 1
                      FROM codes inner join specimens
                        ON codes.referenced_relation = 'specimens'
                        AND codes.record_id = specimens.id
                      WHERE codes.code_category = 'main'
                        AND specimens.collection_ref = col.id
                        AND codes.code_num IS NOT NULL
                      LIMIT 1
                     );
        IF NOT FOUND THEN
		raise notice 'default';
          UPDATE collections
          SET code_last_value = DEFAULT
          WHERE id=col.id;
        END IF;
      ELSE
	raise notice 'no update % % %', OLD.code, isnumeric(OLD.code), (SELECt count(*) FROM specimens where id=OLD.id); 
      END IF;
    ELSE
	raise notice 'not updated % ', OLD.code;
    END IF ;
    RETURN OLD;
  END IF;
END;
$$;


ALTER FUNCTION darwin2.check_auto_increment_code_in_spec() OWNER TO postgres;

--
-- TOC entry 710 (class 1255 OID 18671)
-- Name: check_auto_increment_code_in_spec_on_specimen(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.check_auto_increment_code_in_spec_on_specimen() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  col collections%ROWTYPE;
  codesrow codes%ROWTYPE;
  number BIGINT ;
BEGIN
  IF TG_OP = 'DELETE' THEN
  --raise notice 'delete';
   SELECT c.* INTO codesrow FROM codes c INNER JOIN specimens s ON c.record_id=OLD.id and referenced_relation='specimens' AND c.code_category = 'main';
   IF FOUND THEN
    
      SELECT c.* INTO col FROM collections c INNER JOIN specimens s ON s.collection_ref=c.id WHERE s.id=OLD.id;
      IF col.id Is NOT NULL AND isnumeric(codesrow.code) AND strpos(codesrow.code, 'E') = 0 THEN
      		
      		SELECT max(code_num) into number
                               FROM codes INNER JOIN specimens
                                 ON  codes.referenced_relation = 'specimens'
                                 AND codes.record_id = specimens.id
                                 
                               WHERE codes.code_category = 'main'
                                 AND specimens.collection_ref = col.id
                                 AND specimens.id !=OLD.id
                                 AND codes.code_num IS NOT NULL;
        --raise notice 'reinit % %', col.id, number;                         
       
        --IF isnumeric(number) THEN
		 UPDATE collections
		SET code_last_value = number
		WHERE id=col.id
		  AND EXISTS (SELECT 1
			      FROM codes inner join specimens
				ON codes.referenced_relation = 'specimens'
				AND codes.record_id = specimens.id
			      WHERE codes.code_category = 'main'
				AND specimens.collection_ref = col.id
				 AND specimens.id !=OLD.id
				AND codes.code_num IS NOT NULL
			      LIMIT 1
			     );
	--END IF;
        IF NOT FOUND THEN
		raise notice 'default';
          UPDATE collections
          SET code_last_value = DEFAULT
          WHERE id=col.id;
        END IF;
     -- ELSE
--	raise notice 'no update % ',  OLD.id::varchar; 
      END IF;
   -- ELSE
--	raise notice 'not updated % ', OLD.code;
    END IF ;
    RETURN OLD;
  END IF;
END;
$$;


ALTER FUNCTION darwin2.check_auto_increment_code_in_spec_on_specimen() OWNER TO darwin2;

--
-- TOC entry 711 (class 1255 OID 18672)
-- Name: chk_specimens_not_loaned(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.chk_specimens_not_loaned() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    IF exists( SELECT 1 FROM loan_items i INNER JOIN loan_status s on i.loan_ref = s.loan_ref
        WHERE s.is_last= true AND s.status != 'closed' AND i.specimen_ref = OLD.id ) THEN
      RAISE EXCEPTION 'The Part is currently used in an ongoing loan';
    END IF;
    RETURN OLD;
END;
$$;


ALTER FUNCTION darwin2.chk_specimens_not_loaned() OWNER TO darwin2;

--
-- TOC entry 712 (class 1255 OID 18673)
-- Name: concat(text[]); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.concat(VARIADIC text[]) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT array_to_string($1,'');
$_$;


ALTER FUNCTION darwin2.concat(VARIADIC text[]) OWNER TO darwin2;

--
-- TOC entry 713 (class 1255 OID 18674)
-- Name: convert_to_integer(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.convert_to_integer(v_input character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE v_int_value INTEGER DEFAULT 0;
BEGIN
    BEGIN
        v_int_value := v_input::INTEGER;
    EXCEPTION WHEN OTHERS THEN
/*        RAISE NOTICE 'Invalid integer value: "%".  Returning NULL.', v_input;*/
        RETURN 0;
    END;
RETURN v_int_value;
END;
$$;


ALTER FUNCTION darwin2.convert_to_integer(v_input character varying) OWNER TO darwin2;

--
-- TOC entry 714 (class 1255 OID 18675)
-- Name: convert_to_real(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.convert_to_real(v_input character varying) RETURNS real
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE v_int_value REAL DEFAULT 0;
BEGIN
    BEGIN
        v_int_value := v_input::REAL;
    EXCEPTION WHEN OTHERS THEN
/*        RAISE NOTICE 'Invalid integer value: "%".  Returning NULL.', v_input;*/
        RETURN 0;
    END;
RETURN v_int_value;
END;
$$;


ALTER FUNCTION darwin2.convert_to_real(v_input character varying) OWNER TO darwin2;

--
-- TOC entry 717 (class 1255 OID 18676)
-- Name: convert_to_unified(character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
    r_val real :=0;
BEGIN
    IF property is NULL THEN
        RETURN NULL;
    END IF;

    BEGIN
      r_val := property::real;
    EXCEPTION WHEN SQLSTATE '22P02' THEN
      RETURN null;

      WHEN OTHERS THEN
        RETURN null;
    END;

    IF property_unit IN ('Kt', 'Beaufort', 'm/s') THEN
        RETURN fct_cpy_speed_conversion(r_val, property_unit)::text;
    END IF;

    IF property_unit IN ( 'g', 'hg', 'kg', 'ton', 'dg', 'cg', 'mg', 'lb', 'lbs', 'pound' , 'ounce' , 'grain') THEN
        RETURN fct_cpy_weight_conversion(r_val, property_unit)::text;
    END IF;

    IF property_unit IN ('m³', 'l', 'cm³', 'ml', 'mm³' ,'µl' , 'µm³' , 'km³', 'Ml' , 'hl') THEN
        RETURN fct_cpy_volume_conversion(r_val, property_unit)::text;
    END IF;

    IF property_unit IN ('K', '°C', '°F', '°Ra', '°Re', '°r', '°N', '°Rø', '°De') THEN
        RETURN fct_cpy_temperature_conversion(r_val, property_unit)::text;
    END IF;

    IF property_unit IN ('m', 'dm', 'cm', 'mm', 'µm', 'nm', 'pm', 'fm', 'am', 'zm', 'ym', 'am', 'dam', 'hm', 'km', 'Mm', 'Gm', 'Tm', 'Pm', 'Em', 'Zm', 'Ym', 'mam', 'mom', 'Å', 'ua', 'ch', 'fathom', 'fermi', 'ft', 'in', 'K', 'l.y.', 'ly', 'µ', 'mil', 'mi', 'nautical mi', 'pc', 'point', 'pt', 'pica', 'rd', 'yd', 'arp', 'lieue', 'league', 'cal', 'twp', 'p', 'P', 'fur', 'brasse', 'vadem', 'fms') THEN
        RETURN fct_cpy_length_conversion(r_val, property_unit)::text;
    END IF;

    RETURN  property;

END;
$$;


ALTER FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying) OWNER TO darwin2;

--
-- TOC entry 718 (class 1255 OID 18677)
-- Name: convert_to_unified(character varying, character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying, property_type character varying) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    r_val real :=0;
BEGIN
    IF property is NULL THEN
        RETURN NULL;
    END IF;

    BEGIN
      r_val := property::real;
    EXCEPTION WHEN SQLSTATE '22P02' THEN
      RETURN null;
	WHEN OTHERS THEN
      RETURN null;
    END;

    IF property_type = 'speed' THEN
        RETURN fct_cpy_speed_conversion(r_val, property_unit)::text;
    END IF;

    IF property_type = 'weight' THEN
        RETURN fct_cpy_weight_conversion(r_val, property_unit)::text;
    END IF;

    IF property_type = 'volume' THEN
        RETURN fct_cpy_volume_conversion(r_val, property_unit)::text;
    END IF;

    IF property_type = 'temperature' AND property_unit IN ('K', '°C', '°F', '°Ra', '°Re', '°r', '°N', '°Rø', '°De') THEN
        RETURN fct_cpy_temperature_conversion(r_val, property_unit)::text;
    END IF;

    IF property_type IN ('length') AND property_unit IN ('m', 'dm', 'cm', 'mm', 'µm', 'nm', 'pm', 'fm', 'am', 'zm', 'ym', 'am', 'dam', 'hm', 'km', 'Mm', 'Gm', 'Tm', 'Pm', 'Em', 'Zm', 'Ym', 'mam', 'mom', 'Å', 'ua', 'ch', 'fathom', 'fermi', 'ft', 'in', 'K', 'l.y.', 'ly', 'µ', 'mil', 'mi', 'nautical mi', 'pc', 'point', 'pt', 'pica', 'rd', 'yd', 'arp', 'lieue', 'league', 'cal', 'twp', 'p', 'P', 'fur', 'brasse', 'vadem', 'fms') THEN
        RETURN fct_cpy_length_conversion(r_val, property_unit)::text;
    END IF;

    RETURN  property;
END;
$$;


ALTER FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying, property_type character varying) OWNER TO darwin2;

--
-- TOC entry 719 (class 1255 OID 18678)
-- Name: fct_add_in_dict(text, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_add_in_dict(ref_relation text, ref_field text, old_value text, new_val text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  query_str varchar;
BEGIN
  IF new_val is NULL OR old_value IS NOT DISTINCT FROM new_val THEN
    RETURN TRUE;
  END IF;
    query_str := ' INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT ' || quote_literal(ref_relation) || ' , ' || quote_literal(ref_field) || ', ' || quote_literal(new_val) || ' WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = ' || quote_literal(ref_relation) || '
        AND dict_field = ' || quote_literal(ref_field) || '
        AND dict_value = ' || quote_literal(new_val) || ')
    );';
    execute query_str;
    RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_add_in_dict(ref_relation text, ref_field text, old_value text, new_val text) OWNER TO darwin2;

--
-- TOC entry 721 (class 1255 OID 18679)
-- Name: fct_add_in_dict_dept(text, text, text, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_add_in_dict_dept(ref_relation text, ref_field text, old_value text, new_val text, depending_old_value text, depending_new_value text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  query_str varchar;
  dpt_new_val varchar;
BEGIN
  IF new_val is NULL OR ( old_value IS NOT DISTINCT FROM new_val AND depending_old_value IS NOT DISTINCT FROM depending_new_value ) THEN
    RETURN TRUE;
  END IF;
  dpt_new_val := coalesce(depending_new_value,'');

    query_str := ' INSERT INTO flat_dict (referenced_relation, dict_field, dict_value, dict_depend)
    (
      SELECT ' || quote_literal(ref_relation) || ' , ' || quote_literal(ref_field) || ', ' || quote_literal(new_val) || ', '
        || quote_literal(dpt_new_val) || ' WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = ' || quote_literal(ref_relation) || '
        AND dict_field = ' || quote_literal(ref_field) || '
        AND dict_value = ' || quote_literal(new_val) || '
        AND dict_depend = ' || quote_literal(dpt_new_val) || '
      )
    );';
    --RAISE info 'hem %' ,  dpt_new_val;
    execute query_str;
    RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_add_in_dict_dept(ref_relation text, ref_field text, old_value text, new_val text, depending_old_value text, depending_new_value text) OWNER TO darwin2;

--
-- TOC entry 722 (class 1255 OID 18680)
-- Name: fct_after_save_add_code(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_after_save_add_code(collectionid integer, specimenid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  col collections%ROWTYPE;
BEGIN
  SELECT c.* INTO col FROM collections c WHERE c.id = collectionId;
  IF FOUND THEN
    IF col.code_auto_increment = TRUE THEN
      INSERT INTO codes (referenced_relation, record_id, code_prefix, code_prefix_separator, code, code_suffix_separator, code_suffix)
      SELECT 'specimens', specimenId, col.code_prefix, col.code_prefix_separator, (col.code_last_value+1)::varchar, col.code_suffix_separator, col.code_suffix
      WHERE NOT EXISTS (SELECT 1 
                        FROM codes 
                        WHERE referenced_relation = 'specimens'
                          AND record_id = specimenId
                          AND code_category = 'main'
                          AND code_num IS NOT NULL
                        LIMIT 1
                       );
    END IF;
  END IF;
  RETURN 0;
END;
$$;


ALTER FUNCTION darwin2.fct_after_save_add_code(collectionid integer, specimenid integer) OWNER TO darwin2;

--
-- TOC entry 723 (class 1255 OID 18681)
-- Name: fct_array_find(anyarray, anyelement); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_array_find(in_array anyarray, elem anyelement, OUT item_order integer) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
    select s from generate_series(1,array_upper($1, 1)) as s where $1[s] = $2;
$_$;


ALTER FUNCTION darwin2.fct_array_find(in_array anyarray, elem anyelement, OUT item_order integer) OWNER TO darwin2;

--
-- TOC entry 724 (class 1255 OID 18682)
-- Name: fct_array_find(character varying, anyelement); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_array_find(in_array character varying, elem anyelement, OUT item_order integer) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
    select fct_array_find(string_to_array($1,','), $2::text);
$_$;


ALTER FUNCTION darwin2.fct_array_find(in_array character varying, elem anyelement, OUT item_order integer) OWNER TO darwin2;

--
-- TOC entry 725 (class 1255 OID 18683)
-- Name: fct_auto_insert_status_history(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_auto_insert_status_history() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
 user_id int;
BEGIN
    SELECT COALESCE(get_setting('darwin.userid'),'0')::integer INTO user_id;
    IF user_id = 0 THEN
      RETURN NEW;
    END IF;

    INSERT INTO loan_status
      (loan_ref, user_ref, status, modification_date_time, comment, is_last)
      VALUES
      (NEW.id, user_id, 'new', now(), '', true);

    INSERT INTO loan_rights
      (loan_ref, user_ref, has_encoding_right)
      VALUES
      (NEW.id, user_id, true);

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_auto_insert_status_history() OWNER TO darwin2;

--
-- TOC entry 726 (class 1255 OID 18684)
-- Name: fct_cast_to_real(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cast_to_real(element text) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE r_val double precision;
BEGIN
    BEGIN
      r_val := element::double precision;
      return r_val;
    EXCEPTION WHEN SQLSTATE '22P02' THEN
      RETURN null;
    END;
END;
$$;


ALTER FUNCTION darwin2.fct_cast_to_real(element text) OWNER TO darwin2;

--
-- TOC entry 727 (class 1255 OID 18685)
-- Name: fct_catalogue_import_keywords_update(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_catalogue_import_keywords_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  DECLARE
    booContinue BOOLEAN := FALSE;
    intDiag INTEGER;
  BEGIN
    IF TG_TABLE_NAME = 'staging_catalogue' THEN
      IF TG_OP IN ('INSERT', 'UPDATE') THEN
        IF COALESCE(NEW.catalogue_ref,0) != 0 AND COALESCE(NEW.level_ref,0) != 0 THEN
          UPDATE classification_keywords as mck
            SET
              referenced_relation = (
                SELECT level_type
                FROM catalogue_levels
                WHERE id = NEW.level_ref
              ),
              record_id = NEW.catalogue_ref
          WHERE mck.referenced_relation = TG_TABLE_NAME
            AND mck.record_id = NEW.id
            AND NOT EXISTS (
              SELECT 1
              FROM classification_keywords as sck
              WHERE sck.referenced_relation = (
                  SELECT level_type
                  FROM catalogue_levels
                  WHERE id = NEW.level_ref
                )
                AND sck.record_id = NEW.catalogue_ref
                AND sck.keyword_type = mck.keyword_type
                AND sck.keyword_indexed = mck.keyword_indexed
              );
		--ftheeten 2018 06 11
              UPDATE properties as pupd1 SET record_id = NEW.catalogue_ref, referenced_relation='taxonomy' WHERE referenced_relation='staging_catalogue' AND record_id
              =NEW.id AND NOT EXISTS (SELECT 1 FROM properties pupd2 WHERE referenced_relation='taxonomy' and record_id=NEW.catalogue_ref AND pupd1.property_type=pupd2.property_type AND pupd1.lower_value= pupd2.lower_value ) ;
        END IF;
        RETURN NEW;
      ELSE --delete
        DELETE FROM classification_keywords
        WHERE referenced_relation = 'staging_catalogue'
              AND record_id = OLD.id;
              --ftheeten 2018 06011
		DELETE FROM template_table_record_ref where referenced_relation = 'staging_catalogue' AND record_id = OLD.id;    
        RETURN NULL;
      END IF;
    ELSEIF TG_TABLE_NAME = 'staging' THEN
      IF TG_OP IN ('INSERT', 'UPDATE') THEN
        IF COALESCE(NEW.taxon_ref,0) != 0 AND COALESCE(NEW.taxon_level_ref,0) != 0 THEN
          IF TG_OP = 'UPDATE' THEN
            IF COALESCE(NEW.taxon_ref,0) != COALESCE(OLD.taxon_ref,0) THEN
              booContinue := TRUE;
            END IF;
          ELSE
            booContinue := TRUE;
          END IF;
          IF booContinue = TRUE THEN
            UPDATE classification_keywords as mck
            SET
              referenced_relation = 'taxonomy',
              record_id = NEW.taxon_ref
            WHERE mck.referenced_relation = TG_TABLE_NAME
                  AND mck.record_id = NEW.id
                  AND mck.keyword_type IN (
                                            'GenusOrMonomial',
                                            'Subgenus',
                                            'SpeciesEpithet',
                                            'FirstEpiteth',
                                            'SubspeciesEpithet',
                                            'InfraspecificEpithet',
                                            'AuthorTeamAndYear',
                                            'AuthorTeam',
                                            'AuthorTeamOriginalAndYear',
                                            'AuthorTeamParenthesisAndYear',
                                            'SubgenusAuthorAndYear',
                                            'CultivarGroupName',
                                            'CultivarName',
                                            'Breed',
                                            'CombinationAuthorTeamAndYear',
                                            'NamedIndividual'
                                          )
                  AND NOT EXISTS (
                                  SELECT 1
                                  FROM classification_keywords as sck
                                  WHERE sck.referenced_relation = 'taxonomy'
                                        AND sck.record_id = NEW.taxon_ref
                                        AND sck.keyword_type = mck.keyword_type
                                        AND sck.keyword_indexed = mck.keyword_indexed
            );
          END IF;
        ELSEIF COALESCE(NEW.mineral_ref,0) != 0 AND COALESCE(NEW.mineral_level_ref,0) != 0 THEN
          IF TG_OP = 'UPDATE' THEN
            IF COALESCE(NEW.mineral_ref,0) != COALESCE(OLD.mineral_ref,0) THEN
              booContinue := TRUE;
            END IF;
          ELSE
            booContinue := TRUE;
          END IF;
          IF booContinue = TRUE THEN
            UPDATE classification_keywords as mck
            SET
              referenced_relation = 'mineralogy',
              record_id = NEW.mineral_ref
            WHERE mck.referenced_relation = TG_TABLE_NAME
                  AND mck.record_id = NEW.id
                  AND mck.keyword_type IN (
                                            'AuthorTeamAndYear',
                                            'AuthorTeam',
                                            'NamedIndividual'
                                          )
                  AND NOT EXISTS (
                                  SELECT 1
                                  FROM classification_keywords as sck
                                  WHERE sck.referenced_relation = 'mineralogy'
                                        AND sck.record_id = NEW.mineral_ref
                                        AND sck.keyword_type = mck.keyword_type
                                        AND sck.keyword_indexed = mck.keyword_indexed
            );
          END IF;
        END IF;
        RETURN NEW;
      ELSE
        DELETE FROM classification_keywords
        WHERE referenced_relation = 'staging'
              AND record_id = OLD.id;
        RETURN NULL;
      END IF;
    END IF;
  END;
$$;


ALTER FUNCTION darwin2.fct_catalogue_import_keywords_update() OWNER TO darwin2;

--
-- TOC entry 728 (class 1255 OID 18686)
-- Name: fct_chk_canupdatecollectionsrights(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_canupdatecollectionsrights() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  mgrName varchar;
  booContinue boolean := false;
BEGIN
  /*Check an unpromotion occurs by modifying db_user_type explicitely or implicitely by replacing a user by an other
    or moving a user from one collection to an other
  */
  IF (NEW.db_user_type < 4 AND OLD.db_user_type >=4) OR NEW.collection_ref IS DISTINCT FROM OLD.collection_ref OR NEW.user_ref IS DISTINCT FROM OLD.user_ref THEN
    SELECT formated_name INTO mgrName
    FROM collections INNER JOIN users ON users.id = collections.main_manager_ref
    WHERE collections.id = OLD.collection_ref
      AND main_manager_ref = OLD.user_ref;
    /*If user concerned still main manager of the collection, cannot be updated*/
    IF FOUND THEN
      RAISE EXCEPTION 'This manager (%) cannot be updated because he/she is still defined as a main manager for this collection', mgrName;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_canupdatecollectionsrights() OWNER TO darwin2;

--
-- TOC entry 729 (class 1255 OID 18687)
-- Name: fct_chk_onceinpath(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_onceinpath(path character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN

    PERFORM * FROM regexp_split_to_table(path, E'\/') as i_id WHERE i_id != '' GROUP BY i_id HAVING COUNT(*)>1;
    IF FOUND THEN
        RETURN FALSE;
    END IF;
    RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_onceinpath(path character varying) OWNER TO darwin2;

--
-- TOC entry 730 (class 1255 OID 18688)
-- Name: fct_chk_parentcollinstitution(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_parentcollinstitution() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  institutionRef integer;
  booContinue boolean := false;
BEGIN
  IF TG_OP = 'INSERT' THEN
    booContinue := true;
  ELSIF TG_OP = 'UPDATE' THEN
    IF NEW.institution_ref IS DISTINCT FROM OLD.institution_ref OR NEW.parent_ref IS DISTINCT FROM OLD.parent_ref THEN
      booContinue := true;
    END IF;
  END IF;
  IF booContinue THEN
    IF NEW.parent_ref IS NOT NULL THEN
      SELECT institution_ref INTO institutionRef FROM collections WHERE id = NEW.parent_ref;
      IF institutionRef != NEW.institution_ref THEN
        RAISE EXCEPTION 'You tried to insert or update a collection with an other institution than the one given for the parent collection';
      END IF;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_parentcollinstitution() OWNER TO darwin2;

--
-- TOC entry 731 (class 1255 OID 18689)
-- Name: fct_chk_peopleismoral(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_peopleismoral() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_exists boolean;
BEGIN
   SELECT is_physical FROM people WHERE id=NEW.institution_ref into rec_exists;

   IF rec_exists = TRUE THEN
    RAISE EXCEPTION 'You cannot link a moral person as Institution';
   END IF;

   RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_peopleismoral() OWNER TO darwin2;

--
-- TOC entry 732 (class 1255 OID 18690)
-- Name: fct_chk_possible_upper_level(character varying, integer, integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_possible_upper_level(referenced_relation character varying, new_parent_ref integer, new_level_ref integer, new_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
response boolean;
BEGIN
  EXECUTE 'SELECT true WHERE EXISTS( SELECT * ' ||
          'from possible_upper_levels ' ||
          'where level_ref = ' || quote_literal(new_level_ref) ||
          '  and coalesce(level_upper_ref,0) = case when ' || quote_literal(coalesce(new_parent_ref,0)) || ' != '|| quote_literal(0) || ' then (select level_ref from ' || quote_ident(referenced_relation) || ' where id = ' || quote_literal(coalesce(new_parent_ref,0)) || ') else ' || quote_literal(coalesce(new_parent_ref,0)) || ' end' ||
          '                              )'
    INTO response;
  IF response IS NULL THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

  RETURN FALSE;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_possible_upper_level(referenced_relation character varying, new_parent_ref integer, new_level_ref integer, new_id integer) OWNER TO darwin2;

--
-- TOC entry 733 (class 1255 OID 18691)
-- Name: fct_chk_referencedrecord(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_referencedrecord() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_exists integer;
BEGIN
	  IF NEW.record_id != -1 THEN --ftheeten 2019 01 18
		  EXECUTE 'SELECT 1 WHERE EXISTS ( SELECT id FROM ' || quote_ident(NEW.referenced_relation)  || ' WHERE id=' || quote_literal(NEW.record_id) || ')' INTO rec_exists;
		  IF rec_exists IS NULL THEN
		    RAISE EXCEPTION 'The referenced record does not exists % %',NEW.referenced_relation, NEW.record_id;
		  END IF;	 
	  END IF;	
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_referencedrecord() OWNER TO darwin2;

--
-- TOC entry 734 (class 1255 OID 18692)
-- Name: fct_chk_referencedrecordrelationship(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_referencedrecordrelationship() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_exists integer;
BEGIN

  EXECUTE 'SELECT count(id)  FROM ' || quote_ident(NEW.referenced_relation)  || ' WHERE id=' || quote_literal(NEW.record_id_1) ||  ' OR id=' || quote_literal(NEW.record_id_2) INTO rec_exists;

  IF rec_exists != 2 THEN
    RAISE EXCEPTION 'The referenced record does not exists';
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION darwin2.fct_chk_referencedrecordrelationship() OWNER TO darwin2;

--
-- TOC entry 735 (class 1255 OID 18693)
-- Name: fct_chk_specimencollectionallowed(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_specimencollectionallowed() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  user_id integer;
  db_user_type_cpy smallint;
  col_ref integer;
BEGIN
  SELECT COALESCE(get_setting('darwin.userid'),'0')::integer INTO user_id;
  /*If no user id allows modification -> if we do a modif in SQL it should be possible*/
  IF user_id = 0 THEN
    IF TG_OP = 'DELETE' THEN
      RETURN OLD;
    END IF;
    RETURN NEW;
  END IF;

  IF user_id = -1 THEN
    RETURN NEW;
  END IF;
  /*If user_id <> 0, get db_user_type of user concerned*/
  SELECT db_user_type INTO db_user_type_cpy FROM users WHERE id = user_id;
  /*If admin allows whatever*/
  IF db_user_type_cpy = 8 THEN
    IF TG_OP = 'DELETE' THEN
      RETURN OLD;
    END IF;
    RETURN NEW;
  END IF;

  IF TG_TABLE_NAME = 'specimens' THEN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
      IF NOT EXISTS (SELECT 1 FROM fct_search_authorized_encoding_collections (user_id) as r WHERE r = NEW.collection_ref) THEN
        RAISE EXCEPTION 'You don''t have the rights to insert into or update a specimen in this collection';
      END IF;
    ELSE /*Delete*/
      PERFORM true WHERE OLD.collection_ref::integer IN (SELECT * FROM fct_search_authorized_encoding_collections(user_id));
      IF NOT EXISTS (SELECT 1 FROM fct_search_authorized_encoding_collections (user_id) as r WHERE r = OLD.collection_ref) THEN
        RAISE EXCEPTION 'You don''t have the rights to delete a specimen from this collection';
      END IF;
    END IF;
  END IF;
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_specimencollectionallowed() OWNER TO darwin2;

--
-- TOC entry 736 (class 1255 OID 18694)
-- Name: fct_chk_upper_level_for_childrens(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_upper_level_for_childrens() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_exists integer;
BEGIN

  EXECUTE 'SELECT count(id)  FROM ' || quote_ident(TG_TABLE_NAME::text) ||
    ' WHERE parent_ref=' || quote_literal(NEW.id) ||
    ' AND fct_chk_possible_upper_level('|| quote_literal(TG_TABLE_NAME::text) ||
    ', parent_ref, level_ref, id) = false ' INTO rec_exists;

  IF rec_exists > 0 THEN
    RAISE EXCEPTION 'Children of this record does not follow the level hierarchy';
  END IF;
  RETURN NEW;

END;
$$;


ALTER FUNCTION darwin2.fct_chk_upper_level_for_childrens() OWNER TO darwin2;

--
-- TOC entry 740 (class 1255 OID 18695)
-- Name: fct_clean_staging_catalogue(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_clean_staging_catalogue(importref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
  DECLARE
    recDistinctStagingCatalogue RECORD;
  BEGIN
    FOR recDistinctStagingCatalogue IN SELECT DISTINCT ON (level_ref, fullToIndex(name), name)
                                       id, import_ref, name, level_ref
                                       FROM
                                         (
                                           SELECT
                                             id,
                                             import_ref,
                                             name,
                                             level_ref
                                           FROM staging_catalogue
                                           WHERE import_ref = importRef
                                           ORDER BY level_ref, fullToIndex(name), id
                                         ) as subqry
    LOOP
      UPDATE staging_catalogue
      SET parent_ref = recDistinctStagingCatalogue.id
      WHERE
        import_ref = importRef
        AND parent_ref IN
            (
              SELECT id
              FROM staging_catalogue
              WHERE import_ref = importRef
                AND name = recDistinctStagingCatalogue.name
                AND level_ref = recDistinctStagingCatalogue.level_ref
                AND id != recDistinctStagingCatalogue.id
            );
      DELETE FROM staging_catalogue
      WHERE import_ref = importRef
            and name = recDistinctStagingCatalogue.name
            and level_ref = recDistinctStagingCatalogue.level_ref
            and id != recDistinctStagingCatalogue.id;
    END LOOP;
    RETURN TRUE;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE WARNING 'Error:%', SQLERRM;
      RETURN FALSE;
  END;
$$;


ALTER FUNCTION darwin2.fct_clean_staging_catalogue(importref integer) OWNER TO darwin2;

--
-- TOC entry 741 (class 1255 OID 18696)
-- Name: fct_clear_identifiers_in_flat(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_clear_identifiers_in_flat() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp_user text;
BEGIN
 SELECT COALESCE(get_setting('darwin.userid'),'0') INTO tmp_user;
  PERFORM set_config('darwin.userid', '-1', false) ;

  IF EXISTS(SELECT true FROM catalogue_people cp WHERE cp.record_id = OLD.id AND cp.referenced_relation = 'identifications') THEN
    -- There's NO identifier associated to this identification'
    UPDATE specimens SET spec_ident_ids = fct_remove_array_elem(spec_ident_ids,
      (
        select array_agg(people_ref) FROM catalogue_people p  INNER JOIN identifications i ON p.record_id = i.id AND i.id = OLD.id
        AND people_ref NOT in
          (
            SELECT people_ref from catalogue_people p INNER JOIN identifications i ON p.record_id = i.id AND p.referenced_relation = 'identifications'
            AND p.people_type='identifier' where i.record_id=OLD.record_id AND i.referenced_relation=OLD.referenced_relation AND i.id != OLD.id
          )
      ))
      WHERE id = OLD.record_id;
  END IF;

  PERFORM set_config('darwin.userid', tmp_user, false) ;
  RETURN OLD;

END;
$$;


ALTER FUNCTION darwin2.fct_clear_identifiers_in_flat() OWNER TO darwin2;

--
-- TOC entry 742 (class 1255 OID 18697)
-- Name: fct_clear_referencedrecord(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_clear_referencedrecord() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP ='UPDATE' THEN
    IF NEW.id != OLD.id THEN
      UPDATE template_table_record_ref SET record_id = NEW.id WHERE referenced_relation = TG_TABLE_NAME AND record_id = OLD.id;
    END IF;
  ELSEIF TG_OP = 'DELETE' THEN
    DELETE FROM template_table_record_ref where referenced_relation = TG_TABLE_NAME AND record_id = OLD.id;
  END IF;
  RETURN NULL;
 END;
$$;


ALTER FUNCTION darwin2.fct_clear_referencedrecord() OWNER TO darwin2;

--
-- TOC entry 743 (class 1255 OID 18698)
-- Name: fct_clr_specialstatus(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_clr_specialstatus() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  newType varchar := fullToIndex(NEW.type);
BEGIN

  -- IF Type not changed
  IF TG_OP = 'UPDATE' THEN
    IF fullToIndex(OLD.type) = newType THEN
      RETURN NEW;
    END IF;
  END IF;

  IF newType = 'specimen' THEN
    NEW.type_search := 'specimen';
    NEW.type_group := 'specimen';
  ELSIF newType = 'type' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  ELSIF newType = 'subtype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  ELSIF newType = 'allotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'allotype';
  ELSIF newType = 'cotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'syntype';
  ELSIF newType = 'genotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  ELSIF newType = 'holotype' THEN
    NEW.type_search := 'holotype';
    NEW.type_group := 'holotype';
  ELSIF newType = 'hypotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'hypotype';
  ELSIF newType = 'lectotype' THEN
    NEW.type_search := 'lectotype';
    NEW.type_group := 'lectotype';
  ELSIF newType = 'locotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'locotype';
  ELSIF newType = 'neallotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  ELSIF newType = 'neotype' THEN
    NEW.type_search := 'neotype';
    NEW.type_group := 'neotype';
  ELSIF newType = 'paralectotype' THEN
    NEW.type_search := 'paralectotype';
    NEW.type_group := 'paralectotype';
  ELSIF newType = 'paratype' THEN
    NEW.type_search := 'paratype';
    NEW.type_group := 'paratype';
  ELSIF newType = 'plastotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'plastotype';
  ELSIF newType = 'plesiotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'plesiotype';
  ELSIF newType = 'syntype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'syntype';
  ELSIF newType = 'topotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'topotype';
  ELSIF newType = 'typeinlitteris' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type in litteris';
  ELSE
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  END IF;

  RETURN NEW;
EXCEPTION
  WHEN RAISE_EXCEPTION THEN
    return NULL;
END;
$$;


ALTER FUNCTION darwin2.fct_clr_specialstatus() OWNER TO darwin2;

--
-- TOC entry 744 (class 1255 OID 18699)
-- Name: fct_cpy_deleted_file(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_deleted_file() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO multimedia_todelete (uri) VALUES (OLD.uri);
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_deleted_file() OWNER TO darwin2;

--
-- TOC entry 745 (class 1255 OID 18700)
-- Name: fct_cpy_formattedname(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_formattedname() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP ='UPDATE' THEN
    IF NEW.family_name = OLD.family_name AND NEW.given_name = OLD.given_name AND NEW.title = OLD.title THEN
      RETURN NEW;
    END IF;
  END IF;

  IF NEW.is_physical THEN
  -- IF COALESCE(NEW.title, '') = '' THEN
  IF LENGTH(COALESCE(NEW.title, ''))=0 THEN
      NEW.formated_name := trim(COALESCE(NEW.family_name,'') || ' ' || COALESCE(NEW.given_name,''));
      --mrac 2015 07 16 test
      NEW.formated_name_indexed := trim(fulltoindex(COALESCE(NEW.family_name,''), true) || fulltoindex(' ' || COALESCE(NEW.given_name,''),true));
      NEW.formated_name_unique := TRIM(touniquestr(COALESCE(NEW.family_name,''), true) || touniquestr(' ' || COALESCE(NEW.given_name,''), true));      
    ELSE
      NEW.formated_name := TRIM(COALESCE(NEW.family_name,'') || ' ' || COALESCE(NEW.given_name,'') || ' (' || NEW.title || ')');
      --mrac 2015 07 16 test
      NEW.formated_name_indexed := TRIM(fulltoindex(COALESCE(NEW.family_name,''),true) || fulltoindex(COALESCE(NEW.given_name,'') || ' (' || NEW.title || ')', true));
       NEW.formated_name_unique := TRIM(touniquestr(COALESCE(NEW.family_name,'')) || touniquestr(COALESCE(NEW.given_name,'') || ' (' || NEW.title || ')', true));
    END IF;
  ELSE
     --rmca jim and ftheteen 2018 04 05
    NEW.formated_name := COALESCE(NEW.family_name, NEW.formated_name,'' );
        --rmca jim and ftheteen 2018 04 05
    NEW.family_name := COALESCE(NEW.family_name,'' );
    --mrac test
    NEW.formated_name_indexed := TRIM(fullToIndex(NEW.formated_name, true));
    NEW.formated_name_unique := TRIM(toUniqueStr(NEW.formated_name, true));
  END IF;

  --NEW.formated_name_indexed := fullToIndex(NEW.formated_name);
  --NEW.formated_name_unique := toUniqueStr(NEW.formated_name);
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_formattedname() OWNER TO darwin2;

--
-- TOC entry 748 (class 1255 OID 18701)
-- Name: fct_cpy_fulltoindex(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_fulltoindex() RETURNS trigger
    LANGUAGE plpgsql
    AS $_$
BEGIN
        IF TG_TABLE_NAME = 'properties' THEN
                NEW.applies_to_indexed := COALESCE(fullToIndex(NEW.applies_to),'');
                NEW.method_indexed := COALESCE(fullToIndex(NEW.method),'');
        ELSIF TG_TABLE_NAME = 'chronostratigraphy' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'collections' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'expeditions' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'bibliography' THEN
                NEW.title_indexed := fullToIndex(NEW.title);
        ELSIF TG_TABLE_NAME = 'identifications' THEN
                NEW.value_defined_indexed := COALESCE(fullToIndex(NEW.value_defined),'');
        ELSIF TG_TABLE_NAME = 'lithology' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'lithostratigraphy' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'mineralogy' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
                NEW.formule_indexed := fullToIndex(NEW.formule);
        ELSIF TG_TABLE_NAME = 'people' THEN
                NEW.formated_name_indexed := COALESCE(fullToIndex(NEW.formated_name),'');
                NEW.name_formated_indexed := fulltoindex(coalesce(NEW.given_name,'') || coalesce(NEW.family_name,''));
                NEW.formated_name_unique := COALESCE(toUniqueStr(NEW.formated_name),'');
        ELSIF TG_TABLE_NAME = 'codes' THEN
                IF NEW.code ~ '^[0-9]+$' THEN
                    NEW.code_num := NEW.code;
                ELSIF ARRAY_LENGTH(regexp_matches(NEW.code,'(\d+)[^0-9]*$','g'),1) > 0 THEN
	              new.code_num :=(regexp_matches(NEW.code,'(\d+)[^0-9]*$','g'))[1] ;
                ELSE
                    NEW.code_num := null;
                END IF;
                NEW.full_code_indexed := fullToIndex(COALESCE(NEW.code_prefix,'') || COALESCE(NEW.code::text,'') || COALESCE(NEW.code_suffix,'') );
        ELSIF TG_TABLE_NAME = 'tag_groups' THEN
                NEW.group_name_indexed := fullToIndex(NEW.group_name);
                NEW.sub_group_name_indexed := fullToIndex(NEW.sub_group_name);
        ELSIF TG_TABLE_NAME = 'taxonomy' THEN
		If TG_OP='INSERT' OR NEW.name !=old.name THEN
			NEW.name_indexed := fullToIndex(NEW.name);
	        END IF;
        ELSIF TG_TABLE_NAME = 'classification_keywords' THEN
                NEW.keyword_indexed := fullToIndex(NEW.keyword);
        ELSIF TG_TABLE_NAME = 'users' THEN
                NEW.formated_name_indexed := COALESCE(fullToIndex(NEW.formated_name),'');
                NEW.formated_name_unique := COALESCE(toUniqueStr(NEW.formated_name),'');
        ELSIF TG_TABLE_NAME = 'vernacular_names' THEN
                NEW.community_indexed := fullToIndex(NEW.community);
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'igs' THEN
                NEW.ig_num_indexed := fullToIndex(NEW.ig_num);
        ELSIF TG_TABLE_NAME = 'collecting_methods' THEN
                NEW.method_indexed := fullToIndex(NEW.method);
        ELSIF TG_TABLE_NAME = 'collecting_tools' THEN
                NEW.tool_indexed := fullToIndex(NEW.tool);
        ELSIF TG_TABLE_NAME = 'loans' THEN
                NEW.search_indexed := fullToIndex(COALESCE(NEW.name,'') || COALESCE(NEW.description,''));
        ELSIF TG_TABLE_NAME = 'multimedia' THEN
                NEW.search_indexed := fullToIndex ( COALESCE(NEW.title,'') ||  COALESCE(NEW.description,'') || COALESCE(NEW.extracted_info,'') ) ;
        ELSIF TG_TABLE_NAME = 'comments' THEN
                NEW.comment_indexed := fullToIndex(NEW.comment);
        ELSIF TG_TABLE_NAME = 'ext_links' THEN
                NEW.comment_indexed := fullToIndex(NEW.comment);
               --ftheeten 2016 08 08
        --ELSIF TG_TABLE_NAME = 'specimens' THEN
          --      NEW.object_name_indexed := fullToIndex(COALESCE(NEW.object_name,'') );
        ELSIF TG_TABLE_NAME = 'storage_parts' THEN
                NEW.object_name_indexed := fullToIndex(COALESCE(NEW.object_name,'') );
        END IF;
    
	RETURN NEW;
END;
$_$;


ALTER FUNCTION darwin2.fct_cpy_fulltoindex() OWNER TO darwin2;

--
-- TOC entry 749 (class 1255 OID 18702)
-- Name: fct_cpy_gtutags(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_gtutags() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  curs_entry refcursor;
  entry_row RECORD;
  seen_el varchar[];
BEGIN
  IF TG_OP != 'DELETE' THEN
    --OPEN curs_entry FOR SELECT distinct(fulltoIndex(tags)) as u_tag, trim(tags) as tags
    --                    FROM regexp_split_to_table(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value, ';') as tags
    --                    WHERE fulltoIndex(tags) != '';
    --ftheeten 2016 03 29
       OPEN curs_entry FOR SELECT distinct(fulltoIndex(tags,true)) as u_tag, trim(tags) as tags
                        FROM regexp_split_to_table(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value, ';') as tags
                        WHERE fulltoIndex(tags, true) != '';
    LOOP
      FETCH curs_entry INTO entry_row;
      EXIT WHEN NOT FOUND;

      seen_el := array_append(seen_el, entry_row.u_tag);

     IF EXISTS( SELECT 1 FROM tags
                WHERE gtu_ref = NEW.gtu_ref
                  AND group_ref = NEW.id
                  AND tag_indexed = entry_row.u_tag) THEN
        IF TG_OP = 'UPDATE' THEN
          IF OLD.sub_group_name != NEW.sub_group_name THEN
            UPDATE tags
            SET sub_group_type = NEW.sub_group_name
            WHERE group_ref = NEW.id;
          END IF;
        END IF;
        CONTINUE;
      ELSE
        INSERT INTO tags (gtu_ref, group_ref, tag_indexed, tag, group_type, sub_group_type )
        VALUES ( NEW.gtu_ref, NEW.id, entry_row.u_tag, entry_row.tags, NEW.group_name, NEW.sub_group_name);
      END IF;
    END LOOP;

    CLOSE curs_entry;

    UPDATE gtu
    SET tag_values_indexed = (SELECT array_agg(tags_list)
                              FROM (SELECT lineToTagRows(tag_agg) AS tags_list
                                    FROM (SELECT case when international_name != '' THEN international_name || ';' ELSE '' END || tag_value AS tag_agg
                                          FROM tag_groups
                                          WHERE id <> NEW.id
                                            AND gtu_ref = NEW.gtu_ref
                                          UNION
                                          SELECT case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value
                                         ) as tag_list_selection
                                   ) as tags_rows
                             )
    WHERE id = NEW.gtu_ref;

    DELETE FROM tags
           WHERE group_ref = NEW.id
              AND gtu_ref = NEW.gtu_ref
              AND fct_array_find(seen_el, tag_indexed ) IS NULL;
    RETURN NEW;
  ELSE
    UPDATE gtu
    SET tag_values_indexed = (SELECT array_agg(tags_list)
                              FROM (SELECT lineToTagRows(tag_agg) AS tags_list
                                    FROM (SELECT tag_value AS tag_agg
                                          FROM tag_groups
                                          WHERE id <> OLD.id
                                            AND gtu_ref = OLD.gtu_ref
                                         ) as tag_list_selection
                                   ) as tags_rows
                             )
    WHERE id = OLD.gtu_ref;
    RETURN NULL;
  END IF;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_gtutags() OWNER TO darwin2;

--
-- TOC entry 750 (class 1255 OID 18703)
-- Name: fct_cpy_ig_to_loan_items(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_ig_to_loan_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF OLD.ig_ref is distinct from NEW.ig_ref THEN
    UPDATE loan_items li SET ig_ref = NEW.ig_ref
    WHERE specimen_ref = NEW.ID
    AND li.ig_ref IS NOT DISTINCT FROM OLD.ig_ref;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_ig_to_loan_items() OWNER TO darwin2;

--
-- TOC entry 751 (class 1255 OID 18704)
-- Name: fct_cpy_length_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'dm' THEN
        ($1)*10^(-1)
      WHEN $2 = 'ft' THEN
        ($1)*3.048*10^(-1)
      WHEN $2 = 'P' THEN
        ($1)*3.24839385*10^(-1)
      WHEN $2 = 'yd' THEN
        ($1)*9.144*10^(-1)
      WHEN $2 = 'cm' THEN
        ($1)*10^(-2)
      WHEN $2 = 'in' THEN
        ($1)*2.54*10^(-2)
      WHEN $2 = 'mm' THEN
        ($1)*10^(-3)
      WHEN $2 = 'pica' THEN
        ($1)*4.233333*10^(-3)
      WHEN $2 = 'p' THEN
        ($1)*27.069949*10^(-3)
      WHEN $2 = 'mom' THEN
        ($1)*10^(-4)
      WHEN $2 IN ('pt', 'point') THEN
        ($1)*3.527778*10^(-4)
      WHEN $2 = 'mil' THEN
        ($1)*2.54*10^(-5)
      WHEN $2 IN ('µm', 'µ') THEN
        ($1)*10^(-6)
      WHEN $2 = 'twp' THEN
        ($1)*17.639*10^(-6)
      WHEN $2 = 'cal' THEN
        ($1)*254*10^(-6)
      WHEN $2 = 'nm' THEN
        ($1)*10^(-9)
      WHEN $2 = 'Å' THEN
        ($1)*10^(-10)
      WHEN $2 = 'pm' THEN
        ($1)*10^(-12)
      WHEN $2 IN ('fm', 'fermi') THEN
        ($1)*10^(-15)
      WHEN $2 = 'am' THEN
        ($1)*10^(-18)
      WHEN $2 = 'zm' THEN
        ($1)*10^(-21)
      WHEN $2 = 'ym' THEN
        ($1)*10^(-24)
      WHEN $2 IN ('brasse', 'vadem') THEN
        ($1)*1.8288
      WHEN $2 = 'fathom' THEN
        ($1)*1.828804
      WHEN $2 = 'rd' THEN
        ($1)*5.02921
      WHEN $2 = 'dam' THEN
        ($1)*10
      WHEN $2 = 'ch' THEN
        ($1)*20.11684
      WHEN $2 = 'arp' THEN
        ($1)*58.471089295
      WHEN $2 IN ('hm', 'K') THEN
        ($1)*10^2
      WHEN $2 = 'fur' THEN
        ($1)*201.168
      WHEN $2 = 'km' THEN
        ($1)*10^3
      WHEN $2 = 'mi' THEN
        ($1)*1.609344*10^3
      WHEN $2 = 'nautical mi' THEN
        ($1)*1.852*10^3
      WHEN $2 IN ('lieue', 'league') THEN
        ($1)*4.828032*10^3
      WHEN $2 = 'mam' THEN
        ($1)*10^4
      WHEN $2 = 'Mm' THEN
        ($1)*10^6
      WHEN $2 = 'Gm' THEN
        ($1)*10^9
      WHEN $2 = 'ua' THEN
        ($1)*1.495979*10^11
      WHEN $2 = 'Tm' THEN
        ($1)*10^12
      WHEN $2 = 'Pm' THEN
        ($1)*10^15
      WHEN $2 = 'pc' THEN
        ($1)*3.085678*10^16
      WHEN $2 IN ('ly', 'l.y.') THEN
        ($1)*9.4607304725808*10^15
      WHEN $2 = 'Em' THEN
        ($1)*10^18
      WHEN $2 = 'Zm' THEN
        ($1)*10^21
      WHEN $2 = 'Ym' THEN
        ($1)*10^24
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit text) OWNER TO darwin2;

--
-- TOC entry 752 (class 1255 OID 18705)
-- Name: fct_cpy_loan_history(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_loan_history(loan_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN

  -- LOAN
  INSERT INTO loan_history (loan_ref, referenced_table, record_line)
  (
    select loan_id, 'loans', hstore(l.*) from loans l where l.id = loan_id

    UNION

    select loan_id, 'catalogue_people', hstore(p.*) from catalogue_people p where
      (referenced_relation='loans'  AND record_id = loan_id) OR (referenced_relation='loan_items'  AND record_id in (select id from loan_items l where l.loan_ref = loan_id) )

    UNION

    select loan_id, 'properties', hstore(c.*) from properties c where
      (referenced_relation='loans'  AND record_id = loan_id) OR (referenced_relation='loan_items'  AND record_id in (select id from loan_items l where l.loan_ref = loan_id) )

  );


  --ITEMS
  INSERT INTO loan_history (loan_ref, referenced_table, record_line)
  (
    select loan_id, 'loan_items', hstore(l.*) from loan_items l where l.loan_ref = loan_id

    UNION

    select loan_id, 'specimens', hstore(sfl.*) from specimens sfl
      where sfl.id in (select specimen_ref from loan_items l where l.loan_ref = loan_id)
  );

  -- BOTH
  INSERT INTO loan_history (loan_ref, referenced_table, record_line)
  (
    select loan_id, 'people', hstore(p.*) from people p where id in (select (record_line->'people_ref')::int from loan_history where loan_ref = loan_id
      and referenced_table='catalogue_people' and modification_date_time = now())

    UNION

    select loan_id, 'people_addresses', hstore(p.*) from people_addresses p where person_user_ref in (select (record_line->'id')::int from loan_history where loan_ref = loan_id
      and referenced_table='people' and modification_date_time = now())
  );
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_loan_history(loan_id integer) OWNER TO darwin2;

--
-- TOC entry 754 (class 1255 OID 18706)
-- Name: fct_cpy_location(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_location() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  --NEW.location := POINT(NEW.latitude, NEW.longitude);
--ftheeten 2017 05 30
NEW.location := POINT(NEW.longitude, NEW.latitude);
IF NEW.latitude is NOT NULL and NEW.longitude IS NOT NULL THEN
  	NEW.geom=ST_SETSRID(ST_Point(NEW.location[0], NEW.location[1]),4326);
  ELSE
  	NEW.geom=NULL;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_location() OWNER TO darwin2;

--
-- TOC entry 753 (class 1255 OID 18707)
-- Name: fct_cpy_path(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_path() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
      IF TG_TABLE_NAME::text = 'collections' THEN

        IF NEW.id = 0 THEN
          NEW.parent_ref := null;
        END IF;
        IF NEW.parent_ref IS NULL THEN
          NEW.path :='/';
        ELSE
          EXECUTE 'SELECT path || id || ' || quote_literal('/') ||' FROM ' || quote_ident(TG_TABLE_NAME::text) || ' WHERE id=' || quote_literal(NEW.parent_ref) INTO STRICT NEW.path;
        END IF;
      ELSIF TG_TABLE_NAME::text = 'people_relationships' THEN
        SELECT path || NEW.person_1_ref || '/' INTO NEW.path
          FROM people_relationships
          WHERE person_2_ref=NEW.person_1_ref;
        IF NEW.path is NULL THEN
          NEW.path := '/' || NEW.person_1_ref || '/';
        END IF;
      END IF;
    ELSIF TG_OP = 'UPDATE' THEN
      IF TG_TABLE_NAME::text = 'collections' THEN

        IF NEW.parent_ref IS DISTINCT FROM OLD.parent_ref THEN
          IF NEW.parent_ref IS NULL THEN
            NEW.path := '/';
          ELSIF COALESCE(OLD.parent_ref,0) = COALESCE(NEW.parent_ref,0) THEN
            RETURN NEW;
          ELSE
            EXECUTE 'SELECT path || id || ' || quote_literal('/') ||' FROM ' || quote_ident(TG_TABLE_NAME::text) || ' WHERE id=' || quote_literal(NEW.parent_ref) INTO STRICT NEW.path;
          END IF;

          EXECUTE 'UPDATE ' || quote_ident(TG_TABLE_NAME::text) || ' SET path=replace(path, ' ||  quote_literal(OLD.path || OLD.id || '/') ||' , ' || quote_literal( NEW.path || OLD.id || '/') || ') ' ||
            ' WHERE path like ' || quote_literal(OLD.path || OLD.id || '/%');
        END IF;
      ELSE
        IF NEW.person_1_ref IS DISTINCT FROM OLD.person_1_ref OR NEW.person_2_ref IS DISTINCT FROM OLD.person_2_ref THEN
          SELECT path ||  NEW.person_1_ref || '/' INTO NEW.path FROM people_relationships WHERE person_2_ref=NEW.person_1_ref;

            IF NEW.path is NULL THEN
              NEW.path := '/' || NEW.person_1_ref || '/';
            END IF;
            -- AND UPDATE CHILDRENS
            UPDATE people_relationships SET path=replace(path, OLD.path, NEW.path) WHERE person_1_ref=OLD.person_2_ref;
        END IF;
      END IF;
    END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_path() OWNER TO darwin2;

--
-- TOC entry 755 (class 1255 OID 18708)
-- Name: fct_cpy_path_catalogs(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_path_catalogs() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' AND (TG_TABLE_NAME::text = 'taxonomy' OR
          TG_TABLE_NAME::text = 'lithology' OR
          TG_TABLE_NAME::text = 'lithostratigraphy' OR
          TG_TABLE_NAME::text = 'mineralogy' OR
          TG_TABLE_NAME::text = 'chronostratigraphy') THEN

          IF NEW.parent_ref IS NULL THEN
            NEW.path ='/';
          ELSE
            EXECUTE 'SELECT path || id || ''/'' FROM ' || quote_ident(TG_TABLE_NAME::text) || ' WHERE id=' || quote_literal(NEW.parent_ref) INTO STRICT NEW.path;
          END IF;
    ELSIF TG_OP = 'UPDATE' AND (TG_TABLE_NAME::text = 'taxonomy' OR
        TG_TABLE_NAME::text = 'lithology' OR
        TG_TABLE_NAME::text = 'lithostratigraphy' OR
        TG_TABLE_NAME::text = 'mineralogy' OR
        TG_TABLE_NAME::text = 'chronostratigraphy') THEN

        IF NEW.parent_ref IS DISTINCT FROM OLD.parent_ref THEN
          IF NEW.parent_ref IS NULL THEN
            NEW.path ='/';
          ELSIF OLD.parent_ref IS NOT DISTINCT FROM NEW.parent_ref THEN
            RETURN NEW;
          ELSE
            EXECUTE 'SELECT  path || id || ''/''  FROM ' || quote_ident(TG_TABLE_NAME::text) || ' WHERE id=' || quote_literal(NEW.parent_ref) INTO STRICT NEW.path;
          END IF;

          EXECUTE 'UPDATE ' || quote_ident(TG_TABLE_NAME::text) || ' SET path=replace(path, ' ||  quote_literal(OLD.path || OLD.id || '/') ||' , ' || quote_literal( NEW.path || OLD.id || '/') || ') ' ||
            ' WHERE path like ' || quote_literal(OLD.path || OLD.id || '/%');
        END IF;
--         RAISE INFO 'nothing diff';
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_path_catalogs() OWNER TO darwin2;

--
-- TOC entry 756 (class 1255 OID 18709)
-- Name: fct_cpy_speed_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'Kt' THEN
        ($1)*0.51444444444444
      WHEN $2 = 'Beaufort' THEN
        CASE
          WHEN $1 = 0 THEN
            0.13888888888888
          WHEN $1 = 1 THEN
            3*0.27777777777778
          WHEN $1 = 2 THEN
            8*0.27777777777778
          WHEN $1 = 3 THEN
            15*0.27777777777778
          WHEN $1 = 4 THEN
            23.5*0.27777777777778
          WHEN $1 = 5 THEN
            33*0.27777777777778
          WHEN $1 = 6 THEN
            44*0.27777777777778
          WHEN $1 = 7 THEN
            55.5*0.27777777777778
          WHEN $1 = 8 THEN
            68*0.27777777777778
          WHEN $1 = 9 THEN
            81.5*0.27777777777778
          WHEN $1 = 10 THEN
            95.5*0.27777777777778
          WHEN $1 = 11 THEN
            110*0.27777777777778
          ELSE
            120*0.27777777777778
        END
      ELSE
        CASE
          WHEN strpos($2, '/') > 0 THEN
            fct_cpy_length_conversion($1, substr($2, 0, strpos($2, '/')))/fct_cpy_time_conversion(1, substr($2, strpos($2, '/')+1))
          ELSE
            $1
        END
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit text) OWNER TO darwin2;

--
-- TOC entry 757 (class 1255 OID 18710)
-- Name: fct_cpy_temperature_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = '°C' THEN
        ($1)+273.15
      WHEN $2 = '°F' THEN
        (($1)+459.67)/1.8
      WHEN $2 = '°Ra' THEN
        ($1)/1.8
      WHEN $2 in ('°Ré', '°r') THEN
        (($1)*5/4)+273.15
      WHEN $2 = '°N' THEN
        (($1)+273.15)*0.33
      WHEN $2 = '°Rø' THEN
        (((($1)-7.5)*40)/21)+273.15
      WHEN $2 = '°De' THEN
        373.15-(($1)*2/3)
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit text) OWNER TO darwin2;

--
-- TOC entry 758 (class 1255 OID 18711)
-- Name: fct_cpy_time_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'ns' THEN
        ($1)*10^(-9)
      WHEN $2 = 'shake' THEN
        ($1)*10^(-8)
      WHEN $2 = 'µs' THEN
        ($1)*10^(-6)
      WHEN $2 = 'ms' THEN
        ($1)*10^(-3)
      WHEN $2 = 'cs' THEN
        ($1)*10^(-2)
      WHEN $2 = 't' THEN
        ($1)/60
      WHEN $2 = 'ds' THEN
        ($1)*10^(-1)
      WHEN $2 = 'min' THEN
        60*($1)
      WHEN $2 = 'h' THEN
        3600*($1)
      WHEN $2 IN ('d', 'j') THEN
        86400*($1)
      WHEN $2 IN ('y', 'year') THEN
        ($1)*3.1536*10^7
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit text) OWNER TO darwin2;

--
-- TOC entry 759 (class 1255 OID 18712)
-- Name: fct_cpy_unified_values(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_unified_values() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  property_line properties%ROWTYPE;
BEGIN
  NEW.lower_value_unified = convert_to_unified(NEW.lower_value, NEW.property_unit, NEW.property_type);
  NEW.upper_value_unified = convert_to_unified(CASE WHEN NEW.upper_value = '' THEN NEW.lower_value ELSE NEW.upper_value END, NEW.property_unit, NEW.property_type);
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_unified_values() OWNER TO darwin2;

--
-- TOC entry 760 (class 1255 OID 18713)
-- Name: fct_cpy_updatecollectionrights(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_updatecollectionrights() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	db_user_type_val integer ;
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO collections_rights (collection_ref, user_ref, db_user_type)
    (SELECT NEW.id as coll_ref, NEW.main_manager_ref as mgr_ref, 4 as user_type
     UNION
     SELECT NEW.id as coll_ref, user_ref as mgr_ref, db_user_type as user_type
     FROM collections_rights
     WHERE collection_ref = NEW.parent_ref
       AND db_user_type = 4
    );
  ELSIF TG_OP = 'UPDATE' THEN
    IF NEW.main_manager_ref IS DISTINCT FROM OLD.main_manager_ref THEN
      SELECT db_user_type INTO db_user_type_val FROM collections_rights WHERE collection_ref = NEW.id AND user_ref = NEW.main_manager_ref;
      IF FOUND AND db_user_type_val is distinct from 4 THEN
        UPDATE collections_rights
        SET db_user_type = 4
        WHERE collection_ref = NEW.id
          AND user_ref = NEW.main_manager_ref;
      ELSE
        INSERT INTO collections_rights (collection_ref, user_ref, db_user_type)
        VALUES(NEW.id,NEW.main_manager_ref,4);
      END IF;
    END IF;
    IF NEW.parent_ref IS DISTINCT FROM OLD.parent_ref THEN
      INSERT INTO collections_rights (collection_ref, user_ref, db_user_type)
      (
        SELECT NEW.id, user_ref, db_user_type
        FROM collections_rights
        WHERE collection_ref = NEW.parent_ref
          AND db_user_type = 4
          AND user_ref NOT IN
            (
              SELECT user_ref
              FROM collections_rights
              WHERE collection_ref = NEW.id
            )
      );
    END IF;
  END IF;

  RETURN NEW;

EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'An error occured: %', SQLERRM;
    RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_updatecollectionrights() OWNER TO darwin2;

--
-- TOC entry 761 (class 1255 OID 18714)
-- Name: fct_cpy_updatecollinstitutioncascade(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_updatecollinstitutioncascade() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.institution_ref IS DISTINCT FROM OLD.institution_ref THEN
    UPDATE collections
    SET institution_ref = NEW.institution_ref
    WHERE id != NEW.id
      AND parent_ref = NEW.id;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_updatecollinstitutioncascade() OWNER TO darwin2;

--
-- TOC entry 765 (class 1255 OID 18715)
-- Name: fct_cpy_updatemywidgetscoll(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_updatemywidgetscoll() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  booContinue boolean := false;
BEGIN
  IF TG_TABLE_NAME = 'collections_rights' THEN
    IF TG_OP = 'DELETE' THEN
      booContinue := true;
    ELSE
      IF OLD.collection_ref IS DISTINCT FROM NEW.collection_ref OR OLD.user_ref IS DISTINCT FROM NEW.user_ref THEN
        booContinue := true;
      END IF;
    END IF;
    IF booContinue THEN
      /*!!! Whats done is only removing the old collection reference from list of collections set in widgets !!!
        !!! We considered the add of widgets available for someone in a collection still be a manual action !!!
      */
      UPDATE my_widgets
      SET collections = regexp_replace(collections, E'\,' || OLD.collection_ref || E'\,', E'\,', 'g')
      WHERE user_ref = OLD.user_ref
        AND collections ~ (E'\,' || OLD.collection_ref || E'\,');
    END IF;
  END IF;
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_updatemywidgetscoll() OWNER TO darwin2;

--
-- TOC entry 766 (class 1255 OID 18716)
-- Name: fct_cpy_updateuserrights(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_updateuserrights() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  db_user_type_val integer ;
  booCollFound boolean;
  booContinue boolean;
BEGIN
  /*When updating main manager ref -> impact potentially db_user_type
    of new user chosen as manager
  */
  IF TG_TABLE_NAME = 'collections' THEN
    /*We take in count only an update
      An insertion as it's creating an entry in collections_rights will trigger this current trigger again ;)
    */
    IF TG_OP = 'UPDATE' THEN
      IF NEW.main_manager_ref IS DISTINCT FROM OLD.main_manager_ref THEN
        UPDATE users
        SET db_user_type = 4
        WHERE id = NEW.main_manager_ref
          AND db_user_type < 4;
      END IF;
    END IF;
  ELSE -- trigger on collections_rights table
    IF TG_OP = 'INSERT' THEN
      /*If user is promoted by inserting her/him
        with a higher db_user_type than she/he is -> promote her/him
      */
      UPDATE users
      SET db_user_type = NEW.db_user_type
      WHERE id = NEW.user_ref
        AND db_user_type < NEW.db_user_type;
    END IF;
    IF TG_OP = 'UPDATE' THEN
      /*First case: replacing a user by an other*/
      IF NEW.user_ref IS DISTINCT FROM OLD.user_ref THEN
        /*Update the user db_user_type chosen as the new one as if it would be an insertion*/
        UPDATE users
        SET db_user_type = NEW.db_user_type
        WHERE id = NEW.user_ref
          AND db_user_type < NEW.db_user_type;
        /*Un promote the user replaced if necessary*/
        UPDATE users
          SET db_user_type = subq.db_user_type_max
          FROM (
                SELECT COALESCE(MAX(db_user_type),1) as db_user_type_max
                FROM collections_rights
                WHERE user_ref = OLD.user_ref
              ) subq
          WHERE id = OLD.user_ref
            AND db_user_type != 8;
      END IF;
      IF NEW.db_user_type IS DISTINCT FROM OLD.db_user_type THEN
        /* Promotion */
        IF NEW.db_user_type > OLD.db_user_type THEN
          UPDATE users
          SET db_user_type = NEW.db_user_type
          WHERE id = NEW.user_ref
            AND db_user_type < NEW.db_user_type;
        /* Unpromotion */
        ELSE
          UPDATE users
          SET db_user_type = subq.db_user_type_max
          FROM (
                SELECT COALESCE(MAX(db_user_type),1) as db_user_type_max
                FROM collections_rights
                WHERE user_ref = NEW.user_ref
              ) subq
          WHERE id = NEW.user_ref
            AND db_user_type != 8;
        END IF;
      END IF;
    END IF;
    IF TG_OP = 'DELETE' THEN
      IF OLD.db_user_type >=4 THEN
        SELECT true
        INTO booCollFound
        FROM collections
        WHERE id = OLD.collection_ref
          AND main_manager_ref = OLD.user_ref;
        IF FOUND THEN
          RAISE EXCEPTION 'You try to delete a manager who is still defined as a main manager of the current collection';
        END IF;
      END IF;
      UPDATE users
      SET db_user_type = subq.db_user_type_max
      FROM (
            SELECT COALESCE(MAX(db_user_type),1) as db_user_type_max
            FROM collections_rights
            WHERE user_ref = OLD.user_ref
           ) subq
      WHERE id = OLD.user_ref
        AND db_user_type != 8;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_updateuserrights() OWNER TO darwin2;

--
-- TOC entry 767 (class 1255 OID 18717)
-- Name: fct_cpy_volume_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'l' THEN
        ($1)*10^(-3)
      WHEN $2 = 'cm³' OR $2 = 'ml' THEN
        ($1)*10^(-6)
      WHEN $2 = 'mm³' OR $2 = 'µl' THEN
        ($1)*10^(-9)
      WHEN $2 = 'µm³' THEN
        ($1)*10^(-18)
      WHEN $2 = 'km³' THEN
        ($1)*10^(9)
      WHEN $2 = 'Ml' THEN
        ($1)*10^(3)
      WHEN $2 = 'hl' THEN
        ($1)*10
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit text) OWNER TO darwin2;

--
-- TOC entry 768 (class 1255 OID 18718)
-- Name: fct_cpy_weight_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'hg' THEN
        ($1)*10^(2)
      WHEN $2 = 'kg' THEN
        ($1)*10^(3)
      WHEN $2 = 'Mg' OR $2 = 'ton' THEN
        ($1)*10^(6)
      WHEN $2 = 'dg' THEN
        ($1)*10^(-1)
      WHEN $2 = 'cg' THEN
        ($1)*10^(-2)
      WHEN $2 = 'mg' THEN
        ($1)*10^(-3)
      WHEN $2 = 'lb' OR $2 = 'lbs' OR $2 = 'pound' THEN
        ($1)*453.59237
      WHEN $2 = 'ounce' THEN
        ($1)*28.349523125
      WHEN $2 = 'grain' THEN
        ($1)*6.479891*10^(-2)
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit text) OWNER TO darwin2;

--
-- TOC entry 769 (class 1255 OID 18719)
-- Name: fct_del_in_dict(text, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_del_in_dict(ref_relation text, ref_field text, old_value text, new_val text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result boolean;
  query_str text;
BEGIN
  IF old_value IS null OR old_value IS NOT DISTINCT FROM new_val THEN
    RETURN TRUE;
  END IF;
  query_str := ' SELECT EXISTS( SELECT 1 from ' || quote_ident(ref_relation) || ' where ' || quote_ident(ref_field) || ' = ' || quote_literal(old_value) || ');';
  execute query_str into result;

  IF result = false THEN
    DELETE FROM flat_dict where
          referenced_relation = ref_relation
          AND dict_field = ref_field
          AND dict_value = old_value;
  END IF;
  RETURN TRUE;
END;
$$;


ALTER FUNCTION darwin2.fct_del_in_dict(ref_relation text, ref_field text, old_value text, new_val text) OWNER TO darwin2;

--
-- TOC entry 770 (class 1255 OID 18720)
-- Name: fct_del_in_dict_dept(text, text, text, text, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_del_in_dict_dept(ref_relation text, ref_field text, old_value text, new_val text, depending_old_value text, depending_new_value text, depending_field text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result boolean;
  query_str text;
BEGIN
  IF old_value is NULL OR ( old_value IS NOT DISTINCT FROM new_val AND depending_old_value IS NOT DISTINCT FROM depending_new_value ) THEN
    RETURN TRUE;
  END IF;
  query_str := ' SELECT EXISTS( SELECT id from ' || quote_ident(ref_relation) || ' where ' || quote_ident(ref_field) || ' = ' || quote_literal(old_value)
  || ' AND ' || quote_ident(depending_field) || ' = ' || quote_literal(depending_old_value) || ' );';
  execute query_str into result;

  IF result = false THEN
    DELETE FROM flat_dict where
          referenced_relation = ref_relation
          AND dict_field = ref_field
          AND dict_value = old_value
          AND dict_depend = depending_old_value;
  END IF;
  RETURN TRUE;
END;
$$;


ALTER FUNCTION darwin2.fct_del_in_dict_dept(ref_relation text, ref_field text, old_value text, new_val text, depending_old_value text, depending_new_value text, depending_field text) OWNER TO darwin2;

--
-- TOC entry 771 (class 1255 OID 18721)
-- Name: fct_duplicate_loans(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_duplicate_loans(loan_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    new_loan_id loans.id%TYPE;
    new_loan_item_id loan_items.id%TYPE;
    rec_loan_items RECORD;
  BEGIN
  --ftheeten 2018 03 09 added collection_ref
    INSERT INTO loans (name, description, collection_ref)
      (SELECT 'COPY_OF_'||name, description, collection_ref FROM loans WHERE id = loan_id)
    RETURNING id INTO new_loan_id;
   /* INSERT INTO loan_rights (loan_ref, user_ref, has_encoding_right)
      (SELECT new_loan_id, user_ref, has_encoding_right from loan_rights where loan_ref = loan_id);*/
    INSERT INTO catalogue_people (referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
      (
        SELECT referenced_relation, new_loan_id, people_type, people_sub_type, order_by, people_ref
        FROM catalogue_people
        WHERE referenced_relation = 'loans'
          AND record_id = loan_id
      );
    INSERT INTO insurances (referenced_relation,
                            record_id,
                            insurance_value,
                            insurance_currency,
                            insurer_ref,
                            date_from_mask,
                            date_from,
                            date_to_mask,
                            date_to,
                            contact_ref)
      (SELECT
         referenced_relation,
         new_loan_id,
         insurance_value,
         insurance_currency,
         insurer_ref,
         date_from_mask,
         date_from,
         date_to_mask,
         date_to,
         contact_ref
       FROM insurances
        WHERE referenced_relation = 'loans'
          AND record_id = loan_id
      );
    INSERT INTO comments (referenced_relation, record_id, notion_concerned, comment)
      (SELECT referenced_relation, new_loan_id, notion_concerned, comment from comments where referenced_relation = 'loans' AND record_id = loan_id);
    INSERT INTO properties (
      referenced_relation,
      record_id,
      property_type,
      applies_to,
      date_from_mask,
      date_from,
      date_to_mask,
      date_to,
      is_quantitative,
      property_unit,
      method,
      lower_value,
      upper_value,
      property_accuracy
    )
      (
        SELECT
          referenced_relation,
          new_loan_id,
          property_type,
          applies_to,
          date_from_mask,
          date_from,
          date_to_mask,
          date_to,
          is_quantitative,
          property_unit,
          method,
          lower_value,
          upper_value,
          property_accuracy
        FROM properties
        WHERE referenced_relation = 'loans'
          AND record_id = loan_id
      );
    FOR rec_loan_items IN SELECT id FROM loan_items WHERE loan_ref = loan_id
      LOOP
        INSERT INTO loan_items (loan_ref, ig_ref, specimen_ref, details)
          (SELECT new_loan_id, ig_ref, specimen_ref, details FROM loan_items WHERE id = rec_loan_items.id)
        RETURNING id INTO new_loan_item_id;
        INSERT INTO catalogue_people (referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
          (
            SELECT referenced_relation, new_loan_item_id, people_type, people_sub_type, order_by, people_ref
            FROM catalogue_people
            WHERE referenced_relation = 'loan_items'
                  AND record_id = rec_loan_items.id
          );
        INSERT INTO codes (
          referenced_relation,
          record_id,
          code_category,
          code_prefix,
          code_prefix_separator,
          code,
          code_suffix_separator,
          code_suffix,
          code_date,
          code_date_mask
        )
        (
          SELECT
           referenced_relation,
           new_loan_item_id,
           code_category,
           code_prefix,
           code_prefix_separator,
           code,
           code_suffix_separator,
           code_suffix,
           code_date,
           code_date_mask
          FROM codes
          WHERE referenced_relation = 'loan_items'
            AND record_id = rec_loan_items.id
        );
        INSERT INTO insurances (referenced_relation,
                                record_id,
                                insurance_value,
                                insurance_currency,
                                insurer_ref,
                                date_from_mask,
                                date_from,
                                date_to_mask,
                                date_to,
                                contact_ref)
          (SELECT
             referenced_relation,
             new_loan_item_id,
             insurance_value,
             insurance_currency,
             insurer_ref,
             date_from_mask,
             date_from,
             date_to_mask,
             date_to,
             contact_ref
           FROM insurances
           WHERE referenced_relation = 'loan_items'
                 AND record_id = rec_loan_items.id
          );
        INSERT INTO comments (referenced_relation, record_id, notion_concerned, comment)
          (SELECT referenced_relation, new_loan_item_id, notion_concerned, comment from comments where referenced_relation = 'loan_items' AND record_id = rec_loan_items.id);
        INSERT INTO properties (
          referenced_relation,
          record_id,
          property_type,
          applies_to,
          date_from_mask,
          date_from,
          date_to_mask,
          date_to,
          is_quantitative,
          property_unit,
          method,
          lower_value,
          upper_value,
          property_accuracy
        )
          (
            SELECT
              referenced_relation,
              new_loan_item_id,
              property_type,
              applies_to,
              date_from_mask,
              date_from,
              date_to_mask,
              date_to,
              is_quantitative,
              property_unit,
              method,
              lower_value,
              upper_value,
              property_accuracy
            FROM properties
            WHERE referenced_relation = 'loan_items'
                  AND record_id = rec_loan_items.id
          );
      END LOOP;
    RETURN new_loan_id;
  EXCEPTION
    WHEN OTHERS THEN
      RETURN 0;
  END;
  $$;


ALTER FUNCTION darwin2.fct_duplicate_loans(loan_id integer) OWNER TO darwin2;

--
-- TOC entry 772 (class 1255 OID 18722)
-- Name: fct_explode_array(anyarray); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_explode_array(in_array anyarray) RETURNS SETOF anyelement
    LANGUAGE sql IMMUTABLE
    AS $_$
    select ($1)[s] from generate_series(1,array_upper($1, 1)) as s;
$_$;


ALTER FUNCTION darwin2.fct_explode_array(in_array anyarray) OWNER TO darwin2;

--
-- TOC entry 773 (class 1255 OID 18723)
-- Name: fct_filter_encodable_row(character varying, character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_filter_encodable_row(ids character varying, col_name character varying, user_id integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_id integer;
BEGIN
    IF col_name = 'spec_ref' THEN
      FOR rec_id IN SELECT id FROM specimens WHERE id in (select X::int from regexp_split_to_table(ids, ',' ) as X)
            AND collection_ref in (select X FROM fct_search_authorized_encoding_collections(user_id) as X)
      LOOP
        return next rec_id;
      END LOOP;
    END IF;

END;
$$;


ALTER FUNCTION darwin2.fct_filter_encodable_row(ids character varying, col_name character varying, user_id integer) OWNER TO darwin2;

--
-- TOC entry 774 (class 1255 OID 18724)
-- Name: fct_find_tax_level(text, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_find_tax_level(tax_path text, searched_level integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
   SELECT id FROM taxonomy where  level_ref = $2 and id in (select i::int from regexp_split_to_table($1, E'\/') as i where i != '');
$_$;


ALTER FUNCTION darwin2.fct_find_tax_level(tax_path text, searched_level integer) OWNER TO darwin2;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- TOC entry 243 (class 1259 OID 18725)
-- Name: staging; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging (
    id integer NOT NULL,
    import_ref integer NOT NULL,
    create_taxon boolean DEFAULT false NOT NULL,
    spec_ref integer,
    category character varying,
    expedition_ref integer,
    expedition_name character varying,
    expedition_from_date date,
    expedition_from_date_mask integer,
    expedition_to_date date,
    expedition_to_date_mask integer,
    station_visible boolean,
    gtu_ref integer,
    gtu_code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_latitude double precision,
    gtu_longitude double precision,
    gtu_lat_long_accuracy double precision,
    gtu_elevation double precision,
    gtu_elevation_accuracy double precision,
    taxon_ref integer,
    taxon_name character varying,
    taxon_level_ref integer,
    taxon_level_name character varying,
    taxon_status character varying,
    taxon_extinct boolean,
    taxon_parents public.hstore,
    litho_ref integer,
    litho_name character varying,
    litho_level_ref integer,
    litho_level_name character varying,
    litho_status character varying,
    litho_local boolean,
    litho_color character varying,
    litho_parents public.hstore,
    chrono_ref integer,
    chrono_name character varying,
    chrono_level_ref integer,
    chrono_level_name character varying,
    chrono_status character varying,
    chrono_local boolean,
    chrono_color character varying,
    chrono_upper_bound numeric(10,3),
    chrono_lower_bound numeric(10,3),
    chrono_parents public.hstore,
    lithology_ref integer,
    lithology_name character varying,
    lithology_level_ref integer,
    lithology_level_name character varying,
    lithology_status character varying,
    lithology_local boolean,
    lithology_color character varying,
    lithology_parents public.hstore,
    mineral_ref integer,
    mineral_name character varying,
    mineral_level_ref integer,
    mineral_level_name character varying,
    mineral_status character varying,
    mineral_local boolean,
    mineral_color character varying,
    mineral_path character varying,
    mineral_parents public.hstore,
    mineral_classification character varying,
    ig_ref integer,
    ig_num character varying,
    ig_date_mask integer,
    ig_date date,
    acquisition_category character varying,
    acquisition_date_mask integer,
    acquisition_date date,
    individual_type character varying,
    individual_sex character varying,
    individual_state character varying,
    individual_stage character varying,
    individual_social_status character varying,
    individual_rock_form character varying,
    individual_count_min integer,
    individual_count_max integer,
    part character varying,
    part_status character varying,
    institution_ref integer,
    institution_name character varying,
    building character varying,
    floor character varying,
    room character varying,
    "row" character varying,
    col character varying,
    shelf character varying,
    container_type character varying,
    container_storage character varying,
    container character varying,
    sub_container_type character varying,
    sub_container_storage character varying,
    sub_container character varying,
    part_count_min integer,
    part_count_max integer,
    specimen_status character varying,
    complete boolean,
    surnumerary boolean,
    status public.hstore DEFAULT ''::public.hstore NOT NULL,
    to_import boolean DEFAULT false,
    object_name text,
    part_count_males_min integer,
    part_count_males_max integer,
    part_count_females_min integer,
    part_count_females_max integer,
    part_count_juveniles_min integer,
    part_count_juveniles_max integer,
    specimen_taxonomy_ref integer
);


ALTER TABLE darwin2.staging OWNER TO darwin2;

--
-- TOC entry 775 (class 1255 OID 18734)
-- Name: fct_imp_checker_catalogue(darwin2.staging, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_catalogue(line darwin2.staging, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  ref_record RECORD;
  rec_id integer := null;
  line_store hstore;
  field_name text;
  field_level_name text;
  test text;
  ref refcursor;

   --ftheeten 2017 08 03
  taxonomy_ref_str varchar;
  restrict_taxonomy boolean;
  filter_taxonomy_str varchar;
   --ftheeten 2017 08 03
BEGIN
    line_store := hstore(line);
    field_name := prefix || '_name';
    field_name := line_store->field_name;
    field_level_name := prefix || '_level_name';
    field_level_name := coalesce(line_store->field_level_name,'');

     --ftheeten 2017 08 03
  taxonomy_ref_str :=line_store->'specimen_taxonomy_ref';
  restrict_taxonomy := false;
  filter_taxonomy_str:='';
  IF LENGTH(TRIM(taxonomy_ref_str))> 0 THEN
	IF(taxonomy_ref_str::int)>0 AND catalogue_table='taxonomy'  THEN
		restrict_taxonomy:=TRUE;
		filter_taxonomy_str:='  metadata_ref = '|| taxonomy_ref_str||' AND ';		
	END IF;
  END IF;
   --ftheeten 2017 08 03

    OPEN ref FOR EXECUTE 'SELECT * FROM ' || catalogue_table || ' t
    INNER JOIN catalogue_levels c on t.level_ref = c.id
    WHERE '||filter_taxonomy_str ||' name = ' || quote_literal( field_name) || ' AND  level_sys_name = CASE WHEN ' || quote_literal(field_level_name) || ' = '''' THEN level_sys_name ELSE ' || quote_literal(field_level_name) || ' END
    LIMIT 2';
    LOOP
      FETCH ref INTO ref_record;
      IF  NOT FOUND THEN
        EXIT;  -- exit loop
      END IF;

      rec_id := ref_record.id;
      result_nbr := result_nbr +1;
    END LOOP;

    IF result_nbr = 1 THEN -- It's Ok!

      PERFORM fct_imp_checker_catalogues_parents(line,rec_id, catalogue_table, prefix);
      RETURN true;
    END IF;

    IF result_nbr >= 2 THEN
      UPDATE staging SET status = (status || hstore(prefix, 'too_much')) where id= line.id;
      RETURN true;
    END IF;

    CLOSE ref;

  /*** Then CHECK fuzzy name ***/

  result_nbr := 0;
  IF catalogue_table = 'mineralogy' THEN
    OPEN ref FOR EXECUTE 'SELECT * FROM ' || catalogue_table || ' t
    INNER JOIN catalogue_levels c on t.level_ref = c.id
    WHERE name_indexed like fullToIndex(' || quote_literal( field_name) || ') AND  level_sys_name = CASE WHEN ' || quote_literal(field_level_name) || ' = '''' THEN level_sys_name ELSE ' || quote_literal(field_level_name) || ' END
    LIMIT 2';
    LOOP
      FETCH ref INTO ref_record;
      IF  NOT FOUND THEN
        EXIT;  -- exit loop
      END IF;

      rec_id := ref_record.id;
      result_nbr := result_nbr +1;
    END LOOP;
  ELSE
    OPEN ref FOR EXECUTE 'SELECT * FROM ' || catalogue_table || ' t
    INNER JOIN catalogue_levels c on t.level_ref = c.id
    WHERE '||filter_taxonomy_str ||' name_indexed like fullToIndex(' || quote_literal( field_name) || ') || ''%'' AND  level_sys_name = CASE WHEN ' || quote_literal(field_level_name) || ' = '''' THEN level_sys_name ELSE ' || quote_literal(field_level_name) || ' END
    LIMIT 2';
    LOOP
      FETCH ref INTO ref_record;
      IF  NOT FOUND THEN
        EXIT;  -- exit loop
      END IF;

      rec_id := ref_record.id;
      result_nbr := result_nbr +1;
    END LOOP;
  END IF ;

  IF result_nbr = 1 THEN -- It's Ok!
    PERFORM fct_imp_checker_catalogues_parents(line,rec_id, catalogue_table, prefix);
    RETURN true;
  END IF;

  IF result_nbr >= 2 THEN
    UPDATE staging SET status = (status || hstore(prefix, 'too_much')) where id= line.id;
    RETURN true;
  END IF;

  IF result_nbr = 0 THEN
    UPDATE staging SET status = (status || hstore(prefix, 'not_found')) where id=line.id;
    RETURN true;
  END IF;

  CLOSE ref;
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_catalogue(line darwin2.staging, catalogue_table text, prefix text) OWNER TO darwin2;

--
-- TOC entry 776 (class 1255 OID 18735)
-- Name: fct_imp_checker_catalogues_parents(darwin2.staging, integer, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_catalogues_parents(line darwin2.staging, rec_id integer, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  row_record record;
  lvl_name varchar;
  lvl_value varchar;
  rec_parents hstore;
  line_store hstore;
  field_name text;

  --ftheeten 2017 08 03
  taxonomy_ref_str varchar;
  restrict_taxonomy boolean;
  filter_taxonomy_str varchar;
   --ftheeten 2017 08 03

   --ftheeten 2018 08 14
   rec_parents_darwin hstore;
BEGIN
  line_store := hstore(line);
  field_name := prefix || '_parents';
  rec_parents := line_store->field_name;

  --ftheeten 2017 08 03
  taxonomy_ref_str :=line_store->'specimen_taxonomy_ref';
  restrict_taxonomy := false;
  filter_taxonomy_str:='';
  IF LENGTH(TRIM(taxonomy_ref_str))> 0 THEN
	IF(taxonomy_ref_str::int)>0 AND catalogue_table='taxonomy'  THEN
		restrict_taxonomy:=TRUE;
		filter_taxonomy_str:='  metadata_ref = '|| taxonomy_ref_str||' AND ';		
	END IF;
  END IF;
   --ftheeten 2017 08 03

--ftheeten 2018 06 16
If catalogue_table='taxonomy' THEN
	IF rec_parents is not null AND rec_parents != ''::hstore  AND rec_id is not null THEN
		 --EXECUTE 'select *,  from taxonomy where id = ' || rec_id into row_record ;
		 SELECT fct_rmca_sort_taxon_path_alphabetically_hstore(path) INTO rec_parents_darwin FROM taxonomy where id = rec_id; --INNER JOIN catalogue_levels c on taxonomy.level_ref = c.id where id=rec_id;
		 --raise notice 'darwin %', rec_parents_darwin;
		  --raise notice '%', line.taxon_level_name;
		 rec_parents := rec_parents - line.taxon_level_name;
		 -- raise notice 'imported %', rec_parents_darwin;
		 IF (rec_parents_darwin @> rec_parents) = FALSE THEN
		-- raise notice '%', rec_parents_darwin @> rec_parent;
			--RAISE NOTIcE '% % NOTCONTAINED % !!!!', rec_id ,rec_parents_darwin, rec_parents;
			 EXECUTE 'UPDATE staging SET status = (status || hstore('|| quote_literal(prefix) || ' , ''bad_hierarchy'')), ' || prefix || '_ref = null where id=' || line.id;
			RETURN TRUE;
		 --ELSE
			--RAISE NOTIcE 'CONTAINED !!!!';
		 END IF;
	END IF;
ELSE

  IF rec_parents is not null AND rec_parents != ''::hstore  AND rec_id is not null THEN
    EXECUTE 'select * from '|| quote_ident(catalogue_table) || ' where id = ' || rec_id into row_record ;

    FOR lvl_name in SELECT s FROM fct_explode_array(akeys(rec_parents)) as s
    LOOP
      lvl_value := rec_parents->lvl_name;
      EXECUTE 'SELECT count(*) from ' || quote_ident(catalogue_table) || ' t
        INNER JOIN catalogue_levels c on t.level_ref = c.id
        WHERE '|| filter_taxonomy_str||' level_sys_name = ' || quote_literal(lvl_name) || ' AND
          name_indexed like fullToIndex( ' || quote_literal(lvl_value) || '  ) || ''%''
          AND ' || quote_literal(row_record.path) || 'like t.path || t.id || ''/%'' ' INTO result_nbr;
      IF result_nbr = 0 THEN
        EXECUTE 'UPDATE staging SET status = (status || hstore('|| quote_literal(prefix) || ', ''bad_hierarchy'')), ' || prefix || '_ref = null where id=' || line.id;
        RETURN TRUE;
      END IF;
    END LOOP;
  END IF;
END IF;
  EXECUTE 'UPDATE staging SET status = delete(status, ' || quote_literal(prefix) ||'), ' || prefix|| '_ref = ' || rec_id || ' where id=' || line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_catalogues_parents(line darwin2.staging, rec_id integer, catalogue_table text, prefix text) OWNER TO darwin2;

--
-- TOC entry 777 (class 1255 OID 18736)
-- Name: fct_imp_checker_catalogues_parents_bck20180415(darwin2.staging, integer, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_catalogues_parents_bck20180415(line darwin2.staging, rec_id integer, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  row_record record;
  lvl_name varchar;
  lvl_value varchar;
  rec_parents hstore;
  line_store hstore;
  field_name text;
BEGIN
  line_store := hstore(line);
  field_name := prefix || '_parents';
  rec_parents := line_store->field_name;

  IF rec_parents is not null AND rec_parents != ''::hstore  AND rec_id is not null THEN
    EXECUTE 'select * from '|| quote_ident(catalogue_table) || ' where id = ' || rec_id into row_record ;

    FOR lvl_name in SELECT s FROM fct_explode_array(akeys(rec_parents)) as s
    LOOP
      lvl_value := rec_parents->lvl_name;
      EXECUTE 'SELECT count(*) from ' || quote_ident(catalogue_table) || ' t
        INNER JOIN catalogue_levels c on t.level_ref = c.id
        WHERE level_sys_name = ' || quote_literal(lvl_name) || ' AND
          name_indexed like fullToIndex( ' || quote_literal(lvl_value) || '  ) || ''%''
          AND ' || quote_literal(row_record.path) || 'like t.path || t.id || ''/%'' ' INTO result_nbr;
      IF result_nbr = 0 THEN
        EXECUTE 'UPDATE staging SET status = (status || ('|| quote_literal(prefix) || ' => ''bad_hierarchy'')), ' || prefix || '_ref = null where id=' || line.id;
        RETURN TRUE;
      END IF;
    END LOOP;
  END IF;

  EXECUTE 'UPDATE staging SET status = delete(status, ' || quote_literal(prefix) ||'), ' || prefix|| '_ref = ' || rec_id || ' where id=' || line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_catalogues_parents_bck20180415(line darwin2.staging, rec_id integer, catalogue_table text, prefix text) OWNER TO darwin2;

--
-- TOC entry 785 (class 1255 OID 18737)
-- Name: fct_imp_checker_expeditions(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_expeditions(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_rec integer :=0;
BEGIN
  IF line.expedition_name is null OR line.expedition_name ='' OR line.expedition_ref is not null THEN
    RETURN true;
  END IF;

  select id into ref_rec from expeditions where name_indexed = fulltoindex(line.expedition_name) and
    expedition_from_date = COALESCE(line.expedition_from_date,'01/01/0001') AND
    expedition_to_date = COALESCE(line.expedition_to_date,'31/12/2038');
  IF NOT FOUND THEN
      IF import THEN
        INSERT INTO expeditions (name, expedition_from_date, expedition_to_date, expedition_from_date_mask,expedition_to_date_mask)
        VALUES (
          line.expedition_name, COALESCE(line.expedition_from_date,'01/01/0001'),
          COALESCE(line.expedition_to_date,'31/12/2038'), COALESCE(line.expedition_from_date_mask,0),
          COALESCE(line.expedition_to_date_mask,0)
        )
        RETURNING id INTO line.expedition_ref;

        ref_rec := line.expedition_ref;
        PERFORM fct_imp_checker_staging_info(line, 'expeditions');
      ELSE
        RETURN TRUE;
      END IF;
  END IF;

  UPDATE staging SET status = delete(status,'expedition'), expedition_ref = ref_rec where id=line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_expeditions(line darwin2.staging, import boolean) OWNER TO darwin2;

--
-- TOC entry 786 (class 1255 OID 18738)
-- Name: fct_imp_checker_gtu(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_gtu(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_rec integer :=0;
  tags staging_tag_groups ;
  cpt integer;
BEGIN
  IF line.gtu_ref is not null THEN
    RETURN true;
  END IF;
  IF (line.gtu_code is null OR line.gtu_code  = '') AND (line.gtu_from_date is null OR line.gtu_code  = '') AND NOT EXISTS (select 1 from staging_tag_groups g where g.staging_ref = line.id ) THEN
    RETURN true;
  END IF;

    select id into ref_rec from gtu g where
      COALESCE(latitude,0) = COALESCE(line.gtu_latitude,0) AND
      COALESCE(longitude,0) = COALESCE(line.gtu_longitude,0) AND
      --ftheeten 2016 07 11
      --gtu_from_date = COALESCE(line.gtu_from_date, '01/01/0001') AND
      --gtu_to_date = COALESCE(line.gtu_to_date, '31/12/2038') AND
      fullToIndex(code) = fullToIndex(line.gtu_code)

      AND id != 0 LIMIT 1;



  IF NOT FOUND THEN
      IF import THEN
      --ftheeten 2018 04 23 added import_ref
        INSERT into gtu
          (code, latitude, longitude, lat_long_accuracy, elevation, elevation_accuracy,
          --ftheeten 2018 04 23
		import_ref
          )
        VALUES
          (COALESCE(line.gtu_code,'import/'|| line.import_ref || '/' || line.id ), 
          --ftheeten 2016 07 1
          --COALESCE(line.gtu_from_date_mask,0), COALESCE(line.gtu_from_date, '01/01/0001'),
          --COALESCE(line.gtu_to_date_mask,0), COALESCE(line.gtu_to_date, '31/12/2038'), 
          line.gtu_latitude, line.gtu_longitude, line.gtu_lat_long_accuracy, line.gtu_elevation, line.gtu_elevation_accuracy
		--ftheeten 2018 04 23
		,line.import_ref
          )
        RETURNING id INTO line.gtu_ref;
        ref_rec := line.gtu_ref;
        FOR tags IN SELECT * FROM staging_tag_groups WHERE staging_ref = line.id LOOP
        BEGIN
          SELECT count(*) into cpt FROM tag_groups where gtu_ref=ref_rec AND group_name=tags.group_name AND sub_group_name= tags.sub_group_name;
          IF cpt>0 THEN
               tags.sub_group_name:= tags.sub_group_name||'_1';
          END IF;
          INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value)
            Values(ref_rec,tags.group_name, tags.sub_group_name, tags.tag_value );
        --  DELETE FROM staging_tag_groups WHERE staging_ref = line.id;
          EXCEPTION WHEN unique_violation THEN
            RAISE EXCEPTION 'An error occured: %', SQLERRM;
        END ;
        END LOOP ;
        PERFORM fct_imp_checker_staging_info(line, 'gtu');
      ELSE
        RETURN TRUE;
      END IF;
  END IF;

  UPDATE staging SET status = delete(status,'gtu'), gtu_ref = ref_rec where id=line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_gtu(line darwin2.staging, import boolean) OWNER TO darwin2;

--
-- TOC entry 787 (class 1255 OID 18739)
-- Name: fct_imp_checker_gtu_20160713(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_gtu_20160713(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_rec integer :=0;
  tags staging_tag_groups ;
BEGIN
  IF line.gtu_ref is not null THEN
    RETURN true;
  END IF;
  IF (line.gtu_code is null OR line.gtu_code  = '') AND (line.gtu_from_date is null OR line.gtu_code  = '') AND NOT EXISTS (select 1 from staging_tag_groups g where g.staging_ref = line.id ) THEN
    RETURN true;
  END IF;

    select id into ref_rec from gtu g where
      COALESCE(latitude,0) = COALESCE(line.gtu_latitude,0) AND
      COALESCE(longitude,0) = COALESCE(line.gtu_longitude,0) AND
      gtu_from_date = COALESCE(line.gtu_from_date, '01/01/0001') AND
      gtu_to_date = COALESCE(line.gtu_to_date, '31/12/2038') AND
      fullToIndex(code) = fullToIndex(line.gtu_code)

      AND id != 0 LIMIT 1;



  IF NOT FOUND THEN
      IF import THEN
        INSERT into gtu
          (code, gtu_from_date_mask, gtu_from_date,gtu_to_date_mask, gtu_to_date, latitude, longitude, lat_long_accuracy, elevation, elevation_accuracy)
        VALUES
          (COALESCE(line.gtu_code,'import/'|| line.import_ref || '/' || line.id ), COALESCE(line.gtu_from_date_mask,0), COALESCE(line.gtu_from_date, '01/01/0001'),
          COALESCE(line.gtu_to_date_mask,0), COALESCE(line.gtu_to_date, '31/12/2038')
          , line.gtu_latitude, line.gtu_longitude, line.gtu_lat_long_accuracy, line.gtu_elevation, line.gtu_elevation_accuracy)
        RETURNING id INTO line.gtu_ref;
        ref_rec := line.gtu_ref;
        FOR tags IN SELECT * FROM staging_tag_groups WHERE staging_ref = line.id LOOP
        BEGIN
          INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value)
            Values(ref_rec,tags.group_name, tags.sub_group_name, tags.tag_value );
        --  DELETE FROM staging_tag_groups WHERE staging_ref = line.id;
          EXCEPTION WHEN unique_violation THEN
            RAISE EXCEPTION 'An error occured: %', SQLERRM;
        END ;
        END LOOP ;
        PERFORM fct_imp_checker_staging_info(line, 'gtu');
      ELSE
        RETURN TRUE;
      END IF;
  END IF;

  UPDATE staging SET status = delete(status,'gtu'), gtu_ref = ref_rec where id=line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_gtu_20160713(line darwin2.staging, import boolean) OWNER TO darwin2;

--
-- TOC entry 792 (class 1255 OID 18740)
-- Name: fct_imp_checker_igs(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_igs(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_rec integer :=0;
BEGIN
  IF line.ig_num is null OR  line.ig_num = '' OR line.ig_ref is not null THEN
    RETURN true;
  END IF;

  select id into ref_rec from igs where ig_num = line.ig_num ;
  IF NOT FOUND THEN
    IF import THEN
        INSERT INTO igs (ig_num, ig_date_mask, ig_date)
        VALUES (line.ig_num,  COALESCE(line.ig_date_mask,line.ig_date_mask,'0'), COALESCE(line.ig_date,'01/01/0001'))
        RETURNING id INTO line.ig_ref;

        ref_rec := line.ig_ref;
        PERFORM fct_imp_checker_staging_info(line, 'igs');
    ELSE
    --UPDATE staging SET status = (status || hstore('igs' , 'not_found')), ig_ref = null where id=line.id;
      RETURN TRUE;
    END IF;
  END IF;

  UPDATE staging SET status = delete(status,'igs'), ig_ref = ref_rec where id=line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_igs(line darwin2.staging, import boolean) OWNER TO darwin2;

--
-- TOC entry 797 (class 1255 OID 18741)
-- Name: fct_imp_checker_manager(darwin2.staging); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_manager(line darwin2.staging) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	--rmca 2019 12 17
	var_merge boolean;
	enforce_unicity BOOLEAN;
	collection_ref_var INTEGER;
BEGIN
--rmca 2019 12 17
SELECT merge_gtu, code_specimen_duplicate, collections.id INTO var_merge, enforce_unicity , collection_ref_var FROM imports LEFT JOIN collections ON imports.collection_ref=collections.id
WHERE imports.id=line.import_ref;

IF COALESCE(enforce_unicity,FALSE) =TRUE THEN
	enforce_unicity=FALSE;
ELSE
	enforce_unicity=TRUE;
END IF;

  IF line.taxon_name IS NOT NULL AND line.taxon_name is distinct from '' AND line.taxon_ref is null THEN
    PERFORM fct_imp_create_catalogues_and_parents(line, 'taxonomy','taxon');
    PERFORM fct_imp_checker_catalogue(line,'taxonomy','taxon');
  END IF;

  IF line.chrono_name IS NOT NULL AND line.chrono_name is distinct from '' AND line.chrono_ref is null THEN
    PERFORM fct_imp_checker_catalogue(line,'chronostratigraphy','chrono');
  END IF;

  IF line.lithology_name IS NOT NULL AND line.lithology_name is distinct from '' AND line.lithology_ref is null THEN
    PERFORM fct_imp_checker_catalogue(line,'lithology','lithology');
  END IF;

  IF line.mineral_name IS NOT NULL AND line.mineral_name is distinct from '' AND line.mineral_ref is null THEN
    PERFORM fct_imp_checker_catalogue(line,'mineralogy','mineral');
  END IF;

  IF line.litho_name IS NOT NULL AND line.litho_name is distinct from '' AND line.litho_ref is null THEN
    PERFORM fct_imp_checker_catalogue(line,'lithostratigraphy','litho');
  END IF;

  PERFORM fct_imp_checker_igs(line);
  PERFORM fct_imp_checker_expeditions(line);
  --PERFORM fct_imp_checker_gtu(line);
--ftheeten 2019 12 17
  --IF COALESCE(var_merge, FALSE) = TRUE THEN
         -- ftheeten 2019 12 16
        PERFORM fct_rmca_imp_checker_gtu_search_code(line, NULL);
  --ELSE
   --       PERFORM fct_imp_checker_gtu(line);
  --END IF;
  IF enforce_unicity=TRUE THEN
	RAISE NOTICE 'check_unicity'; 
	PERFORM fct_rmca_imp_checker_specimen_code(line, collection_ref_var);
  END IF;
  PERFORM fct_imp_checker_people(line);
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_manager(line darwin2.staging) OWNER TO darwin2;

--
-- TOC entry 793 (class 1255 OID 18742)
-- Name: fct_imp_checker_people(darwin2.staging); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_people(line darwin2.staging) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_record integer :=0;
  cnt integer :=-1;
  p_name text;
  merge_status integer :=1;
  ident_line RECORD;
  people_line RECORD ;
BEGIN


  --  Donators and collectors

  FOR people_line IN select * from staging_people WHERE referenced_relation ='staging' AND record_id = line.id
  LOOP
    IF people_line.people_ref is not null THEN
      continue;
    END IF;
    SELECT fct_look_for_people(people_line.formated_name) into ref_record;
    CASE ref_record
      WHEN -1,0 THEN merge_status := -1 ;
      --WHEN 0 THEN merge_status := 0;
      ELSE
        UPDATE staging_people SET people_ref = ref_record WHERE id=people_line.id ;
    END CASE;
  END LOOP;
  IF merge_status = 1 THEN
    UPDATE staging SET status = delete(status,'people') where id=line.id;
  ELSE
    UPDATE staging SET status = (status || hstore('people' , 'people')) where id= line.id;
  END IF;

  -- Identifiers

  merge_status := 1 ;
  FOR ident_line in select * from identifications where referenced_relation ='staging' AND  record_id = line.id
  LOOP
    FOR people_line IN select * from staging_people WHERE referenced_relation ='identifications' AND record_id = ident_line.id
    LOOP
      IF people_line.people_ref is not null THEN
        continue;
      END IF;
      SELECT fct_look_for_people(people_line.formated_name) into ref_record;
      CASE ref_record
        WHEN -1,0 THEN merge_status := -1 ;
        --WHEN 0 THEN merge_status := 0;
        ELSE
          UPDATE staging_people SET people_ref = ref_record WHERE id=people_line.id ;
      END CASE;
    END LOOP;
  END LOOP;

  IF merge_status = 1 THEN
    UPDATE staging SET status = delete(status,'identifiers') where id=line.id;
  ELSE
    UPDATE staging SET status = (status || hstore('identifiers' , 'people')) where id= line.id;
  END IF;

  -- Sequencers

  merge_status := 1 ;
  FOR ident_line in select * from collection_maintenance where referenced_relation ='staging' AND  record_id = line.id
  LOOP
    FOR people_line IN select * from staging_people WHERE referenced_relation ='collection_maintenance' AND record_id = ident_line.id
    LOOP
      IF people_line.people_ref is not null THEN
        continue;
      END IF;
      SELECT fct_look_for_people(people_line.formated_name) into ref_record;
      CASE ref_record
        WHEN -1,0 THEN merge_status := -1 ;
        --WHEN 0 THEN merge_status := 0;
        ELSE
          UPDATE staging_people SET people_ref = ref_record WHERE id=people_line.id ;
      END CASE;
    END LOOP;
  END LOOP;

  IF merge_status = 1 THEN
    UPDATE staging SET status = delete(status,'operator') where id=line.id;
  ELSE
    UPDATE staging SET status = (status || hstore('operator' , 'people')) where id= line.id;
  END IF;

  /**********
  * Institution
  **********/
  IF line.institution_name IS NOT NULL and line.institution_name  != '' AND line.institution_ref is null THEN
    SELECT fct_look_for_institution(line.institution_name) into ref_record ;
  CASE ref_record
  WHEN -1 THEN
    UPDATE staging SET status = (status || hstore('institution' , 'too_much')) where id= line.id;
  WHEN 0 THEN
    UPDATE staging SET status = (status || hstore('institution' , 'not_found')) where id= line.id;
  ELSE
    UPDATE staging SET status = delete(status,'institution'), institution_ref = ref_record where id=line.id;
      END CASE;
  END IF;

  /**********
  * Institution in staging_relationship
  **********/
  FOR ident_line in select * from staging_relationship where record_id = line.id
  LOOP
    IF ident_line.institution_name IS NOT NULL and ident_line.institution_name  != '' AND ident_line.institution_ref is null AND ident_line.institution_name  != 'Not defined' THEN
      SELECT fct_look_for_institution(ident_line.institution_name) into ref_record;
      CASE ref_record
      WHEN -1 THEN
        UPDATE staging SET status = (status || hstore('institution_relationship' , 'too_much')) where id= line.id;
      WHEN 0 THEN
        UPDATE staging SET status = (status || hstore('institution_relationship' , 'not_found')) where id= line.id;
        ELSE
          UPDATE staging_relationship SET institution_ref = ref_record WHERE id=ident_line.id ;
          UPDATE staging SET status = delete(status,'institution_relationship') where id=line.id;
      END CASE;
    END IF;
  END LOOP;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_people(line darwin2.staging) OWNER TO darwin2;

--
-- TOC entry 794 (class 1255 OID 18743)
-- Name: fct_imp_checker_staging_info(darwin2.staging, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_staging_info(line darwin2.staging, st_type text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  info_line staging_info ;
  record_line RECORD ;
BEGIN

  FOR info_line IN select * from staging_info i WHERE i.staging_ref = line.id AND i.referenced_relation = st_type
  LOOP
    BEGIN
    CASE info_line.referenced_relation
      WHEN 'gtu' THEN
        IF line.gtu_ref IS NOT NULL THEN
          FOR record_line IN select * from template_table_record_ref where referenced_relation='staging_info' and record_id=info_line.id
          LOOP
            UPDATE template_table_record_ref set referenced_relation='gtu', record_id=line.gtu_ref where referenced_relation='staging_info' and record_id=info_line.id;
          END LOOP ;
        END IF;
      WHEN 'taxonomy' THEN
        IF line.taxon_ref IS NOT NULL THEN
          FOR record_line IN select * from template_table_record_ref where referenced_relation='staging_info' and record_id=info_line.id
          LOOP
            UPDATE template_table_record_ref set referenced_relation='taxonomy', record_id=line.taxon_ref where referenced_relation='staging_info' and record_id=info_line.id;
          END LOOP ;
        END IF;
      WHEN 'expeditions' THEN
        IF line.expedition_ref IS NOT NULL THEN
          FOR record_line IN select * from template_table_record_ref where referenced_relation='staging_info' and record_id=info_line.id
          LOOP
            UPDATE template_table_record_ref set referenced_relation='expeditions', record_id=line.expedition_ref where referenced_relation='staging_info' and record_id=info_line.id;
          END LOOP ;
        END IF;
      WHEN 'lithostratigraphy' THEN
        IF line.litho_ref IS NOT NULL THEN
          FOR record_line IN select * from template_table_record_ref where referenced_relation='staging_info' and record_id=info_line.id
          LOOP
            UPDATE template_table_record_ref set referenced_relation='lithostratigraphy', record_id=line.litho_ref where referenced_relation='staging_info' and record_id=info_line.id;
          END LOOP ;
        END IF;
      WHEN 'lithology' THEN
        IF line.lithology_ref IS NOT NULL THEN
          FOR record_line IN select * from template_table_record_ref where referenced_relation='staging_info' and record_id=info_line.id
          LOOP
            UPDATE template_table_record_ref set referenced_relation='lithology', record_id=line.lithology_ref where referenced_relation='staging_info' and record_id=info_line.id;
          END LOOP ;
        END IF;
      WHEN 'chronostratigraphy' THEN
        IF line.chrono_ref IS NOT NULL THEN
          FOR record_line IN select * from template_table_record_ref where referenced_relation='staging_info' and record_id=info_line.id
          LOOP
            UPDATE template_table_record_ref set referenced_relation='chronostratigraphy', record_id=line.chrono_ref where id=record_line.id ;
          END LOOP ;
        END IF;
      WHEN 'mineralogy' THEN
        IF line.mineral_ref IS NOT NULL THEN
          FOR record_line IN select * from template_table_record_ref where referenced_relation='staging_info' and record_id=info_line.id
          LOOP
            UPDATE template_table_record_ref set referenced_relation='mineralogy', record_id=line.mineral_ref where referenced_relation='staging_info' and record_id=info_line.id;
          END LOOP ;
        END IF;
      WHEN 'igs' THEN
        IF line.ig_ref IS NOT NULL THEN
          FOR record_line IN select * from template_table_record_ref where referenced_relation='staging_info' and record_id=info_line.id
          LOOP
            UPDATE template_table_record_ref set referenced_relation='igs', record_id=line.ig_ref where referenced_relation='staging_info' and record_id=info_line.id;
          END LOOP ;
        END IF;
      ELSE continue ;
      END CASE ;
      EXCEPTION WHEN unique_violation THEN
        RAISE NOTICE 'An error occured: %', SQLERRM;
      END ;
  END LOOP;
  DELETE FROM staging_info WHERE staging_ref = line.id ;
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_staging_info(line darwin2.staging, st_type text) OWNER TO darwin2;

--
-- TOC entry 805 (class 1255 OID 18744)
-- Name: fct_imp_checker_staging_relationship(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_staging_relationship() RETURNS integer[]
    LANGUAGE plpgsql
    AS $$
DECLARE
  relation_line RECORD ;
  specimen_ref INTEGER ;
  id_array integer ARRAY ;
BEGIN

  FOR relation_line IN select sr.*, s.spec_ref from staging_relationship sr, staging s WHERE sr.record_id = s.id AND s.spec_ref IS NOT NULL
  LOOP
    IF relation_line.staging_related_ref IS NOT NULL THEN
      SELECT spec_ref INTO specimen_ref FROM staging where id=relation_line.staging_related_ref ;
      IF specimen_ref IS NULL THEN
        id_array := array_append(id_array, relation_line.record_id);
        continue ;
      ELSE
        INSERT INTO specimens_relationships(id, specimen_ref, relationship_type, unit_type, specimen_related_ref, institution_ref)
        SELECT nextval('specimens_relationships_id_seq'), relation_line.spec_ref, relation_line.relationship_type, unit_type, specimen_ref, institution_ref
        from staging_relationship where id=relation_line.id AND staging_related_ref=relation_line.staging_related_ref;
      END IF;
   ELSIF  relation_line.existing_specimen_ref IS NOT NULL THEN --! staging_relationship.specimen_ref => related specimens; staging.spec_ref => creates specimen

		INSERT INTO specimens_relationships(id, specimen_ref, relationship_type, unit_type, specimen_related_ref, institution_ref)
			SELECT nextval('specimens_relationships_id_seq'), relation_line.spec_ref, relation_line.relationship_type, unit_type, relation_line.existing_specimen_ref, institution_ref
			from staging_relationship where id=relation_line.id;
    ELSE
    INSERT INTO specimens_relationships(id, specimen_ref, relationship_type, unit_type, institution_ref,taxon_ref, mineral_ref, source_name,
    source_id, quantity, unit)
        SELECT nextval('specimens_relationships_id_seq'), relation_line.spec_ref, relation_line.relationship_type, unit_type, institution_ref,
        taxon_ref, mineral_ref, source_name, source_id, quantity, unit
        from staging_relationship where id=relation_line.id ;
    END IF ;
    DELETE FROM staging_relationship WHERE id = relation_line.id ;
  END LOOP;
  RETURN id_array;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_staging_relationship() OWNER TO darwin2;

--
-- TOC entry 798 (class 1255 OID 18745)
-- Name: fct_imp_create_catalogues_and_parents(darwin2.staging, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  row_record record;
  lvl_name varchar;
  lvl_value varchar;
  lvl_id integer;

  old_parent_id integer;
  parent_id integer;
  rec_parents hstore;
  line_store hstore;
  field_name1 text;
  field_name2 text;

  tmp text;
  --ftheeten 2017 08 03
  taxonomy_ref_str varchar;
  restrict_taxonomy boolean;
  filter_taxonomy_str varchar;
   --ftheeten 2017 08 03
BEGIN
raise notice 'called' ;
  line_store := hstore(line);
  field_name1 := prefix || '_parents';
  rec_parents := line_store->field_name1;
   --ftheeten 2017 08 03
  taxonomy_ref_str :=COALESCE(line_store->'specimen_taxonomy_ref','');
  restrict_taxonomy := false;
  filter_taxonomy_str:='';
  IF LENGTH(TRIM(taxonomy_ref_str))> 0 THEN
	IF(taxonomy_ref_str::int)>0 AND catalogue_table='taxonomy'  THEN
		restrict_taxonomy:=TRUE;
		filter_taxonomy_str:='  metadata_ref = '|| taxonomy_ref_str||' AND ';		
	END IF;
  END IF;
   --ftheeten 2017 08 03
    IF line.create_taxon  then
   
    raise notice 'should create';
    raise notice 'parent: %', rec_parents;
    end if;

  IF line.create_taxon AND rec_parents is not null AND rec_parents != ''::hstore  THEN
    BEGIN
    raise notice 'create';
      field_name2 := prefix || '_name';
      field_name1 := prefix || '_level_name';

      IF line_store->field_name2 != '' THEN
        rec_parents = rec_parents || hstore(line_store->field_name1, line_store->field_name2);
      END IF;

      FOR row_record in SELECT s.key as lvl_name, s.value as lvl_value, l.id as lvl_id
        FROM each(rec_parents) as s LEFT JOIN catalogue_levels l on s.key = l.level_sys_name
        ORDER BY l.level_order ASC
      LOOP
        old_parent_id := parent_id;
        EXECUTE 'SELECT count(*), min(t.id) as id from ' || quote_ident(catalogue_table) || ' t
          INNER JOIN catalogue_levels c on t.level_ref = c.id
          WHERE '||filter_taxonomy_str ||' level_sys_name = ' || quote_literal(row_record.lvl_name) || ' AND
            name_indexed like fullToIndex( ' || quote_literal(row_record.lvl_value) || '  ) || ''%'' '
          INTO result_nbr, parent_id;

        IF result_nbr = 0 THEN
          IF old_parent_id IS NULL THEN
            RAISE EXCEPTION 'Unable to create taxon with no common parents';
          END IF;
          EXECUTE 'INSERT INTO ' || quote_ident(catalogue_table) || '  (name, level_ref, parent_ref) VALUES
            (' || quote_literal(row_record.lvl_value) || ', ' ||
            quote_literal(row_record.lvl_id) ||', '|| quote_literal(old_parent_id) ||') returning ID' into parent_id ;

          -- We are at the last level
          IF lvl_name = line_store->field_name1 THEN
            PERFORM fct_imp_checker_staging_info(line, 'taxonomy');
          END IF;
        END IF;
      END LOOP;

    EXCEPTION WHEN OTHERS THEN
      UPDATE staging set create_taxon = false where id = line.id;
      RETURN TRUE;
    END;
  END IF;
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text) OWNER TO darwin2;

--
-- TOC entry 799 (class 1255 OID 18746)
-- Name: fct_imp_create_catalogues_and_parents_bck20180415(darwin2.staging, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_create_catalogues_and_parents_bck20180415(line darwin2.staging, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  row_record record;
  lvl_name varchar;
  lvl_value varchar;
  lvl_id integer;

  old_parent_id integer;
  parent_id integer;
  rec_parents hstore;
  line_store hstore;
  field_name1 text;
  field_name2 text;

  tmp text;
BEGIN
  line_store := hstore(line);
  field_name1 := prefix || '_parents';
  rec_parents := line_store->field_name1;

  IF line.create_taxon AND rec_parents is not null AND rec_parents != ''::hstore  THEN
    BEGIN
      field_name2 := prefix || '_name';
      field_name1 := prefix || '_level_name';

      IF line_store->field_name2 != '' THEN
        rec_parents = rec_parents || hstore(line_store->field_name1, line_store->field_name2);
      END IF;

      FOR row_record in SELECT s.key as lvl_name, s.value as lvl_value, l.id as lvl_id
        FROM each(rec_parents) as s LEFT JOIN catalogue_levels l on s.key = l.level_sys_name
        ORDER BY l.level_order ASC
      LOOP
        old_parent_id := parent_id;
        EXECUTE 'SELECT count(*), min(t.id) as id from ' || quote_ident(catalogue_table) || ' t
          INNER JOIN catalogue_levels c on t.level_ref = c.id
          WHERE level_sys_name = ' || quote_literal(row_record.lvl_name) || ' AND
            name_indexed like fullToIndex( ' || quote_literal(row_record.lvl_value) || '  ) || ''%'' '
          INTO result_nbr, parent_id;

        IF result_nbr = 0 THEN
          IF old_parent_id IS NULL THEN
            RAISE EXCEPTION 'Unable to create taxon with no common parents';
          END IF;
          EXECUTE 'INSERT INTO ' || quote_ident(catalogue_table) || '  (name, level_ref, parent_ref) VALUES
            (' || quote_literal(row_record.lvl_value) || ', ' ||
            quote_literal(row_record.lvl_id) ||', '|| quote_literal(old_parent_id) ||') returning ID' into parent_id ;

          -- We are at the last level
          IF lvl_name = line_store->field_name1 THEN
            PERFORM fct_imp_checker_staging_info(line, 'taxonomy');
          END IF;
        END IF;
      END LOOP;

    EXCEPTION WHEN OTHERS THEN
      UPDATE staging set create_taxon = false where id = line.id;
      RETURN TRUE;
    END;
  END IF;
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_create_catalogues_and_parents_bck20180415(line darwin2.staging, catalogue_table text, prefix text) OWNER TO darwin2;

--
-- TOC entry 800 (class 1255 OID 18747)
-- Name: fct_importer_abcd(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_abcd(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$

DECLARE
  userid integer;
  rec_id integer;
  people_id integer;
  all_line RECORD ;
  line staging;
  people_line RECORD;
  maintenance_line collection_maintenance;
  staging_line staging;
  id_to_delete integer ARRAY;
  id_to_keep integer ARRAY ;
  collection collections%ROWTYPE;
  code_count integer;
  --ftheeten 2016 08 26
  array_categories varchar array;
  array_specimen_parts varchar array;
  --array_complete varchar array;
  --array_institution_refs integer array;
  array_buildings varchar array;
  array_floors varchar array;
  array_rooms varchar array;
  array_rows varchar array;
  array_cols varchar array;
  array_shelves varchar array;
  array_containers varchar array;
  array_sub_containers varchar array;
  array_containers_type varchar array;
  array_sub_containers_type varchar array;
  array_containers_storage varchar array;
  array_sub_containers_storage varchar array;
    --array_surnumerary varchar array;
        array_statuses varchar array;
            array_object_name varchar array;
  process_multiple_storage boolean;
  array_lengths integer array;
  max_length integer;
  i integer;
  
  var_merge boolean;
  
  --
  --debug varchar;
BEGIN
raise notice 'begin';
i=0;
  SELECT merge_gtu INTO var_merge FROM imports WHERE id=req_import_ref;
  max_length:=null;
  SELECT * INTO collection FROM collections WHERE id = (SELECT collection_ref FROM imports WHERE id = req_import_ref AND is_finished = FALSE LIMIT 1);
  select user_ref into userid from imports where id=req_import_ref ;
  PERFORM set_config('darwin.userid',userid::varchar, false) ;
  INSERT INTO classification_keywords (referenced_relation, record_id, keyword_type, keyword)
          (
            SELECT DISTINCT ON (referenced_relation, taxon_ref, keyword_type, keyword_indexed)
                  'taxonomy',
                  taxon_ref,
                  keyword_type,
                  "keyword"
            FROM staging INNER JOIN classification_keywords as ckmain ON ckmain.referenced_relation = 'staging'
                                                                     AND staging.id = ckmain.record_id
                         INNER JOIN imports as i ON i.id = staging.import_ref
            WHERE import_ref = req_import_ref
              AND to_import=true
              AND status = ''::hstore
              AND i.is_finished =  FALSE
              AND NOT EXISTS (
                              SELECT 1
                              FROM classification_keywords
                              WHERE referenced_relation = 'taxonomy'
                                AND record_id = staging.taxon_ref
                                AND keyword_type = ckmain.keyword_type
                                AND keyword_indexed = ckmain.keyword_indexed
              )
          );
  EXECUTE 'DELETE FROM classification_keywords
           WHERE referenced_relation = ''staging''
             AND record_id IN (
                                SELECT s.id
                                FROM staging s INNER JOIN imports i ON  s.import_ref = i.id
                                WHERE import_ref = $1
                                  AND to_import=true
                                  AND status = ''''::hstore
                                  AND i.is_finished =  FALSE
                             )'
  USING req_import_ref;
  FOR all_line IN SELECT * from staging s INNER JOIN imports i on  s.import_ref = i.id
      WHERE import_ref = req_import_ref AND to_import=true and status = ''::hstore AND i.is_finished =  FALSE
  --BEGIN LOOP 1
  LOOP
    --BEGIN TRANSACTION 1
    BEGIN
      -- I know it's dumb but....
      -- @ToDo: We need to correct this to avoid reselecting from the staging table !!!
      raise notice 'staging line %', all_line.id;
      raise notice '%', i;
      i:=i+1;
     -- select * into staging_line from staging where id = all_line.id;
	staging_line=all_line;
     
     PERFORM fct_imp_checker_igs(staging_line, true);
     PERFORM fct_imp_checker_expeditions(staging_line, true);

     IF COALESCE(var_merge, FALSE) = TRUE THEN
         -- ftheeten 2019 12 16
         PERFORM fct_rmca_imp_checker_gtu_search_code(staging_line, NULL);
     ELSE
          PERFORM fct_imp_checker_gtu(staging_line, true);
     END IF;

      --RE SELECT WITH UPDATE
      select * into line from staging s INNER JOIN imports i on  s.import_ref = i.id where s.id=all_line.id LIMIT 1;

    rec_id := nextval('specimens_id_seq');
    --BEGIN IF 1
    IF line.spec_ref IS NULL THEN
    raise notice 'INSERT';
      INSERT INTO specimens (id,  collection_ref, expedition_ref, gtu_ref, taxon_ref, litho_ref, chrono_ref, lithology_ref, mineral_ref,
          acquisition_category, acquisition_date_mask, acquisition_date, station_visible, ig_ref, type, sex, stage, state, social_status, rock_form,
          --these 2 fields not handled in staging ftheeten 2016 08 26 
         -- complete,surnumerary,
          specimen_count_min, specimen_count_max
		--ftheeten 2016 06 22
		,specimen_count_males_min, specimen_count_males_max,specimen_count_females_min, specimen_count_females_max,specimen_count_juveniles_min, specimen_count_juveniles_max
        --ftheeten 2016 12 08
        ,gtu_from_date_mask,
       gtu_from_date,
       gtu_to_date_mask,
       gtu_to_date,
       --ftheeten 2018 03 23
       import_ref
          )
      VALUES (rec_id,  all_line.collection_ref, line.expedition_ref, line.gtu_ref, line.taxon_ref, line.litho_ref, line.chrono_ref,
        line.lithology_ref, line.mineral_ref, COALESCE(line.acquisition_category,''), COALESCE(line.acquisition_date_mask,0), COALESCE(line.acquisition_date,'01/01/0001'),
        COALESCE(line.station_visible,true),  line.ig_ref, COALESCE(line.individual_type,'specimen'), COALESCE(line.individual_sex,'undefined'),
        COALESCE(line.individual_stage,'undefined'), COALESCE(line.individual_state,'not applicable'),COALESCE(line.individual_social_status,'not applicable'),
        COALESCE(line.individual_rock_form,'not applicable'),
        --COALESCE(line.complete,true),COALESCE(line.surnumerary,false),
        COALESCE(line.part_count_min,1), COALESCE(line.part_count_max,line.part_count_min,1)
        --ftheeten 2016 06 22
        ,COALESCE(line.part_count_males_min,0),COALESCE(line.part_count_males_max,0),COALESCE(line.part_count_females_min,0),COALESCE(line.part_count_females_max,0)
,COALESCE(line.part_count_juveniles_min,0),COALESCE(line.part_count_juveniles_max,0)
        --ftheeten 2016 12 08
        
        , COALESCE(line.gtu_from_date_mask,0),
          COALESCE(line.gtu_from_date, '01/01/0001'),
          COALESCE(line.gtu_to_date_mask,0),
          COALESCE(line.gtu_to_date, '31/12/2038'),
          --ftheeten 208 03 23
          req_import_ref
      );
      --BEGIN LOOP 2
      FOR maintenance_line IN SELECT * from collection_maintenance where referenced_relation = 'staging' AND record_id=line.id
      LOOP
        SELECT people_ref into people_id FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
        UPDATE collection_maintenance set people_ref=people_id where id=maintenance_line.id ;
        DELETE FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id AND import_ref=req_import_ref;
       --END LOOP 2
      END LOOP;

      SELECT COUNT(*) INTO code_count FROM codes WHERE referenced_relation = 'staging' AND record_id = line.id AND code_category = 'main' AND code IS NOT NULL;
      --BEGIN IF 3
      IF code_count = 0 THEN
        PERFORM fct_after_save_add_code(all_line.collection_ref, rec_id);
      ELSE
        UPDATE codes SET referenced_relation = 'specimens', 
                         record_id = rec_id, 
                         code_prefix = 
                         CASE 
				WHEN COALESCE(code_prefix,'') != collection.code_prefix
				THEN collection.code_prefix ELSE code_prefix END,
                         code_prefix_separator = CASE 
				WHEN COALESCE(code_prefix_separator,'') !=collection.code_prefix_separator   
				THEN collection.code_prefix_separator ELSE code_prefix_separator END,
                         code_suffix = CASE WHEN COALESCE(code_suffix,'') != collection.code_suffix  THEN collection.code_suffix 
                         ELSE code_suffix END,
                         code_suffix_separator = CASE 
                         WHEN COALESCE(code_suffix_separator,'') !=  collection.code_suffix_separator THEN collection.code_suffix_separator ELSE code_suffix_separator END
        WHERE referenced_relation = 'staging'
          AND record_id = line.id
          AND code_category = 'main';
      --END IF 3
      END IF;
		
      UPDATE template_table_record_ref SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      --UPDATE collection_maintenance SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      -- Import identifiers whitch identification have been updated to specimen
      --RAISE NOTICE 'identifications';
      INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        SELECT nextval('catalogue_people_id_seq'), s.referenced_relation, s.record_id, s.people_type, s.people_sub_type, s.order_by, s.people_ref 
        FROM staging_people s, identifications i 
        WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ;
      DELETE FROM staging_people where id in (SELECT s.id FROM staging_people s, identifications i WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' )  AND import_ref= req_import_ref;
      -- Import collecting_methods
      INSERT INTO specimen_collecting_methods(id, specimen_ref, collecting_method_ref)
        SELECT nextval('specimen_collecting_methods_id_seq'), rec_id, collecting_method_ref 
        FROM staging_collecting_methods 
        WHERE staging_ref = line.id;
      
      DELETE FROM staging_collecting_methods where staging_ref = line.id;
      UPDATE staging set spec_ref=rec_id WHERE id=all_line.id;
      --BEGIN LOOP 3
      FOR people_line IN SELECT * from staging_people WHERE referenced_relation = 'specimens'  AND import_ref= req_import_ref
      LOOP
       --RAISE NOTICE 'people %', people_line.id;
        INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        VALUES(nextval('catalogue_people_id_seq'),people_line.referenced_relation, people_line.record_id, people_line.people_type, people_line.people_sub_type, people_line.order_by, people_line.people_ref) ;
      END LOOP;
      --END LOOP 3
      DELETE FROM staging_people WHERE referenced_relation = 'specimens' AND import_ref= req_import_ref;
    --END IF 1
    END IF ;
    id_to_delete = array_append(id_to_delete,all_line.id) ;
    --ftheeten to do handle array of storage
    process_multiple_storage:=false;
      
    array_categories :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.category),''), '(^\[|\]$)','','g'),'(\|)');
    array_specimen_parts :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.part),''), '(^\[|\]$)','','g'),'(\|)');
     -- array_institution_refs :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.institution_ref),''), '(^\[|\]$)','','g'),'(\|)');
    array_buildings :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.building),''), '(^\[|\]$)','','g'),'(\|)');
    array_floors :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.floor),''), '(^\[|\]$)','','g'),'(\|)');
    array_rooms :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.room),''), '(^\[|\]$)','','g'),'(\|)');
    array_rows :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.row),''), '(^\[|\]$)','','g'),'(\|)');
    array_cols :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.col),''), '(^\[|\]$)','','g'),'(\|)');
    array_shelves :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.shelf),''), '(^\[|\]$)','','g'),'(\|)');
    array_containers :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.container),''), '(^\[|\]$)','','g'),'(\|)');
    array_sub_containers :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.sub_container),''), '(^\[|\]$)','','g'),'(\|)');
    array_containers_type :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.container_type),''), '(^\[|\]$)','','g'),'(\|)');
    array_sub_containers_type :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.sub_container_type),''), '(^\[|\]$)','','g'),'(\|)');
    array_containers_storage :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.container_storage),''), '(^\[|\]$)','','g'),'(\|)');
    array_sub_containers_storage :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.sub_container_storage),''), '(^\[|\]$)','','g'),'(\|)');
    array_statuses :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.specimen_status),''), '(^\[|\]$)','','g'),'(\|)');
    array_object_name :=regexp_split_to_array(regexp_replace(NULLIF(trim(line.object_name),''), '(^\[|\]$)','','g'),'(\|)');
                
    ----work
    array_lengths:=ARRAY[]::INT[];
    array_lengths:=array_lengths||ARRAY_LENGTH( array_categories,1);
    array_lengths:=array_lengths||ARRAY_LENGTH(array_specimen_parts ,1);
    --array_lengths:=array_lengths||ARRAY_LENGTH(array_institution_refs ,1);
    array_lengths:=array_lengths||ARRAY_LENGTH( array_buildings,1);
    array_lengths:=array_lengths||ARRAY_LENGTH( array_floors,1);
    array_lengths:=array_lengths||ARRAY_LENGTH( array_rooms,1);
    array_lengths:=array_lengths||ARRAY_LENGTH(array_rows ,1);
    array_lengths:=array_lengths||ARRAY_LENGTH(array_cols ,1);
    array_lengths:=array_lengths||ARRAY_LENGTH(array_shelves ,1);
    array_lengths:=array_lengths||ARRAY_LENGTH(array_containers ,1);
    array_lengths:=array_lengths||ARRAY_LENGTH( array_sub_containers,1);
    array_lengths:= array_lengths||ARRAY_LENGTH(array_containers_type ,1);
    array_lengths:=array_lengths||ARRAY_LENGTH(array_sub_containers_type ,1);
    array_lengths:=array_lengths||ARRAY_LENGTH( array_containers_storage,1);
    array_lengths:=array_lengths||ARRAY_LENGTH( array_sub_containers_storage,1);
    array_lengths:=array_lengths||ARRAY_LENGTH( array_statuses,1);
    array_lengths:=array_lengths||ARRAY_LENGTH(array_object_name ,1);
     --max_length:=MAX(UNNEST(array_lengths));    
    max_length:=MAX(x) FROM UNNEST(array_lengths) x;
    /*
        debug:=', '||COALESCE(ARRAY_LENGTH( array_categories,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH(array_specimen_parts ,1)::varchar,'');
    --array_lengths:=array_lengths||ARRAY_LENGTH(array_institution_refs ,1);
    debug:=debug||', '||COALESCE(ARRAY_LENGTH( array_buildings,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH( array_floors,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH( array_rooms,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH(array_rows ,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH(array_cols ,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH(array_shelves ,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH(array_containers ,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH( array_sub_containers,1)::varchar,'');
    debug:= debug||', '||COALESCE(ARRAY_LENGTH(array_containers_type ,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH(array_sub_containers_type ,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH( array_containers_storage,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH( array_sub_containers_storage,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH( array_statuses,1)::varchar,'');
    debug:=debug||', '||COALESCE(ARRAY_LENGTH(array_object_name ,1)::varchar,'');
    debug:=debug||' x'||','||(COALESCE(ARRAY_LENGTH( array_categories,1),max_length)::varchar||',' ||COALESCE(ARRAY_LENGTH(array_specimen_parts ,1),max_length))::varchar||
    ','||(COALESCE(ARRAY_LENGTH( array_buildings,1),max_length)::varchar||',' ||COALESCE(ARRAY_LENGTH(array_floors ,1),max_length))::varchar||
    ','||(COALESCE(ARRAY_LENGTH( array_rooms,1),max_length)::varchar||',' ||COALESCE(ARRAY_LENGTH(array_rows ,1),max_length))::varchar||
    ','||(COALESCE(ARRAY_LENGTH( array_cols,1),max_length)::varchar||',' ||COALESCE(ARRAY_LENGTH(array_shelves ,1),max_length))::varchar||
    ','||(COALESCE(ARRAY_LENGTH( array_containers,1),max_length)::varchar||',' ||COALESCE(ARRAY_LENGTH(array_sub_containers ,1),max_length))::varchar||
    ','||(COALESCE(ARRAY_LENGTH( array_containers_type,1),max_length)::varchar||',' ||COALESCE(ARRAY_LENGTH(array_sub_containers_type ,1),max_length))::varchar||
     ','||(COALESCE(ARRAY_LENGTH( array_containers_storage,1),max_length)::varchar||',' ||COALESCE(ARRAY_LENGTH(array_sub_containers_storage ,1),max_length))::varchar||
     ','||(COALESCE(ARRAY_LENGTH( array_statuses,1),max_length)::varchar||',' ||COALESCE(ARRAY_LENGTH(array_object_name ,1),max_length))::varchar;
    */
    --IF 2
    IF 
    (COALESCE(ARRAY_LENGTH( array_categories,1),max_length)=COALESCE(ARRAY_LENGTH(array_specimen_parts ,1),max_length))
    AND
    (COALESCE(ARRAY_LENGTH( array_buildings,1),max_length)= COALESCE(ARRAY_LENGTH( array_floors,1),max_length))
    AND
    (COALESCE(ARRAY_LENGTH( array_rooms,1),max_length)=COALESCE(ARRAY_LENGTH(array_rows ,1),max_length))
    AND
    (COALESCE(ARRAY_LENGTH(array_cols ,1),max_length)=COALESCE(ARRAY_LENGTH(array_shelves ,1),max_length))
    AND
    (COALESCE(ARRAY_LENGTH(array_containers ,1),max_length)=COALESCE(ARRAY_LENGTH( array_sub_containers,1),max_length))
    AND
    (COALESCE(ARRAY_LENGTH(array_containers_type ,1),max_length)=COALESCE(ARRAY_LENGTH(array_sub_containers_type ,1),max_length))
    AND
    (COALESCE(ARRAY_LENGTH( array_containers_storage,1),max_length)=COALESCE(ARRAY_LENGTH( array_sub_containers_storage,1),max_length))
    AND
    (COALESCE(ARRAY_LENGTH( array_statuses,1),max_length)= COALESCE(ARRAY_LENGTH(array_object_name ,1),max_length))
	
	AND
	COALESCE(ARRAY_LENGTH(array_specimen_parts ,1),max_length)=COALESCE(ARRAY_LENGTH( array_buildings,1),max_length)
	AND 
	COALESCE(ARRAY_LENGTH(array_floors ,1),max_length)=COALESCE(ARRAY_LENGTH( array_rooms,1),max_length)
	AND 
	COALESCE(ARRAY_LENGTH(array_rows ,1),max_length)=COALESCE(ARRAY_LENGTH( array_cols,1),max_length)
	AND 
	COALESCE(ARRAY_LENGTH(array_shelves ,1),max_length)=COALESCE(ARRAY_LENGTH( array_containers,1),max_length)
	AND 
	COALESCE(ARRAY_LENGTH(array_sub_containers ,1),max_length)=COALESCE(ARRAY_LENGTH( array_containers_type,1),max_length)
	AND 
	COALESCE(ARRAY_LENGTH(array_sub_containers_type ,1),max_length)=COALESCE(ARRAY_LENGTH( array_containers_storage,1),max_length)
	AND 
	COALESCE(ARRAY_LENGTH(array_sub_containers_storage ,1),max_length)=COALESCE(ARRAY_LENGTH( array_statuses,1),max_length)
    THEN
        process_multiple_storage:=true;
        --BEGIN LOOP 3
        FOR i in 1..max_length LOOP
            INSERT INTO darwin2.storage_parts(
                            category, 
                            specimen_ref, 
                            specimen_part, 
                            institution_ref, 
                            building, 
                            floor, 
                            room, 
                            "row", 
                            col, 
                            shelf, 
                            container, 
                            sub_container, 
                            container_type, 
                            sub_container_type, 
                            container_storage, 
                            sub_container_storage, 
                            surnumerary, 
                            object_name, 
                            specimen_status, 
                            complete
                            --, debug
                            )
                    VALUES ( 
                            COALESCE(array_categories[i],'physical'), 
                            rec_id,
                             COALESCE(array_specimen_parts[i],'specimen'), 
                            COALESCE(line.institution_ref, collection.institution_ref  ), 
                            array_buildings[i], 
                            array_floors[i], 
                            array_rooms[i], 
                            array_rows[i], 
                            array_cols[i], 
                            array_shelves[i], 
                            array_containers[i], 
                            array_sub_containers[i], 
                            COALESCE(array_containers_type[i],'container'), 
                            COALESCE(array_sub_containers_type[i],'container'), 
                            COALESCE(array_containers_storage[i],''), 
                            COALESCE(array_sub_containers_storage[i],''), 
                            COALESCE(line.surnumerary,false), 
                            array_object_name[i], 
                            COALESCE(array_statuses[i],''), 
                            COALESCE(line.complete,true)--,
                            --debug
                            );
        --END LOOP 3
        END LOOP;
    --END IF 2
    END IF;
    --IF 3  
    IF  process_multiple_storage=false THEN
            INSERT INTO darwin2.storage_parts(
                             category, 
                             specimen_ref, 
                             specimen_part, 
                             institution_ref, 
                             building, 
                            floor, 
                            room, 
                            "row", 
                            col, 
                            shelf, 
                            container, 
                            sub_container, 
                            container_type, 
                            sub_container_type, 
                            container_storage, 
                            sub_container_storage, 
                            surnumerary, 
                            object_name, 
                            specimen_status, 
                            complete--,
                            --debug
                            )
                    VALUES ( 
                            COALESCE(line.category,'physical'), 
                            rec_id,
                             COALESCE(line.part,'specimen'), 
                            COALESCE(line.institution_ref, collection.institution_ref), 
                            line.building, 
                            line.floor, 
                            line.room, 
                            line.row, 
                            line.col, 
                            line.shelf, 
                            line.container, 
                            line.sub_container, 
                            COALESCE(line.container_type,'container'), 
                            COALESCE(line.sub_container_type,'container'), 
                            COALESCE(line.container_storage,''), 
                            COALESCE(line.sub_container_storage,''), 
                            COALESCE(line.surnumerary,false), 
                            line.object_name, 
                            COALESCE(line.specimen_status,''), 
                            COALESCE(line.complete,true)--,
                           -- debug
                            );
    --END IF 3
    END IF;
    --END TRANSACTION 1
    END;
   --END LOOP 1
  END LOOP;
  SELECT fct_imp_checker_staging_relationship() into id_to_keep ;
  --BEGIN IF 4
  IF id_to_keep IS NOT NULL THEN
    DELETE from staging where (id = ANY (id_to_delete)) AND NOT (id = ANY (id_to_keep)) ;
  else
    DELETE from staging where (id = ANY (id_to_delete)) ;
  END IF ;
  --END IF 4
    --BEGIN IF 5
  IF EXISTS( select id FROM  staging WHERE import_ref = req_import_ref) THEN
    UPDATE imports set state = 'pending' where id = req_import_ref;
  ELSE
    UPDATE imports set state = 'finished', is_finished = true where id = req_import_ref;
  END IF;
    --END IF 5
  RETURN true;
END;

$_$;


ALTER FUNCTION darwin2.fct_importer_abcd(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 801 (class 1255 OID 18750)
-- Name: fct_importer_abcd_bck20160622(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_abcd_bck20160622(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  userid integer;
  rec_id integer;
  people_id integer;
  all_line RECORD ;
  line staging;
  people_line RECORD;
  maintenance_line collection_maintenance;
  staging_line staging;
  id_to_delete integer ARRAY;
  id_to_keep integer ARRAY ;
  collection collections%ROWTYPE;
  code_count integer;
BEGIN
  SELECT * INTO collection FROM collections WHERE id = (SELECT collection_ref FROM imports WHERE id = req_import_ref AND is_finished = FALSE LIMIT 1);
  select user_ref into userid from imports where id=req_import_ref ;
  PERFORM set_config('darwin.userid',userid::varchar, false) ;
  INSERT INTO classification_keywords (referenced_relation, record_id, keyword_type, keyword)
          (
            SELECT DISTINCT ON (referenced_relation, taxon_ref, keyword_type, keyword_indexed)
                  'taxonomy',
                  taxon_ref,
                  keyword_type,
                  "keyword"
            FROM staging INNER JOIN classification_keywords as ckmain ON ckmain.referenced_relation = 'staging'
                                                                     AND staging.id = ckmain.record_id
                         INNER JOIN imports as i ON i.id = staging.import_ref
            WHERE import_ref = req_import_ref
              AND to_import=true
              AND status = ''::hstore
              AND i.is_finished =  FALSE
              AND NOT EXISTS (
                              SELECT 1
                              FROM classification_keywords
                              WHERE referenced_relation = 'taxonomy'
                                AND record_id = staging.taxon_ref
                                AND keyword_type = ckmain.keyword_type
                                AND keyword_indexed = ckmain.keyword_indexed
              )
          );
  EXECUTE 'DELETE FROM classification_keywords
           WHERE referenced_relation = ''staging''
             AND record_id IN (
                                SELECT s.id
                                FROM staging s INNER JOIN imports i ON  s.import_ref = i.id
                                WHERE import_ref = $1
                                  AND to_import=true
                                  AND status = ''''::hstore
                                  AND i.is_finished =  FALSE
                             )'
  USING req_import_ref;
  FOR all_line IN SELECT * from staging s INNER JOIN imports i on  s.import_ref = i.id
      WHERE import_ref = req_import_ref AND to_import=true and status = ''::hstore AND i.is_finished =  FALSE
  LOOP
    BEGIN
      -- I know it's dumb but....
      -- @ToDo: We need to correct this to avoid reselecting from the staging table !!!
      select * into staging_line from staging where id = all_line.id;
      PERFORM fct_imp_checker_igs(staging_line, true);
      PERFORM fct_imp_checker_expeditions(staging_line, true);
      PERFORM fct_imp_checker_gtu(staging_line, true);

      --RE SELECT WITH UPDATE
      select * into line from staging s INNER JOIN imports i on  s.import_ref = i.id where s.id=all_line.id;

    rec_id := nextval('specimens_id_seq');
    IF line.spec_ref IS NULL THEN
      INSERT INTO specimens (id, category, collection_ref, expedition_ref, gtu_ref, taxon_ref, litho_ref, chrono_ref, lithology_ref, mineral_ref,
          acquisition_category, acquisition_date_mask, acquisition_date, station_visible, ig_ref, type, sex, stage, state, social_status, rock_form,
          specimen_part, complete, institution_ref, building, floor, room, row, col, shelf, container, sub_container,container_type, sub_container_type,
          container_storage, sub_container_storage, surnumerary, specimen_status, specimen_count_min, specimen_count_max, object_name)
      VALUES (rec_id, COALESCE(line.category,'physical') , all_line.collection_ref, line.expedition_ref, line.gtu_ref, line.taxon_ref, line.litho_ref, line.chrono_ref,
        line.lithology_ref, line.mineral_ref, COALESCE(line.acquisition_category,''), COALESCE(line.acquisition_date_mask,0), COALESCE(line.acquisition_date,'01/01/0001'),
        COALESCE(line.station_visible,true),  line.ig_ref, COALESCE(line.individual_type,'specimen'), COALESCE(line.individual_sex,'undefined'),
        COALESCE(line.individual_stage,'undefined'), COALESCE(line.individual_state,'not applicable'),COALESCE(line.individual_social_status,'not applicable'),
        COALESCE(line.individual_rock_form,'not applicable'), COALESCE(line.part,'specimen'), COALESCE(line.complete,true), line.institution_ref, line.building,
        line.floor, line.room, line.row,  line.col, line.shelf, line.container, line.sub_container,COALESCE(line.container_type,'container'),
        COALESCE(line.sub_container_type, 'container'), COALESCE(line.container_storage,''),COALESCE(line.sub_container_storage,''),
        COALESCE(line.surnumerary,false), COALESCE(line.specimen_status,''),COALESCE(line.part_count_min,1), COALESCE(line.part_count_max,line.part_count_min,1), line.object_name
      );
      FOR maintenance_line IN SELECT * from collection_maintenance where referenced_relation = 'staging' AND record_id=line.id
      LOOP
        SELECT people_ref into people_id FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
        UPDATE collection_maintenance set people_ref=people_id where id=maintenance_line.id ;
        DELETE FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
      END LOOP;

      SELECT COUNT(*) INTO code_count FROM codes WHERE referenced_relation = 'staging' AND record_id = line.id AND code_category = 'main' AND code IS NOT NULL;
      IF code_count = 0 THEN
        PERFORM fct_after_save_add_code(all_line.collection_ref, rec_id);
      ELSE
        UPDATE codes SET referenced_relation = 'specimens', 
                         record_id = rec_id, 
                         code_prefix = CASE WHEN code_prefix IS NULL THEN collection.code_prefix ELSE code_prefix END,
                         code_prefix_separator = CASE WHEN code_prefix_separator IS NULL THEN collection.code_prefix_separator ELSE code_prefix_separator END,
                         code_suffix = CASE WHEN code_suffix IS NULL THEN collection.code_suffix ELSE code_suffix END,
                         code_suffix_separator = CASE WHEN code_suffix_separator IS NULL THEN collection.code_suffix_separator ELSE code_suffix_separator END
        WHERE referenced_relation = 'staging'
          AND record_id = line.id
          AND code_category = 'main';
      END IF;

      UPDATE template_table_record_ref SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      --UPDATE collection_maintenance SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      -- Import identifiers whitch identification have been updated to specimen
      INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        SELECT nextval('catalogue_people_id_seq'), s.referenced_relation, s.record_id, s.people_type, s.people_sub_type, s.order_by, s.people_ref 
        FROM staging_people s, identifications i 
        WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ;
      DELETE FROM staging_people where id in (SELECT s.id FROM staging_people s, identifications i WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ) ;
      -- Import collecting_methods
      INSERT INTO specimen_collecting_methods(id, specimen_ref, collecting_method_ref)
        SELECT nextval('specimen_collecting_methods_id_seq'), rec_id, collecting_method_ref 
        FROM staging_collecting_methods 
        WHERE staging_ref = line.id;
      
      DELETE FROM staging_collecting_methods where staging_ref = line.id;
      UPDATE staging set spec_ref=rec_id WHERE id=all_line.id;

      FOR people_line IN SELECT * from staging_people WHERE referenced_relation = 'specimens'
      LOOP
        INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        VALUES(nextval('catalogue_people_id_seq'),people_line.referenced_relation, people_line.record_id, people_line.people_type, people_line.people_sub_type, people_line.order_by, people_line.people_ref) ;
      END LOOP;
      DELETE FROM staging_people WHERE referenced_relation = 'specimens' ;
    END IF ;
    id_to_delete = array_append(id_to_delete,all_line.id) ;
    END;
  END LOOP;
  select fct_imp_checker_staging_relationship() into id_to_keep ;
  IF id_to_keep IS NOT NULL THEN
    DELETE from staging where (id = ANY (id_to_delete)) AND NOT (id = ANY (id_to_keep)) ;
  else
    DELETE from staging where (id = ANY (id_to_delete)) ;
  END IF ;
  IF EXISTS( select id FROM  staging WHERE import_ref = req_import_ref) THEN
    UPDATE imports set state = 'pending' where id = req_import_ref;
  ELSE
    UPDATE imports set state = 'finished', is_finished = true where id = req_import_ref;
  END IF;
  RETURN true;
END;
$_$;


ALTER FUNCTION darwin2.fct_importer_abcd_bck20160622(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 802 (class 1255 OID 18753)
-- Name: fct_importer_abcd_bck20160713(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_abcd_bck20160713(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  userid integer;
  rec_id integer;
  people_id integer;
  all_line RECORD ;
  line staging;
  people_line RECORD;
  maintenance_line collection_maintenance;
  staging_line staging;
  id_to_delete integer ARRAY;
  id_to_keep integer ARRAY ;
  collection collections%ROWTYPE;
  code_count integer;
BEGIN
  SELECT * INTO collection FROM collections WHERE id = (SELECT collection_ref FROM imports WHERE id = req_import_ref AND is_finished = FALSE LIMIT 1);
  select user_ref into userid from imports where id=req_import_ref ;
  PERFORM set_config('darwin.userid',userid::varchar, false) ;
  INSERT INTO classification_keywords (referenced_relation, record_id, keyword_type, keyword)
          (
            SELECT DISTINCT ON (referenced_relation, taxon_ref, keyword_type, keyword_indexed)
                  'taxonomy',
                  taxon_ref,
                  keyword_type,
                  "keyword"
            FROM staging INNER JOIN classification_keywords as ckmain ON ckmain.referenced_relation = 'staging'
                                                                     AND staging.id = ckmain.record_id
                         INNER JOIN imports as i ON i.id = staging.import_ref
            WHERE import_ref = req_import_ref
              AND to_import=true
              AND status = ''::hstore
              AND i.is_finished =  FALSE
              AND NOT EXISTS (
                              SELECT 1
                              FROM classification_keywords
                              WHERE referenced_relation = 'taxonomy'
                                AND record_id = staging.taxon_ref
                                AND keyword_type = ckmain.keyword_type
                                AND keyword_indexed = ckmain.keyword_indexed
              )
          );
  EXECUTE 'DELETE FROM classification_keywords
           WHERE referenced_relation = ''staging''
             AND record_id IN (
                                SELECT s.id
                                FROM staging s INNER JOIN imports i ON  s.import_ref = i.id
                                WHERE import_ref = $1
                                  AND to_import=true
                                  AND status = ''''::hstore
                                  AND i.is_finished =  FALSE
                             )'
  USING req_import_ref;
  FOR all_line IN SELECT * from staging s INNER JOIN imports i on  s.import_ref = i.id
      WHERE import_ref = req_import_ref AND to_import=true and status = ''::hstore AND i.is_finished =  FALSE
  LOOP
    BEGIN
      -- I know it's dumb but....
      -- @ToDo: We need to correct this to avoid reselecting from the staging table !!!
      select * into staging_line from staging where id = all_line.id;
      PERFORM fct_imp_checker_igs(staging_line, true);
      PERFORM fct_imp_checker_expeditions(staging_line, true);
      PERFORM fct_imp_checker_gtu(staging_line, true);

      --RE SELECT WITH UPDATE
      select * into line from staging s INNER JOIN imports i on  s.import_ref = i.id where s.id=all_line.id;

    rec_id := nextval('specimens_id_seq');
    IF line.spec_ref IS NULL THEN
      INSERT INTO specimens (id, category, collection_ref, expedition_ref, gtu_ref, taxon_ref, litho_ref, chrono_ref, lithology_ref, mineral_ref,
          acquisition_category, acquisition_date_mask, acquisition_date, station_visible, ig_ref, type, sex, stage, state, social_status, rock_form,
          specimen_part, complete, institution_ref, building, floor, room, row, col, shelf, container, sub_container,container_type, sub_container_type,
          container_storage, sub_container_storage, surnumerary, specimen_status, specimen_count_min, specimen_count_max, object_name
		--ftheeten 2016 06 22
		,specimen_count_males_min, specimen_count_males_max,specimen_count_females_min, specimen_count_females_max
          )
      VALUES (rec_id, COALESCE(line.category,'physical') , all_line.collection_ref, line.expedition_ref, line.gtu_ref, line.taxon_ref, line.litho_ref, line.chrono_ref,
        line.lithology_ref, line.mineral_ref, COALESCE(line.acquisition_category,''), COALESCE(line.acquisition_date_mask,0), COALESCE(line.acquisition_date,'01/01/0001'),
        COALESCE(line.station_visible,true),  line.ig_ref, COALESCE(line.individual_type,'specimen'), COALESCE(line.individual_sex,'undefined'),
        COALESCE(line.individual_stage,'undefined'), COALESCE(line.individual_state,'not applicable'),COALESCE(line.individual_social_status,'not applicable'),
        COALESCE(line.individual_rock_form,'not applicable'), COALESCE(line.part,'specimen'), COALESCE(line.complete,true), line.institution_ref, line.building,
        line.floor, line.room, line.row,  line.col, line.shelf, line.container, line.sub_container,COALESCE(line.container_type,'container'),
        COALESCE(line.sub_container_type, 'container'), COALESCE(line.container_storage,''),COALESCE(line.sub_container_storage,''),
        COALESCE(line.surnumerary,false), COALESCE(line.specimen_status,''),COALESCE(line.part_count_min,1), COALESCE(line.part_count_max,line.part_count_min,1), line.object_name
        --ftheeten 2016 06 22
        ,COALESCE(line.part_count_males_min,0),COALESCE(line.part_count_males_max,0),COALESCE(line.part_count_females_min,0),COALESCE(line.part_count_females_max,0)
      );
      FOR maintenance_line IN SELECT * from collection_maintenance where referenced_relation = 'staging' AND record_id=line.id
      LOOP
        SELECT people_ref into people_id FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
        UPDATE collection_maintenance set people_ref=people_id where id=maintenance_line.id ;
        DELETE FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
      END LOOP;

      SELECT COUNT(*) INTO code_count FROM codes WHERE referenced_relation = 'staging' AND record_id = line.id AND code_category = 'main' AND code IS NOT NULL;
      IF code_count = 0 THEN
        PERFORM fct_after_save_add_code(all_line.collection_ref, rec_id);
      ELSE
        UPDATE codes SET referenced_relation = 'specimens', 
                         record_id = rec_id, 
                         code_prefix = CASE WHEN code_prefix IS NULL THEN collection.code_prefix ELSE code_prefix END,
                         code_prefix_separator = CASE WHEN code_prefix_separator IS NULL THEN collection.code_prefix_separator ELSE code_prefix_separator END,
                         code_suffix = CASE WHEN code_suffix IS NULL THEN collection.code_suffix ELSE code_suffix END,
                         code_suffix_separator = CASE WHEN code_suffix_separator IS NULL THEN collection.code_suffix_separator ELSE code_suffix_separator END
        WHERE referenced_relation = 'staging'
          AND record_id = line.id
          AND code_category = 'main';
      END IF;

      UPDATE template_table_record_ref SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      --UPDATE collection_maintenance SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      -- Import identifiers whitch identification have been updated to specimen
      INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        SELECT nextval('catalogue_people_id_seq'), s.referenced_relation, s.record_id, s.people_type, s.people_sub_type, s.order_by, s.people_ref 
        FROM staging_people s, identifications i 
        WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ;
      DELETE FROM staging_people where id in (SELECT s.id FROM staging_people s, identifications i WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ) ;
      -- Import collecting_methods
      INSERT INTO specimen_collecting_methods(id, specimen_ref, collecting_method_ref)
        SELECT nextval('specimen_collecting_methods_id_seq'), rec_id, collecting_method_ref 
        FROM staging_collecting_methods 
        WHERE staging_ref = line.id;
      
      DELETE FROM staging_collecting_methods where staging_ref = line.id;
      UPDATE staging set spec_ref=rec_id WHERE id=all_line.id;

      FOR people_line IN SELECT * from staging_people WHERE referenced_relation = 'specimens'
      LOOP
        INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        VALUES(nextval('catalogue_people_id_seq'),people_line.referenced_relation, people_line.record_id, people_line.people_type, people_line.people_sub_type, people_line.order_by, people_line.people_ref) ;
      END LOOP;
      DELETE FROM staging_people WHERE referenced_relation = 'specimens' ;
    END IF ;
    id_to_delete = array_append(id_to_delete,all_line.id) ;
    END;
  END LOOP;
  select fct_imp_checker_staging_relationship() into id_to_keep ;
  IF id_to_keep IS NOT NULL THEN
    DELETE from staging where (id = ANY (id_to_delete)) AND NOT (id = ANY (id_to_keep)) ;
  else
    DELETE from staging where (id = ANY (id_to_delete)) ;
  END IF ;
  IF EXISTS( select id FROM  staging WHERE import_ref = req_import_ref) THEN
    UPDATE imports set state = 'pending' where id = req_import_ref;
  ELSE
    UPDATE imports set state = 'finished', is_finished = true where id = req_import_ref;
  END IF;
  RETURN true;
END;
$_$;


ALTER FUNCTION darwin2.fct_importer_abcd_bck20160713(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 803 (class 1255 OID 18756)
-- Name: fct_importer_abcd_bck20160826(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_abcd_bck20160826(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  userid integer;
  rec_id integer;
  people_id integer;
  all_line RECORD ;
  line staging;
  people_line RECORD;
  maintenance_line collection_maintenance;
  staging_line staging;
  id_to_delete integer ARRAY;
  id_to_keep integer ARRAY ;
  collection collections%ROWTYPE;
  code_count integer;
BEGIN
  SELECT * INTO collection FROM collections WHERE id = (SELECT collection_ref FROM imports WHERE id = req_import_ref AND is_finished = FALSE LIMIT 1);
  select user_ref into userid from imports where id=req_import_ref ;
  PERFORM set_config('darwin.userid',userid::varchar, false) ;
  INSERT INTO classification_keywords (referenced_relation, record_id, keyword_type, keyword)
          (
            SELECT DISTINCT ON (referenced_relation, taxon_ref, keyword_type, keyword_indexed)
                  'taxonomy',
                  taxon_ref,
                  keyword_type,
                  "keyword"
            FROM staging INNER JOIN classification_keywords as ckmain ON ckmain.referenced_relation = 'staging'
                                                                     AND staging.id = ckmain.record_id
                         INNER JOIN imports as i ON i.id = staging.import_ref
            WHERE import_ref = req_import_ref
              AND to_import=true
              AND status = ''::hstore
              AND i.is_finished =  FALSE
              AND NOT EXISTS (
                              SELECT 1
                              FROM classification_keywords
                              WHERE referenced_relation = 'taxonomy'
                                AND record_id = staging.taxon_ref
                                AND keyword_type = ckmain.keyword_type
                                AND keyword_indexed = ckmain.keyword_indexed
              )
          );
  EXECUTE 'DELETE FROM classification_keywords
           WHERE referenced_relation = ''staging''
             AND record_id IN (
                                SELECT s.id
                                FROM staging s INNER JOIN imports i ON  s.import_ref = i.id
                                WHERE import_ref = $1
                                  AND to_import=true
                                  AND status = ''''::hstore
                                  AND i.is_finished =  FALSE
                             )'
  USING req_import_ref;
  FOR all_line IN SELECT * from staging s INNER JOIN imports i on  s.import_ref = i.id
      WHERE import_ref = req_import_ref AND to_import=true and status = ''::hstore AND i.is_finished =  FALSE
  LOOP
    BEGIN
      -- I know it's dumb but....
      -- @ToDo: We need to correct this to avoid reselecting from the staging table !!!
      select * into staging_line from staging where id = all_line.id;
      PERFORM fct_imp_checker_igs(staging_line, true);
      PERFORM fct_imp_checker_expeditions(staging_line, true);
      PERFORM fct_imp_checker_gtu(staging_line, true);

      --RE SELECT WITH UPDATE
      select * into line from staging s INNER JOIN imports i on  s.import_ref = i.id where s.id=all_line.id;

    rec_id := nextval('specimens_id_seq');
    IF line.spec_ref IS NULL THEN
      INSERT INTO specimens (id, category, collection_ref, expedition_ref, gtu_ref, taxon_ref, litho_ref, chrono_ref, lithology_ref, mineral_ref,
          acquisition_category, acquisition_date_mask, acquisition_date, station_visible, ig_ref, type, sex, stage, state, social_status, rock_form,
          specimen_part, complete, institution_ref, building, floor, room, row, col, shelf, container, sub_container,container_type, sub_container_type,
          container_storage, sub_container_storage, surnumerary, specimen_status, specimen_count_min, specimen_count_max, object_name
		--ftheeten 2016 06 22
		,specimen_count_males_min, specimen_count_males_max,specimen_count_females_min, specimen_count_females_max,
		--ftheeten 2016 07 11
        gtu_from_date_mask,
        gtu_from_date,
        gtu_to_date_mask,
        gtu_to_date
          )
      VALUES (rec_id, COALESCE(line.category,'physical') , all_line.collection_ref, line.expedition_ref, line.gtu_ref, line.taxon_ref, line.litho_ref, line.chrono_ref,
        line.lithology_ref, line.mineral_ref, COALESCE(line.acquisition_category,''), COALESCE(line.acquisition_date_mask,0), COALESCE(line.acquisition_date,'01/01/0001'),
        COALESCE(line.station_visible,true),  line.ig_ref, COALESCE(line.individual_type,'specimen'), COALESCE(line.individual_sex,'undefined'),
        COALESCE(line.individual_stage,'undefined'), COALESCE(line.individual_state,'not applicable'),COALESCE(line.individual_social_status,'not applicable'),
        COALESCE(line.individual_rock_form,'not applicable'), COALESCE(line.part,'specimen'), COALESCE(line.complete,true), line.institution_ref, line.building,
        line.floor, line.room, line.row,  line.col, line.shelf, line.container, line.sub_container,COALESCE(line.container_type,'container'),
        COALESCE(line.sub_container_type, 'container'), COALESCE(line.container_storage,''),COALESCE(line.sub_container_storage,''),
        COALESCE(line.surnumerary,false), COALESCE(line.specimen_status,''),COALESCE(line.part_count_min,1), COALESCE(line.part_count_max,line.part_count_min,1), line.object_name
        --ftheeten 2016 06 22
        ,COALESCE(line.part_count_males_min,0),COALESCE(line.part_count_males_max,0),COALESCE(line.part_count_females_min,0),COALESCE(line.part_count_females_max,0),    --ftheeten 2016 07 11
        
        COALESCE(line.gtu_from_date_mask,0), COALESCE(line.gtu_from_date, '01/01/0001'),
          COALESCE(line.gtu_to_date_mask,0), COALESCE(line.gtu_to_date, '31/12/2038')
      );
      FOR maintenance_line IN SELECT * from collection_maintenance where referenced_relation = 'staging' AND record_id=line.id
      LOOP
        SELECT people_ref into people_id FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
        UPDATE collection_maintenance set people_ref=people_id where id=maintenance_line.id ;
        DELETE FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
      END LOOP;

      SELECT COUNT(*) INTO code_count FROM codes WHERE referenced_relation = 'staging' AND record_id = line.id AND code_category = 'main' AND code IS NOT NULL;
      IF code_count = 0 THEN
        PERFORM fct_after_save_add_code(all_line.collection_ref, rec_id);
      ELSE
        UPDATE codes SET referenced_relation = 'specimens', 
                         record_id = rec_id, 
                         code_prefix = CASE WHEN code_prefix IS NULL THEN collection.code_prefix ELSE code_prefix END,
                         code_prefix_separator = CASE WHEN code_prefix_separator IS NULL THEN collection.code_prefix_separator ELSE code_prefix_separator END,
                         code_suffix = CASE WHEN code_suffix IS NULL THEN collection.code_suffix ELSE code_suffix END,
                         code_suffix_separator = CASE WHEN code_suffix_separator IS NULL THEN collection.code_suffix_separator ELSE code_suffix_separator END
        WHERE referenced_relation = 'staging'
          AND record_id = line.id
          AND code_category = 'main';
      END IF;

      UPDATE template_table_record_ref SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      --UPDATE collection_maintenance SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      -- Import identifiers whitch identification have been updated to specimen
      INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        SELECT nextval('catalogue_people_id_seq'), s.referenced_relation, s.record_id, s.people_type, s.people_sub_type, s.order_by, s.people_ref 
        FROM staging_people s, identifications i 
        WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ;
      DELETE FROM staging_people where id in (SELECT s.id FROM staging_people s, identifications i WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ) ;
      -- Import collecting_methods
      INSERT INTO specimen_collecting_methods(id, specimen_ref, collecting_method_ref)
        SELECT nextval('specimen_collecting_methods_id_seq'), rec_id, collecting_method_ref 
        FROM staging_collecting_methods 
        WHERE staging_ref = line.id;
      
      DELETE FROM staging_collecting_methods where staging_ref = line.id;
      UPDATE staging set spec_ref=rec_id WHERE id=all_line.id;

      FOR people_line IN SELECT * from staging_people WHERE referenced_relation = 'specimens'
      LOOP
        INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        VALUES(nextval('catalogue_people_id_seq'),people_line.referenced_relation, people_line.record_id, people_line.people_type, people_line.people_sub_type, people_line.order_by, people_line.people_ref) ;
      END LOOP;
      DELETE FROM staging_people WHERE referenced_relation = 'specimens' ;
    END IF ;
    id_to_delete = array_append(id_to_delete,all_line.id) ;
    END;
  END LOOP;
  select fct_imp_checker_staging_relationship() into id_to_keep ;
  IF id_to_keep IS NOT NULL THEN
    DELETE from staging where (id = ANY (id_to_delete)) AND NOT (id = ANY (id_to_keep)) ;
  else
    DELETE from staging where (id = ANY (id_to_delete)) ;
  END IF ;
  IF EXISTS( select id FROM  staging WHERE import_ref = req_import_ref) THEN
    UPDATE imports set state = 'pending' where id = req_import_ref;
  ELSE
    UPDATE imports set state = 'finished', is_finished = true where id = req_import_ref;
  END IF;
  RETURN true;
END;
$_$;


ALTER FUNCTION darwin2.fct_importer_abcd_bck20160826(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 804 (class 1255 OID 18759)
-- Name: fct_importer_abcd_bck20160928_no_storage_part(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_abcd_bck20160928_no_storage_part(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  userid integer;
  rec_id integer;
  people_id integer;
  all_line RECORD ;
  line staging;
  people_line RECORD;
  maintenance_line collection_maintenance;
  staging_line staging;
  id_to_delete integer ARRAY;
  id_to_keep integer ARRAY ;
  collection collections%ROWTYPE;
  code_count integer;
BEGIN
  SELECT * INTO collection FROM collections WHERE id = (SELECT collection_ref FROM imports WHERE id = req_import_ref AND is_finished = FALSE LIMIT 1);
  select user_ref into userid from imports where id=req_import_ref ;
  PERFORM set_config('darwin.userid',userid::varchar, false) ;
  INSERT INTO classification_keywords (referenced_relation, record_id, keyword_type, keyword)
          (
            SELECT DISTINCT ON (referenced_relation, taxon_ref, keyword_type, keyword_indexed)
                  'taxonomy',
                  taxon_ref,
                  keyword_type,
                  "keyword"
            FROM staging INNER JOIN classification_keywords as ckmain ON ckmain.referenced_relation = 'staging'
                                                                     AND staging.id = ckmain.record_id
                         INNER JOIN imports as i ON i.id = staging.import_ref
            WHERE import_ref = req_import_ref
              AND to_import=true
              AND status = ''::hstore
              AND i.is_finished =  FALSE
              AND NOT EXISTS (
                              SELECT 1
                              FROM classification_keywords
                              WHERE referenced_relation = 'taxonomy'
                                AND record_id = staging.taxon_ref
                                AND keyword_type = ckmain.keyword_type
                                AND keyword_indexed = ckmain.keyword_indexed
              )
          );
  EXECUTE 'DELETE FROM classification_keywords
           WHERE referenced_relation = ''staging''
             AND record_id IN (
                                SELECT s.id
                                FROM staging s INNER JOIN imports i ON  s.import_ref = i.id
                                WHERE import_ref = $1
                                  AND to_import=true
                                  AND status = ''''::hstore
                                  AND i.is_finished =  FALSE
                             )'
  USING req_import_ref;
  FOR all_line IN SELECT * from staging s INNER JOIN imports i on  s.import_ref = i.id
      WHERE import_ref = req_import_ref AND to_import=true and status = ''::hstore AND i.is_finished =  FALSE
  LOOP
    BEGIN
      -- I know it's dumb but....
      -- @ToDo: We need to correct this to avoid reselecting from the staging table !!!
      select * into staging_line from staging where id = all_line.id;
      PERFORM fct_imp_checker_igs(staging_line, true);
      PERFORM fct_imp_checker_expeditions(staging_line, true);
      PERFORM fct_imp_checker_gtu(staging_line, true);

      --RE SELECT WITH UPDATE
      select * into line from staging s INNER JOIN imports i on  s.import_ref = i.id where s.id=all_line.id;

    rec_id := nextval('specimens_id_seq');
    IF line.spec_ref IS NULL THEN
      INSERT INTO specimens (id, category, collection_ref, expedition_ref, gtu_ref, taxon_ref, litho_ref, chrono_ref, lithology_ref, mineral_ref,
          acquisition_category, acquisition_date_mask, acquisition_date, station_visible, ig_ref, type, sex, stage, state, social_status, rock_form,
          specimen_part, complete, institution_ref, building, floor, room, row, col, shelf, container, sub_container,container_type, sub_container_type,
          container_storage, sub_container_storage, surnumerary, specimen_status, specimen_count_min, specimen_count_max, object_name
		--ftheeten 2016 06 22
		,specimen_count_males_min, specimen_count_males_max,specimen_count_females_min, specimen_count_females_max,
		--ftheeten 2016 07 11
        gtu_from_date_mask,
        gtu_from_date,
        gtu_to_date_mask,
        gtu_to_date
          )
      VALUES (rec_id, COALESCE(line.category,'physical') , all_line.collection_ref, line.expedition_ref, line.gtu_ref, line.taxon_ref, line.litho_ref, line.chrono_ref,
        line.lithology_ref, line.mineral_ref, COALESCE(line.acquisition_category,''), COALESCE(line.acquisition_date_mask,0), COALESCE(line.acquisition_date,'01/01/0001'),
        COALESCE(line.station_visible,true),  line.ig_ref, COALESCE(line.individual_type,'specimen'), COALESCE(line.individual_sex,'undefined'),
        COALESCE(line.individual_stage,'undefined'), COALESCE(line.individual_state,'not applicable'),COALESCE(line.individual_social_status,'not applicable'),
        COALESCE(line.individual_rock_form,'not applicable'), COALESCE(line.part,'specimen'), COALESCE(line.complete,true), line.institution_ref, line.building,
        line.floor, line.room, line.row,  line.col, line.shelf, line.container, line.sub_container,COALESCE(line.container_type,'container'),
        COALESCE(line.sub_container_type, 'container'), COALESCE(line.container_storage,''),COALESCE(line.sub_container_storage,''),
        COALESCE(line.surnumerary,false), COALESCE(line.specimen_status,''),COALESCE(line.part_count_min,1), COALESCE(line.part_count_max,line.part_count_min,1), line.object_name
        --ftheeten 2016 06 22
        ,COALESCE(line.part_count_males_min,0),COALESCE(line.part_count_males_max,0),COALESCE(line.part_count_females_min,0),COALESCE(line.part_count_females_max,0),    --ftheeten 2016 07 11
        
        COALESCE(line.gtu_from_date_mask,0), COALESCE(line.gtu_from_date, '01/01/0001'),
          COALESCE(line.gtu_to_date_mask,0), COALESCE(line.gtu_to_date, '31/12/2038')
      );
      FOR maintenance_line IN SELECT * from collection_maintenance where referenced_relation = 'staging' AND record_id=line.id
      LOOP
        SELECT people_ref into people_id FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
        UPDATE collection_maintenance set people_ref=people_id where id=maintenance_line.id ;
        DELETE FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
      END LOOP;

      SELECT COUNT(*) INTO code_count FROM codes WHERE referenced_relation = 'staging' AND record_id = line.id AND code_category = 'main' AND code IS NOT NULL;
      IF code_count = 0 THEN
        PERFORM fct_after_save_add_code(all_line.collection_ref, rec_id);
      ELSE
        UPDATE codes SET referenced_relation = 'specimens', 
                         record_id = rec_id, 
                         code_prefix = CASE WHEN code_prefix IS NULL THEN collection.code_prefix ELSE code_prefix END,
                         code_prefix_separator = CASE WHEN code_prefix_separator IS NULL THEN collection.code_prefix_separator ELSE code_prefix_separator END,
                         code_suffix = CASE WHEN code_suffix IS NULL THEN collection.code_suffix ELSE code_suffix END,
                         code_suffix_separator = CASE WHEN code_suffix_separator IS NULL THEN collection.code_suffix_separator ELSE code_suffix_separator END
        WHERE referenced_relation = 'staging'
          AND record_id = line.id
          AND code_category = 'main';
      END IF;

      UPDATE template_table_record_ref SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      --UPDATE collection_maintenance SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
      -- Import identifiers whitch identification have been updated to specimen
      INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        SELECT nextval('catalogue_people_id_seq'), s.referenced_relation, s.record_id, s.people_type, s.people_sub_type, s.order_by, s.people_ref 
        FROM staging_people s, identifications i 
        WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ;
      DELETE FROM staging_people where id in (SELECT s.id FROM staging_people s, identifications i WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ) ;
      -- Import collecting_methods
      INSERT INTO specimen_collecting_methods(id, specimen_ref, collecting_method_ref)
        SELECT nextval('specimen_collecting_methods_id_seq'), rec_id, collecting_method_ref 
        FROM staging_collecting_methods 
        WHERE staging_ref = line.id;
      
      DELETE FROM staging_collecting_methods where staging_ref = line.id;
      UPDATE staging set spec_ref=rec_id WHERE id=all_line.id;

      FOR people_line IN SELECT * from staging_people WHERE referenced_relation = 'specimens'
      LOOP
        INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
        VALUES(nextval('catalogue_people_id_seq'),people_line.referenced_relation, people_line.record_id, people_line.people_type, people_line.people_sub_type, people_line.order_by, people_line.people_ref) ;
      END LOOP;
      DELETE FROM staging_people WHERE referenced_relation = 'specimens' ;
    END IF ;
    id_to_delete = array_append(id_to_delete,all_line.id) ;
    END;
  END LOOP;
  select fct_imp_checker_staging_relationship() into id_to_keep ;
  IF id_to_keep IS NOT NULL THEN
    DELETE from staging where (id = ANY (id_to_delete)) AND NOT (id = ANY (id_to_keep)) ;
  else
    DELETE from staging where (id = ANY (id_to_delete)) ;
  END IF ;
  IF EXISTS( select id FROM  staging WHERE import_ref = req_import_ref) THEN
    UPDATE imports set state = 'pending' where id = req_import_ref;
  ELSE
    UPDATE imports set state = 'finished', is_finished = true where id = req_import_ref;
  END IF;
  RETURN true;
END;
$_$;


ALTER FUNCTION darwin2.fct_importer_abcd_bck20160928_no_storage_part(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 808 (class 1255 OID 18762)
-- Name: fct_importer_catalogue(integer, text, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
        var_taxonomy_name varchar;
	is_reference boolean;
	var_creation_date date;
	var_creation_date_mask integer;
	var_definition_taxonomy varchar;
	var_source_taxonomy varchar;
	var_url_website_taxonomy varchar;
	var_url_webservice_taxonomy varchar;
	last_id_metadata integer;
	taxonomy_ref integer;	 
	--ftheeten 2019 02 19
	staging_catalogue_line staging_catalogue;
	kingdom_id integer;
	
BEGIN
	SELECT imports.specimen_taxonomy_ref , taxonomy_metadata.is_reference_taxonomy into taxonomy_ref, is_reference FROM imports LEFT JOIN taxonomy_metadata
	ON imports.specimen_taxonomy_ref=taxonomy_metadata.id	 WHERE imports.id=req_import_ref;
	IF taxonomy_ref IS NULL THEN
		--raise notice 'init';
		SELECT taxonomy_name, creation_date, creation_date_mask,definition_taxonomy, is_reference_taxonomy , source_taxonomy ,
		url_website_taxonomy,  url_webservice_taxonomy INTO var_taxonomy_name , var_creation_date, var_creation_date_mask , var_definition_taxonomy, is_reference, var_source_taxonomy,  var_url_website_taxonomy , var_url_webservice_taxonomy FROM imports WHERE id=req_import_ref;
		INSERT INTO taxonomy_metadata (taxonomy_name, creation_date, creation_date_mask, import_ref, 
	       definition, is_reference_taxonomy, source, url_website, url_webservice) VALUES (var_taxonomy_name, var_creation_date, var_creation_date_mask, req_import_ref, var_definition_taxonomy, is_reference, var_source_taxonomy, var_url_website_taxonomy, var_url_webservice_taxonomy) RETURNING id INTO last_id_metadata;
       ELSE
		last_id_metadata:=taxonomy_ref;
       END IF;

	
	IF is_reference = true THEN
		raise notice 'ref';
		raise notice 'import = %', req_import_ref;
		raise notice 'metadata %', last_id_metadata;
		--return fct_importer_catalogue_reference_taxonomy(req_import_ref , last_id_metadata, referenced_relation, exclude_invalid_entries   );
		return fct_importer_catalogue_non_reference_taxonomy(req_import_ref , last_id_metadata, referenced_relation, exclude_invalid_entries   );
	ELSE	
		raise notice 'non ref';
		raise notice 'import = %', req_import_ref;
		raise notice 'metadata %', last_id_metadata;
		--return fct_rmca_handle_non_reference_taxonomies(req_import_ref , last_id_metadata, exclude_invalid_entries   );
		return fct_importer_catalogue_non_reference_taxonomy(req_import_ref , last_id_metadata, referenced_relation, exclude_invalid_entries   );
		/*raise notice 'test kingdom';
                FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue where import_ref=req_import_ref and  parent_ref is null   and  parent_ref_internal is null  and level_ref<=34
			LOOP
				IF staging_catalogue_line.level_ref>2 THEN
					raise notice 'force kingdom';
					INSERT INTO darwin2.staging_catalogue(
						import_ref, name , level_ref,
						parent_ref, parent_ref_internal, catalogue_ref, 
						parent_updated,	is_reference_taxonomy, source_taxonomy, 
						name_cluster, imported)
						VALUES (
						staging_catalogue_line.import_ref, (SELECT taxonomy.name FROM imports LEFT JOIN taxonomy ON imports.taxonomy_kingdom=taxonomy.id::varchar where imports.id= staging_catalogue_line.import_ref LIMIT 1), 2
						, NULL, NULL, NULL, 
						false, 	staging_catalogue_line.is_reference_taxonomy, staging_catalogue_line.source_taxonomy, 
						staging_catalogue_line.name_cluster, false) RETURNING id into kingdom_id;
					UPDATE staging_catalogue SET parent_ref = kingdom_id  , parent_ref_internal= kingdom_id WHERE id=staging_catalogue_line.id;
				END IF;
			END LOOP;
	        RAISE NOTICE '2nd pass';
		return fct_rmca_handle_non_reference_taxonomies(req_import_ref , last_id_metadata, exclude_invalid_entries   );*/
	
	END IF;
END;
$$;


ALTER FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 806 (class 1255 OID 18763)
-- Name: fct_importer_catalogue_non_reference_taxonomy(integer, integer, text, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_non_reference_taxonomy(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
  DECLARE
	returned BOOLEAN;
	check_duplicates_hierarchies RECORD;
	duplicate_hierarchies_msg varchar;

  BEGIN	
  raise notice 'test';
	IF referenced_relation= 'taxonomy' THEN
		raise notice '0';
		
		--PERFORM fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref, true, false, not exclude_invalid_entries);
		--SELECT fct_importer_catalogue_reference_taxonomy_logic_reference INTO returned FROM  fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref , var_metadata_ref ,  exclude_invalid_entries );
		PERFORM fct_rmca_document_taxonomy_staging_darwin_non_reference(req_import_ref, var_metadata_ref, true, false, not exclude_invalid_entries);
		SELECT fct_importer_catalogue_reference_taxonomy_logic_non_reference INTO returned FROM  fct_importer_catalogue_reference_taxonomy_logic_non_reference(req_import_ref , var_metadata_ref ,  exclude_invalid_entries );
	ELSE
		SELECT fct_importer_catalogue_reference_taxonomy_rmca_non_taxo INTO returned  FROM fct_importer_catalogue_reference_taxonomy_rmca_non_taxo(req_import_ref , var_metadata_ref , referenced_relation , exclude_invalid_entries );
		
	END IF;

	 RETURN returned;
  END;
  $$;


ALTER FUNCTION darwin2.fct_importer_catalogue_non_reference_taxonomy(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 807 (class 1255 OID 18764)
-- Name: fct_importer_catalogue_non_reference_taxonomy_add_author(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_non_reference_taxonomy_add_author(var_staging_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_catalogue_ref INTEGER;
	var_name varchar;
	var_name_taxo varchar;
	var_level_ref integer;
	var_taxonomy_ref integer;
	var_cpts integer[];
	var_names varchar[];
	var_names2 varchar[];
	returned INTEGER;
		
BEGIN
	returned :=NULL;
	SELECT name, specimen_taxonomy_ref, level_ref, catalogue_Ref INTO var_name, var_taxonomy_ref , var_level_ref,var_catalogue_ref  FROM staging_catalogue LEFT JOIN imports ON staging_catalogue.import_ref=imports.id  WHERE staging_catalogue.id=var_staging_id;
	
	IF var_taxonomy_ref IS NOT NULL AND var_catalogue_ref IS NULL AND var_level_ref>=41 THEN
		SELECT array_agg(id),array_agg(name) INTO var_cpts,var_names FROM taxonomy WHERE metadata_ref=var_taxonomy_ref AND level_ref=var_level_ref AND name ~ ('^('|| replace(replace(replace(var_name,')','\)'), '(','\('),'.','\.')||')($|\s)');
		IF ARRAY_LENGTH(var_cpts,1) =1 THEN
			returned:=var_cpts[1];
			var_name_taxo:=var_names[1];
            raise notice '%', var_name_taxo;
			SELECT * INTO var_names2 FROM fct_rmca_taxonomy_split_name_author(var_name_taxo, var_level_ref);
			 raise notice '%', var_names2;
            IF ARRAY_LENGTH(var_names2,1)=2 THEN
            	raise notice 'go';
				IF TRIM(var_names2[1])=TRIM(var_name) THEN
                	raise notice 'update';
					UPDATE staging_catalogue SET name=var_name_taxo WHERE id=var_staging_id;
				END IF;
			END IF;
			
				
		END IF;
	END IF;
	
	RETURN returned;
END;
$_$;


ALTER FUNCTION darwin2.fct_importer_catalogue_non_reference_taxonomy_add_author(var_staging_id integer) OWNER TO darwin2;

--
-- TOC entry 809 (class 1255 OID 18765)
-- Name: fct_importer_catalogue_non_reference_taxonomy_add_author_file(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_non_reference_taxonomy_add_author_file(var_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

	returned boolean;
	
		
BEGIN
	returned:=FALSE;
	WITH name_no_author 
		AS
		(SELECT staging_catalogue.id, 
		keyword as author_year, 
		TRIM(REPLACE(name, keyword, '')) AS name_no_author,

		TRIM(REPLACE(name, keyword, ''))||' '||keyword as name_author
		FROM staging_catalogue LEFT JOIN classification_keywords
							ON classification_keywords.record_id=staging_catalogue.id
							AND referenced_relation='staging_catalogue' 
							WHERE					
							 keyword_type= 'AuthorTeamParenthesisAndYear' 
			     AND staging_catalogue.import_ref=var_import_ref
			     AND keyword ~ '.*[A-Z].*' and coalesce(TRIM(REPLACE(name, keyword, '')),'')   !=''           
		)
		UPDATE staging_catalogue 
		SET name=name_author,
		import_exception='duplicate_name_without_author'
		FROM name_no_author
		WHERE 
		name=name_no_author.name_no_author
		AND staging_catalogue.id !=name_no_author.id
		AND import_ref=var_import_ref;
     returned:=true;
     RETURN returned;
END;
$$;


ALTER FUNCTION darwin2.fct_importer_catalogue_non_reference_taxonomy_add_author_file(var_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 810 (class 1255 OID 18766)
-- Name: fct_importer_catalogue_non_reference_taxonomy_add_author_loop(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_non_reference_taxonomy_add_author_loop(var_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned boolean;

BEGIN
	returned:=FALSE;
	PERFORM fct_importer_catalogue_non_reference_taxonomy_add_author_file(var_import_ref) ;
	PERFORM fct_importer_catalogue_non_reference_taxonomy_add_author(id) FROM staging_catalogue WHERE import_ref=var_import_ref AND level_ref>=41;
	returned:=TRUE;
	RETURN returned;
END;
$$;


ALTER FUNCTION darwin2.fct_importer_catalogue_non_reference_taxonomy_add_author_loop(var_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 811 (class 1255 OID 18767)
-- Name: fct_importer_catalogue_reference_taxonomy(integer, integer, text, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
  DECLARE
	returned BOOLEAN;
	check_duplicates_hierarchies RECORD;
	duplicate_hierarchies_msg varchar;

  BEGIN	
  raise notice 'test';
	IF referenced_relation= 'taxonomy' THEN
		raise notice '0';
		
		PERFORM fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref, true, false, not exclude_invalid_entries);
		SELECT fct_importer_catalogue_reference_taxonomy_logic_reference INTO returned FROM  fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref , var_metadata_ref ,  exclude_invalid_entries );
	ELSE
		SELECT fct_importer_catalogue_reference_taxonomy_rmca_non_taxo INTO returned  FROM fct_importer_catalogue_reference_taxonomy_rmca_non_taxo(req_import_ref , var_metadata_ref , referenced_relation , exclude_invalid_entries );
	END IF;

	 RETURN returned;
  END;
  $$;


ALTER FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 812 (class 1255 OID 18768)
-- Name: fct_importer_catalogue_reference_taxonomy_logic(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
  DECLARE
	returned boolean;
	i integer;
	array_levels integer[];
	current_level integer;
	current_names RECORD;
	
	--taxo_path varchar[];
	reference_kingdom int;
	recCatalogue RECORD;
	line_created boolean;
	existing_taxon integer;
	taxon_to_copy integer;
	parent_to_update integer;

	name_parent varchar;
	--updated_id integer;
	is_updated boolean;


  BEGIN	
	PERFORM setval('taxonomy_id_seq', (SELECT MAX(id)+1 FROM taxonomy ), false);
	returned :=FALSE;

	SELECT taxonomy_kingdom INTO reference_kingdom FROM imports where id=req_import_ref LIMIT 1;
	SELECT  array_agg(distinct level_ref order by level_ref) INTO array_levels FROM  staging_catalogue WHERE  import_ref=req_import_ref ;


	FOR i in 1..ARRAY_LENGTH(array_levels, 1)
	LOOP
		current_level := array_levels[i];
		RAISE NOTICE '%', current_level;
		FOR  current_names in SELECT DISTINCT min(id) as min_id, min(parent_ref) as min_parent_ref, name,  fulltoindex(name,FALSE) as name_indexed FROM  staging_catalogue WHERE  import_ref=req_import_ref and level_ref = current_level --AND catalogue_ref IS NULL --AND parent_updated=false 
		GROUP BY name ORDER BY name_indexed
		LOOP
			line_created:=FALSE;
			raise notice '%', current_names.name;
			--SELECT fct_rmca_taxo_staging_path_in_reference INTO taxo_path FROM fct_rmca_taxo_staging_path_in_reference(current_names.min_id);
			--raise notice '%', taxo_path;
			IF exclude_invalid_entries =FALSE THEN
				SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.is_reference_taxonomy = TRUE and name_indexed=current_names.name_indexed and level_ref=current_level;
			ELSE
				SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.is_reference_taxonomy = TRUE and name_indexed=current_names.name_indexed and level_ref=current_level  AND status != 'invalid' ;
			END IF;
			IF existing_taxon IS NULL THEN
				--create higher of taxonomy
				IF current_level = 4 AND i=1 THEN 
					--raise notice 'init';
					parent_to_update:=reference_kingdom;
				ELSE
					SELECT parent_updated into is_updated FROM staging_catalogue WHERE id=current_names.min_id;
					--raise notice 'min parent ref %',current_names.min_parent_ref;
					IF is_updated IS TRUE THEN
						--raise notice 'found updated';
						parent_to_update:=current_names.min_parent_ref;
					ELSE
						SELECT catalogue_ref, name INTO parent_to_update, name_parent FROM staging_catalogue WHERE id=current_names.min_parent_ref;
					END IF;
					--parent_to_update:=current_names.min_parent_ref;
				END IF;
				--raise notice 'parent_to_update %',parent_to_update;
				IF parent_to_update IS NOT NULL THEN
					EXECUTE 'INSERT INTO taxonomy  (id,name,level_ref,parent_ref, metadata_ref, import_ref) ' ||
						  'VALUES(DEFAULT,$1,$2,$3,$4,$5) ' ||
						  'RETURNING *;'
						INTO recCatalogue
						USING current_names.name,current_level , parent_to_update , var_metadata_ref, req_import_ref;
					line_created:=TRUE;

					taxon_to_copy:=recCatalogue.id;
				END IF;	
				--in principle we'll be never in this case as the previosu row of the same staging record shoudl have created the taxonomy			
				
			ELSE
				
				taxon_to_copy:=existing_taxon;
				line_created:=TRUE;

				
				
			END IF;
			IF line_created=TRUE THEN
				--raise notice 'taxon_to_copy %',taxon_to_copy;
				--raise notice 'UPDATE staging';
				WITH staging_catalogue_updated(updated_id) AS (
				  UPDATE staging_catalogue as sc
				  SET catalogue_ref = taxon_to_copy
				  WHERE sc.import_ref = req_import_ref
					AND sc.name = current_names.name
					AND sc.level_ref = current_level
				  RETURNING id
				)
				UPDATE staging_catalogue as msc
				SET parent_ref = taxon_to_copy,
				  parent_updated = TRUE
				WHERE msc.import_ref = req_import_ref
				      AND msc.parent_ref IN (
				  SELECT updated_id FROM staging_catalogue_updated
				)
				      AND parent_updated = FALSE;
			      END IF;

		END LOOP;
	END LOOP;

	returned =TRUE;
	 RETURN returned;
  END;
  $_$;


ALTER FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 813 (class 1255 OID 18769)
-- Name: fct_importer_catalogue_reference_taxonomy_logic_non_reference(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_non_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$

  DECLARE
returned boolean;
i integer;
array_levels integer[];
current_level integer;
current_names RECORD;

--taxo_path varchar[];
reference_kingdom int;
recCatalogue RECORD;
line_created boolean;
existing_taxon integer;
taxon_to_copy integer;
parent_to_update integer;

name_parent varchar;
--updated_id integer;
is_updated boolean;
--_c text;

  BEGIN
  
  --2019 12 03 add author
PERFORM  fct_importer_catalogue_non_reference_taxonomy_add_author_loop(req_import_ref);
PERFORM setval('taxonomy_id_seq', (SELECT MAX(id)+1 FROM taxonomy ), false);
returned :=FALSE;

SELECT taxonomy_kingdom INTO reference_kingdom FROM imports where id=req_import_ref LIMIT 1;
SELECT  array_agg(distinct level_ref order by level_ref) INTO array_levels FROM  staging_catalogue WHERE  import_ref=req_import_ref ;

FOR i in 1..ARRAY_LENGTH(array_levels, 1)
LOOP
 current_level := array_levels[i];
 RAISE NOTICE '%', current_level;
 FOR  current_names in SELECT DISTINCT min(id) as min_id, min(parent_ref) as min_parent_ref, name,  fulltoindex(name,FALSE) as name_indexed FROM  staging_catalogue WHERE  import_ref=req_import_ref and level_ref = current_level AND
 name_cluster IN (select distinct s2.name_cluster FROM staging_catalogue s2
 WHERE s2.import_exception= 'taxon_to_be_created' AND s2.import_ref=req_import_ref) --AND catalogue_ref IS NULL --AND parent_updated=false
 GROUP BY name ORDER BY name_indexed
 LOOP
  BEGIN
 
   line_created:=FALSE;
   raise notice 'NAME TO IMPORT %', current_names.name;
   --SELECT fct_rmca_taxo_staging_path_in_reference INTO taxo_path FROM fct_rmca_taxo_staging_path_in_reference(current_names.min_id);
   --raise notice '%', taxo_path;
   IF exclude_invalid_entries =FALSE THEN
   RAISE NOTICE 'INVALID_INCLUDED';
    SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.id = var_metadata_ref and name_indexed=current_names.name_indexed and level_ref=current_level;
   ELSE
   RAISE NOTICE 'EXCLUDE_INVALID';
    SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.id = var_metadata_ref and name_indexed=current_names.name_indexed and level_ref=current_level  AND status != 'invalid' ;
   END IF;
   IF existing_taxon IS NULL THEN
    RAISE NOTICE 'CREATE';
    --create higher of taxonomy
    IF current_level = 4 AND i=1 THEN
     --raise notice 'init';
     parent_to_update:=reference_kingdom;
    ELSE
     SELECT parent_updated into is_updated FROM staging_catalogue WHERE id=current_names.min_id;
     --raise notice 'min parent ref %',current_names.min_parent_ref;
     IF is_updated IS TRUE THEN
      raise notice 'IS_UPDATED';
      parent_to_update:=current_names.min_parent_ref;
     ELSE
      raise notice 'IS_NOT_UPDATED';
      SELECT catalogue_ref, name INTO parent_to_update, name_parent FROM staging_catalogue WHERE id=current_names.min_parent_ref;
     END IF;
     --parent_to_update:=current_names.min_parent_ref;
     --SELECT catalogue_ref, name INTO parent_to_update, name_parent FROM staging_catalogue WHERE id= (SELECT parent_ref_internal FROM staging_catalogue WHERE
     -- id = current_names.min_id LIMIT 1);
    END IF;
    raise notice 'parent_to_update %',parent_to_update;
    IF parent_to_update IS NOT NULL THEN
     RAISE NOTICE 'INSERT INTO taxonomy  (id,name,level_ref,parent_ref, metadata_ref, import_ref) VALUES(DEFAULT,''%'',%,%,%,%) ', current_names.name,current_level , parent_to_update , var_metadata_ref, req_import_ref;
     EXECUTE 'INSERT INTO taxonomy  (id,name,level_ref,parent_ref, metadata_ref, import_ref) ' ||
        'VALUES(DEFAULT,$1,$2,$3,$4,$5) ' ||
        'RETURNING *;'
      INTO recCatalogue
      USING current_names.name,current_level , parent_to_update , var_metadata_ref, req_import_ref;
     --2019 03 21
     taxon_to_copy:=recCatalogue.id;
     line_created:=TRUE;
        --2019 02 10
      UPDATE staging_catalogue set imported =true , import_exception='imported_taxon' WHERE id=current_names.min_id;

    ELSE
     UPDATE staging_catalogue set imported =false , import_exception='taxon_to_be_created_without_suitable_parent' WHERE id=current_names.min_id;
    END IF;
    --in principle we'll be never in this case as the previous row of the same staging record shoudl have created the taxonomy  
   
   ELSE
    RAISE NOTICE 'EXISTS';
    taxon_to_copy:=existing_taxon;
    line_created:=TRUE;

   
   
   END IF;
   IF line_created=TRUE THEN
    --raise notice 'taxon_to_copy %',taxon_to_copy;
    --raise notice 'UPDATE staging';
    WITH staging_catalogue_updated(updated_id) AS (
      UPDATE staging_catalogue as sc
      SET catalogue_ref = taxon_to_copy
      WHERE sc.import_ref = req_import_ref
     AND sc.name = current_names.name
     AND sc.level_ref = current_level
      RETURNING id
    )
    UPDATE staging_catalogue as msc
    SET parent_ref = taxon_to_copy,
      parent_updated = TRUE
    WHERE msc.import_ref = req_import_ref
          AND msc.parent_ref IN (
      SELECT updated_id FROM staging_catalogue_updated
    )
    AND parent_updated = FALSE;
   END IF;
  EXCEPTION WHEN OTHERS THEN
  --RAISE NOTICE 'EXCEPTION';
 -- RAISE NOTICE '% %', SQLERRM, SQLSTATE;

  UPDATE staging_catalogue set import_exception= SQLERRM WHERE id=current_names.min_id;
  UPDATE imports SET state='pending', errors_in_import=SQLERRM  WHERE id=req_import_ref;
  --RETURN FALSE;
  END;
         

 END LOOP;
END LOOP;

returned =TRUE;
 RETURN returned;

  END;
  
$_$;


ALTER FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_non_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 814 (class 1255 OID 18772)
-- Name: fct_importer_catalogue_reference_taxonomy_logic_reference(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$

  DECLARE
returned boolean;
i integer;
array_levels integer[];
current_level integer;
current_names RECORD;

--taxo_path varchar[];
reference_kingdom int;
recCatalogue RECORD;
line_created boolean;
existing_taxon integer;
taxon_to_copy integer;
parent_to_update integer;

name_parent varchar;
--updated_id integer;
is_updated boolean;
--_c text;

  BEGIN
  
    --2019 12 03 add author
PERFORM  fct_importer_catalogue_non_reference_taxonomy_add_author_loop(req_import_ref);
PERFORM setval('taxonomy_id_seq', (SELECT MAX(id)+1 FROM taxonomy ), false);
returned :=FALSE;

SELECT taxonomy_kingdom INTO reference_kingdom FROM imports where id=req_import_ref LIMIT 1;
SELECT  array_agg(distinct level_ref order by level_ref) INTO array_levels FROM  staging_catalogue WHERE  import_ref=req_import_ref ;

FOR i in 1..ARRAY_LENGTH(array_levels, 1)
LOOP
 current_level := array_levels[i];
 RAISE NOTICE '%', current_level;
 FOR  current_names in SELECT DISTINCT min(id) as min_id, min(parent_ref) as min_parent_ref, name,  fulltoindex(name,FALSE) as name_indexed FROM  staging_catalogue WHERE  import_ref=req_import_ref and level_ref = current_level AND
 name_cluster IN (select distinct s2.name_cluster FROM staging_catalogue s2
 WHERE s2.import_exception= 'taxon_to_be_created' AND s2.import_ref=req_import_ref) --AND catalogue_ref IS NULL --AND parent_updated=false
 GROUP BY name ORDER BY name_indexed
 LOOP
  BEGIN
 
   line_created:=FALSE;
   raise notice 'NAME TO IMPORT %', current_names.name;
   --SELECT fct_rmca_taxo_staging_path_in_reference INTO taxo_path FROM fct_rmca_taxo_staging_path_in_reference(current_names.min_id);
   --raise notice '%', taxo_path;
   IF exclude_invalid_entries =FALSE THEN
   RAISE NOTICE 'INVALID_INCLUDED';
    SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.is_reference_taxonomy = TRUE and name_indexed=current_names.name_indexed and level_ref=current_level;
   ELSE
   RAISE NOTICE 'EXCLUDE_INVALID';
    SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.is_reference_taxonomy = TRUE and name_indexed=current_names.name_indexed and level_ref=current_level  AND status != 'invalid' ;
   END IF;
   IF existing_taxon IS NULL THEN
    RAISE NOTICE 'CREATE';
    --create higher of taxonomy
    IF current_level = 4 AND i=1 THEN
     --raise notice 'init';
     parent_to_update:=reference_kingdom;
    ELSE
     SELECT parent_updated into is_updated FROM staging_catalogue WHERE id=current_names.min_id;
     --raise notice 'min parent ref %',current_names.min_parent_ref;
     IF is_updated IS TRUE THEN
      raise notice 'IS_UPDATED';
      parent_to_update:=current_names.min_parent_ref;
     ELSE
      raise notice 'IS_NOT_UPDATED';
      SELECT catalogue_ref, name INTO parent_to_update, name_parent FROM staging_catalogue WHERE id=current_names.min_parent_ref;
     END IF;
     --parent_to_update:=current_names.min_parent_ref;
     --SELECT catalogue_ref, name INTO parent_to_update, name_parent FROM staging_catalogue WHERE id= (SELECT parent_ref_internal FROM staging_catalogue WHERE
     -- id = current_names.min_id LIMIT 1);
    END IF;
    raise notice 'parent_to_update %',parent_to_update;
    IF parent_to_update IS NOT NULL THEN
     RAISE NOTICE 'INSERT INTO taxonomy  (id,name,level_ref,parent_ref, metadata_ref, import_ref) VALUES(DEFAULT,''%'',%,%,%,%) ', current_names.name,current_level , parent_to_update , var_metadata_ref, req_import_ref;
     EXECUTE 'INSERT INTO taxonomy  (id,name,level_ref,parent_ref, metadata_ref, import_ref) ' ||
        'VALUES(DEFAULT,$1,$2,$3,$4,$5) ' ||
        'RETURNING *;'
      INTO recCatalogue
      USING current_names.name,current_level , parent_to_update , var_metadata_ref, req_import_ref;
     --2019 03 21
     taxon_to_copy:=recCatalogue.id;
     line_created:=TRUE;
        --2019 02 10
      UPDATE staging_catalogue set imported =true , import_exception='imported_taxon' WHERE id=current_names.min_id;

    ELSE
     UPDATE staging_catalogue set imported =false , import_exception='taxon_to_be_created_without_suitable_parent' WHERE id=current_names.min_id;
    END IF;
    --in principle we'll be never in this case as the previous row of the same staging record shoudl have created the taxonomy  
   
   ELSE
    RAISE NOTICE 'EXISTS';
    taxon_to_copy:=existing_taxon;
    line_created:=TRUE;

   
   
   END IF;
   IF line_created=TRUE THEN
    --raise notice 'taxon_to_copy %',taxon_to_copy;
    --raise notice 'UPDATE staging';
    WITH staging_catalogue_updated(updated_id) AS (
      UPDATE staging_catalogue as sc
      SET catalogue_ref = taxon_to_copy
      WHERE sc.import_ref = req_import_ref
     AND sc.name = current_names.name
     AND sc.level_ref = current_level
      RETURNING id
    )
    UPDATE staging_catalogue as msc
    SET parent_ref = taxon_to_copy,
      parent_updated = TRUE
    WHERE msc.import_ref = req_import_ref
          AND msc.parent_ref IN (
      SELECT updated_id FROM staging_catalogue_updated
    )
    AND parent_updated = FALSE;
   END IF;
  EXCEPTION WHEN OTHERS THEN
  --RAISE NOTICE 'EXCEPTION';
 -- RAISE NOTICE '% %', SQLERRM, SQLSTATE;

  UPDATE staging_catalogue set import_exception= SQLERRM WHERE id=current_names.min_id;
  UPDATE imports SET state='pending', errors_in_import=SQLERRM  WHERE id=req_import_ref;
  --RETURN FALSE;
  END;
         

 END LOOP;
END LOOP;

returned =TRUE;
 RETURN returned;

  END;
  
$_$;


ALTER FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 815 (class 1255 OID 18775)
-- Name: fct_importer_catalogue_reference_taxonomy_rmca_non_taxo(integer, integer, text, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_rmca_non_taxo(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    staging_catalogue_line staging_catalogue;
    where_clause_complement_1 text := ' ';
    where_clause_complement_2 text := ' ';
    where_clause_complement_3 text := ' ';
    where_clause_complement_3_bis text := ' ';
    where_clause_complement_4 text := ' ';
    where_clause_complement_5 text := ' ';
    where_clause_exclude_invalid text := ' ';
    recCatalogue RECORD;
    id_existing_taxon integer;
    existing_text_hierarchy varchar;
    staging_text_hierarchy varchar;
    parent_path template_classifications.path%TYPE;
    parentRef staging_catalogue.parent_ref%TYPE;
    parent_level catalogue_levels.id%TYPE;
    catalogueRef staging_catalogue.catalogue_ref%TYPE;
    levelRef staging_catalogue.level_ref%TYPE;
    error_msg TEXT := '';
    children_move_forward BOOLEAN := FALSE;
    level_naming TEXT;
    tempSQL TEXT;
    check_duplicates_hierarchies RECORD;
    duplicate_hierarchies_msg varchar;


  BEGIN

    FOR staging_catalogue_line IN SELECT * from staging_catalogue WHERE import_ref = req_import_ref ORDER BY level_ref, fullToIndex(name)
    LOOP
	
      IF trim(touniquestr(staging_catalogue_line.name)) = '' THEN
        RAISE EXCEPTION E'Case 0, Could not import this file, % is not a valid name.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
      END IF;
      SELECT parent_ref, catalogue_ref, level_ref INTO parentRef, catalogueRef, levelRef FROM staging_catalogue WHERE id = staging_catalogue_line.id;
      --raise notice 'lie id % assign parentRef % found if %', staging_catalogue_line.id, parentRef, (SELECT parent_ref FROM staging_catalogue WHERE id = staging_catalogue_line.id) ;
      IF catalogueRef IS NULL THEN
        -- Check if we're at a top taxonomic entry in the template/staging_catalogue line
        IF parentRef IS NULL THEN
          -- If top entry, we have not parent defined and we therefore have no other filtering criteria
          where_clause_complement_1 := ' ';
          where_clause_complement_2 := ' ';
          where_clause_complement_3 := ' ';
          where_clause_complement_3_bis := ' ';
        ELSE
          -- If a child entry, we've got to use the informations from the already matched or created parent
          where_clause_complement_1 := '  AND tax.parent_ref = ' || parentRef || ' ';
          where_clause_complement_2 := '  AND tax.parent_ref != ' || parentRef || ' ';
          -- Select the path from parent catalogue unit
          EXECUTE 'SELECT path, level_ref FROM ' || quote_ident(referenced_relation) || ' WHERE id = $1'
          INTO parent_path, parent_level
          USING parentRef;
          where_clause_complement_3 := '  AND position (' || quote_literal(parent_path) || ' IN tax.path) = 1 ';
          where_clause_complement_3_bis := '  AND (select t2.level_ref from ' || quote_ident(referenced_relation) || ' as t2 where t2.id = tax.parent_ref) > ' || parent_level || ' ';
        END IF;
        where_clause_complement_4 := '  AND left(substring(tax.name from length(trim(' ||
                                     quote_literal(staging_catalogue_line.name) || '))+1),1) IN (' ||
                                     quote_literal(' ') || ', ' || quote_literal(',') || ') ';
        where_clause_complement_5 := '  AND left(substring(' || quote_literal(staging_catalogue_line.name) ||
                                     ' from length(trim(tax.name))+1),1) IN (' ||
                                     quote_literal(' ') || ', ' || quote_literal(',') || ') ';
        -- Set the invalid where clause if asked
        IF exclude_invalid_entries = TRUE THEN
          where_clause_exclude_invalid := '  AND tax.status != ' || quote_literal('invalid') || ' ';
        END IF;
        -- Check a perfect match entry
        -- Take care here, a limit 1 has been set, we only kept the EXIT in case the limit would be accidently removed
        FOR recCatalogue IN EXECUTE 'SELECT COUNT(id) OVER () as total_count, * ' ||
                                    'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                                    'WHERE tax.level_ref = $1 ' ||
                                    '  AND tax.name_indexed = fullToIndex( $2 ) ' ||
                                    where_clause_exclude_invalid ||
                                    where_clause_complement_1 ||
                                    'LIMIT 1;'
        USING staging_catalogue_line.level_ref, staging_catalogue_line.name
        LOOP
          -- If more than one entry found, we set an error...
          IF recCatalogue.total_count > 1 THEN
            --RAISE notice E'Case 1, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
          END IF;
          EXIT;
        END LOOP;
        -- No perfect match occured with the same parent (if it applies - doesn't apply for top taxonomic entry in template)
        IF NOT FOUND THEN
          -- For this step, as it depends upon the existence of a parent, we test well we are on that case
          -- It concerns a perfect match with parents differents but with a path common
          -- That means, if only one entry exists, that they are the same but with a more detailed hierarchy in the
          -- already existing entry
          IF parentRef IS NOT NULL THEN
            FOR recCatalogue IN EXECUTE 'SELECT COUNT(id) OVER () as total_count, * ' ||
                                        'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                                        'WHERE tax.level_ref = $1 ' ||
                                        '  AND tax.name_indexed = fullToIndex( $2 ) ' ||
                                        where_clause_exclude_invalid ||
                                        where_clause_complement_2 ||
                                        where_clause_complement_3 ||
                                        where_clause_complement_3_bis ||
                                        'LIMIT 1;'
            USING staging_catalogue_line.level_ref, staging_catalogue_line.name
            LOOP
              -- If for this kind of perfect match with different parent but kind of same path start, we get multiple
              -- possibilities, then fail
              IF recCatalogue.total_count > 1 THEN
                RAISE EXCEPTION E'Case 2, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
              END IF;
              EXIT;
            END LOOP;
            -- If it gave no result, we've got to move forward and try the next option
            IF NOT FOUND THEN
              children_move_forward := TRUE;
            END IF;
          END IF;
          IF parentRef IS NULL OR children_move_forward = TRUE THEN
            -- This next option try a fuzzy match, with, if it's a child entry in the template, a verification that
            -- the parent specified in the template and the path of the potential corresponding entry in catalogue
            -- have a common path...
            --RAISE NOTICE 'FOUND 1';
            tempSQL := 'SELECT COUNT(id) OVER () as total_count, * ' ||
                       'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                       'WHERE tax.level_ref = $1 ' ||
                       '  AND tax.name_indexed LIKE fullToIndex( $2 ) || ' || quote_literal('%') ||
                       where_clause_exclude_invalid ||
                       where_clause_complement_3 ||
                       where_clause_complement_4;
            IF parentRef IS NOT NULL THEN
              tempSQL := tempSQL || where_clause_complement_1;
            END IF;
            tempSQL := tempSQL || 'LIMIT 1;';
            FOR recCatalogue IN EXECUTE tempSQL
            USING staging_catalogue_line.level_ref, staging_catalogue_line.name
            LOOP
              -- If we're on the case of a top entry in the template, we cannot afford the problem of multiple entries
              IF recCatalogue.total_count > 1 THEN
                RAISE EXCEPTION E'Case 3, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
              END IF;
              EXIT;
            END LOOP;
            -- Last chance is to try to find if the entry in DaRWIN shouldn't be completed
            -- This entry should be "alone" of its kind - check the NOT EXIST clause
            IF NOT FOUND THEN
           -- RAISE NOTICE 'FOUND 2';
              FOR recCatalogue IN EXECUTE 'SELECT COUNT(id) OVER () as total_count, * ' ||
                                          'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                                          'WHERE tax.level_ref = $1 ' ||
                                          '  AND position(tax.name_indexed IN fullToIndex( $2 )) = 1 ' ||
                                          where_clause_exclude_invalid ||
                                          '  AND NOT EXISTS (SELECT 1 ' ||
                                          '                  FROM ' || quote_ident(referenced_relation) || ' as stax ' ||
                                          '                  WHERE stax.id != tax.id ' ||
                                          '                  AND stax.level_ref = tax.level_ref ' ||
                                          '                  AND stax.path = tax.path ' ||
                                          '                  AND stax.name_indexed LIKE tax.name_indexed || ' || quote_literal('%') ||
                                          '                  LIMIT 1 ' ||
                                          '                 ) ' ||
                                          where_clause_complement_3 ||
                                          where_clause_complement_5 ||
                                          'LIMIT 1;'
              USING staging_catalogue_line.level_ref, staging_catalogue_line.name
              LOOP
                IF recCatalogue.total_count > 1 THEN
                  RAISE EXCEPTION E'Case 4, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
                ELSE
                --raise notice 'upd 4';
                  -- If only one entry is found, we can replace the name of this entry
                  EXECUTE 'UPDATE ' || quote_ident(referenced_relation) || ' ' ||
                          'SET name = ' || quote_literal(staging_catalogue_line.name) || ' ' ||
                          'WHERE id = ' || recCatalogue.id || ';';
                END IF;
                EXIT;
              END LOOP;
              IF NOT FOUND THEN
               --raise notice 'not found';
              -- raise notice 'parentRef %', parentRef;
                IF parentRef IS NOT NULL THEN
               -- raise notice 'test';
		  IF LOWER(referenced_relation) = 'taxonomy' THEN
			--ftheeten 2018 04 15
			PERFORM * FROM taxonomy WHERE (name_indexed=fulltoindex(staging_catalogue_line.name) 
						OR (fct_rmca_taxonomy_split_name_author(name, level_ref))[1]=(fct_rmca_taxonomy_split_name_author(staging_catalogue_line.name, staging_catalogue_line.level_ref))[1])
								AND
										level_ref = staging_catalogue_line.level_ref 
										AND is_reference_taxonomy =TRUE;
			IF NOT FOUND THEN
				raise notice 'insert %', staging_catalogue_line.name;
				EXECUTE 'INSERT INTO ' || quote_ident(referenced_relation) || '(id,name,level_ref,parent_ref, metadata_ref, import_ref) ' ||
		 			  'VALUES(DEFAULT,$1,$2,$3,$4,$5) ' ||
					  'RETURNING *;'
				  INTO recCatalogue
				  USING staging_catalogue_line.name,staging_catalogue_line.level_ref,parentRef, var_metadata_ref, req_import_ref;
			ELSE
				raise notice 'insert %', staging_catalogue_line.name;
				
				--compare existing hierarchy with hierarchy in staging
				--ftheeten 2018 06 05
				SELECT id, fct_rmca_sort_taxon_path_alphabetically(path||id) INTO id_existing_taxon , existing_text_hierarchy FROM taxonomy WHERE (name_indexed=fulltoindex(staging_catalogue_line.name) 
						OR (fct_rmca_taxonomy_split_name_author(name, level_ref))[1]=(fct_rmca_taxonomy_split_name_author(staging_catalogue_line.name, staging_catalogue_line.level_ref))[1])
								AND
										level_ref = staging_catalogue_line.level_ref 
										AND is_reference_taxonomy =TRUE LIMIT 1;
				SELECT  fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue_line.id) INTO staging_text_hierarchy;
				RAISE NOTICE E'Hierarchy in staging\t % (line %)', staging_text_hierarchy, staging_catalogue_line.id;
				RAISE NOTICE E'Hierarchy in Darwin \t %',existing_text_hierarchy;
				raise notice 'parent= %', parentRef;
				IF  staging_text_hierarchy != existing_text_hierarchy THEN
					RAISE EXCEPTION E'CASE 7  Could not import this file, % (level %) may already exists in DaRWIN with a different hierarchy and cannot be attached, please check  or create this % manually (line staging %, apparent parent %) \r\n Hierarchy in staging\t % \r\nHierarchy in Darwin\t %\r\n ', 

staging_catalogue_line.name,  
level_naming, 
quote_ident(referenced_relation), 
staging_catalogue_line.id, 
staging_catalogue_line.parent_ref,
staging_text_hierarchy, 
existing_text_hierarchy ;
				ELSE
					raise notice 'hierarchy exists (possibily overlapping with Paul-André code)';
					recCatalogue.id:=id_existing_taxon;
				END IF;
			END IF;	  
		     ELSE
			  EXECUTE 'INSERT INTO ' || quote_ident(referenced_relation) || '(id,name,level_ref,parent_ref) ' ||
				  'VALUES(DEFAULT,$1,$2,$3) ' ||
				  'RETURNING *;'
			  INTO recCatalogue
			  USING staging_catalogue_line.name,staging_catalogue_line.level_ref,parentRef;
			-- tell to update the staging line to set the catalogue_ref with the id found
	           END IF;
                ELSE
                  SELECT level_name INTO level_naming FROM catalogue_levels WHERE id = staging_catalogue_line.level_ref;
                  RAISE EXCEPTION 'CASE 6 Could not import this file, % (level %) does not exist in DaRWIN and cannot be attached, correct your file or create this % manually (line staging %, apparent parent %) ', staging_catalogue_line.name,  level_naming, quote_ident(referenced_relation), staging_catalogue_line.id, staging_catalogue_line.parent_ref;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
        -- update the staging line to set the catalogue_ref with the id found
        -- update the staging children lines
        IF recCatalogue.id is NULL then
		RAISe exception 'Problem for % (line %)', staging_catalogue_line.name, recCatalogue.id ;
	end if;
        WITH staging_catalogue_updated(updated_id/*, catalogue_ref_updated*/) AS (
          UPDATE staging_catalogue as sc
          SET catalogue_ref = recCatalogue.id
          WHERE sc.import_ref = staging_catalogue_line.import_ref
                AND sc.name = staging_catalogue_line.name
                AND sc.level_ref = staging_catalogue_line.level_ref
          RETURNING id
        )
        UPDATE staging_catalogue as msc
        SET parent_ref = recCatalogue.id,
          parent_updated = TRUE
        WHERE msc.import_ref = staging_catalogue_line.import_ref
              AND msc.parent_ref IN (
          SELECT updated_id FROM staging_catalogue_updated
        )
              AND parent_updated = FALSE;
      END IF;
      children_move_forward := FALSE;
    END LOOP;
    RETURN TRUE;
    /*EXCEPTION WHEN OTHERS THEN
    IF SQLERRM = 'This record does not follow the level hierarchy' THEN
      SELECT level_name INTO level_naming FROM catalogue_levels WHERE id = staging_catalogue_line.level_ref;
      RAISE EXCEPTION E'Could not import this file, % (level %) does not follow the accepted level hierarchy in DaRWIN an cannot be attached nor created.\nPlease correct your file.\nStaging Catalogue Line: %', staging_catalogue_line.name,  level_naming, staging_catalogue_line.id;
      
    ELSE
      RAISE EXCEPTION 'exception %', SQLERRM;
    END IF;*/
  END;
  $_$;


ALTER FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_rmca_non_taxo(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 816 (class 1255 OID 18778)
-- Name: fct_informative_reset_last_flag(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_informative_reset_last_flag() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE informative_workflow
    SET is_last = true
    WHERE referenced_relation = OLD.referenced_relation
      AND record_id = OLD.record_id
      AND id = (select id from informative_workflow
        WHERE referenced_relation = OLD.referenced_relation AND record_id = OLD.record_id ORDER BY modification_date_time desc LIMIT 1)
    ;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_informative_reset_last_flag() OWNER TO darwin2;

--
-- TOC entry 817 (class 1255 OID 18779)
-- Name: fct_look_for_institution(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_look_for_institution(fullname text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_record integer :=0;
  result_nbr integer;

BEGIN
    result_nbr := 0;
    FOR ref_record IN SELECT id from people p
      WHERE is_physical = false  AND
      ( formated_name_indexed like fulltoindex(fullname) || '%' OR fulltoindex(additional_names) =  fulltoindex(fullname) )
      LIMIT 2
    LOOP
      result_nbr := result_nbr +1;
    END LOOP;

    IF result_nbr = 1 THEN -- It's Ok!
      return ref_record;
    END IF;

    IF result_nbr >= 2 THEN
      return -1 ;-- To Much
      --continue;
    END IF;
  RETURN 0;
END;
$$;


ALTER FUNCTION darwin2.fct_look_for_institution(fullname text) OWNER TO darwin2;

--
-- TOC entry 818 (class 1255 OID 18780)
-- Name: fct_look_for_people(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_look_for_people(fullname text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_record integer :=0;
  result_nbr integer;
  searched_name text;
BEGIN
    result_nbr := 0;
     --modif ftheeten 20140630
     --modif ftheeten 20160226
     searched_name := fulltoindex(fullname,true);--|| '%'  ;
    --searched_name := fulltoindex(fullname);--|| '%'  ;
    --searched_name := fulltoindex(fullname)|| '%'  ;
    FOR ref_record IN SELECT id from people p
      WHERE
        formated_name_indexed like searched_name
        OR  name_formated_indexed like searched_name LIMIT 2
    LOOP
      result_nbr := result_nbr +1;
    END LOOP;

    IF result_nbr = 1 THEN -- It's Ok!
      return ref_record;
    END IF;

    IF result_nbr >= 2 THEN
      return -1 ;-- To Much
      --continue;
    END IF;
  RETURN 0;
END;
$$;


ALTER FUNCTION darwin2.fct_look_for_people(fullname text) OWNER TO darwin2;

--
-- TOC entry 819 (class 1255 OID 18781)
-- Name: fct_mask_date(timestamp without time zone, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_mask_date(date_fld timestamp without time zone, mask_fld integer) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$

  SELECT
CASE WHEN ($2 & 32)!=0 THEN date_part('year',$1)::text ELSE 'xxxx' END || '-' ||
CASE WHEN ($2 & 16)!=0 THEN date_part('month',$1)::text ELSE 'xx' END || '-' ||
CASE WHEN ($2 & 8)!=0 THEN date_part('day',$1)::text ELSE 'xx' END;
$_$;


ALTER FUNCTION darwin2.fct_mask_date(date_fld timestamp without time zone, mask_fld integer) OWNER TO darwin2;

--
-- TOC entry 820 (class 1255 OID 18782)
-- Name: fct_mask_date_dmy(timestamp without time zone, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_mask_date_dmy(date_fld timestamp without time zone, mask_fld integer) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$

  SELECT
  CASE WHEN ($2 & 8)!=0 THEN date_part('day',$1)::text ELSE 'xx' END|| '-'||
CASE WHEN ($2 & 16)!=0 THEN date_part('month',$1)::text ELSE 'xx' END || '-' ||
CASE WHEN ($2 & 32)!=0 THEN date_part('year',$1)::text ELSE 'xxxx'
END;
$_$;


ALTER FUNCTION darwin2.fct_mask_date_dmy(date_fld timestamp without time zone, mask_fld integer) OWNER TO darwin2;

--
-- TOC entry 1636 (class 1255 OID 1416195)
-- Name: fct_mask_date_ymd(timestamp without time zone, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_mask_date_ymd(date_fld timestamp without time zone, mask_fld integer) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$

  SELECT
  CASE WHEN ($2 & 32)!=0 THEN date_part('year',$1)::text ELSE 'xxxx' END ||'-'||
  CASE WHEN ($2 & 16)!=0 THEN lpad(date_part('month',$1)::text, 2,'0') ELSE 'xx' END  ||'-'||
   CASE WHEN ($2 & 8)!=0 THEN lpad(date_part('day',$1)::text, 2,'0') ELSE 'xx'-- END
  /*
  CASE WHEN ($2 & 8)!=0 THEN date_part('day',$1)::text ELSE 'xx' END|| '-'||
CASE WHEN ($2 & 16)!=0 THEN date_part('month',$1)::text ELSE 'xx' END || '-' ||
CASE WHEN ($2 & 32)!=0 THEN date_part('year',$1)::text ELSE 'xxxx'*/
END;
$_$;


ALTER FUNCTION darwin2.fct_mask_date_ymd(date_fld timestamp without time zone, mask_fld integer) OWNER TO darwin2;

--
-- TOC entry 1638 (class 1255 OID 1416228)
-- Name: fct_mask_date_ymd_gbif(timestamp without time zone, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_mask_date_ymd_gbif(date_fld timestamp without time zone, mask_fld integer) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$

  SELECT
 replace( CASE WHEN ($2 & 32)!=0 THEN date_part('year',$1)::text ELSE 'xxxx' END ||'-'||
  CASE WHEN ($2 & 16)!=0 THEN lpad(date_part('month',$1)::text, 2,'0') ELSE 'xx' END  ||'-'||
   CASE WHEN ($2 & 8)!=0 THEN lpad(date_part('day',$1)::text, 2,'0') ELSE 'xx'-- END
  /*
  CASE WHEN ($2 & 8)!=0 THEN date_part('day',$1)::text ELSE 'xx' END|| '-'||
CASE WHEN ($2 & 16)!=0 THEN date_part('month',$1)::text ELSE 'xx' END || '-' ||
CASE WHEN ($2 & 32)!=0 THEN date_part('year',$1)::text ELSE 'xxxx'*/
END,'-xx','');
$_$;


ALTER FUNCTION darwin2.fct_mask_date_ymd_gbif(date_fld timestamp without time zone, mask_fld integer) OWNER TO darwin2;

--
-- TOC entry 821 (class 1255 OID 18783)
-- Name: fct_nbr_in_relation(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_nbr_in_relation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  nbr integer = 0 ;
BEGIN
  SELECT count(record_id_2) INTO nbr FROM catalogue_relationships WHERE
      relationship_type = NEW.relationship_type
      AND record_id_1 = NEW.record_id_1
      AND referenced_relation = NEW.referenced_relation;

  IF NEW.relationship_type = 'current_name' THEN
    IF TG_OP = 'INSERT' THEN
      IF nbr > 0 THEN
	RAISE EXCEPTION 'Maximum number of renamed item reach';
      END IF;
    ELSE
      IF nbr > 1 THEN
	RAISE EXCEPTION 'Maximum number of renamed item reach';
      END IF;
    END IF;
  ELSEIF NEW.relationship_type = 'recombined from' THEN
    IF TG_OP = 'INSERT' THEN
      IF nbr > 1 THEN
	RAISE EXCEPTION 'Maximum number of recombined item reach';
      END IF;
    ELSE
      IF nbr > 2 THEN
	RAISE EXCEPTION 'Maximum number of recombined item reach';
      END IF;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_nbr_in_relation() OWNER TO darwin2;

--
-- TOC entry 822 (class 1255 OID 18784)
-- Name: fct_nbr_in_synonym(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_nbr_in_synonym() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  nbr integer = 0 ;
BEGIN

  SELECT count(id) INTO nbr FROM classification_synonymies WHERE
      referenced_relation = NEW.referenced_relation
      AND record_id = NEW.record_id
      AND group_name = NEW.group_name;

  IF TG_OP = 'INSERT' THEN
    IF nbr > 1 THEN
      RAISE EXCEPTION 'You can ''t set this synonym twice!';
    END IF;
  ELSE
--     RAISE info 'nbr %', nbr;
    IF nbr > 2 THEN
      RAISE EXCEPTION 'You can ''t set this synonym twice!';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_nbr_in_synonym() OWNER TO darwin2;

--
-- TOC entry 823 (class 1255 OID 18785)
-- Name: fct_rcma_sort_letter_before_numbers(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rcma_sort_letter_before_numbers(character varying) RETURNS character varying
    LANGUAGE sql
    AS $_$
  SELECT regexp_replace($1,'^([0-9])','zzz \1')  COLLATE "C"
$_$;


ALTER FUNCTION darwin2.fct_rcma_sort_letter_before_numbers(character varying) OWNER TO darwin2;

--
-- TOC entry 824 (class 1255 OID 18786)
-- Name: fct_reinit_sequences_synonyms(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_reinit_sequences_synonyms() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_exists integer;
BEGIN
	  IF NEW.record_id != -1 THEN --ftheeten 2019 01 18
		  PERFORM SETVAL('classification_synonymies_group_id_seq', (SELECT MAX(group_id)+1 FROM classification_synonymies));
	  END IF;	
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_reinit_sequences_synonyms() OWNER TO darwin2;

--
-- TOC entry 825 (class 1255 OID 18787)
-- Name: fct_remove_array_elem(anyarray, anyarray); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_array_elem(in_array anyarray, elem anyarray, OUT out_array anyarray) RETURNS anyarray
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	SELECT array(select s FROM fct_explode_array (in_array)  as s WHERE NOT elem @> ARRAY[s]) INTO out_array;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_array_elem(in_array anyarray, elem anyarray, OUT out_array anyarray) OWNER TO darwin2;

--
-- TOC entry 826 (class 1255 OID 18788)
-- Name: fct_remove_empty_string_array_elem(anyarray); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_empty_string_array_elem(in_array anyarray, OUT out_array anyarray) RETURNS anyarray
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	SELECT array(select s FROM fct_explode_array (in_array)  as s WHERE  s !='') INTO out_array;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_empty_string_array_elem(in_array anyarray, OUT out_array anyarray) OWNER TO darwin2;

--
-- TOC entry 827 (class 1255 OID 18789)
-- Name: fct_remove_last_flag(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_last_flag() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE informative_workflow
    SET is_last = false
    WHERE referenced_relation = NEW.referenced_relation
      AND record_id = NEW.record_id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_last_flag() OWNER TO darwin2;

--
-- TOC entry 828 (class 1255 OID 18790)
-- Name: fct_remove_last_flag_loan(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_last_flag_loan() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE loan_status
    SET is_last = false
    WHERE loan_ref = NEW.loan_ref;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_last_flag_loan() OWNER TO darwin2;

--
-- TOC entry 829 (class 1255 OID 18791)
-- Name: fct_remove_null_array_elem(anyarray); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_null_array_elem(in_array anyarray, OUT out_array anyarray) RETURNS anyarray
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	SELECT array(select s FROM fct_explode_array (in_array)  as s WHERE  s is not null) INTO out_array;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_null_array_elem(in_array anyarray, OUT out_array anyarray) OWNER TO darwin2;

--
-- TOC entry 830 (class 1255 OID 18792)
-- Name: fct_rmca_abbreviate_names(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_abbreviate_names(given_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 
	returned varchar;
	tmp varchar; --varchar[];
	i integer;
	i2 integer;
	begin_word boolean;
	delimiter_word boolean;
BEGIN
	IF TRIM(COALESCE(given_name,''))='' THEN
		return '';
	END IF;
	
	given_name:=given_name||'.';
	returned:=given_name;
	
	i2:=1;
	begin_word:=true;
	delimiter_word:=false;
	
	IF CHAR_LENGTH(TRIM(given_name)) >0 THEN
		returned:='';
	END IF;
	given_name:=regexp_replace(given_name, '\W?(\s)(\W)(\s)','\2');
	FOR i IN 1..CHAR_LENGTH(TRIM(given_name)) 
	LOOP
		tmp:=SUBSTRING(given_name FROM i FOR 1);
		
		IF begin_word  AND  tmp ~ '\w'  THEN
			returned:=returned||tmp;
			begin_word:=FALSE;
			delimiter_word:=FALSE;
		END IF;
		
		IF tmp ~ '\w' = FALSE AND delimiter_word = FALSE THEN
			IF tmp=' ' OR tmp='.' THEN 
				tmp:='. ';
			END IF;
			
			returned:=returned||tmp;
			delimiter_word:=TRUE;
			begin_word:=TRUE;
		END IF;
		
	END LOOP;
	RETURN TRIM(returned);
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_abbreviate_names(given_name character varying) OWNER TO darwin2;

--
-- TOC entry 831 (class 1255 OID 18793)
-- Name: fct_rmca_add_in_people(boolean, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_add_in_people(ref_isphysical boolean, ref_name text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  query_str varchar;
  query_str2 varchar;
  ref_name2 varchar;
  idres integer;
  pos integer;

BEGIN
  IF ref_name is NULL THEN
    RETURN 0;
  END IF;
  --ref_name = "Musée National d'Histoire Naturelle Paris§§§4044";
  pos = position('§§§' in ref_name);
  IF pos > 0 THEN
	ref_name2 = substring(ref_name from 1 for pos-1);
  ELSE
	ref_name2 = ref_name;
  END IF;
  
  query_str := 
    
    ' INSERT INTO people (is_physical, formated_name, family_name)
    (
      SELECT ' || quote_literal(ref_isphysical) || ' , ' || quote_literal(ref_name2) || ' , ' || quote_literal(ref_name2)|| ' WHERE NOT EXISTS
      (SELECT id FROM people WHERE
        is_physical = ' || quote_literal(ref_isphysical) || '
        AND formated_name = ' || quote_literal(ref_name2) || '
        AND family_name = ' || quote_literal(ref_name2) || ')
    );'

    ;
    RAISE NOTICE 'query_str=(%)', query_str;
    EXECUTE query_str;

    idres := (SELECT id FROM people WHERE formated_name = ref_name2);
    RETURN idres;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_add_in_people(ref_isphysical boolean, ref_name text) OWNER TO darwin2;

--
-- TOC entry 832 (class 1255 OID 18794)
-- Name: fct_rmca_add_in_people_address(integer, text, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_add_in_people_address(ref_user integer, address_ref text, zip_ref text, city_ref text, country_ref text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  query_str varchar;

BEGIN
  IF ref_user is NULL THEN
    RETURN true;
  END IF;
    query_str := 
    
    ' INSERT INTO people_addresses (person_user_ref, entry, zip_code, locality, country)
    (
      SELECT ' || quote_literal(ref_user) || ' , ' || quote_literal(address_ref) || ' , ' || quote_literal(zip_ref) || ' , ' || quote_literal(city_ref) || ' , ' || quote_literal(country_ref)|| ' WHERE NOT EXISTS
      (SELECT id FROM people_addresses WHERE
        person_user_ref = ' || quote_literal(ref_user) || '
        AND entry = ' || quote_literal(address_ref) || ')
    );'

    ;
    EXECUTE query_str;

    RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_add_in_people_address(ref_user integer, address_ref text, zip_ref text, city_ref text, country_ref text) OWNER TO darwin2;

--
-- TOC entry 833 (class 1255 OID 18795)
-- Name: fct_rmca_all_occurences_of_parent_in_staging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_all_occurences_of_parent_in_staging(req_import_ref integer) RETURNS integer[]
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	check_duplicates_hierarchies RECORD;
	returned  boolean;
BEGIN 

	returned:=TRUE;
	PERFORM * FROM  fct_rmca_compare_taxonomy_staging_darwin(req_import_ref);
		IF FOUND THEN
			
			FOR check_duplicates_hierarchies IN SELECT * FROM  fct_rmca_compare_taxonomy_staging_darwin(req_import_ref)
			LOOP 			
				UPDATE staging_catalogue SET hierarchical_conflict = TRUE WHERE import_ref=req_import_ref AND staging_catalogue.level_ref=check_duplicates_hierarchies.level_ref AND staging_catalogue.name=check_duplicates_hierarchies.name;
			END LOOP;
			UPDATE imports SET state='error' , errors_in_import= 'taxonomic_conflict' ,working=false WHERE id=req_import_ref;
			returned:=FALSE;
		END IF;
		RETURN returned;
END;


 $$;


ALTER FUNCTION darwin2.fct_rmca_all_occurences_of_parent_in_staging(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 834 (class 1255 OID 18796)
-- Name: fct_rmca_check_people_before_delete(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_check_people_before_delete() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN            
        IF EXISTS (SELECT 1 FROM catalogue_people WHERE people_ref=OLD.ID)
OR
	EXISTS (SELECT 1 FROM specimens WHERE OLD.ID = ANY(spec_ident_ids) OR OLD.ID =ANY(spec_coll_ids) OR OLD.ID = ANY (spec_don_sel_ids))


         THEN
            RAISE EXCEPTION 'cannot delete this people, still related to record';
         ELSE 
		RETURN OLD;
        END IF;

END;
$$;


ALTER FUNCTION darwin2.fct_rmca_check_people_before_delete() OWNER TO darwin2;

--
-- TOC entry 835 (class 1255 OID 18797)
-- Name: fct_rmca_chk_is_already_reference_taxo(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_chk_is_already_reference_taxo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	tmp_taxon varchar;
	check_is_reference boolean;
BEGIN
--ftheeten 2017 07 03
 SELECT is_reference_taxonomy INTO check_is_reference FROM taxonomy_metadata WHERE id=NEW.metadata_ref LIMIT 1;
  IF check_is_reference=TRUE THEN
	IF (TG_OP = 'INSERT') THEN
	   PERFORM * FROM taxonomy 
	   LEFT JOIN taxonomy_metadata
	   ON taxonomy.metadata_ref=taxonomy_metadata.id

	   WHERE name_indexed=fulltoindex(NEW.name) AND level_ref=NEW.level_ref  AND taxonomy_metadata.is_reference_taxonomy=true;
	    IF FOUND THEN
		RAISE EXCEPTION 'This taxon can be only present once in the reference taxonomy, check %', NEW.name;
	    END IF;
	ELSEIF (TG_OP = 'UPDATE') THEN
		SELECT name INTO tmp_taxon FROM taxonomy
		LEFT JOIN taxonomy_metadata
		ON taxonomy.metadata_ref=taxonomy_metadata.id
		 WHERE name_indexed=fulltoindex(NEW.name) AND level_ref=NEW.level_ref  AND taxonomy_metadata.is_reference_taxonomy=true AND taxonomy.id <>NEW.id ;
	    IF FOUND THEN
		RAISE EXCEPTION 'This taxon can be only present once in the reference taxonomy, check %', tmp_taxon;
	    END IF;
	END IF;
   --ELSE
   --      IF LENGTH(TRIM(COALESCE(NEW.source,'')))=0 THEN
--		RAISE EXCEPTION 'Please specify a source for alternate taxonomies';
   --      END IF;	    
   END IF;	    
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_chk_is_already_reference_taxo() OWNER TO darwin2;

--
-- TOC entry 836 (class 1255 OID 18798)
-- Name: fct_rmca_chk_only_one_reference_taxo(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_chk_only_one_reference_taxo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN
  
	IF (SELECT COUNT(*) FROM taxonomy_metadata where is_reference_taxonomy=TRUE)>=1 THEN
		RAISE EXCEPTION 'A reference taxonomy already exists in this database (only one is supported)';
	END IF;
   
 	    
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_chk_only_one_reference_taxo() OWNER TO darwin2;

--
-- TOC entry 837 (class 1255 OID 18799)
-- Name: fct_rmca_chk_uniqueness_reference_taxo(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_chk_uniqueness_reference_taxo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	cursor_tmp RECORD;
	duplicates  varchar[];
	test_refs int[];
	i INTEGER;	
BEGIN
--ftheeten 2017 07 03

		   IF new.is_reference_taxonomy =TRUE THEN
				IF (SELECT COUNT(*) FROM taxonomy_metadata where is_reference_taxonomy=TRUE AND id !=NEW.id)>=1 THEN
					RAISE EXCEPTION 'A reference taxonomy already exists in this database (only one is supported)';
				END IF;
				IF new.is_reference_taxonomy =TRUE AND TG_OP = 'UPDATE' THEN
			i:=0;
			test_refs:=test_refs||new.id;
			FOR  cursor_tmp IN 
				SELECT count(*), 
					array_to_string(array_agg(name), '; '::varchar) as name
					FROM taxonomy WHERE taxonomy.metadata_Ref=NEW.ID 
					GROUP BY name_indexed , level_ref HAVING count(*) > 1
			LOOP 
				duplicates:=duplicates||cursor_tmp.name;
				i:=i+1;

			END LOOP;
	
	
			IF i>0 THEN
				RAISE EXCEPTION 'Some taxa are present several times in the reference taxonomy, check %', array_to_string(duplicates,',');
			END IF;
		END IF;
   END IF;

	    
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_chk_uniqueness_reference_taxo() OWNER TO darwin2;

--
-- TOC entry 1524 (class 1255 OID 18800)
-- Name: fct_rmca_collection_check_code_unicity(integer, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_collection_check_code_unicity(col_id integer, code_indexed character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned boolean;
	row_col record;
	indexed_form varchar;

BEGIN
	returned :=false;
	indexed_form= fulltoindex(code_indexed);
	RAISE NOTICE 'call check % % ' , col_id, code_indexed;
	PERFORM codes.id FROM specimens LEFT JOIN codes ON specimens.id=codes.record_id AND referenced_relation='specimens' and code_category='main' WHERE codes.id IS NOT NULL 
			and specimens.collection_ref=col_id AND full_code_indexed=indexed_form ;
			IF FOUND THEN
				RAISE NOTICE 'Duplicate found';
				RETURN	true;
			END IF;
	FOR row_col IN
		SELECT a.*,code_auto_increment, code_ai_inherit , code_last_value ,

		strpos(a.path , '/'||parent||'/')
		FROM

		(SELECT unnest(string_to_array(path||'/'||col_id||'/','/')) as parent, id, path  from collections)  a
		LEFT JOIN collections
		ON a.parent=collections.id::varchar
		WHERE parent is not null and length(parent)>0
		AND a.id=col_id
		ORDER BY strpos(a.path , '/'||parent||'/') DESC
		LOOP
			RAISE notice '%', row_col.parent;
			RAISE notice '%', indexed_form;
			PERFORM codes.id FROM specimens LEFT JOIN codes ON specimens.id=codes.record_id AND referenced_relation='specimens' and code_category='main' WHERE codes.id IS NOT NULL 
			and specimens.collection_ref::varchar=row_col.parent AND full_code_indexed=indexed_form ;
			IF FOUND THEN
				RAISE NOTICE 'Duplicate found';
				RETURN	true;
			END IF;
			--UPDATE collections SET code_last_value= new_code_value WHERE id=row_col.parent;
			--returned :=TRUE;
			IF  row_col.code_ai_inherit IS NOT TRUE THEN
				RAISE NOTICE 'exit';
				EXIT;
			END IF; 
			
		END LOOP;
		
	RETURN returned;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_collection_check_code_unicity(col_id integer, code_indexed character varying) OWNER TO darwin2;

--
-- TOC entry 1657 (class 1255 OID 1868041)
-- Name: fct_rmca_collection_full_path_in_specimens(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_collection_full_path_in_specimens() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
                collection_text_path varchar;
BEGIN

  SELECT name_full_path INTO  collection_text_path FROM v_collections_full_path_recursive WHERE  v_collections_full_path_recursive.id=NEW.collection_ref;

NEW.collection_name_full_path=collection_text_path;             
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_collection_full_path_in_specimens() OWNER TO darwin2;

--
-- TOC entry 1525 (class 1255 OID 18801)
-- Name: fct_rmca_collection_get_autoincrement_hierarchy(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_collection_get_autoincrement_hierarchy(col_id integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned BIGINT;
	row_col record;

BEGIN
	returned :=0;
	FOR row_col IN
		SELECT a.*,code_auto_increment, code_ai_inherit , code_last_value ,

		strpos(a.path , '/'||parent||'/')
		FROM

		(SELECT unnest(string_to_array(path||'/'||id::varchar||'/','/')) as parent, id, path  from collections)  a
		LEFT JOIN collections
		ON a.parent=collections.id::varchar
		WHERE parent is not null and length(parent)>0
		AND a.id=col_id
		ORDER BY strpos(a.path , '/'||parent||'/') DESC
		LOOP
			RAISE NOTICE '%', row_col.parent;
			IF  row_col.code_last_value>returned THEN
				
				returned :=row_col.code_last_value;
			END IF;
			IF  row_col.code_ai_inherit IS NOT TRUE THEN
				EXIT;
			END IF; 
			
		END LOOP;
		
	RETURN returned;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_collection_get_autoincrement_hierarchy(col_id integer) OWNER TO darwin2;

--
-- TOC entry 1650 (class 1255 OID 1483943)
-- Name: fct_rmca_collection_move_taxa_to_subcollection(integer, integer, integer, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_collection_move_taxa_to_subcollection(id_source_collection integer, id_target_collection integer, id_taxon integer, collection_prefix character varying DEFAULT ''::character varying, collection_prefix_separator character varying DEFAULT ''::character varying, collection_suffix character varying DEFAULT ''::character varying, collection_suffix_separator character varying DEFAULT ''::character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN

with a as
(
	select * from specimens where collection_ref=2
	and taxon_path like '%/'||id_taxon::varchar||'/%' or taxon_ref=id_taxon and collection_ref=id_source_collection)

	update specimens set collection_ref=id_target_collection from a where specimens.id=a.id ;
	
	IF collection_prefix<>'' OR collection_prefix_separator<>'' 
	OR collection_suffix<>'' OR collection_suffix_separator<>''
	THEN
		
			with a as
			(
			select codes.* from codes inner join specimens 
				on codes.record_id=specimens.id and 
				code_category='main' and referenced_relation='specimens'
				where collection_ref=id_target_collection)
			update codes
			set 
			code_prefix=COALESCE(NULLIF(collection_prefix,''),codes.code_prefix),
			code_prefix_separator=COALESCE(NULLIF(collection_prefix_separator,''),codes.code_prefix_separator),
			code_suffix=COALESCE(NULLIF(collection_suffix,''),codes.code_suffix),
			code_suffix_separator=COALESCE(NULLIF(collection_suffix_separator,''),codes.code_suffix_separator)
			from a where codes.id=a.id;
	END IF;

	return TRUE;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_collection_move_taxa_to_subcollection(id_source_collection integer, id_target_collection integer, id_taxon integer, collection_prefix character varying, collection_prefix_separator character varying, collection_suffix character varying, collection_suffix_separator character varying) OWNER TO darwin2;

--
-- TOC entry 715 (class 1255 OID 18802)
-- Name: fct_rmca_collection_update_autoincrements_hierarchy(integer, bigint); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_collection_update_autoincrements_hierarchy(col_id integer, new_code_value bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned boolean;
	row_col record;

BEGIN
	returned :=false;
	FOR row_col IN
		SELECT a.*,code_auto_increment, code_ai_inherit , code_last_value ,

		strpos(a.path , '/'||parent||'/')
		FROM

		(SELECT unnest(string_to_array(path||'/'||col_id||'/','/')) as parent, id, path  from collections)  a
		LEFT JOIN collections
		ON a.parent=collections.id::varchar
		WHERE parent is not null and length(parent)>0
		AND a.id=col_id
		ORDER BY strpos(a.path , '/'||parent||'/') DESC
		LOOP
			
			UPDATE collections SET code_last_value= new_code_value WHERE id::varchar=row_col.parent;
			returned :=TRUE;
			IF  row_col.code_ai_inherit IS NOT TRUE THEN
				EXIT;
			END IF; 
			
		END LOOP;
		
	RETURN returned;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_collection_update_autoincrements_hierarchy(col_id integer, new_code_value bigint) OWNER TO darwin2;

--
-- TOC entry 1643 (class 1255 OID 1418916)
-- Name: fct_rmca_collections_change_prefix(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_collections_change_prefix(nb_col integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
with a as (
select * from specimens where collection_ref=nb_col
),
b as
(

select codes.* from codes inner join a on record_id=a.id and 
	referenced_relation='specimens' and code_category='main'),
	c as (select * from collections where id=nb_col)
	UPDATE codes 
	SET code_prefix=(select code_prefix FROM c LIMIT 1 ),
	code_prefix_separator=(select code_prefix_separator FROM c LIMIT 1 ),
	 code_suffix=(select code_suffix FROM c LIMIT 1 ),
	 code_suffix_separator=(select code_suffix_separator FROM c LIMIT 1 )
	FROM b WHERE codes.id=b.id;
	
	return true;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_collections_change_prefix(nb_col integer) OWNER TO darwin2;

--
-- TOC entry 1531 (class 1255 OID 18803)
-- Name: fct_rmca_compare_taxonomy_staging_darwin(integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin(req_import_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS TABLE(name character varying, staging_catalogue_hierarchy character varying, darwin_hierarchy character varying, level_name character varying, level_ref integer)
    LANGUAGE sql
    AS $_$ SELECT distinct staging_catalogue.name, fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue.id,$2, $3)

as staging_catalogue_hierarchy 

, 
fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar,  fct_rmca_sort_taxon_path_get_max_level_in_staging(staging_catalogue.id) ) as darwin_hierarchy, level_name, 
staging_catalogue.level_ref
 from staging_catalogue

LEFT JOIN taxonomy ON fulltoindex(name_indexed, false)= fulltoindex(staging_catalogue.name, false) and staging_catalogue.level_ref=taxonomy.level_ref
LEFT JOIN catalogue_levels
ON staging_catalogue.level_ref=catalogue_levels.id
 WHERE staging_catalogue.import_ref=$1
 AND taxonomy.is_reference_taxonomy=TRUE
 AND path !='/' and fct_rmca_sort_taxon_path_alphabetically(path,  fct_rmca_sort_taxon_path_get_max_level_in_staging(staging_catalogue.parent_Ref) ) != fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue.parent_Ref) order by staging_catalogue.level_ref, staging_catalogue.name;
 $_$;


ALTER FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin(req_import_ref integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1532 (class 1255 OID 18804)
-- Name: fct_rmca_compare_taxonomy_staging_darwin_non_reference(integer, integer, boolean, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_non_reference(req_import_ref integer, var_metadata_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false, match_invalid_units boolean DEFAULT true) RETURNS TABLE(id integer, name character varying, staging_catalogue_hierarchy character varying, darwin_hierarchy character varying, level_name character varying, level_ref integer, taxonomic_id integer, msg character varying)
    LANGUAGE plpgsql
    AS $$ 
BEGIN
IF match_invalid_units IS FALSE THEN
	RETURN QUERY 
		SELECT * 
		, 
			CASE 
			WHEN 
			taxonomy_id is NULL THEN
			'taxon_to_be_created'::varchar
			when
			POSITION(LOWER(subquery.staging_catalogue_hierarchy) IN LOWER(subquery.darwin_hierarchy)) >0 THEN
			'taxonomic_hierarchy_already_exists'::varchar
			WHEN 
			POSITION(LOWER(subquery.staging_catalogue_hierarchy) IN LOWER(subquery.darwin_hierarchy)) =0 THEN
			'taxonomic_conflict'::varchar

			END


		FROM (SELECT 
		a.base_id as id, 
		a.base_name as name, 
		a.path as staging_catalogue_hierarchy, 
		fct_rmca_sort_taxon_path_alphabetically(b.path||b.id::varchar

			,
			1 , true, false
			)  darwin_hierarchy , 
		c.level_name, 
		c.id level_ref , 
		b.id as taxonomy_id 

		 FROM fct_rmca_taxonomy_get_staging_hierarchy_recursive(req_import_ref) a
		LEFT JOIN taxonomy b ON fulltoindex(name_indexed, false)= fulltoindex(a.base_name, false) and a.base_level_ref=b.level_ref
			 AND b.metadata_ref=var_metadata_ref
			 AND b.status !='invalid'

		LEFT JOIN catalogue_levels c
			ON a.base_level_ref=c.id
			) subquery
		;

ELSE
	RETURN QUERY 
		SELECT * 
		, 
			CASE 
			WHEN 
			taxonomy_id is NULL THEN
			'taxon_to_be_created'::varchar
			when
			POSITION(LOWER(subquery.staging_catalogue_hierarchy) IN LOWER(subquery.darwin_hierarchy)) >0 THEN
			'taxonomic_hierarchy_already_exists'::varchar
			WHEN 
			POSITION(LOWER(subquery.staging_catalogue_hierarchy) IN LOWER(subquery.darwin_hierarchy)) =0 THEN
			'taxonomic_conflict'::varchar

			END


		FROM (SELECT 
		a.base_id as id, 
		a.base_name as name, 
		a.path as staging_catalogue_hierarchy, 
		fct_rmca_sort_taxon_path_alphabetically(b.path||b.id::varchar

			,
			1 , true, false
			)  darwin_hierarchy , 
		c.level_name, 
		c.id level_ref , 
		b.id as taxonomy_id 

		 FROM fct_rmca_taxonomy_get_staging_hierarchy_recursive(req_import_ref) a
		LEFT JOIN taxonomy b ON fulltoindex(name_indexed, false)= fulltoindex(a.base_name, false) and a.base_level_ref=b.level_ref
			 AND b.metadata_ref=var_metadata_ref
		LEFT JOIN catalogue_levels c
			ON a.base_level_ref=c.id
			) subquery
		;

 END IF;
 END 
 $$;


ALTER FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_non_reference(req_import_ref integer, var_metadata_ref integer, with_rank boolean, is_indexed boolean, match_invalid_units boolean) OWNER TO darwin2;

--
-- TOC entry 1538 (class 1255 OID 18805)
-- Name: fct_rmca_compare_taxonomy_staging_darwin_non_reference_bck(integer, integer, boolean, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_non_reference_bck(req_import_ref integer, var_metadata_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false, match_invalid_units boolean DEFAULT true) RETURNS TABLE(id integer, name character varying, staging_catalogue_hierarchy character varying, darwin_hierarchy character varying, level_name character varying, level_ref integer, taxonomic_id integer, msg character varying)
    LANGUAGE plpgsql
    AS $_$ 
BEGIN
IF match_invalid_units IS FALSE THEN
	RETURN QUERY SELECT a.*, 
	CASE 
	WHEN 
	taxonomy_id is NULL THEN
	'taxon_to_be_created'::varchar
	when
	staging_catalogue_hierarchy_db=darwin_hierarchy_db THEN
	'taxonomic_hierarchy_already_exists'::varchar
	WHEN 
	staging_catalogue_hierarchy_db <> darwin_hierarchy_db THEN
	'taxonomic_conflict'::varchar

	END

	 FROM (SELECT distinct 

	staging_catalogue.id, staging_catalogue.name, fct_rmca_sort_taxon_path_alphabetically_staging_merge(staging_catalogue.id,req_import_ref, $3, $4)

	as staging_catalogue_hierarchy_db 

	, 
	fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

	,
	1 , true, false
	) as darwin_hierarchy_db, catalogue_levels.level_name,

	staging_catalogue.level_ref,
	taxonomy.id  as taxonomy_id
	 from staging_catalogue

	LEFT JOIN taxonomy ON fulltoindex(name_indexed, false)= fulltoindex(staging_catalogue.name, false) and staging_catalogue.level_ref=taxonomy.level_ref
	 AND taxonomy.metadata_ref=$2
	LEFT JOIN catalogue_levels
	ON staging_catalogue.level_ref=catalogue_levels.id
	 WHERE staging_catalogue.import_ref=$1 AND taxonomy.status !='invalid'

	 ORDER BY staging_catalogue.level_ref, staging_catalogue.name) a ;

ELSE

	RETURN QUERY SELECT a.*, 
	CASE 
	WHEN 
	taxonomy_id is NULL THEN
	'taxon_to_be_created'::varchar
	when
	staging_catalogue_hierarchy_db=darwin_hierarchy_db THEN
	'taxonomic_hierarchy_already_exists'::varchar
	WHEN 
	staging_catalogue_hierarchy_db <> darwin_hierarchy_db THEN
	'taxonomic_conflict'::varchar

	END

	 FROM (SELECT distinct 

		staging_catalogue.id, staging_catalogue.name, 
		fct_rmca_sort_taxon_path_alphabetically_staging_merge(staging_catalogue.id,req_import_ref, $3, $4)

		as staging_catalogue_hierarchy_db 

		, 
		fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

		,
		1 , true, false
		) as darwin_hierarchy_db,  catalogue_levels.level_name,

		staging_catalogue.level_ref,
		taxonomy.id  as taxonomy_id
		 from staging_catalogue
		LEFT JOIN taxonomy ON  fulltoindex(staging_catalogue.name, false)=fulltoindex(taxonomy.name, false) 
	and staging_catalogue.level_ref=taxonomy.level_ref
		 AND taxonomy.metadata_ref=$2
		LEFT JOIN catalogue_levels
		ON staging_catalogue.level_ref=catalogue_levels.id
		 WHERE staging_catalogue.import_ref=$1
		
		 ORDER BY  staging_catalogue.level_ref, staging_catalogue.name) a ;
   END IF;
 END 
 $_$;


ALTER FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_non_reference_bck(req_import_ref integer, var_metadata_ref integer, with_rank boolean, is_indexed boolean, match_invalid_units boolean) OWNER TO darwin2;

--
-- TOC entry 1539 (class 1255 OID 18806)
-- Name: fct_rmca_compare_taxonomy_staging_darwin_reference(integer, boolean, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false, match_invalid_units boolean DEFAULT true) RETURNS TABLE(id integer, name character varying, staging_catalogue_hierarchy character varying, darwin_hierarchy character varying, level_name character varying, level_ref integer, taxonomic_id integer, msg character varying)
    LANGUAGE plpgsql
    AS $_$ 
BEGIN
IF match_invalid_units IS FALSE THEN
	RETURN QUERY SELECT a.*, 
	CASE 
	WHEN 
	taxonomy_id is NULL THEN
	'taxon_to_be_created'::varchar
	when
	staging_catalogue_hierarchy_db=darwin_hierarchy_db THEN
	'taxonomic_hierarchy_already_exists'::varchar
	WHEN 
	staging_catalogue_hierarchy_db <> darwin_hierarchy_db THEN
	'taxonomic_conflict_in_reference'::varchar

	END

	 FROM (SELECT distinct 

	staging_catalogue.id, staging_catalogue.name, fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(staging_catalogue.id,req_import_ref, $2, $3)

	as staging_catalogue_hierarchy_db 

	, 
	fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

	,
	1 , true, false
	) as darwin_hierarchy_db, catalogue_levels.level_name,

	staging_catalogue.level_ref,
	taxonomy.id  as taxonomy_id
	 from staging_catalogue

	LEFT JOIN taxonomy ON fulltoindex(name_indexed, false)= fulltoindex(staging_catalogue.name, false) and staging_catalogue.level_ref=taxonomy.level_ref
	 AND taxonomy.is_reference_taxonomy=TRUE
	LEFT JOIN catalogue_levels
	ON staging_catalogue.level_ref=catalogue_levels.id
	 WHERE staging_catalogue.import_ref=$1 AND taxonomy.status !='invalid'

	 ORDER BY staging_catalogue.level_ref, staging_catalogue.name) a ;

ELSE

	RETURN QUERY SELECT a.*, 
	CASE 
	WHEN 
	taxonomy_id is NULL THEN
	'taxon_to_be_created'::varchar
	when
	staging_catalogue_hierarchy_db=darwin_hierarchy_db THEN
	'taxonomic_hierarchy_already_exists'::varchar
	WHEN 
	staging_catalogue_hierarchy_db <> darwin_hierarchy_db THEN
	'taxonomic_conflict_in_reference'::varchar

	END

	 FROM (SELECT distinct 

	staging_catalogue.id, staging_catalogue.name, fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(staging_catalogue.id,req_import_ref, $2, $3)

	as staging_catalogue_hierarchy_db 

	, 
	fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

	,
	1 , true, false
	) as darwin_hierarchy_db,  catalogue_levels.level_name,

	staging_catalogue.level_ref,
	taxonomy.id  as taxonomy_id
	 from staging_catalogue

	LEFT JOIN taxonomy ON fulltoindex(name_indexed, false)= fulltoindex(staging_catalogue.name, false) and staging_catalogue.level_ref=taxonomy.level_ref
	 AND taxonomy.is_reference_taxonomy=TRUE
	LEFT JOIN catalogue_levels
	ON staging_catalogue.level_ref=catalogue_levels.id
	 WHERE staging_catalogue.import_ref=$1

	 ORDER BY  staging_catalogue.level_ref, staging_catalogue.name) a ;
   END IF;
 END 
 $_$;


ALTER FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean, is_indexed boolean, match_invalid_units boolean) OWNER TO darwin2;

--
-- TOC entry 1540 (class 1255 OID 18807)
-- Name: fct_rmca_compare_taxonomy_staging_darwin_tagging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_tagging(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	check_duplicates_hierarchies RECORD;
	returned  boolean;
BEGIN 

	returned:=TRUE;
	UPDATE staging_catalogue SET hierarchical_conflict = FALSE WHERE import_ref=req_import_ref;
	PERFORM * FROM  fct_rmca_compare_taxonomy_staging_darwin(req_import_ref);
		IF FOUND THEN
			
			FOR check_duplicates_hierarchies IN SELECT * FROM  fct_rmca_compare_taxonomy_staging_darwin(req_import_ref)
			LOOP 			
				UPDATE staging_catalogue SET hierarchical_conflict = TRUE WHERE import_ref=req_import_ref AND staging_catalogue.level_ref=check_duplicates_hierarchies.level_ref AND staging_catalogue.name=check_duplicates_hierarchies.name;
			END LOOP;
			UPDATE imports SET state='error' , errors_in_import= 'taxonomic_conflict' ,working=false WHERE id=req_import_ref;
			returned:=FALSE;
		END IF;
		RETURN returned;
END;


 $$;


ALTER FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_tagging(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1541 (class 1255 OID 18808)
-- Name: fct_rmca_compare_varchar_array_as_integer(character varying[], character varying[]); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_varchar_array_as_integer(p1 character varying[], p2 character varying[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned boolean;
 i integer;
BEGIN
returned:=false;
	IF(ARRAY_LENGTH(p1,1)=ARRAY_LENGTH(p2,1)) THEN
		returned=true;
		i=1;
		WHILE returned=true AND i<= ARRAY_LENGTH(p1,1) LOOP 
			IF p1[i]::integer <>  p2[i]::integer THEN
				returned=false;
			END IF;
			i=i+1;
		END LOOP;
	END IF;
return returned;
END
$$;


ALTER FUNCTION darwin2.fct_rmca_compare_varchar_array_as_integer(p1 character varying[], p2 character varying[]) OWNER TO darwin2;

--
-- TOC entry 1542 (class 1255 OID 18809)
-- Name: fct_rmca_develop_range(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_develop_range(lower integer, upper integer) RETURNS integer[]
    LANGUAGE plpgsql
    AS $$
DECLARE
returned integer[];
tmp integer;
i integer;
BEGIN
 
 returned:='{}';

 IF upper <lower then
   tmp:=lower;
   lower:=upper;
   upper:=tmp;
 END IF;
 FOR i in lower..upper LOOP
	returned:=returned||i;
 END LOOP;


 return returned;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_develop_range(lower integer, upper integer) OWNER TO darwin2;

--
-- TOC entry 1543 (class 1255 OID 18810)
-- Name: fct_rmca_display_staging_taxon_comparison(public.hstore); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_display_staging_taxon_comparison(public.hstore) RETURNS SETOF character varying
    LANGUAGE sql
    AS $_$
SELECT  fct_rmca_sort_taxon_path_alphabetically_not_indexed(path) as taxon_path_alpha FROM each($1)
LEFT JOIN  catalogue_levels
ON key=level_name
and level_type='taxonomy'
LEFT JOIN taxonomy
ON value=taxonomy.name
ORDER BY level_order desc limit 1
$_$;


ALTER FUNCTION darwin2.fct_rmca_display_staging_taxon_comparison(public.hstore) OWNER TO darwin2;

--
-- TOC entry 1544 (class 1255 OID 18811)
-- Name: fct_rmca_display_staging_taxon_reorder(public.hstore); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_display_staging_taxon_reorder(public.hstore) RETURNS TABLE(taxon_path_alpha character varying)
    LANGUAGE sql
    AS $_$
SELECT   string_agg(value, '/') FROM (SELECT value FROM each($1)
LEFT JOIN  catalogue_levels
ON key=level_name
and level_type='taxonomy'
GROUP BY level_order, value
ORDER BY level_order asc)
a

$_$;


ALTER FUNCTION darwin2.fct_rmca_display_staging_taxon_reorder(public.hstore) OWNER TO darwin2;

--
-- TOC entry 1545 (class 1255 OID 18812)
-- Name: fct_rmca_document_taxonomy_staging_darwin_non_reference(integer, integer, boolean, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_document_taxonomy_staging_darwin_non_reference(req_import_ref integer, var_metadata_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false, match_invalid_taxonomies boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	curs_taxo  RECORD ; 
	returned boolean;
BEGIN 

	returned = false;
	for curs_taxo IN SELECT *  FROM fct_rmca_compare_taxonomy_staging_darwin_non_reference(req_import_ref, var_metadata_ref, with_rank, is_indexed, match_invalid_taxonomies)
	LOOP
		IF curs_taxo.taxonomic_id IS NOT NULL THEN
			UPDATE staging_catalogue SET import_exception=curs_taxo.msg, staging_hierarchy=curs_taxo.staging_catalogue_hierarchy, darwin_hierarchy=curs_taxo.darwin_hierarchy, catalogue_ref=curs_taxo.taxonomic_id WHERE id=curs_taxo.id;
			UPDATE staging_catalogue SET parent_ref= curs_taxo.taxonomic_id ,parent_updated=true WHERE import_ref=req_import_ref AND parent_ref=curs_taxo.id AND parent_updated=false;
		ELSE
			UPDATE staging_catalogue SET import_exception=curs_taxo.msg, staging_hierarchy=curs_taxo.staging_catalogue_hierarchy, darwin_hierarchy=curs_taxo.darwin_hierarchy WHERE id=curs_taxo.id;
		END IF;
	END LOOP;
	returned:=TRUE;
	return returned;
END
 $$;


ALTER FUNCTION darwin2.fct_rmca_document_taxonomy_staging_darwin_non_reference(req_import_ref integer, var_metadata_ref integer, with_rank boolean, is_indexed boolean, match_invalid_taxonomies boolean) OWNER TO darwin2;

--
-- TOC entry 1546 (class 1255 OID 18813)
-- Name: fct_rmca_dynamic_saved_search(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search(id_query integer, id_user integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	sql varchar;

	where_part varchar;
	param_part varchar;
	param_part_array varchar[];
	elem varchar;
	subst_where_part varchar[];
	
BEGIN

	SELECT  query_where, query_parameters  into   where_part, param_part FROM my_saved_searches WHERE id=id_query AND user_ref= id_user LIMIT 1;
	select array_agg(i) into subst_where_part
		FROM(
		SELECT (regexp_matches(where_part
		,'(''.*?'')'
		,'g'
		))[1] i
		) t
		;
	
	param_part_array=regexp_split_to_array(param_part, ';(?=|)'); 
	select regexp_REPLACE( where_part ,'(''.*?'')'
		,'DW_WORD_SQL', 'g'
		) into where_part;
			
	FOR i in 2..array_length( param_part_array,1)	LOOP
		elem:=regexp_replace(trim(param_part_array[i]), '^(\|)','');
		elem:=regexp_replace(trim(elem), '(\|)$','');
		elem=replace(elem,'''','''''');
		where_part:=regexp_replace(where_part, '(\?)',''''||elem||'''');
		
	END LOOP;

	IF  array_length( subst_where_part,1) IS NOT NULL  THEN
		FOR i in 1..array_length( subst_where_part,1)	LOOP
			where_part:=regexp_replace(where_part, 'DW_WORD_SQL',subst_where_part[i]);
			
		END LOOP;
	END IF;
		
	 RETURN QUERY EXECUTE 'SELECT DISTINCT s.id '||where_part;
END
$_$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search(id_query integer, id_user integer) OWNER TO darwin2;

--
-- TOC entry 720 (class 1255 OID 18814)
-- Name: fct_rmca_dynamic_saved_search(integer, integer, integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search(id_query integer, id_user integer, page integer, page_size integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	sql varchar;

	where_part varchar;
	param_part varchar;
	param_part_array varchar[];
	elem varchar;
	current_offset integer;
	
BEGIN

        current_offset=(page-1)*page_size;
	SELECT  query_where, query_parameters  into   where_part, param_part FROM my_saved_searches WHERE id=id_query AND user_ref= id_user LIMIT 1;
	
	
	param_part_array=regexp_split_to_array(param_part, ';(?=|)'); 
	
	FOR i in 2..array_length( param_part_array,1)	LOOP
		elem:=regexp_replace(trim(param_part_array[i]), '^(\|)','');
		elem:=regexp_replace(trim(elem), '(\|)$','');
		elem=replace(elem,'''','''''');
		where_part:=regexp_replace(where_part, '(\?)',''''||elem||'''');
		
	END LOOP;

	 RETURN QUERY EXECUTE 'SELECT s.id '||where_part||' ORDER BY s.id LIMIT '||page_size::varchar||' OFFSET '||current_offset::varchar ;
END
$_$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search(id_query integer, id_user integer, page integer, page_size integer) OWNER TO darwin2;

--
-- TOC entry 1708 (class 1255 OID 1416251)
-- Name: fct_rmca_dynamic_saved_search_gbif(integer, integer, character varying, character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search_gbif(id_query integer, id_user integer, url_prefix character varying DEFAULT 'https://darwinweb.africamuseum.be/page_specimen/'::character varying, contact_person character varying DEFAULT 'didier.van.den.spiegel@africamuseum.be'::character varying, p_licence character varying DEFAULT 'placeholder for CC licence'::character varying) RETURNS TABLE(id integer, uuid uuid, guid text, collection_ref integer, collection_code character varying, collection_name character varying, collection_id integer, collection_path character varying, cataloguenumber text, auxcode character varying, basisofrecord text, institutionid text, iso_country_institution text, bibliographic_citation text, licence text, email text, type character varying, taxon_path character varying, taxon_ref integer, taxon_name character varying, family character varying, iso_country character varying, country character varying, location text, latitude character varying, longitude character varying, lat_long_accuracy double precision, collector_ids integer[], collectors text, donator_ids integer[], donators text, identifiers_ids integer[], identifiers text, gtu_from_date text, gtu_to_date text, eventdate text, country_unnest character varying, urls_thumbnails character varying, image_category_thumbnails character varying, contributor_thumbnails character varying, disclaimer_thumbnails character varying, license_thumbnails character varying, display_order_thumbnails integer, urls_image_links character varying, image_category_image_links character varying, contributor_image_links character varying, disclaimer_image_links character varying, license_image_links character varying, display_order_image_links integer, urls_3d_snippets character varying, image_category_3d_snippets character varying, contributor_3d_snippets character varying, disclaimer_3d_snippets character varying, license_3d_snippets character varying, display_order_3d_snippets integer, identification_date text, history text, gtu_ref integer, specimen_count_min integer, specimen_count_males_min integer, specimen_count_females_min integer, specimen_count_juveniles_min integer)
    LANGUAGE plpgsql
    AS $$

DECLARE
	
	
BEGIN

	
		
	 RETURN QUERY  SELECT DISTINCT specimens.id, specimens.uuid , 
	 
	url_prefix||specimens.uuid::text
	 
	 
	AS guid, specimens.collection_ref, collections.code AS collection_code, collections.name AS collection_name, collections.id AS collection_id, collections.path AS collection_path, 
	COALESCE(codes.code_prefix, ''::character varying)::text 
	|| COALESCE(codes.code_prefix_separator, ''::character varying)::text 
	|| COALESCE(codes.code, ''::character varying)::text 
	|| COALESCE(codes.code_suffix_separator, ''::character varying)::text
	|| COALESCE(codes.code_suffix, ''::character varying)::text 
	AS cataloguenumber, 
	string_agg(distinct aux_code.code::text,';'::text order by aux_code.code::text)::varchar, 
	'PreservedSpecimen'::text AS basisofrecord, 'RMCA'::text AS institutionid, 'BE-RMCA'::text AS iso_country_institution, 'Please cite the source database appropriatly'::text AS bibliographic_citation, p_licence::text AS license, contact_person::text AS email, specimens.type, specimens.taxon_path, specimens.taxon_ref, specimens.taxon_name, fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 34) AS family, specimens.gtu_iso3166 AS iso_country, specimens.gtu_country_tag_value AS country, btrim(replace(replace(specimens.gtu_others_tag_value::text, specimens.gtu_country_tag_value::text, ''::text), 'Africa'::text, ''::text), ';'::text) AS location, specimens.gtu_location[1]::character varying AS latitude, specimens.gtu_location[0]::character varying AS longitude, gtu.lat_long_accuracy, specimens.spec_coll_ids AS collector_ids,
	( SELECT string_agg(distinct people.formated_name::text, ', '::text ORDER BY people.formated_name::text) AS string_agg
           FROM people
          WHERE people.id = ANY (specimens.spec_coll_ids))
		  AS collectors,
		  specimens.spec_don_sel_ids AS donator_ids,
		  ( SELECT string_agg(distinct people.formated_name::text, ', '::text ORDER BY people.formated_name::text) AS string_agg
           FROM people
          WHERE people.id = ANY (specimens.spec_don_sel_ids)) 
		  AS donators, 
		  specimens.spec_ident_ids AS identifiers_ids, 
		  ( SELECT string_agg(distinct people.formated_name::text, ', '::text ORDER BY people.formated_name::text) AS string_agg
           FROM people
          WHERE people.id = ANY (specimens.spec_ident_ids)) AS identifiers, 
		  darwin2.fct_mask_date_ymd_gbif(specimens.gtu_from_date,specimens.gtu_from_date_mask ) gtu_from_date,
		  darwin2.fct_mask_date_ymd_gbif(specimens.gtu_to_date,specimens.gtu_to_date_mask ) gtu_to_date, 
		  replace(replace(NULLIF(fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask), 
								 'xxxx-xx-xx'::text) || COALESCE('-'::text || NULLIF(fct_mask_date(specimens.gtu_to_date, specimens.gtu_to_date_mask), 'xxxx-xx-xx'::text), ''::text), 'xxxx'::text, ''::text), '-xx'::text, ''::text) AS eventdate
								 , 
       unnest( CASE
            WHEN specimens.gtu_country_tag_indexed IS NOT NULL THEN specimens.gtu_country_tag_indexed
            ELSE NULL::character varying[]
        END) AS country_unnest, ext_links_thumbnails.url AS urls_thumbnails, ext_links_thumbnails.category AS image_category_thumbnails, ext_links_thumbnails.contributor AS contributor_thumbnails, ext_links_thumbnails.disclaimer AS disclaimer_thumbnails, ext_links_thumbnails.license AS license_thumbnails, ext_links_thumbnails.display_order AS display_order_thumbnails, ext_links_image_links.url AS urls_image_links, ext_links_image_links.category AS image_category_image_links, ext_links_image_links.contributor AS contributor_image_links, ext_links_image_links.disclaimer AS disclaimer_image_links, ext_links_image_links.license AS license_image_links, ext_links_image_links.display_order AS display_order_image_links, ext_links_3d_snippets.url AS urls_3d_snippets, ext_links_3d_snippets.category AS image_category_3d_snippets, ext_links_3d_snippets.contributor AS contributor_3d_snippets, ext_links_3d_snippets.disclaimer AS disclaimer_3d_snippets, ext_links_3d_snippets.license AS license_3d_snippets, ext_links_3d_snippets.display_order AS display_order_3d_snippets,

		fct_mask_date_ymd_gbif(identifications.notion_date, notion_date_mask) AS identification_date, NULL::text AS history, specimens.gtu_ref,
		specimens.specimen_count_min, specimens.specimen_count_males_min, specimens.specimen_count_females_min, specimens.specimen_count_juveniles_min
   FROM specimens INNER JOIN (select fct_rmca_dynamic_saved_search f_id FROM fct_rmca_dynamic_saved_search(
    id_query ,
    id_user )) f ON specimens.id=f_id
   LEFT JOIN collections ON specimens.collection_ref = collections.id
   LEFT JOIN codes ON codes.referenced_relation::text = 'specimens'::text AND codes.code_category::text = 'main'::text AND specimens.id = codes.record_id
   LEFT JOIN codes as aux_code ON aux_code.referenced_relation::text = 'specimens'::text AND lower(aux_code.code_category::text) = 'additional id'::text AND specimens.id = aux_code.record_id
   LEFT JOIN ext_links ext_links_thumbnails ON specimens.id = ext_links_thumbnails.record_id AND ext_links_thumbnails.referenced_relation::text = 'specimens'::text AND ext_links_thumbnails.category::text = 'thumbnail'::text
   LEFT JOIN ext_links ext_links_image_links ON specimens.id = ext_links_image_links.record_id AND ext_links_image_links.referenced_relation::text = 'specimens'::text AND ext_links_image_links.category::text = 'image_link'::text
   LEFT JOIN ext_links ext_links_3d_snippets ON specimens.id = ext_links_3d_snippets.record_id AND ext_links_3d_snippets.referenced_relation::text = 'specimens'::text AND ext_links_3d_snippets.category::text = 'html_3d_snippet'::text
   LEFT JOIN identifications ON identifications.referenced_relation::text = 'specimens'::text AND specimens.id = identifications.record_id AND identifications.notion_concerned::text = 'taxonomy'::text
   LEFT JOIN tags ON specimens.gtu_ref = tags.gtu_ref
   LEFT JOIN gtu ON specimens.gtu_ref = gtu.id
  GROUP BY 
  specimens.id,
  specimens.uuid,
url_prefix||specimens.uuid::text
   , collections.id, collections.path, collections.name, collections.code, (((COALESCE(codes.code_prefix, ''::character varying)::text || COALESCE(codes.code_prefix_separator, ''::character varying)::text) || COALESCE(codes.code, ''::character varying)::text) || COALESCE(codes.code_suffix_separator, ''::character varying)::text) || COALESCE(codes.code_suffix, ''::character varying)::text, specimens.taxon_path, specimens.taxon_ref, specimens.collection_ref, specimens.gtu_country_tag_indexed, specimens.gtu_country_tag_value, specimens.gtu_iso3166, specimens.gtu_location[0]::character varying, specimens.gtu_location[1]::character varying, specimens.spec_ident_ids, specimens.gtu_others_tag_indexed, specimens.gtu_others_tag_value, specimens.taxon_name, ext_links_thumbnails.url, ext_links_thumbnails.category, ext_links_thumbnails.contributor, ext_links_thumbnails.disclaimer, ext_links_thumbnails.license, ext_links_thumbnails.display_order, ext_links_image_links.url, ext_links_image_links.category, ext_links_image_links.contributor, ext_links_image_links.disclaimer, ext_links_image_links.license, ext_links_image_links.display_order, ext_links_3d_snippets.url, ext_links_3d_snippets.category, ext_links_3d_snippets.contributor, ext_links_3d_snippets.disclaimer, ext_links_3d_snippets.license, ext_links_3d_snippets.display_order, identifications.notion_date, identifications.notion_date_mask, specimens.gtu_ref, specimens.gtu_from_date, specimens.gtu_from_date_mask, specimens.gtu_to_date, specimens.gtu_to_date_mask, specimens.type, specimens.spec_coll_ids, specimens.spec_don_sel_ids, codes.full_code_indexed, gtu.lat_long_accuracy
   ,
		specimens.specimen_count_min, specimens.specimen_count_males_min, specimens.specimen_count_females_min, specimens.specimen_count_juveniles_min
   ;

END
$$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search_gbif(id_query integer, id_user integer, url_prefix character varying, contact_person character varying, p_licence character varying) OWNER TO darwin2;

--
-- TOC entry 1549 (class 1255 OID 18818)
-- Name: fct_rmca_dynamic_saved_search_geojson(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search_geojson(id_query integer, id_user integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned varchar;
	
BEGIN

	SELECT 
		'{  "type": "FeatureCollection",
		  "features": ['||
		string_agg('{"type" : "Feature", 
			"geometry" : {
				"type" : "Point",
				"coordinates" : ['||longitude||', '||latitude||']
			},
			"properties": {
				"collection_number" : "'||code_display::varchar||'",
				"taxon_name" : "'||taxon_name::varchar||'",
				"type" : "'||coll_type::varchar||'",
				"collecting_date" : "'||date_from_display::varchar||'",
				"collecting_date_end" : "'||NULLIF(date_from_display, 'xxxx-xx-xx')::varchar||'",

				"country" : "'||gtu_country_tag_value::varchar||'",
				"latitude" : "'||latitude::varchar||'",
				"longitude" : "'||longitude::varchar||'"
			}
		}'::varchar,',')||']
		}'INTO returned 
 FROM   v_rmca_public_view WHERE id in (SELECT fct_rmca_dynamic_saved_search(id_query, id_user)) and latitude is not null and longitude is not null LIMIT 1;

 return returned;
END
$$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search_geojson(id_query integer, id_user integer) OWNER TO darwin2;

--
-- TOC entry 1550 (class 1255 OID 18819)
-- Name: fct_rmca_dynamic_saved_search_get_specimen_collective_access(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search_get_specimen_collective_access(query_id integer, user_id integer) RETURNS TABLE(title character varying, code character varying, description character varying, filename character varying, related_object character varying, media_info character varying, empty_1 character varying, view character varying, empty_2 character varying, view_order character varying, phylum character varying, class character varying, "order" character varying, family character varying, genus character varying, species character varying, subspecies character varying, type character varying, digitisation character varying, "3d" character varying, contributor character varying, uuid uuid, institution character varying, boxid character varying, sex character varying, stage character varying, specimen_count_min integer, country character varying, coordinates character varying, location_detail character varying, empty_3 character varying, empty_4 character varying, date_of_collect character varying, collectors character varying, identifiers character varying, access integer, collection character varying, collection_virtual_collection character varying)
    LANGUAGE plpgsql
    AS $$
DECLARE 

BEGIN 
RETURN QUERY 
WITH
	criteria AS
	(SELECT fct_rmca_dynamic_saved_search as spec_id, gtu_ref FROM  fct_rmca_dynamic_saved_search(
					query_id,user_id)
					 INNER JOIN specimens ON fct_rmca_dynamic_saved_search=specimens.id
	order by fct_rmca_dynamic_saved_search  
					 ),
	exact_site as 
	(
	SELECT tags.gtu_ref, string_agg(tag, '; ')::varchar as tag FROM
	tags 
	INNER JOIN criteria
	ON criteria.gtu_ref= tags.gtu_ref WHERE LOWER(sub_group_type) LIKE '%exact_site%' or  LOWER(sub_group_type) LIKE '%municipality%'
	group by tags.gtu_ref			    
	)
	,

	recol as
	(
	SELECT spec_id as recol_spec_id, string_agg(formated_name, '; ')::varchar as recol_name FROM
	criteria
	INNER JOIN
	catalogue_people cp2
	 ON cp2.referenced_relation='specimens' AND cp2.people_type='collector' AND spec_id=cp2.record_id 
				    LEFT JOIN people recol
					ON cp2.people_ref = recol.id
					GROUP BY spec_id
	)
	, 
	ident as (
SELECT spec_id as ident_spec_id, string_agg(formated_name, '; ') as ident_name FROM
	criteria
	
LEFT JOIN identifications i
ON i.referenced_relation='specimens' AND spec_id=i.record_id
 LEFT JOIN catalogue_people cp1
ON cp1.referenced_relation='identifications' AND i.id=cp1.record_id 
   LEFT JOIN people ident
ON cp1.people_ref = ident.id
GROUP BY spec_id
	)
	,

	donator as
	(
	SELECT spec_id as donator_spec_id, recol.* FROM
	criteria
	INNER JOIN
	catalogue_people cp2
	 ON cp2.referenced_relation='specimens' AND cp2.people_type='donator' AND spec_id=cp2.record_id 
				    LEFT JOIN people recol
					ON cp2.people_ref = recol.id
	),
	codes2 as
	(select
	c2.*
,  COALESCE(c2.code_prefix,'')||COALESCE(c2.code_prefix_separator,'')||COALESCE(c2.code,'')||COALESCE(c2.code_suffix,'')||
				    COALESCE(c2.code_suffix_separator,'') as code_full_text
	FROM
	criteria
	INNER JOIN
	codes c2
					ON  spec_id=c2.record_id
					AND c2.referenced_relation='specimens'
					AND c2.code_category ='main'
	)
,

spec AS(
select  specimens.id as id2, spec_id, specimens.* , fct_rmca_sort_taxon_path_alphabetically_hstore(taxon_path||taxon_ref::varchar||'/') htaxa from specimens inner join criteria on specimens.id=spec_id)


SELECT distinct (taxon_name||' '||code_full_text)::varchar title,
code_full_text::varchar as code,
NULL::varchar description,
NULL::varchar filename,
NULL::varchar related_object,
NULL::varchar media_info,
NULL::varchar as empty_1,
NULL::varchar as view,
NULL::varchar as empty_2,
NULL::varchar as view_order,
 (htaxa->'phylum')::varchar  as phylum ,
(htaxa->'class')::varchar  as class ,
(htaxa->'order')::varchar  as order ,
(htaxa->'family')::varchar  as family ,
(htaxa->'genus')::varchar  as genus ,
(htaxa->'species')::varchar  as species ,
(htaxa->'sub species')::varchar  as subspecies ,
spec.type,
NULL::varchar as digitisation,
NULL::varchar as" 3d",
NULL::varchar as contributor,
specimens_stable_ids.uuid,
inst.formated_name as institution,
storage_parts.container as boxid,
spec.sex,
spec.stage,
spec.specimen_count_min,
gtu_country_tag_value,
 ('['||latitude::varchar||','||longitude::varchar||']')::varchar as coordinates,
 tag::varchar as location_details,
 NULL::varchar as empty_3,
  NULL::varchar as empty_4,
  case when spec.gtu_to_date_mask>0 then
    (fct_mask_date_dmy(spec.gtu_from_date, spec.gtu_from_date_mask)||'-'|| fct_mask_date_dmy(spec.gtu_to_date, spec.gtu_to_date_mask))::varchar
  when  spec.gtu_from_date_mask>0 then
  fct_mask_date_dmy(spec.gtu_from_date, spec.gtu_from_date_mask)::varchar
  ELSE
  fct_mask_date_dmy(spec.gtu_from_date, spec.gtu_from_date_mask)::varchar
end
as date_of_collect_formatted,
recol_name::varchar as collector,
ident_name::varchar as identifiers
,
1 as access,
collection_name as collection,
null::varchar as collection_in_virtual_collection 
FROM spec 
LEFT OUTER JOIN codes2
ON spec_id=codes2.record_id
LEFT JOIN specimens_stable_ids
ON spec.id=specimens_stable_ids.specimen_ref
LEFT JOIN
storage_parts
on spec.id=storage_parts.specimen_ref
LEFT JOIN people as inst
ON storage_parts.institution_ref=inst.id
LEFT JOIN gtu
ON spec.gtu_ref=gtu.id
LEFT JOIN exact_site
ON gtu.id=exact_site.gtu_ref
LEFT JOIN recol 
ON spec_id=recol.recol_spec_id
LEFT JOIN ident 
ON spec_id=ident.ident_spec_id;
RETURN --QUERY SELECT * FROM user_query_tmp
;
END
$$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search_get_specimen_collective_access(query_id integer, user_id integer) OWNER TO darwin2;

--
-- TOC entry 1551 (class 1255 OID 18822)
-- Name: fct_rmca_dynamic_saved_search_page(integer, integer, integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search_page(id_query integer, id_user integer, page integer, page_size integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	sql varchar;

	where_part varchar;
	param_part varchar;
	param_part_array varchar[];
	elem varchar;
	current_offset integer;
	
BEGIN

        current_offset=(page-1)*page_size;
	SELECT  query_where, query_parameters  into   where_part, param_part FROM my_saved_searches WHERE id=id_query AND user_ref= id_user LIMIT 1;
	
	
	param_part_array=regexp_split_to_array(param_part, ';(?=|)'); 
	
	FOR i in 2..array_length( param_part_array,1)	LOOP
		elem:=regexp_replace(trim(param_part_array[i]), '^(\|)','');
		elem:=regexp_replace(trim(elem), '(\|)$','');
		elem=replace(elem,'''','''''');
		where_part:=regexp_replace(where_part, '(\?)',''''||elem||'''');
		
	END LOOP;

	 RETURN QUERY EXECUTE 'SELECT s.id '||where_part||' ORDER BY s.id LIMIT '||page_size::varchar||' OFFSET '||current_offset::varchar ;
END
$_$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search_page(id_query integer, id_user integer, page integer, page_size integer) OWNER TO darwin2;

--
-- TOC entry 1552 (class 1255 OID 18823)
-- Name: fct_rmca_dynamic_saved_search_taxonomy(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search_taxonomy(id_query integer, id_user integer) RETURNS SETOF darwin2.rmca_taxon_report
    LANGUAGE plpgsql
    AS $$
DECLARE
 tmp RECORD;
 declare tmp_ret RECORD;
BEGIN
		FOR tmp in
		
			SELECT
	 DISTINCT fct_rmca_sort_taxon_path_alphabetically_hstore(taxon_path||taxon_ref::varchar) as hstore_field ,

	fct_rmca_sort_taxon_path_alphabetically(taxon_path||taxon_ref::varchar) as alpha_path
	 from specimens where specimens.id in (SELECT fct_rmca_dynamic_saved_search(
				id_query, id_user
			)) order by alpha_path
		LOOP
				BEGIN
					IF  tmp.hstore_field is not null then
					tmp_ret:=populate_record(null::rmca_taxon_report,tmp.hstore_field);				
					RETURN NEXT tmp_ret ;
					end if;
				END;
		END LOOP;
END; $$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search_taxonomy(id_query integer, id_user integer) OWNER TO darwin2;

--
-- TOC entry 1553 (class 1255 OID 18824)
-- Name: fct_rmca_get_all_child_direct_synonyms(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_all_child_direct_synonyms(integer) RETURNS SETOF integer
    LANGUAGE sql
    AS $_$
WITH a as
(

select id from taxonomy where parent_ref=$1
),
b as
(select distinct group_id, record_id FROM classification_synonymies, a WHERE 
record_id=a.id 
 and referenced_relation='taxonomy'
)
select taxonomy.id from b inner join classification_synonymies on b.group_id=classification_synonymies.group_id
inner join taxonomy on classification_synonymies.record_id=taxonomy.id;
$_$;


ALTER FUNCTION darwin2.fct_rmca_get_all_child_direct_synonyms(integer) OWNER TO darwin2;

--
-- TOC entry 1554 (class 1255 OID 18825)
-- Name: fct_rmca_get_all_child_synonyms(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_all_child_synonyms(integer) RETURNS SETOF integer
    LANGUAGE sql
    AS $_$
WITH a as
(

select id from taxonomy where path||'/'||parent_ref||'/' like '%/'||$1||'/%'
),
b as
(select distinct group_id, record_id FROM classification_synonymies, a WHERE 
record_id=a.id 
 and referenced_relation='taxonomy'
)
select taxonomy.id from b inner join classification_synonymies on b.group_id=classification_synonymies.group_id
inner join taxonomy on classification_synonymies.record_id=taxonomy.id;
$_$;


ALTER FUNCTION darwin2.fct_rmca_get_all_child_synonyms(integer) OWNER TO darwin2;

--
-- TOC entry 737 (class 1255 OID 18826)
-- Name: fct_rmca_get_all_inverse_relationships(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_all_inverse_relationships(integer) RETURNS TABLE(id integer, specimen_ref integer, relationship_type character varying, unit_type character varying, specimen_related_ref integer, taxon_ref integer, mineral_ref integer, institution_ref integer, source_name text, source_id text, quantity numeric, unit character varying)
    LANGUAGE sql
    AS $_$
with a as
(select * from specimens_relationships where specimen_ref=$1
 or specimen_related_ref= $1)
select distinct specimens_relationships.* 
from specimens_relationships inner join a 
on specimens_relationships.specimen_ref=a.specimen_related_ref 
or
specimens_relationships.specimen_related_ref=a.specimen_related_ref 
where lower(specimens_relationships.relationship_type) not like '%duplicated%' and specimens_relationships.specimen_ref!=$1
$_$;


ALTER FUNCTION darwin2.fct_rmca_get_all_inverse_relationships(integer) OWNER TO darwin2;

--
-- TOC entry 738 (class 1255 OID 18827)
-- Name: fct_rmca_get_all_inverse_relationships_specimen_ref(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_all_inverse_relationships_specimen_ref(integer) RETURNS integer[]
    LANGUAGE sql
    AS $_$
with a as
(select * from specimens_relationships where specimen_ref=$1
 or specimen_related_ref= $1)
select array_agg(DISTINCT specimens_relationships.specimen_ref)
from specimens_relationships inner join a 
on specimens_relationships.specimen_ref=a.specimen_related_ref 
or
specimens_relationships.specimen_related_ref=a.specimen_related_ref 
where lower(specimens_relationships.relationship_type) not like '%duplicated%' and specimens_relationships.specimen_ref !=$1
$_$;


ALTER FUNCTION darwin2.fct_rmca_get_all_inverse_relationships_specimen_ref(integer) OWNER TO darwin2;

--
-- TOC entry 778 (class 1255 OID 18828)
-- Name: fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(id_staging_taxon integer, exclude_invalid_entries boolean DEFAULT false) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar[];
 returned_tmp varchar;
 parent_updated_tmp boolean;
 tmp_id integer;
 parent integer;
 i integer;
 name_tmp varchar;
 level_of_parent_staging integer;
 catalogue_ref_tmp integer;
 import_ref_tmp integer;

 taxoonomy_id integer;
BEGIN
--raise notice 'ENTRY';
	SELECT parent_updated INTO parent_updated_tmp FROM  staging_catalogue WHERE id=tmp_id;
	IF parent_updated_tmp=true THEN
		return NULL;
	END IF;
	RAISE NOTICE 'GO';
		tmp_id:= id_staging_taxon;
		--real taxonomical path
		--eg. /1/5/5953/5954/5955/
		returned[1]:='';
		--string trascription of the path
		--eg. /Eucaryota/Animalia/CHORDATA/ACTINOPTERYGII/PERCIFORMES/
		returned[2]:='';
		--path corresponding to the longest taxonomical prefix with both taxonomy ids and staging ids
		--/97909/97910/97911/97912/97913/
		returned[3]:='';
		--lowest taxon of the path available in staging and taxonomy 
		--eg. 97913
		returned[4]:='';
		--path the parents in staging not found in taxonomy (remainded of the longest prefix)
		--eg. /97914/97922/
		returned[5]:=''; 
		--levels in staging
		returned[6]:='';
		--levels in taxonomy
		returned[7]:='';
		parent:=tmp_id;
		i=1;
		WHILE parent is not null and i< 70 LOOP
			SELECT parent_ref_internal, name, level_ref, catalogue_ref, import_ref  INTO parent, name_tmp, level_of_parent_staging , catalogue_ref_tmp, import_ref_tmp FROM staging_catalogue WHERE id=tmp_id --and catalogue_ref is NULL 
			LIMIT 1;
			RAISE NOTICE 'loop';
			IF parent is not null THEN
				tmp_id:=parent;
			END IF;
			
			IF catalogue_ref_tmp IS NOT NULL THEN
				
				returned[1]:=catalogue_ref_tmp::varchar||'/'||returned[1];
				returned[3]:=tmp_id::varchar||'/'||returned[3];
				IF returned[4]='' THEN
					 returned[4]:=tmp_id::varchar;
				END IF;
				returned[7]:=level_of_parent_staging::varchar||'/'||returned[7];
			ELSE
				returned[5]:=tmp_id::varchar||'/'||returned[5];
			END IF;
			returned[2]:=name_tmp||'/'||returned[2];
			returned[6]:=level_of_parent_staging::varchar||'/'||returned[6];
			i:=i+1;
		END LOOP;
	returned[1]:='/'||returned[1];
	returned[2]:='/'||returned[2];
	returned[3]:='/'||returned[3];	
	returned[5]:='/'||returned[5];
	returned[6]:='/'||returned[6];
	returned[7]:='/'||returned[7];							
	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(id_staging_taxon integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 779 (class 1255 OID 18829)
-- Name: fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy_(integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy_(id_staging_taxon integer, exclude_invalid_entries boolean DEFAULT false) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar[];
 returned_tmp varchar;
 --ftheeten 2019 02 15
 returned_tmp_levels varchar;
 returned_name varchar;
 returned_ids_staging varchar;

 staging_path_name varchar;
 staging_path_level varchar;
 staging_path_level_array int[];
 staging_path_name_array varchar[];
 --ftheeten 2019 02 15
taxonomy_path_level_array int[];
 
 parent integer;
 i integer;
 tmp_id integer;
 tmp_name_path varchar;
 name_tmp varchar;
 level_tmp integer;
  level_tmp_char varchar;
  level_of_parent_staging int;
  level_of_parent_taxonomy int;
  
 id_main_taxon integer;
 --ftheeten 2019 02 15
 id_level_taxon integer;
 staging_path_found boolean;
 array_ids integer[];
 array_ids_string varchar;
 last_id varchar;
 last_id_set boolean;
 catalogue_ref_tmp integer;
 import_ref_tmp integer;
 parent_updated_tmp boolean;
 parent_updated_refs_array integer[];
 --ftheeten 2019 02 15
  parent_updated_levels_array integer[];
 taxon_found_in_staging boolean;
BEGIN
--raise notice 'ENTRY';
	SELECT parent_updated INTO parent_updated_tmp FROM  staging_catalogue WHERE id=tmp_id;
	IF parent_updated_tmp=true THEN
		return NULL;
	END IF;
		tmp_id:= id_staging_taxon;
		i:=0;
		parent:=-1;

		--staging_path_name:='/';
		--staging_path_level:='/';
		
		--array_ids_string:='/'||tmp_id||'/';
		array_ids:=tmp_id||array_ids;
		WHILE parent is not null and i< 50 LOOP
			SELECT parent_ref, name, level_ref, catalogue_ref, import_ref  INTO parent, name_tmp, level_of_parent_staging , catalogue_ref_tmp, import_ref_tmp FROM staging_catalogue WHERE id=tmp_id --and catalogue_ref is NULL 
			LIMIT 1;
			
			IF parent is not null THEN
				
				IF catalogue_ref_tmp IS NULL THEN
					tmp_id:=parent;
				ELSE
					--raise notice 'APPEND';
					SELECT id, level_ref into tmp_id, level_tmp  FROM  staging_catalogue WHERE import_ref=import_ref_tmp AND catalogue_ref=parent; --AND parent_updated=TRUE;
					parent_updated_refs_array:=parent||parent_updated_refs_array;
					--ftheeten 2019 02 15
					parent_updated_levels_array:= level_tmp||parent_updated_levels_array;
					--raise notice 'APPENDED';
				END IF;
				IF tmp_id IS NOT NULL THEN
					
					array_ids := tmp_id||array_ids;
					--raise notice '%',array_ids_string;
				END IF;
			END IF;
			
			staging_path_name_array:= name_tmp::varchar||staging_path_name_array;
			--raise notice '%',staging_path_name;
			staging_path_level_array:= level_of_parent_staging||staging_path_level_array;
			
			i:=i+1;
		END LOOP;
		--raise notice '%', staging_path_name_array;
		--raise notice '%', staging_path_level_array;
		--raise notice '%', array_ids;
		--raise notice '%', parent_updated_refs_array;
		/*IF staging_path_name='/' OR
		staging_path_level='/' OR 
		array_ids_string='/' THEN
			RETURN NULL;
		END IF;*/
		
		IF ARRAY_LENGTH(staging_path_name_array,1)=0 OR
		ARRAY_LENGTH(staging_path_level_array,1)=0 OR 
		ARRAY_LENGTH(array_ids,1)=0 THEN
		--RAISE NOTICE 'EXIT 0';
			RETURN NULL;
		END IF;
		--staging_path_level_array:=string_to_array(staging_path_level, '/');
		--staging_path_name_array:=string_to_array(staging_path_name, '/');
		--array_ids=string_to_array(array_ids_string, '/');
		
		returned_tmp:='/';
		returned_tmp_levels:='/';
		returned_name:='/';
		returned_ids_staging='/';
		staging_path_found:=false;
		taxon_found_in_staging:=false;
		last_id_set:=false;
--raise notice 'staging_path_name_array %', staging_path_name_array;
		IF ARRAY_LENGTH(staging_path_level_array, 1)=ARRAY_LENGTH(staging_path_name_array, 1) THEN
			FOR i IN  1..ARRAY_LENGTH(staging_path_name_array,1) LOOP
				--RAISe NOTICE '%d', i;
				--RAISe NOTICE '%d', ARRAY_LENGTH(staging_path_name_array,1);
				--RAISe NOTICE '%d', ARRAY_LENGTH(parent_updated_refs_array,1);
				tmp_name_path:=staging_path_name_array[i];
--raise notice 'tmp_name_path %',tmp_name_path;
				IF LENGTH(tmp_name_path)>0 THEN
				
					--raise notice 'TEST';
					level_tmp_char:=staging_path_level_array[i];
					--taxonomic parent already in staging
					IF ARRAY_LENGTH( parent_updated_refs_array ,1)> 0 AND i < ARRAY_LENGTH( parent_updated_refs_array ,1) THEN
						
						id_main_taxon:=parent_updated_refs_array[i];
						--ftheeten 2019 02 15
						id_level_taxon=parent_updated_levels_array[i];
						--raise notice 'id_main_taxon %', id_main_taxon;
						taxon_found_in_staging:=true;
					--find taxonomuic parent from string
					ELSE
						taxon_found_in_staging:=false;

						IF exclude_invalid_entries=true THEN
							SELECT id, level_ref INTO id_main_taxon, id_level_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int AND status !='invalid' LIMIT 1;
							--SELECT id INTO id_main_taxon FROM taxonomy WHERE fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int AND status !='invalid' LIMIT 1;
						
						ELSE
							SELECT id, level_ref INTO id_main_taxon, id_level_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int LIMIT 1;
							--SELECT id INTO id_main_taxon FROM taxonomy WHERE fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int LIMIT 1;
						END IF;
					END IF;
					IF id_main_taxon IS NULL THEN
						--raise notice 'NOT_FOUND';
						returned_tmp:= returned_tmp||'NOT_FOUND/';
						returned_tmp_levels:= returned_tmp_levels||'NOT_FOUND/';
						staging_path_found:=false;
					ELSE						
						--RAISE NOTICE 'FOUND';
						returned_tmp:= returned_tmp||id_main_taxon::varchar||'/';
						--ftheeten 2019 02 15
						returned_tmp_levels:= returned_tmp_levels||id_level_taxon::varchar||'/';
						returned_name:=returned_name||tmp_name_path||'/';
						returned_ids_staging:=returned_ids_staging||array_ids[i]::varchar||'/';
						
						last_id:=array_ids[i];
						staging_path_found:=TRUE;
					END IF;
					IF staging_path_found=TRUE THEN
						IF exclude_invalid_entries=true AND taxon_found_in_staging=false THEN
							
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp AND status !='invalid';
						ELSIF taxon_found_in_staging=false THEN
						
						--raise notice 'returned_tmp : %',returned_tmp; 
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp;
							IF NOT FOUND THEN
								PERFORM id FROM taxonomy WHERE path||id::varchar||'/'LIKE '%'||returned_tmp;
							END IF;
						--ELSE
						--	RAISE NOTICE 'NO check';
						END IF;
						IF FOUND OR taxon_found_in_staging=true THEN
							--RAISE NOTICE 'DEF';
							--parent path found in taxonomy (longest prefix)

							--eg for complete path in staging /97909/97910/97911/97912/97913/97914/97922/ )
							--eg. /1/5/5953/5954/5955/
							returned[1]:=returned_tmp;
							--string trascription of the path
							--eg. /Eucaryota/Animalia/CHORDATA/ACTINOPTERYGII/PERCIFORMES/
							returned[2]:=returned_name;
							--path corresponding to the longest taxonomical prefix with the staging ids
							--/97909/97910/97911/97912/97913/
							returned[3]:=returned_ids_staging;
							--lowest taxon of the path 
							--eg. 97913
							returned[4]:=last_id;
							--path the parents in staging not found in taxonomy (remainded of the longest prefix)
							--eg. /97914/97922/ 
							IF(i<ARRAY_LENGTH(array_ids,1)) THEN
								returned[5]:='/'||array_to_string(array_ids[i+1:ARRAY_LENGTH(array_ids,1)],'/')||'/';
							ELSE
								
								returned[5]:='/';
							END IF;

							--levels in staging
							returned[6]:='/'||array_to_string(staging_path_level_array,'/')||'/';
							--levels in taxonomy
							returned[7]:=returned_tmp_levels;
							
							--SUBSTRING(array_ids_string FROM  POSITION ('/'||last_id||'/' IN array_ids_string) + LENGTH('/'||last_id));
						ELSE
							--RAISE NOTICE 'EXIT 1';
							RETURN returned;
						END IF;
					ELSE 
						--RAISE NOTICE 'EXIT 2';
						RETURN returned;
					END IF;
				END IF;
				
			END LOOP;
		END IF;
--RAISE NOTICE 'EXIT 3';
	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy_(id_staging_taxon integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 780 (class 1255 OID 18832)
-- Name: fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomyb(integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomyb(id_staging_taxon integer, exclude_invalid_entries boolean DEFAULT false) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar[];
 returned_tmp varchar;
 returned_name varchar;
 returned_ids_staging varchar;

 staging_path_name varchar;
 staging_path_level varchar;
 staging_path_level_array int[];
 staging_path_name_array varchar[];
 parent integer;
 i integer;
 tmp_id integer;
 tmp_name_path varchar;
 name_tmp varchar;
 level_tmp varchar;
  level_tmp_char varchar;
  level_of_parent_staging int;
  level_of_parent_taxonomy int;
  
 id_main_taxon integer;
 staging_path_found boolean;
 array_ids integer[];
 array_ids_string varchar;
 last_id varchar;
 last_id_set boolean;
 catalogue_ref_tmp integer;
 import_ref_tmp integer;
 parent_updated_tmp boolean;
 parent_updated_refs_array integer[];
 taxon_found_in_staging boolean;
BEGIN
--raise notice 'entry';
	SELECT parent_updated INTO parent_updated_tmp FROM  staging_catalogue WHERE id=tmp_id;
	IF parent_updated_tmp=true THEN
		return NULL;
	END IF;
		tmp_id:= id_staging_taxon;
		i:=0;
		parent:=-1;

		--staging_path_name:='/';
		--staging_path_level:='/';
		
		--array_ids_string:='/'||tmp_id||'/';
		array_ids:=tmp_id||array_ids;
		WHILE parent is not null and i<30 LOOP
			SELECT parent_ref, name, level_ref, catalogue_ref, import_ref  INTO parent, name_tmp, level_of_parent_staging , catalogue_ref_tmp, import_ref_tmp FROM staging_catalogue WHERE id=tmp_id --and catalogue_ref is NULL 
			LIMIT 1;
			
			IF parent is not null THEN
				
				IF catalogue_ref_tmp IS NULL THEN
					tmp_id:=parent;
				ELSE
					--raise notice 'append';
					SELECT id into tmp_id FROM  staging_catalogue WHERE import_ref=import_ref_tmp AND catalogue_ref=parent; --AND parent_updated=TRUE;
					parent_updated_refs_array:=parent||parent_updated_refs_array;
				END IF;
				IF tmp_id IS NOT NULL THEN
					
					array_ids := tmp_id||array_ids;
					--raise notice '%',array_ids_string;
				END IF;
			END IF;
			
			staging_path_name_array:= name_tmp::varchar||staging_path_name_array;
			--raise notice '%',staging_path_name;
			staging_path_level_array:= level_of_parent_staging||staging_path_level_array;
			
			i:=i+1;
		END LOOP;
		--raise notice '%', staging_path_name_array;
		--raise notice '%', staging_path_level_array;
		--raise notice '%', array_ids;
		--raise notice '%', parent_updated_refs_array;
		/*IF staging_path_name='/' OR
		staging_path_level='/' OR 
		array_ids_string='/' THEN
			RETURN NULL;
		END IF;*/
		
		IF ARRAY_LENGTH(staging_path_name_array,1)=0 OR
		ARRAY_LENGTH(staging_path_level_array,1)=0 OR 
		ARRAY_LENGTH(array_ids,1)=0 THEN
		--RAISE NOTICE 'EXIT 0';
			RETURN NULL;
		END IF;
		--staging_path_level_array:=string_to_array(staging_path_level, '/');
		--staging_path_name_array:=string_to_array(staging_path_name, '/');
		--array_ids=string_to_array(array_ids_string, '/');
		
		returned_tmp:='/';
		returned_name:='/';
		returned_ids_staging='/';
		staging_path_found:=false;
		taxon_found_in_staging:=false;
		last_id_set:=false;
--raise notice 'staging_path_name_array %', staging_path_name_array;
		IF ARRAY_LENGTH(staging_path_level_array, 1)=ARRAY_LENGTH(staging_path_name_array, 1) THEN
			FOR i IN  1..ARRAY_LENGTH(staging_path_name_array,1) LOOP
				--RAISe NOTICE '%d', i;
				--RAISe NOTICE '%d', ARRAY_LENGTH(staging_path_name_array,1);
				--RAISe NOTICE '%d', ARRAY_LENGTH(parent_updated_refs_array,1);
				tmp_name_path:=staging_path_name_array[i];
--raise notice 'tmp_name_path %',tmp_name_path;
				IF LENGTH(tmp_name_path)>0 THEN
				
					--raise notice 'TEST';
					level_tmp_char:=staging_path_level_array[i];
					--taxonomic parent already in staging
					IF ARRAY_LENGTH( parent_updated_refs_array ,1)> 0 AND i < ARRAY_LENGTH( parent_updated_refs_array ,1) THEN
						
						id_main_taxon:=parent_updated_refs_array[i];
						--raise notice 'id_main_taxon %', id_main_taxon;
						taxon_found_in_staging:=true;
					--find taxonomuic parent from string
					ELSE
						taxon_found_in_staging:=false;

						IF exclude_invalid_entries=true THEN
							--SELECT id INTO id_main_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int AND status !='invalid' LIMIT 1;
							SELECT id INTO id_main_taxon FROM taxonomy WHERE fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int AND status !='invalid' LIMIT 1;
						
						ELSE
							--SELECT id INTO id_main_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int LIMIT 1;
							SELECT id INTO id_main_taxon FROM taxonomy WHERE fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int LIMIT 1;
						END IF;
					END IF;
					IF id_main_taxon IS NULL THEN
						--raise notice 'NOT_FOUND';
						returned_tmp:= returned_tmp||'NOT_FOUND/';
						staging_path_found:=false;
					ELSE						
						--RAISE NOTICE 'FOUND';
						returned_tmp:= returned_tmp||id_main_taxon::varchar||'/';
						returned_name:=returned_name||tmp_name_path||'/';
						returned_ids_staging:=returned_ids_staging||array_ids[i]::varchar||'/';
						
						last_id:=array_ids[i];
						staging_path_found:=TRUE;
					END IF;
					IF staging_path_found=TRUE THEN
						IF exclude_invalid_entries=true AND taxon_found_in_staging=false THEN
							
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp AND status !='invalid';
						ELSIF taxon_found_in_staging=false THEN
						
						--raise notice 'returned_tmp : %',returned_tmp; 
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp;
							IF NOT FOUND THEN
								PERFORM id FROM taxonomy WHERE path||id::varchar||'/'LIKE '%'||returned_tmp;
							END IF;
						--ELSE
						--	RAISE NOTICE 'NO check';
						END IF;
						IF FOUND OR taxon_found_in_staging=true THEN
							--RAISE NOTICE 'DEF';
							--parent path found in taxonomy (longest prefix)

							--eg for complete path in staging /97909/97910/97911/97912/97913/97914/97922/ )
							--eg. /1/5/5953/5954/5955/
							returned[1]:=returned_tmp;
							--string trascription of the path
							--eg. /Eucaryota/Animalia/CHORDATA/ACTINOPTERYGII/PERCIFORMES/
							returned[2]:=returned_name;
							--path corresponding to the longest taxonomical prefix with the staging ids
							--/97909/97910/97911/97912/97913/
							returned[3]:=returned_ids_staging;
							--lowest taxon of the path 
							--eg. 97913
							returned[4]:=last_id;
							--path the parents in staging not found in taxonomy (remainded of the longest prefix)
							--eg. /97914/97922/ 
							IF(i<ARRAY_LENGTH(array_ids,1)) THEN
								returned[5]:='/'||array_to_string(array_ids[i+1:ARRAY_LENGTH(array_ids,1)],'/')||'/';
							ELSE
								
								returned[5]:='/';
							END IF;
							--SUBSTRING(array_ids_string FROM  POSITION ('/'||last_id||'/' IN array_ids_string) + LENGTH('/'||last_id));
						ELSE
							--RAISE NOTICE 'EXIT 1';
							RETURN returned;
						END IF;
					ELSE 
						--RAISE NOTICE 'EXIT 2';
						RETURN returned;
					END IF;
				END IF;
				
			END LOOP;
		END IF;
--RAISE NOTICE 'EXIT 3';
	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomyb(id_staging_taxon integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 781 (class 1255 OID 18835)
-- Name: fct_rmca_get_people_name_related_to_specimen(integer, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_people_name_related_to_specimen(integer, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
 returned varchar;
BEGIN
returned:=string_agg(formated_name, ', ' ) FROM  catalogue_people c
   
   LEFT JOIN people p
   ON c.people_ref=p.id
   WHERE c.record_id=$1
   AND c.referenced_relation='specimens' and c.people_type=$2;
   RETURN returned;
   END;
$_$;


ALTER FUNCTION darwin2.fct_rmca_get_people_name_related_to_specimen(integer, character varying) OWNER TO darwin2;

--
-- TOC entry 782 (class 1255 OID 18836)
-- Name: fct_rmca_handle_non_reference_taxonomies(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
		staging_catalogue_line staging_catalogue;
		test_taxo  varchar[];
		higher_found_taxon varchar;
		existing_longest_path varchar;
		existing_longest_path_staging varchar;
		existing_longest_path_array varchar[];
		--marielle adam 2019 02 28
		existing_longest_path_array_no_null varchar[];
		existing_longest_path_staging_array varchar[];
		tmp_staging_id VARCHAR;
		tmp_taxonomy_id VARCHAR;
		is_parent boolean;
		i INTEGER;
		previous_staging_id_as_parent varchar;
		previous_taxonomy_id_as_parent varchar;
		staging_path_to_create_in_taxonomy varchar;
		staging_path_to_create_in_taxonomy_array varchar[];
		tmp_new_parent varchar;
		catalogue_ref_var integer;
		parent_ref_var integer; 
		staging_ref integer;
		parent_updated_var boolean;
		source_text varchar;
		tmp_name varchar;
		tmp_level_ref integer;
		last_id integer;
		parent_ref_var_staging integer;
		--ftheeten 2019 02 15
		staging_levels varchar[];
		--ftheeten 2019 02 15
		taxonomy_levels varchar[];
		--hierarchy_name varchar;
		 _c text;
		 msg varchar;
		 kingdom_id integer;
		 staging_kingdom_id integer;
		 kingdom_name varchar;
		 --kingdom_name varchar;
		 existing_id integer;
		
		
	BEGIN
				--FTHEETEN 2019 02 14
		UPDATE staging_catalogue SET  import_exception=NULL WHERE import_ref=req_import_ref; 
		--UPDATE staging_catalogue SET import_exception='taxon_already_exists_in_taxonomy' FROM taxonomy WHERE staging_catalogue.import_ref=req_import_ref AND fulltoindex(staging_catalogue.name)=taxonomy.name_indexed AND taxonomy.metadata_ref=var_metadata_ref ;
		--raise notice 'enter handle';
		--2019 02 26 create kingdom if not exists
		PERFORM id FROM staging_catalogue WHERE import_ref= req_import_ref AND level_ref=2 ;
		--raise notice '1';
		IF NOT FOUND THEN
raise notice '2';
			SELECT name INTO kingdom_name FROM taxonomy LEFT JOIN imports on taxonomy.id::varchar=imports.taxonomy_kingdom WHERE imports.id=req_import_ref;
			--raise notice '2a';
			SELECT id INTO kingdom_id  FROM taxonomy WHERE metadata_ref=var_metadata_ref AND level_ref=2 AND fulltoindex(name)=fulltoindex(kingdom_name);
			--raise notice '2b';
			IF NOT FOUND THEN
			--raise notice '%', kingdom_name;
				--ATTENTION aT RBINS EUCAROTYA IS -1 INSTEAD oF 1
				INSERT INTO taxonomy (name, level_ref, metadata_ref, parent_ref) VALUES (kingdom_name, 2, var_metadata_ref, 1) RETURNING id INTO kingdom_id;
				raise notice '2c';
			END IF;
			INSERT INTO staging_catalogue (import_ref, name, level_ref, name_cluster, imported) VALUES
				(req_import_ref, kingdom_name, 2, (SELECT MAX(name_cluster::integer)+1 FROM staging_catalogue WHERE import_ref= req_import_ref ), FALSE) RETURNING id INTO staging_kingdom_id;
			RAISE NOTICE 'ADDED KINGDOM';
			UPDATE staging_catalogue SET parent_ref= staging_kingdom_id WHERe parent_ref IS NULL and level_ref>2 AND import_ref=req_import_ref;
		END IF;
		raise notice '3';
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=2 and taxonomy_metadata.id=var_metadata_ref
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=2 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name) AND metadata_ref= var_metadata_ref;
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,2,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
				END IF;
			END LOOP;
		--create phylum beforehand if not exists
		i:=0;

		
		/*FOR staging_catalogue_line IN SELECT staging_catalogue.*, taxonomy_metadata.id as metadata_id FROM staging_catalogue 
		LEFT JOIN imports ON
		staging_catalogue.import_ref=imports.id
		LEFT JOIN taxonomy_metadata
		ON 
		imports.specimen_taxonomy_ref=taxonomy_metadata.id 
		WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE 
		AND 
		--new 2019 02 26
		taxonomy_metadata.id=var_metadata_ref  
		ORDER BY staging_catalogue.level_ref 
		ASC
		, fulltoindex(staging_catalogue.name) ASC
		--LOOP 1			
		LOOP
				raise notice 'in loop';
				raise notice '------------------------------%',(i::varchar);
				raise notice '------------------------------%',(staging_catalogue_line.id::varchar);
				--raise notice 'id %', staging_catalogue_line.id;
				--raise notice 'catalogue_ref %', staging_catalogue_line.catalogue_ref;
				raise notice 'name %', staging_catalogue_line.name;
				
				PERFORM fct_rmca_handle_non_reference_taxonomies_intraloop(staging_catalogue_line.id, var_metadata_ref, req_import_ref, exclude_invalid_entries);
		--END LOOP ONE
		i:=i+1;
		END LOOP;*/
		PERFORM fct_importer_catalogue_reference_taxonomy_logic_non_reference(req_import_ref , var_metadata_ref , exclude_invalid_entries );
		--RAISE NOTICE 'exit';

		/*UPDATE staging_catalogue
		SET import_exception=COALESCE(import_exception, 'taxon_already_exists_in_taxonomy')
			FROM taxonomy
			LEFT JOIN taxonomy_metadata
			ON taxonomy.metadata_ref=taxonomy_metadata.id
			 WHERE  
			staging_catalogue.catalogue_ref=taxonomy.id AND staging_catalogue.import_ref=req_import_ref AND imported=FALSE AND catalogue_ref IS NOT NULL
			--new 2019 02 26
			AND taxonomy.metadata_ref=var_metadata_ref;
		UPDATE staging_catalogue
		SET import_exception=COALESCE(import_exception, 'could_not_link_taxon_check_upper_ranks')			
			WHERE staging_catalogue.import_ref=req_import_ref AND imported=FALSE AND import_exception IS NULL;*/
					
		RETURN TRUE;
	EXCEPTION WHEN OTHERS THEN
		RAISE NOTICE 'EXCEPTION';
		RAISE NOTICE '% %', SQLERRM, SQLSTATE;
	        --GET STACKED DIAGNOSTICS _c = PG_EXCEPTION_CONTEXT;
		--RAISE NOTICE 'context: >>%<<', _c;
		UPDATE imports SET state='error', errors_in_import=SQLERRM  WHERE id=req_import_ref;
		RETURN FALSE;
	END;
	$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 783 (class 1255 OID 18839)
-- Name: fct_rmca_handle_non_reference_taxonomies_bck20190326(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_bck20190326(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
		staging_catalogue_line staging_catalogue;
		test_taxo  varchar[];
		higher_found_taxon varchar;
		existing_longest_path varchar;
		existing_longest_path_staging varchar;
		existing_longest_path_array varchar[];
		--marielle adam 2019 02 28
		existing_longest_path_array_no_null varchar[];
		existing_longest_path_staging_array varchar[];
		tmp_staging_id VARCHAR;
		tmp_taxonomy_id VARCHAR;
		is_parent boolean;
		i INTEGER;
		previous_staging_id_as_parent varchar;
		previous_taxonomy_id_as_parent varchar;
		staging_path_to_create_in_taxonomy varchar;
		staging_path_to_create_in_taxonomy_array varchar[];
		tmp_new_parent varchar;
		catalogue_ref_var integer;
		parent_ref_var integer; 
		staging_ref integer;
		parent_updated_var boolean;
		source_text varchar;
		tmp_name varchar;
		tmp_level_ref integer;
		last_id integer;
		parent_ref_var_staging integer;
		--ftheeten 2019 02 15
		staging_levels varchar[];
		--ftheeten 2019 02 15
		taxonomy_levels varchar[];
		--hierarchy_name varchar;
		 _c text;
		 msg varchar;
		 kingdom_id integer;
		 staging_kingdom_id integer;
		 kingdom_name varchar;
		 --kingdom_name varchar;
		 existing_id integer;
		
		
	BEGIN
				--FTHEETEN 2019 02 14
		UPDATE staging_catalogue SET  import_exception=NULL WHERE import_ref=req_import_ref; 
		--UPDATE staging_catalogue SET import_exception='taxon_already_exists_in_taxonomy' FROM taxonomy WHERE staging_catalogue.import_ref=req_import_ref AND fulltoindex(staging_catalogue.name)=taxonomy.name_indexed AND taxonomy.metadata_ref=var_metadata_ref ;
		--raise notice 'enter handle';
		--2019 02 26 create kingdom if not exists
		PERFORM id FROM staging_catalogue WHERE import_ref= req_import_ref AND level_ref=2 ;
		--raise notice '1';
		IF NOT FOUND THEN
raise notice '2';
			SELECT name INTO kingdom_name FROM taxonomy LEFT JOIN imports on taxonomy.id::varchar=imports.taxonomy_kingdom WHERE imports.id=req_import_ref;
			--raise notice '2a';
			SELECT id INTO kingdom_id  FROM taxonomy WHERE metadata_ref=var_metadata_ref AND level_ref=2 AND fulltoindex(name)=fulltoindex(kingdom_name);
			--raise notice '2b';
			IF NOT FOUND THEN
			--raise notice '%', kingdom_name;
				--ATTENTION aT RBINS EUCAROTYA IS -1 INSTEAD oF 1
				INSERT INTO taxonomy (name, level_ref, metadata_ref, parent_ref) VALUES (kingdom_name, 2, var_metadata_ref, 1) RETURNING id INTO kingdom_id;
				raise notice '2c';
			END IF;
			INSERT INTO staging_catalogue (import_ref, name, level_ref, name_cluster, imported) VALUES
				(req_import_ref, kingdom_name, 2, (SELECT MAX(name_cluster::integer)+1 FROM staging_catalogue WHERE import_ref= req_import_ref ), FALSE) RETURNING id INTO staging_kingdom_id;
			RAISE NOTICE 'ADDED KINGDOM';
			UPDATE staging_catalogue SET parent_ref= staging_kingdom_id WHERe parent_ref IS NULL and level_ref>2 AND import_ref=req_import_ref;
		END IF;
		raise notice '3';
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=2 and taxonomy_metadata.id=var_metadata_ref
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=2 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name) AND metadata_ref= var_metadata_ref;
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,2,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
				END IF;
			END LOOP;
		--create phylum beforehand if not exists
		i:=0;
		--ftheeten 2018 12 14
		/*FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=4 and taxonomy_metadata.id=var_metadata_ref
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=4 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name) AND metadata_ref= var_metadata_ref;
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,4,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
				END IF;
			END LOOP;

                */
		
		
		FOR staging_catalogue_line IN SELECT staging_catalogue.*, taxonomy_metadata.id as metadata_id FROM staging_catalogue 
		LEFT JOIN imports ON
		staging_catalogue.import_ref=imports.id
		LEFT JOIN taxonomy_metadata
		ON 
		imports.specimen_taxonomy_ref=taxonomy_metadata.id 
		WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE 
		AND 
		--new 2019 02 26
		taxonomy_metadata.id=var_metadata_ref  
		ORDER BY staging_catalogue.level_ref 
		DESC
		, fulltoindex(staging_catalogue.name) ASC
		--LOOP 1			
		LOOP
				raise notice 'in loop';
				raise notice '------------------------------%',(i::varchar);
				raise notice '------------------------------%',(staging_catalogue_line.id::varchar);
				--raise notice 'id %', staging_catalogue_line.id;
				--raise notice 'catalogue_ref %', staging_catalogue_line.catalogue_ref;
				raise notice 'name %', staging_catalogue_line.name;
				--take only not yet updated lines into considerations 
				--(attention this field can bbe updated from within the cursor) !

				--IF ONE
				IF staging_catalogue_line.catalogue_ref IS NULL AND staging_catalogue_line.parent_updated = FALSE THEN

					--FTHEETEN 2019 02 14


					
 					RAISE NOTICE 'try import';
					raise notice 'line id=%',staging_catalogue_line.id ;
					raise notice 'test %',staging_catalogue_line.id;
					SELECT fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy INTO test_taxo FROM fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(staging_catalogue_line.id);
					existing_longest_path=test_taxo[1];
					existing_longest_path_staging=test_taxo[3];
					higher_found_taxon=test_taxo[4];
					staging_levels=string_to_array(test_taxo[6], '/');
					taxonomy_levels=string_to_array(test_taxo[7], '/');
					existing_longest_path_array=string_to_array( existing_longest_path, '/');
					existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');

					RAISE NOTICE 'Existing longest path %', existing_longest_path; 
					RAISE NOTICE 'Existing longest path staging %', existing_longest_path_staging;
					RAISE NOTICE 'Higher found taxon %', higher_found_taxon;
					RAISE NOTICE 'Staging level path %', staging_levels;
					RAISE NOTICE 'Taxonomy level path %', taxonomy_levels;
					--IF TWO 
					IF higher_found_taxon::varchar= staging_catalogue_line.id::varchar THEN
						RAISE notice 'taxon found !';
						--whole taxonomic path already in taxonomy
						--update parent_ref and catalogue_ref for the whole path
						--IF THIRD
						existing_longest_path_array_no_null:=fct_remove_null_array_elem(existing_longest_path_array);
						--SELECT taxonomy_name INTO hierarchy_name FROM taxonomy_metadata WHERE taxonomy_metadata.id=(SELECT taxonomy.metadata_ref FROM taxonomy WHERE taxonomy.id::varchar= existing_longest_path_array_no_null[ARRAY_LENGTH(existing_longest_path_array_no_null,1)]) LIMIT 1;
						RAISE NOTICE 'taxonomy of taxon %',  fct_remove_null_array_elem(existing_longest_path_array); 
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
							is_parent:=TRUE;
							--LOOP 2
							FOR i IN  1..ARRAY_LENGTH(existing_longest_path_staging_array,1) LOOP
								tmp_taxonomy_id:=existing_longest_path_array[i];
								tmp_staging_id:=existing_longest_path_staging_array[i];
								--IF FOUR
								If LENGTH(TRIM(tmp_taxonomy_id))>0 AND LENGTH(trim(tmp_staging_id))>0
								AND staging_levels[i]= taxonomy_levels[i]
								 THEN
									--IF FIVE
									IF is_parent=TRUE THEN
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer , import_exception=COALESCE(import_exception,'')||'msg1'  WHERE id=tmp_staging_id::int AND catalogue_Ref IS NULL; -- staging_catalogue_line.id;								
									--ELSE FIVE	
									ELSE
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer, parent_updated=true, parent_ref=previous_taxonomy_id_as_parent::integer, import_exception=COALESCE(import_exception,'')||'msg2'  WHERE id= tmp_staging_id::int  AND catalogue_Ref IS NULL;--staging_catalogue_line.id;
									--END IF FIVE		
									END IF;
									--MENTION source in the original taxonomy
									--UPDATE taxonomy SET source=TRIM(COALESCE(source,'')||'; '||staging_catalogue_line.source_taxonomy) WHERE id=tmp_taxonomy_id::integer;
									is_parent:=FALSE;
									previous_staging_id_as_parent:=tmp_staging_id::int;--staging_catalogue_line.id;
									previous_taxonomy_id_as_parent:=tmp_taxonomy_id;
								--END IF FOUR
								END IF;
							--END LOOP 2	
							END LOOP;
						--END IF THIRD	
						--ftheeten 2019 02 18
						--RAISE notice 'TRY 1 % %',  staging_catalogue_line.id, hierarchy_name;
							--UPDATE staging_catalogue SET import_exception = 'taxon_already_exists (check '||hierarchy_name||')' WHERE id= staging_catalogue_line.id;
						--ELSE
						--RAISE notice 'TRY 2';
							--ftheeten 2019 02 18
							--UPDATE staging_catalogue SET import_exception = 'taxon_already_exists (check '||hierarchy_name||')' WHERE id= staging_catalogue_line.id;
						END IF;
						--lowest taxon is not in taxonomy
					--END IF TWO
					ELSE
						RAISE notice 'taxon to be created %', staging_catalogue_line.name;
						--take part of path which is already in taxonomy
						--(longest prefix)
						--existing_longest_path=test_taxo[1];
						--existing_longest_path_staging=test_taxo[3];
						--higher_found_taxon=test_taxo[4];
						staging_path_to_create_in_taxonomy=test_taxo[5];
						--RAISE NOTICE 'staging path to create in taxonomy (all) %' , test_taxo;  
						--RAISE NOTICE 'staging path to create in taxonomy %' , test_taxo[5];  
						--first create exisint hierarchy 
						--create taxon in taxonomy and keep id
						--update parent_ref and catalogue_ref

						existing_longest_path_array=string_to_array( existing_longest_path, '/');
						existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
						staging_path_to_create_in_taxonomy_array=string_to_array(staging_path_to_create_in_taxonomy, '/');	
						--IF THIRD B	
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
						
						parent_updated_var:=false;
						--existing taxa
							--LOOP 3
							FOR i IN   1 .. ARRAY_LENGTH( existing_longest_path_array,1) LOOP
								--IF FOUR B
								IF LENGTH(TRIM(existing_longest_path_array[i]))>0 AND LENGTH(TRIM(existing_longest_path_staging_array[i]))>0 THEN
									--RAISE NOTICE 'IN IF';
									catalogue_ref_var:=existing_longest_path_array[i]::int;
									staging_ref:=existing_longest_path_staging_array[i]::int;
									RAISE NOTICE 'catalogue_ref_var %', catalogue_ref_var;
									RAISE NOTICE 'staging_ref %', staging_ref;
									--IF FIVE B
									IF parent_updated_var=false THEN
										--RAISE NOTICE 'UPDATE NO PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var,  import_exception=COALESCE(import_exception,'')||'msg3'||' - '|| existing_longest_path_array::varchar || ' - '||existing_longest_path_staging_array::varchar ||' - '||staging_levels::varchar||' - '||taxonomy_levels::varchar 
										WHERE id=staging_ref AND parent_updated=false AND parent_ref IS NULL  and catalogue_Ref IS NULL;
									--ELSE FIVE B
									ELSE
										--RAISE NOTICE 'UPDATE  PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var,
										parent_ref=parent_ref_var, parent_updated=true,
										 import_exception=COALESCE(import_exception,'')||'msg4'||' - '|| existing_longest_path_array::varchar || ' - '||existing_longest_path_staging_array::varchar||' - '||staging_levels::varchar||' - '||taxonomy_levels::varchar 
										WHERE id=staging_ref and parent_updated=false and catalogue_Ref IS NULL;
									--END IF FIVE B
									END IF;
									parent_updated_var:=true;
									parent_ref_var:=catalogue_ref_var;
									--update source in taxonomy
									--UPDATe taxonomy SET source=COALESCE(source||', '||source_text) WHERE id=catalogue_ref_var;
									--RAISE notice 'parent_ref_var %', parent_ref_var;
								--END IF FOUR B
								END IF;
							--END LOOP 3	
							END LOOP;
						--create new taxa
						raise notice 'To create array %', staging_path_to_create_in_taxonomy_array; 
						raise notice 'length array %' , ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1);
						--RAISE notice 'parent_ref_var between loops %', parent_ref_var;
							--LOOP 3 B
							FOR i IN  1..ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1) LOOP
							
								RAISE NOTICE 'IN LOOP NEW TAXA';
								--IF FOUR C
								IF LENGTH(TRIM(staging_path_to_create_in_taxonomy_array[i]))>0 THEN

								--raise notice 'new taxa id %', staging_path_to_create_in_taxonomy_array[i];
								
									--IMPORTANT CALCULATION OF PARENT OF TAXON
									--2019 03 25 : parent_ref_internal instead into parent_ref
									SELECT name , level_ref, parent_ref_internal INTO tmp_name, tmp_level_ref, parent_ref_var_staging FROM staging_catalogue WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									SELECT catalogue_ref INTO parent_ref_var FROM staging_catalogue WHERe id=parent_ref_var_staging;
									RAISE NOTICE 'TEST %', tmp_name;
									--IF FIVE C
									IF parent_updated_var=false AND parent_ref_var IS NULL THEN 
									BEGIN
										RAISE NOTICE 'AA';	
										--raise notice 'tmp_name %', tmp_name;
										SELECT id INTO existing_id FROM taxonomy WHERe name=tmp_name AND  level_ref=tmp_level_ref  AND metadata_ref=var_metadata_ref;
										IF NOT FOUND THEN
											RAISE NOTICE 'CREATE %', tmp_name;

											INSERT INTO taxonomy (id, name, level_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
											tmp_name, tmp_level_ref, var_metadata_ref, req_import_ref) 
											RETURNING id INTO last_id;
											RAISE NOTICE 'INSERTED_ID=%', last_id;
											UPDATE staging_catalogue SET catalogue_ref=last_id, imported=true
											FROM inserted WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										--raise notice 'last_id A %', last_id;
											parent_ref_var:=last_id;
										ELSE
											RAISE NOTICE 'HIERARCHY EXISTS !!!!!!!!!!!!!!!!!!!!!';
											UPDATE staging_catalogue SET imported=FALSE,
											import_exception=COALESCE(import_exception,'path_already_exists (Hierarchy)')
											
											WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										END IF;
									EXCEPTION WHEN OTHERS THEN
										RAISE NOTICE 'XXXXXXXXXXXXXXX EXCEPTION';
										UPDATE staging_catalogue SET import_exception= SQLERRM WHERE staging_catalogue.id=staging_path_to_create_in_taxonomy_array[i]::int;
									END;
									--ELSIF FIVE C
									ELSE --IF parent_ref_var IS NOT NULL THEN
									BEGIN
										RAISE NOTICE 'BB';	
										SELECT id INTO existing_id FROM taxonomy WHERe name=tmp_name AND  level_ref=tmp_level_ref --AND parent_ref=parent_ref_var 
AND metadata_ref=var_metadata_ref;
										IF NOT FOUND THEN
											--raise notice 'tmp_name %', tmp_name;
											--raise notice 'tmp_level_ref %', tmp_level_ref;
											--raise notice 'parent_ref_var %', parent_ref_var;
											--raise notice 'source_text %', source_text;
											RAISE NOTICE 'INSERT %' , tmp_name;
											INSERT INTO taxonomy (id, name, level_ref, parent_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
											tmp_name, tmp_level_ref, parent_ref_var,  var_metadata_ref, req_import_ref) RETURNING id INTO last_id;
											RAISE NOTICE 'INSERTED_ID=%', last_id;
											/*IF staging_levels != taxonomy_levels THEN
												UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true , import_exception = 'taxon_already_exists_with_another_hierarchy' WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											ELSE
											
												UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											END IF;*/
											UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true , import_exception = 'taxon_imported' WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											--raise notice 'last_id B %', last_id;
											 parent_ref_var:=last_id; 
										ELSE
											UPDATE staging_catalogue SET imported=FALSE,
											import_exception=COALESCE(import_exception,'path_already_exists'), catalogue_ref=existing_id WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											--raise notice 'last_id B %', last_id;
											 
										END IF;
									--END IF FIVE C
									EXCEPTION WHEN OTHERS THEN
										RAISE NOTICE '!!!!!!EXCEPTION!!!!!!!!!!!!!!!!!!';
										RAISE NOTICE '%' ,SQLERRM;
										UPDATE staging_catalogue SET import_exception= COALESCE(import_exception,'')|| SQLERRM WHERE staging_catalogue.id=staging_path_to_create_in_taxonomy_array[i]::int;
									END;
									--ELSE
									--RAISE NOTICE 'CC';
									END IF;
								--END IF FOUR C	
								END IF;
							--END LOOP 3 B	
							END LOOP;
						--END IF THIRD B
						END IF;
					--END IF TWO 	
					END IF;
				ELSE --IF ONE	
				--ELSIF staging_catalogue_line.catalogue_ref IS NOT NULL AND staging_catalogue_line.parent_updated = FALSE THEN
				--partially updated
					raise notice 'else 2';
				--END IF ONE
				END IF;
		--END LOOP ONE
		i:=i+1;
		END LOOP;
		--RAISE NOTICE 'exit';

		UPDATE staging_catalogue
		SET import_exception=COALESCE(import_exception, 'taxon_already_exists_in_taxonomy')
			FROM taxonomy
			LEFT JOIN taxonomy_metadata
			ON taxonomy.metadata_ref=taxonomy_metadata.id
			 WHERE  
			staging_catalogue.catalogue_ref=taxonomy.id AND staging_catalogue.import_ref=req_import_ref AND imported=FALSE AND catalogue_ref IS NOT NULL
			--new 2019 02 26
			AND taxonomy.metadata_ref=var_metadata_ref;
		UPDATE staging_catalogue
		SET import_exception=COALESCE(import_exception, 'could_not_link_taxon_check_upper_ranks')			
			WHERE staging_catalogue.import_ref=req_import_ref AND imported=FALSE AND import_exception IS NULL;
					
		RETURN TRUE;
	EXCEPTION WHEN OTHERS THEN
		RAISE NOTICE 'EXCEPTION';
		RAISE NOTICE '% %', SQLERRM, SQLSTATE;
	        --GET STACKED DIAGNOSTICS _c = PG_EXCEPTION_CONTEXT;
		--RAISE NOTICE 'context: >>%<<', _c;
		UPDATE imports SET state='error', errors_in_import=SQLERRM  WHERE id=req_import_ref;
		RETURN FALSE;
	END;
	$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_bck20190326(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 784 (class 1255 OID 18842)
-- Name: fct_rmca_handle_non_reference_taxonomies_bck_ftheeten2018114_ba(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_bck_ftheeten2018114_ba(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
		staging_catalogue_line staging_catalogue;
		test_taxo  varchar[];
		higher_found_taxon varchar;
		existing_longest_path varchar;
		existing_longest_path_staging varchar;
		existing_longest_path_array varchar[];
		existing_longest_path_staging_array varchar[];
		tmp_staging_id VARCHAR;
		tmp_taxonomy_id VARCHAR;
		is_parent boolean;
		i INTEGER;
		previous_staging_id_as_parent varchar;
		previous_taxonomy_id_as_parent varchar;
		staging_path_to_create_in_taxonomy varchar;
		staging_path_to_create_in_taxonomy_array varchar[];
		tmp_new_parent varchar;
		catalogue_ref_var integer;
		parent_ref_var integer; 
		staging_ref integer;
		parent_updated_var boolean;
		source_text varchar;
		tmp_name varchar;
		tmp_level_ref integer;
		last_id integer;
		parent_ref_var_staging integer;
		
	BEGIN
		raise notice 'enter handle';
		--SELECT source_taxonomy INTO source_text FROM imports WHERE id=req_import_ref;
		--browse from lowsert level first
		--LOOP 1
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue 
		LEFT JOIN imports ON
		staging_catalogue.import_ref=imports.id
		LEFT JOIN taxonomy_metadata
		ON 
		imports.specimen_taxonomy_ref=taxonomy_metadata.id 
		WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE ORDER BY staging_catalogue.level_ref DESC, fulltoindex(staging_catalogue.name) ASC
		--LOOP 1	
		LOOP
			raise notice 'in loop';
			raise notice '------------------------------';
			raise notice '%', staging_catalogue_line.id;
			raise notice '%', staging_catalogue_line.catalogue_ref;
			raise notice '%', staging_catalogue_line.name;
			--take only not yet updated lines into considerations 
			--(attention this field can bbe updated from within the cursor) !
			
			--IF ONE
			IF staging_catalogue_line.catalogue_ref IS NULL AND staging_catalogue_line.parent_updated = FALSE THEN
				RAISE NOTICE 'try import';
				raise notice 'line id=%',staging_catalogue_line.id ;
				raise notice 'test %',staging_catalogue_line.id;
				SELECT fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy INTO test_taxo FROM fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(staging_catalogue_line.id);
				existing_longest_path=test_taxo[1];
				existing_longest_path_staging=test_taxo[3];
				higher_found_taxon=test_taxo[4];
				existing_longest_path_array=string_to_array( existing_longest_path, '/');
				existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
				--raise notice '1';
				RAISE NOTICE 'Existing longest path %', existing_longest_path; 
				RAISE NOTICE 'Existing longest path staging %', existing_longest_path_staging;
				RAISE NOTICE 'Higher found taxon %', higher_found_taxon;
				--IF TWO 
				IF higher_found_taxon::varchar= staging_catalogue_line.id::varchar THEN
					RAISE notice 'taxon found';
					--whole taxonomic path already in taxonomy
					--update parent_ref and catalogue_ref for the whole path
					--IF THIRD
					IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
						is_parent:=TRUE;
						--LOOP 2
						FOR i IN  1..ARRAY_LENGTH(existing_longest_path_staging_array,1) LOOP
							tmp_taxonomy_id:=existing_longest_path_array[i];
							tmp_staging_id:=existing_longest_path_staging_array[i];
							--IF FOUR
							If LENGTH(TRIM(tmp_taxonomy_id))>0 AND LENGTH(trim(tmp_staging_id))>0 THEN
								--IF FIVE
								IF is_parent=TRUE THEN
									UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer WHERE id= staging_catalogue_line.id;								
								--ELSE FIVE	
								ELSE
									UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer, parent_updated=true, parent_ref=previous_taxonomy_id_as_parent::integer WHERE id= staging_catalogue_line.id;
								--END IF FIVE		
								END IF;
								--MENTION source in the original taxonomy
								--UPDATE taxonomy SET source=TRIM(COALESCE(source,'')||'; '||staging_catalogue_line.source_taxonomy) WHERE id=tmp_taxonomy_id::integer;
								is_parent:=FALSE;
								previous_staging_id_as_parent:=staging_catalogue_line.id;
								previous_taxonomy_id_as_parent:=tmp_taxonomy_id;
							--END IF FOUR
							END IF;
						--END LOOP 2	
						END LOOP;
					--END IF THIRD	
					END IF;
					--lowest taxon is not in taxonomy
				--END IF TWO
				ELSE
					--RAISE notice 'taxon to be created %', staging_catalogue_line.name;
					--take part of path which is already in taxonomy
					--(longest prefix)
					--existing_longest_path=test_taxo[1];
					--existing_longest_path_staging=test_taxo[3];
					--higher_found_taxon=test_taxo[4];
					staging_path_to_create_in_taxonomy=test_taxo[5];
					--RAISE NOTICE 'staging path to create in taxonomy (all) %' , test_taxo;  
					--RAISE NOTICE 'staging path to create in taxonomy %' , test_taxo[5];  
					--first create exisint hierarchy 
					--create taxon in taxonomy and keep id
					--update parent_ref and catalogue_ref

					existing_longest_path_array=string_to_array( existing_longest_path, '/');
					existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
					staging_path_to_create_in_taxonomy_array=string_to_array(staging_path_to_create_in_taxonomy, '/');	
					--IF THIRD B	
					IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
					
					parent_updated_var:=false;
					--existing taxa
						--LOOP 3
						FOR i IN   1 .. ARRAY_LENGTH( existing_longest_path_array,1) LOOP
							--IF FOUR B
							IF LENGTH(TRIM(existing_longest_path_array[i]))>0 AND LENGTH(TRIM(existing_longest_path_staging_array[i]))>0 THEN
								--RAISE NOTICE 'IN IF';
								catalogue_ref_var:=existing_longest_path_array[i]::int;
								staging_ref:=existing_longest_path_staging_array[i]::int;
								--RAISE NOTICE 'catalogue_ref_var %', catalogue_ref_var;
								--RAISE NOTICE 'staging_ref %', staging_ref;
								--IF FIVE B
								IF parent_updated_var=false THEN
									--RAISE NOTICE 'UPDATE NO PARENT';
									UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var
									WHERE id=staging_ref AND parent_updated=false AND parent_ref IS NULL;
								--ELSE FIVE B
								ELSE
									--RAISE NOTICE 'UPDATE  PARENT';
									UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var,
									parent_ref=parent_ref_var, parent_updated=true
									WHERE id=staging_ref and parent_updated=false;
								--END IF FIVE B
								END IF;
								parent_updated_var:=true;
								parent_ref_var:=catalogue_ref_var;
								--update source in taxonomy
								--UPDATe taxonomy SET source=COALESCE(source||', '||source_text) WHERE id=catalogue_ref_var;
								--RAISE notice 'parent_ref_var %', parent_ref_var;
							--END IF FOUR B
							END IF;
						--END LOOP 3	
						END LOOP;
					--create new taxa
					--raise notice 'To create array %', staging_path_to_create_in_taxonomy_array; 
					--raise notice 'length array %' , ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1);
					--RAISE notice 'parent_ref_var between loops %', parent_ref_var;
						--LOOP 3 B
						FOR i IN  1..ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1) LOOP
						
							--RAISE NOTICE 'IN LOOP NEW TAXA';
							--IF FOUR C
							IF LENGTH(TRIM(staging_path_to_create_in_taxonomy_array[i]))>0 THEN

							--raise notice 'new taxa id %', staging_path_to_create_in_taxonomy_array[i];
								SELECT name , level_ref, parent_ref INTO tmp_name, tmp_level_ref, parent_ref_var_staging FROM staging_catalogue WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
								SELECT catalogue_ref INTO parent_ref_var FROM staging_catalogue WHERe id=parent_ref_var_staging;
								--IF FIVE C
								IF parent_updated_var=false AND parent_ref_var IS NULL THEN 
									--raise notice 'tmp_name %', tmp_name;
									INSERT INTO taxonomy (id, name, level_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
									tmp_name, tmp_level_ref, var_metadata_ref, req_import_ref) 
									RETURNING id INTO last_id;
									UPDATE staging_catalogue SET catalogue_ref=last_id
									FROM inserted WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									--raise notice 'last_id A %', last_id;
									 parent_ref_var:=last_id;
								--ELSIF FIVE C
								ELSIF parent_ref_var IS NOT NULL THEN
									--raise notice 'tmp_name %', tmp_name;
									--raise notice 'tmp_level_ref %', tmp_level_ref;
									--raise notice 'parent_ref_var %', parent_ref_var;
									--raise notice 'source_text %', source_text;
									INSERT INTO taxonomy (id, name, level_ref, parent_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
									tmp_name, tmp_level_ref, parent_ref_var,  var_metadata_ref, req_import_ref) RETURNING id INTO last_id;
									UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									--raise notice 'last_id B %', last_id;
									 parent_ref_var:=last_id; 
								--END IF FIVE C
								END IF;
							--END IF FOUR C	
							END IF;
						--END LOOP 3 B	
						END LOOP;
					--END IF THIRD B
					END IF;
				--END IF TWO 	
				END IF;
			--ELSE IF ONE	
			--ELSIF staging_catalogue_line.catalogue_ref IS NOT NULL AND staging_catalogue_line.parent_updated = FALSE THEN
			--partially updated
				--raise notice 'Catalogue_updated';
			--END IF ONE
			END IF;
		--END LOOP ONE
		END LOOP;
		--RAISE NOTICE 'exit';
		RETURN TRUE;
	END;
	$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_bck_ftheeten2018114_ba(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1555 (class 1255 OID 18845)
-- Name: fct_rmca_handle_non_reference_taxonomies_intraloop(integer, integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_intraloop(id_staging_taxon integer, var_metadata_ref integer, var_import_ref integer, exclude_invalid_entries boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned boolean;
 returned_tmp varchar;
 parent_updated_tmp boolean;
 tmp_id integer;
 parent integer;
 i integer;
 name_tmp varchar;
 level_of_parent_staging integer;
 catalogue_ref_tmp integer;
 import_ref_tmp integer;

 taxonomy_id integer;
 taxonomy_parent_id integer;

 level_name_staging_tmp varchar;
 level_name_darwin_tmp varchar;
 darwin_hierarchy_tmp varchar;
 staging_hierarchy_tmp varchar;

BEGIN
--raise notice 'ENTRY';
	returned := false;
	SELECT parent_updated INTO parent_updated_tmp FROM  staging_catalogue WHERE id=tmp_id;
	IF parent_updated_tmp=true THEN
		return NULL;
	END IF;
	RAISE NOTICE 'GO';
		tmp_id:= id_staging_taxon;
		
		parent:=tmp_id;
		i=1;
		staging_hierarchy_tmp='';
		darwin_hierarchy_tmp='';
		WHILE parent is not null and i< 70 LOOP
			BEGIN
				SELECT parent_ref_internal, name, level_ref, catalogue_ref, import_ref, level_name  INTO parent, name_tmp, level_of_parent_staging , catalogue_ref_tmp, import_ref_tmp, level_name_staging_tmp FROM staging_catalogue LEFT JOIN catalogue_levels ON staging_catalogue.level_ref= catalogue_levels.id WHERE staging_catalogue.id=tmp_id --and catalogue_ref is NULL 
				LIMIT 1;
				RAISE NOTICE 'loop';
				
				staging_hierarchy_tmp=name_tmp||' ('||level_name_staging_tmp||')/'||staging_hierarchy_tmp;
				IF catalogue_ref_tmp IS NOT NULL THEN			
					UPDATE staging_catalogue SET import_exception='taxon_already_exists_in_taxonomy' , staging_hierarchy=staging_hierarchy_tmp, darwin_hierarchy=darwin_hierarchy_tmp WHERE id=tmp_id;
					--UPDATE children
					UPDATE staging_catalogue SET parent_ref=catalogue_ref_tmp , parent_updated=true WHERE import_ref=var_import_ref AND parent_ref_internal=tmp_id;
				ELSE
					IF exclude_invalid_entries IS TRUE THEN
						SELECT taxonomy.id , parent_ref, level_name  INTO taxonomy_id , taxonomy_parent_id , level_name_darwin_tmp FROM taxonomy LEFT JOIN catalogue_levels ON taxonomy.level_ref= catalogue_levels.id WHERE fulltoindex(name) = fulltoindex(name_tmp) AND level_ref=level_of_parent_staging  AND metadata_ref = var_metadata_ref AND status ='valid';
					ELSE
						SELECT taxonomy.id , parent_ref, level_name  INTO taxonomy_id , taxonomy_parent_id, level_name_darwin_tmp FROM taxonomy LEFT JOIN catalogue_levels ON taxonomy.level_ref= catalogue_levels.id WHERE fulltoindex(name) = fulltoindex(name_tmp) AND level_ref=level_of_parent_staging  AND metadata_ref = var_metadata_ref;
					END IF;
					darwin_hierarchy_tmp=name_tmp||' ('||level_name_darwin_tmp||')/'||darwin_hierarchy_tmp;
					IF FOUND THEN
						--UPDATE
						UPDATE staging_catalogue SET catalogue_ref= taxonomy_id , parent_ref= taxonomy_parent_id , parent_updated=true, import_exception='taxon_already_exists_in_taxonomy', staging_hierarchy=staging_hierarchy_tmp, darwin_hierarchy=darwin_hierarchy_tmp WHERE id=tmp_id;
						--UPDATE children
						UPDATE staging_catalogue SET parent_ref=taxonomy_id , parent_updated=true WHERE import_ref=var_import_ref AND parent_ref_internal=tmp_id;
					ELSE
						--TRY INSERT

						--FIND parent
						SELECT parent_ref INTO taxonomy_parent_id FROM staging_catalogue WHERE id= parent AND parent_updated=TRUE;
						IF FOUND THEN
							--CONFIRM INSERTION
							INSERT INTO taxonomy (id, name, level_ref, parent_ref,  metadata_ref, import_ref) 
							VALUES 
							(DEFAULT,name_tmp, level_of_parent_staging, taxonomy_parent_id, var_metadata_ref, var_import_ref) 
							RETURNING id INTO taxonomy_id;
							UPDATE staging_catalogue SET catalogue_ref= taxonomy_id , parent_ref= taxonomy_parent_id , parent_updated=true, imported=true, staging_hierarchy=staging_hierarchy_tmp, darwin_hierarchy=darwin_hierarchy_tmp , import_exception='taxon_imported' WHERE id=tmp_id;
							RAISE NOTICE '°°°°°°°°IMPORTED°°°°°°°°°°°°°°';
							returned:=TRUE;
						ELSE
							UPDATE staging_catalogue SET  import_exception='could_not_link_taxon_check_upper_ranks' WHERE id=tmp_id;
						END IF;
						
					END IF;
				END IF;
				EXCEPTION WHEN OTHERS THEN
					RAISE NOTICE 'EXCEPTION !!!';
					RAISE NOTICE '%',  SQLERRM;
					UPDATE staging_catalogue SET import_exception= COALESCE(import_exception,'')|| SQLERRM WHERE staging_catalogue.id=tmp_id;
				END;
				IF parent is not null THEN
					tmp_id:=parent;
				END IF;
				i:=i+1;
		END LOOP;
					
	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_intraloop(id_staging_taxon integer, var_metadata_ref integer, var_import_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1556 (class 1255 OID 18846)
-- Name: fct_rmca_handle_non_reference_taxonomiesbck20190319(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomiesbck20190319(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
		staging_catalogue_line staging_catalogue;
		test_taxo  varchar[];
		higher_found_taxon varchar;
		existing_longest_path varchar;
		existing_longest_path_staging varchar;
		existing_longest_path_array varchar[];
		existing_longest_path_staging_array varchar[];
		tmp_staging_id VARCHAR;
		tmp_taxonomy_id VARCHAR;
		is_parent boolean;
		i INTEGER;
		previous_staging_id_as_parent varchar;
		previous_taxonomy_id_as_parent varchar;
		staging_path_to_create_in_taxonomy varchar;
		staging_path_to_create_in_taxonomy_array varchar[];
		tmp_new_parent varchar;
		catalogue_ref_var integer;
		parent_ref_var integer; 
		staging_ref integer;
		parent_updated_var boolean;
		source_text varchar;
		tmp_name varchar;
		tmp_level_ref integer;
		last_id integer;
		parent_ref_var_staging integer;
		
		
	BEGIN
		--raise notice 'enter handle';

		--create phylum beforehand if not exists
		--ftheeten 2018 12 14
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=4
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=4 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name);
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,4,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
				END IF;
			END LOOP;
		
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue 
		LEFT JOIN imports ON
		staging_catalogue.import_ref=imports.id
		LEFT JOIN taxonomy_metadata
		ON 
		imports.specimen_taxonomy_ref=taxonomy_metadata.id 
		WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE ORDER BY staging_catalogue.level_ref DESC
		, fulltoindex(staging_catalogue.name) ASC
		--LOOP 1	
		LOOP
			--raise notice 'in loop';
			--raise notice '------------------------------';
			--raise notice 'id %', staging_catalogue_line.id;
			--raise notice 'catalogue_ref %', staging_catalogue_line.catalogue_ref;
			--raise notice 'name %', staging_catalogue_line.name;
			--take only not yet updated lines into considerations 
			--(attention this field can bbe updated from within the cursor) !

			--IF ONE
			IF staging_catalogue_line.catalogue_ref IS NULL AND staging_catalogue_line.parent_updated = FALSE THEN
				--RAISE NOTICE 'try import';
				--raise notice 'line id=%',staging_catalogue_line.id ;
				--raise notice 'test %',staging_catalogue_line.id;
				SELECT fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy INTO test_taxo FROM fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(staging_catalogue_line.id);
				existing_longest_path=test_taxo[1];
				existing_longest_path_staging=test_taxo[3];
				higher_found_taxon=test_taxo[4];
				existing_longest_path_array=string_to_array( existing_longest_path, '/');
				existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
				--raise notice '1';
				--RAISE NOTICE 'Existing longest path %', existing_longest_path; 
				--RAISE NOTICE 'Existing longest path staging %', existing_longest_path_staging;
				--RAISE NOTICE 'Higher found taxon %', higher_found_taxon;
				--IF TWO 
				IF higher_found_taxon::varchar= staging_catalogue_line.id::varchar THEN
					RAISE notice 'taxon found';
					--whole taxonomic path already in taxonomy
					--update parent_ref and catalogue_ref for the whole path
					--IF THIRD
					IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
						is_parent:=TRUE;
						--LOOP 2
						FOR i IN  1..ARRAY_LENGTH(existing_longest_path_staging_array,1) LOOP
							tmp_taxonomy_id:=existing_longest_path_array[i];
							tmp_staging_id:=existing_longest_path_staging_array[i];
							--IF FOUR
							If LENGTH(TRIM(tmp_taxonomy_id))>0 AND LENGTH(trim(tmp_staging_id))>0 THEN
								--IF FIVE
								IF is_parent=TRUE THEN
									UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer WHERE id= staging_catalogue_line.id;								
								--ELSE FIVE	
								ELSE
									UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer, parent_updated=true, parent_ref=previous_taxonomy_id_as_parent::integer WHERE id= staging_catalogue_line.id;
								--END IF FIVE		
								END IF;
								--MENTION source in the original taxonomy
								--UPDATE taxonomy SET source=TRIM(COALESCE(source,'')||'; '||staging_catalogue_line.source_taxonomy) WHERE id=tmp_taxonomy_id::integer;
								is_parent:=FALSE;
								previous_staging_id_as_parent:=staging_catalogue_line.id;
								previous_taxonomy_id_as_parent:=tmp_taxonomy_id;
							--END IF FOUR
							END IF;
						--END LOOP 2	
						END LOOP;
					--END IF THIRD	
					END IF;
					--lowest taxon is not in taxonomy
				--END IF TWO
				ELSE
					--RAISE notice 'taxon to be created %', staging_catalogue_line.name;
					--take part of path which is already in taxonomy
					--(longest prefix)
					--existing_longest_path=test_taxo[1];
					--existing_longest_path_staging=test_taxo[3];
					--higher_found_taxon=test_taxo[4];
					staging_path_to_create_in_taxonomy=test_taxo[5];
					--RAISE NOTICE 'staging path to create in taxonomy (all) %' , test_taxo;  
					--RAISE NOTICE 'staging path to create in taxonomy %' , test_taxo[5];  
					--first create exisint hierarchy 
					--create taxon in taxonomy and keep id
					--update parent_ref and catalogue_ref

					existing_longest_path_array=string_to_array( existing_longest_path, '/');
					existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
					staging_path_to_create_in_taxonomy_array=string_to_array(staging_path_to_create_in_taxonomy, '/');	
					--IF THIRD B	
					IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
					
					parent_updated_var:=false;
					--existing taxa
						--LOOP 3
						FOR i IN   1 .. ARRAY_LENGTH( existing_longest_path_array,1) LOOP
							--IF FOUR B
							IF LENGTH(TRIM(existing_longest_path_array[i]))>0 AND LENGTH(TRIM(existing_longest_path_staging_array[i]))>0 THEN
								--RAISE NOTICE 'IN IF';
								catalogue_ref_var:=existing_longest_path_array[i]::int;
								staging_ref:=existing_longest_path_staging_array[i]::int;
								--RAISE NOTICE 'catalogue_ref_var %', catalogue_ref_var;
								--RAISE NOTICE 'staging_ref %', staging_ref;
								--IF FIVE B
								IF parent_updated_var=false THEN
									--RAISE NOTICE 'UPDATE NO PARENT';
									UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var
									WHERE id=staging_ref AND parent_updated=false AND parent_ref IS NULL;
								--ELSE FIVE B
								ELSE
									--RAISE NOTICE 'UPDATE  PARENT';
									UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var,
									parent_ref=parent_ref_var, parent_updated=true
									WHERE id=staging_ref and parent_updated=false;
								--END IF FIVE B
								END IF;
								parent_updated_var:=true;
								parent_ref_var:=catalogue_ref_var;
								--update source in taxonomy
								--UPDATe taxonomy SET source=COALESCE(source||', '||source_text) WHERE id=catalogue_ref_var;
								--RAISE notice 'parent_ref_var %', parent_ref_var;
							--END IF FOUR B
							END IF;
						--END LOOP 3	
						END LOOP;
					--create new taxa
					--raise notice 'To create array %', staging_path_to_create_in_taxonomy_array; 
					--raise notice 'length array %' , ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1);
					--RAISE notice 'parent_ref_var between loops %', parent_ref_var;
						--LOOP 3 B
						FOR i IN  1..ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1) LOOP
						
							--RAISE NOTICE 'IN LOOP NEW TAXA';
							--IF FOUR C
							IF LENGTH(TRIM(staging_path_to_create_in_taxonomy_array[i]))>0 THEN

							--raise notice 'new taxa id %', staging_path_to_create_in_taxonomy_array[i];
								SELECT name , level_ref, parent_ref INTO tmp_name, tmp_level_ref, parent_ref_var_staging FROM staging_catalogue WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
								SELECT catalogue_ref INTO parent_ref_var FROM staging_catalogue WHERe id=parent_ref_var_staging;
								--IF FIVE C
								IF parent_updated_var=false AND parent_ref_var IS NULL THEN 
									--raise notice 'tmp_name %', tmp_name;
									INSERT INTO taxonomy (id, name, level_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
									tmp_name, tmp_level_ref, var_metadata_ref, req_import_ref) 
									RETURNING id INTO last_id;
									UPDATE staging_catalogue SET catalogue_ref=last_id
									FROM inserted WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									--raise notice 'last_id A %', last_id;
									 parent_ref_var:=last_id;
								--ELSIF FIVE C
								ELSIF parent_ref_var IS NOT NULL THEN
									--raise notice 'tmp_name %', tmp_name;
									--raise notice 'tmp_level_ref %', tmp_level_ref;
									--raise notice 'parent_ref_var %', parent_ref_var;
									--raise notice 'source_text %', source_text;
									INSERT INTO taxonomy (id, name, level_ref, parent_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
									tmp_name, tmp_level_ref, parent_ref_var,  var_metadata_ref, req_import_ref) RETURNING id INTO last_id;
									UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									--raise notice 'last_id B %', last_id;
									 parent_ref_var:=last_id; 
								--END IF FIVE C
								END IF;
							--END IF FOUR C	
							END IF;
						--END LOOP 3 B	
						END LOOP;
					--END IF THIRD B
					END IF;
				--END IF TWO 	
				END IF;
			--ELSE IF ONE	
			--ELSIF staging_catalogue_line.catalogue_ref IS NOT NULL AND staging_catalogue_line.parent_updated = FALSE THEN
			--partially updated
				--raise notice 'Catalogue_updated';
			--END IF ONE
			END IF;
		--END LOOP ONE
		END LOOP;
		--RAISE NOTICE 'exit';
		RETURN TRUE;
	END;
	$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomiesbck20190319(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1557 (class 1255 OID 18849)
-- Name: fct_rmca_imp_checker_gtu_search_code(darwin2.staging, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, collection_ref_for_gtu_var integer, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	counter integer;
	gtu_ids integer[];
BEGIN



IF line.gtu_code IS NOT NULL AND line.gtu_ref IS NULL THEN
	  IF collection_ref_for_gtu_var  IS NOT NULL THEN
		SELECT count(gtu.id), array_agg(gtu.id) INTO counter, gtu_ids FROM gtu WHERE TRIM(LOWER(gtu.code))=TRIM(LOWER(line.gtu_code))
		AND collection_ref= collection_ref_for_gtu_var ;	
	  ELSE
		SELECT count(gtu.id), array_agg(gtu.id) INTO counter, gtu_ids FROM gtu WHERE TRIM(LOWER(gtu.code))=TRIM(LOWER(line.gtu_code));
	  END IF;
	  IF counter = 0 THEN
		UPDATE staging SET status = (status || hstore('gtu' , 'not_found')) where staging.id= line.id; 
	  ELSEIF counter=1 THEN
		UPDATE staging SET gtu_ref=gtu_ids[1] where staging.id= line.id; 
	  ELSEIF counter>1 THEN
		UPDATE staging SET status = (status || hstore('gtu' , 'too_much')) where staging.id= line.id; 
	  END IF;
END IF;
  

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, collection_ref_for_gtu_var integer, import boolean) OWNER TO darwin2;

--
-- TOC entry 1558 (class 1255 OID 18850)
-- Name: fct_rmca_imp_checker_specimen_code(darwin2.staging, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_imp_checker_specimen_code(line darwin2.staging, collection_ref integer, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	code_main varchar;
	returned BOOLEAN;

BEGIN
	

	SELECT full_code_indexed INTO code_main FROM codes WHERe referenced_relation='staging' and code_category='main' AND record_id=line.id;
raise notice 'test %', code_main;
	IF code_main IS NOT NULL THEN
	raise notice 'go';
		returned:= fct_rmca_collection_check_code_unicity(collection_ref, code_main)  ;
		If returned THEN
			raise notice 'set false';
			UPDATE staging SET status = (status || hstore('code' , 'too_much')) where staging.id= line.id; 
			RETURN FALSE;
		END IF;
	END IF;
  

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_imp_checker_specimen_code(line darwin2.staging, collection_ref integer, import boolean) OWNER TO darwin2;

--
-- TOC entry 1559 (class 1255 OID 18851)
-- Name: fct_rmca_instit_address_from_loan_actor(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_instit_address_from_loan_actor(id integer) RETURNS TABLE(id_instit text, instit text, entry text, zip text, locality text, address text, country text)
    LANGUAGE sql
    AS $_$

SELECT 
  (p.formated_name || '§§§' || pr.person_1_ref) AS Id_instit, p.formated_name, COALESCE(a.entry::text),COALESCE(a.zip_code::text), COALESCE(a.locality::text), COALESCE(a.entry::text) || ' ' ||  COALESCE(a.zip_code::text) || ' ' || COALESCE(a.locality::text)  AS address,  COALESCE(a.country::text)
FROM 
  people_relationships pr
LEFT JOIN people p
	ON p.id = pr.person_1_ref
LEFT JOIN people_addresses a
	ON pr.person_1_ref = a.person_user_ref
WHERE 
  pr.person_2_ref = $1 AND
  (pr.relationship_type = 'works for' OR 
  pr.relationship_type = 'belongs to')
  
$_$;


ALTER FUNCTION darwin2.fct_rmca_instit_address_from_loan_actor(id integer) OWNER TO darwin2;

--
-- TOC entry 1560 (class 1255 OID 18852)
-- Name: fct_rmca_keep_staging_catalogue_parent(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_keep_staging_catalogue_parent() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP ='INSERT' THEN
    NEW.parent_ref_internal=NEW.parent_ref;
  
  ELSIF TG_OP ='UPDATE' AND NEW.parent_updated=FALSE  THEN
    NEW.parent_ref_internal=NEW.parent_ref;  
    
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_keep_staging_catalogue_parent() OWNER TO darwin2;

--
-- TOC entry 1561 (class 1255 OID 18853)
-- Name: fct_rmca_log_original_specimens_id_uuid(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_log_original_specimens_id_uuid() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN 
       
        with updated AS
        (
	SELECT DISTINCT
		old_value->'id' old_id, new_value->'id' new_id,  specimen_ref
		FROM 
		(select new_value, old_value from darwin2.users_tracking where referenced_relation='specimens' and action='update' --AND new_value->'id'!=old_value->'id'
		 ) a
		LEFT JOIN darwin2.specimens on  (new_value->'id')::int=specimens.id
		LEFT JOIN darwin2.specimens_stable_ids ON  (old_value->'id')::int=original_id 
		WHERE ((old_value->'id')::int  <>  (new_value->'id')::int) 
				
	)
	UPDATE darwin2.specimens_stable_ids SET specimen_ref=new_id::bigint FROM updated WHERE original_id=old_id::bigint;


	 with old_inserted AS
        (
	SELECT 
		 new_value->'id' new_id,  specimen_ref
		FROM 
		(select new_value, old_value from darwin2.users_tracking where referenced_relation='specimens' and ( action='update' OR action='insert')
		 ) a
		LEFT JOIN darwin2.specimens on  (new_value->'id')::int=specimens.id
		LEFT JOIN darwin2.specimens_stable_ids ON  (new_value->'id')::int=original_id 
		WHERE  specimens.id IS NULL AND original_id IS NULL
				
	)
	INSERT INTO darwin2.specimens_stable_ids (specimen_ref) SELECT DISTINCT new_id::bigint FROM old_inserted;

	/*WITH non_logged_uuid
	AS
	(
		SELECT DISTINCT specimens.id, specimens.uuid FROM specimens INNER JOIN
		specimens_stable_ids ON specimens.id=specimen_ref WHERE specimens_stable_ids.uuid IS NULL
	)
	UPDATE specimens_stable_ids SET uuid=non_logged_uuid.uuid FROM non_logged_uuid WHERE non_logged_uuid.id=specimen_ref ;
	*/

	WITH new_specimens
	AS
	(
		SELECT DISTINCT specimens.id FROM darwin2.specimens LEFT JOIN
		specimens_stable_ids ON specimens.id=specimen_ref WHERE specimen_ref IS NULL
	)
	INSERT INTO specimens_stable_ids (specimen_ref, specimen_fk) SELECT DISTINCT id, id FROM new_specimens;
	RETURN true;

END

$$;


ALTER FUNCTION darwin2.fct_rmca_log_original_specimens_id_uuid() OWNER TO darwin2;

--
-- TOC entry 1562 (class 1255 OID 18854)
-- Name: fct_rmca_look_related_specimens(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_look_related_specimens(p_specimen_ref integer) RETURNS TABLE(id integer)
    LANGUAGE plpgsql
    AS $$
declare

current_Ref integer;
counter integer;
counter_2 integer;

int_list integer[];
i integer;
begin
	i=0;
	
	counter:=-1;
	counter_2:=0;
	current_ref=p_specimen_ref;
	DROP   table if  exists tmp_list_related;
	DROP   table if  exists tmp_list_related;
	 CREATE  temporary table if not exists tmp_list_related(id integer );
	 CREATE  temporary table if not exists tmp_list_related_2(id integer );
	 insert into tmp_list_related_2 VALUES(p_specimen_ref);
	WHILE (counter_2!=counter AND i<200)
	LOOP
		counter:=counter_2;
		 INSERT INTO tmp_list_related(id)  SELECT DISTINCT tmp_id FROM (select specimen_ref as tmp_id FROM specimens_relationships 

		 INNER JOIN  tmp_list_related_2 ON specimen_related_ref=tmp_list_related_2.id
		union 
		select specimen_related_ref FROM specimens_relationships 
		INNER JOIN  tmp_list_related_2 ON specimen_ref=tmp_list_related_2.id
		) a WHERE tmp_id NOT IN (SELECT tmp_list_related.id FROM tmp_list_related ) ;
		i:=i+1;
		INSERT INTO tmp_list_related SELECT * FROM tmp_list_related_2;
		DELETE FROM tmp_list_related_2;
		SELECT COUNT(DISTINCT tmp_list_related.id) into counter_2 FROM tmp_list_related;
	END LOOP;
	
	--DROP TABLE tmp_list_related;
	--DROP TABLE tmp_list_related_2;
	
	RETURN QUERY  SELECT distinct tmp_list_related.id FROM tmp_list_related;
end

$$;


ALTER FUNCTION darwin2.fct_rmca_look_related_specimens(p_specimen_ref integer) OWNER TO darwin2;

--
-- TOC entry 244 (class 1259 OID 18855)
-- Name: template_classifications; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_classifications (
    name character varying NOT NULL,
    name_indexed character varying,
    level_ref integer NOT NULL,
    status character varying DEFAULT 'valid'::character varying NOT NULL,
    local_naming boolean DEFAULT false NOT NULL,
    color character varying,
    path character varying DEFAULT '/'::character varying NOT NULL,
    parent_ref integer
);


ALTER TABLE darwin2.template_classifications OWNER TO darwin2;

--
-- TOC entry 6774 (class 0 OID 0)
-- Dependencies: 244
-- Name: TABLE template_classifications; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_classifications IS 'Template table used to construct every common data in each classifications tables (taxonomy, chronostratigraphy, lithostratigraphy,...)';


--
-- TOC entry 6775 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN template_classifications.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.name IS 'Classification unit name';


--
-- TOC entry 6776 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN template_classifications.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.name_indexed IS 'Indexed form of name field for ordering';


--
-- TOC entry 6777 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN template_classifications.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 6778 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN template_classifications.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 6779 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN template_classifications.local_naming; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.local_naming IS 'Flag telling the appelation is local or internationally recognized';


--
-- TOC entry 6780 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN template_classifications.color; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.color IS 'Hexadecimal value of color associated to the unit';


--
-- TOC entry 6781 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN template_classifications.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 6782 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN template_classifications.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 245 (class 1259 OID 18864)
-- Name: taxonomy; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.taxonomy (
    id integer NOT NULL,
    extinct boolean DEFAULT false NOT NULL,
    sensitive_info_withheld boolean,
    is_reference_taxonomy boolean DEFAULT true NOT NULL,
    metadata_ref integer NOT NULL,
    taxonomy_creation_date timestamp without time zone DEFAULT now(),
    import_ref integer,
    cites boolean DEFAULT false,
    CONSTRAINT fct_chk_onceinpath_taxonomy CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.taxonomy OWNER TO darwin2;

--
-- TOC entry 6783 (class 0 OID 0)
-- Dependencies: 245
-- Name: TABLE taxonomy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.taxonomy IS 'Taxonomic classification table';


--
-- TOC entry 6784 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxonomy.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.name IS 'Classification unit name';


--
-- TOC entry 6785 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxonomy.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 6786 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxonomy.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 6787 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxonomy.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 6788 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxonomy.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 6789 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxonomy.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 6790 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxonomy.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 6791 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN taxonomy.extinct; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.extinct IS 'Tells if taxonomy is extinct or not';


--
-- TOC entry 246 (class 1259 OID 18878)
-- Name: v_rmca_path_parent_children; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_path_parent_children AS
 SELECT b.id AS parent_id,
    ((((b.path)::text || b.id) || '/'::text))::character varying AS parent_path,
    a.id AS child_id,
    ((((a.path)::text || (a.id)::text) || '/'::text))::character varying AS child_path
   FROM (darwin2.taxonomy a
     JOIN darwin2.taxonomy b ON (((((((a.path)::text || (a.id)::text) || '/'::text))::character varying)::text ~~ (((((b.path)::text || (b.id)::text) || '/%'::text))::character varying)::text)));


ALTER TABLE darwin2.v_rmca_path_parent_children OWNER TO darwin2;

--
-- TOC entry 1563 (class 1255 OID 18883)
-- Name: fct_rmca_path_parent_children_by_coll(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_path_parent_children_by_coll(integer) RETURNS SETOF darwin2.v_rmca_path_parent_children
    LANGUAGE sql
    AS $_$
SELECt * FROM v_rmca_path_parent_children
where child_id in (SELECT taxon_ref from specimens where collection_ref=$1);
$_$;


ALTER FUNCTION darwin2.fct_rmca_path_parent_children_by_coll(integer) OWNER TO darwin2;

--
-- TOC entry 1564 (class 1255 OID 18884)
-- Name: fct_rmca_path_parent_children_by_coll_alpha_specimens_count(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_path_parent_children_by_coll_alpha_specimens_count(integer) RETURNS TABLE(parent_id integer, parent_path character varying, parent_name character varying, parent_level character varying, parent_level_order integer, parent_alpha_path character varying, count_children_names_in_collection bigint, count_specimens_identified bigint)
    LANGUAGE sql
    AS $_$
SELECT distinct parent_id, parent_path, 
parent_name, parent_level, parent_level_order,  parent_alpha_path, count(distinct child_id)-1::bigint, (SELECT count(distinct id) FROM specimens where collection_ref=$1 and taxon_ref=a.parent_id ) FROM fct_rmca_path_parent_children_by_coll_extended_alpha( $1) a

--WHERE parent_id<>child_id

GROUP BY parent_id, parent_path, 
parent_name, parent_level, parent_level_order,  parent_alpha_path
order by parent_level_order, parent_alpha_path

$_$;


ALTER FUNCTION darwin2.fct_rmca_path_parent_children_by_coll_alpha_specimens_count(integer) OWNER TO darwin2;

--
-- TOC entry 1565 (class 1255 OID 18885)
-- Name: fct_rmca_path_parent_children_by_coll_alpha_specimens_count_lev(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_path_parent_children_by_coll_alpha_specimens_count_lev(integer) RETURNS TABLE(parent_level character varying, parent_level_order integer, nb_names bigint, count_specimens_identified bigint)
    LANGUAGE sql
    AS $_$
SELECT distinct parent_level, parent_level_order, count($1)::bigint as nb_names, sum(count_specimens_identified)::bigint as count_specimens_identified FROM  fct_rmca_path_parent_children_by_coll_alpha_specimens_count(
    $1
)
GROUP BY parent_level, parent_level_order
 order by parent_level_order;

$_$;


ALTER FUNCTION darwin2.fct_rmca_path_parent_children_by_coll_alpha_specimens_count_lev(integer) OWNER TO darwin2;

--
-- TOC entry 247 (class 1259 OID 18886)
-- Name: catalogue_levels; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.catalogue_levels (
    id integer NOT NULL,
    level_type character varying NOT NULL,
    level_name character varying NOT NULL,
    level_sys_name character varying NOT NULL,
    optional_level boolean DEFAULT false NOT NULL,
    level_order integer DEFAULT 999 NOT NULL
);


ALTER TABLE darwin2.catalogue_levels OWNER TO darwin2;

--
-- TOC entry 6792 (class 0 OID 0)
-- Dependencies: 247
-- Name: TABLE catalogue_levels; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.catalogue_levels IS 'List of hierarchical units levels - organized by type of unit: taxonomy, chroostratigraphy,...';


--
-- TOC entry 6793 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN catalogue_levels.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.id IS 'Unique identifier of a hierarchical unit level';


--
-- TOC entry 6794 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN catalogue_levels.level_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.level_type IS 'Type of unit the levels is applicable to - contained in a predifined list: taxonomy, chronostratigraphy,...';


--
-- TOC entry 6795 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN catalogue_levels.level_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.level_name IS 'Name given to level concerned';


--
-- TOC entry 6796 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN catalogue_levels.level_sys_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.level_sys_name IS 'Name given to level concerned in the system. i.e.: cohort zoology will be writen in system as cohort_zoology';


--
-- TOC entry 6797 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN catalogue_levels.optional_level; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.optional_level IS 'Tells if the level is optional';


--
-- TOC entry 248 (class 1259 OID 18894)
-- Name: v_rmca_path_parent_children_extended_taxonomy; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_path_parent_children_extended_taxonomy AS
 SELECT b.id AS parent_id,
    ((((b.path)::text || b.id) || '/'::text))::character varying AS parent_path,
    b.name AS parent_name,
    d.level_name AS parent_level,
    d.level_order AS parent_level_order,
    a.id AS child_id,
    ((((a.path)::text || (a.id)::text) || '/'::text))::character varying AS child_path,
    a.name AS child_name,
    a.level_ref,
    c.level_name AS child_level,
    c.level_order AS child_level_order
   FROM (((darwin2.taxonomy a
     JOIN darwin2.taxonomy b ON (((((((a.path)::text || (a.id)::text) || '/'::text))::character varying)::text ~~ (((((b.path)::text || (b.id)::text) || '/%'::text))::character varying)::text)))
     JOIN darwin2.catalogue_levels c ON ((a.level_ref = c.id)))
     JOIN darwin2.catalogue_levels d ON ((b.level_ref = d.id)));


ALTER TABLE darwin2.v_rmca_path_parent_children_extended_taxonomy OWNER TO darwin2;

--
-- TOC entry 1566 (class 1255 OID 18899)
-- Name: fct_rmca_path_parent_children_by_coll_extended(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_path_parent_children_by_coll_extended(integer) RETURNS SETOF darwin2.v_rmca_path_parent_children_extended_taxonomy
    LANGUAGE sql
    AS $_$
SELECt * FROM v_rmca_path_parent_children_extended_taxonomy
where child_id in (SELECT taxon_ref from specimens where collection_ref=$1);
$_$;


ALTER FUNCTION darwin2.fct_rmca_path_parent_children_by_coll_extended(integer) OWNER TO darwin2;

--
-- TOC entry 1567 (class 1255 OID 18900)
-- Name: fct_rmca_sort_taxon_path_alphabetically(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically(path character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
BEGIN
	returned ='';
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			SELECT name_indexed INTO tmp FROM taxonomy where id=path_elem::int;
			returned=returned||'/'||tmp;
		END IF;
      END LOOP;

	return returned||'/';
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically(path character varying) OWNER TO darwin2;

--
-- TOC entry 249 (class 1259 OID 18901)
-- Name: v_rmca_path_parent_children_extended_taxonomy_alpha; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_path_parent_children_extended_taxonomy_alpha AS
 SELECT b.id AS parent_id,
    ((((b.path)::text || b.id) || '/'::text))::character varying AS parent_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically(((((b.path)::text || b.id) || '/'::text))::character varying) AS parent_alpha_path,
    b.name AS parent_name,
    d.level_name AS parent_level,
    d.level_order AS parent_level_order,
    a.id AS child_id,
    ((((a.path)::text || (a.id)::text) || '/'::text))::character varying AS child_path,
    a.name AS child_name,
    a.level_ref,
    c.level_name AS child_level,
    c.level_order AS child_level_order
   FROM (((darwin2.taxonomy a
     JOIN darwin2.taxonomy b ON (((((((a.path)::text || (a.id)::text) || '/'::text))::character varying)::text ~~ (((((b.path)::text || (b.id)::text) || '/%'::text))::character varying)::text)))
     JOIN darwin2.catalogue_levels c ON ((a.level_ref = c.id)))
     JOIN darwin2.catalogue_levels d ON ((b.level_ref = d.id)));


ALTER TABLE darwin2.v_rmca_path_parent_children_extended_taxonomy_alpha OWNER TO darwin2;

--
-- TOC entry 1568 (class 1255 OID 18906)
-- Name: fct_rmca_path_parent_children_by_coll_extended_alpha(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_path_parent_children_by_coll_extended_alpha(integer) RETURNS SETOF darwin2.v_rmca_path_parent_children_extended_taxonomy_alpha
    LANGUAGE sql
    AS $_$
SELECt * FROM v_rmca_path_parent_children_extended_taxonomy_alpha
where child_id in (SELECT taxon_ref from specimens where collection_ref=$1);
$_$;


ALTER FUNCTION darwin2.fct_rmca_path_parent_children_by_coll_extended_alpha(integer) OWNER TO darwin2;

--
-- TOC entry 788 (class 1255 OID 18907)
-- Name: fct_rmca_redo_taxonomic_import(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_redo_taxonomic_import(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	--2019 02 19
	returned boolean;
BEGIN
	returned=false;
	 UPDATE  darwin2.staging_catalogue set catalogue_ref=NULL ,parent_updated=FALSE where import_ref=req_import_Ref;
	UPDATE imports set state='loaded' wHERE id=req_import_Ref;
	--PERFORM fct_importer_catalogue(req_import_Ref, 'taxonomy', TRUE);
	returned:=true;
	return returned;
	
END
$$;


ALTER FUNCTION darwin2.fct_rmca_redo_taxonomic_import(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 790 (class 1255 OID 18908)
-- Name: fct_rmca_refresh_public_view(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_refresh_public_view() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	--2019 02 19
	returned boolean;
BEGIN
	insert into darwin2.tv_rdf_view_2_ichtyo_taxo select * from darwin2.v_rdf_view_2_ichtyo_taxo  ;
	returned:=true;
	return returned;
	
END
$$;


ALTER FUNCTION darwin2.fct_rmca_refresh_public_view() OWNER TO darwin2;

--
-- TOC entry 1656 (class 1255 OID 1745970)
-- Name: fct_rmca_regex_numeric_interval_to_array(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_regex_numeric_interval_to_array(param character varying) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $_$
declare
	min_int int;
	max_int int;
	x int;
	returned varchar[];
begin
	returned:= '{}';
	IF isnumeric(TRIM(split_part(param, '-',1)))
	AND isnumeric(TRIM(split_part(param, '-',2))) 
	THEN
		min_int:=TRIM(split_part(param, '-',1))::int;
		max_int:=TRIM(split_part(param, '-',2))::int;
		IF min_int>max_int THEN
			x:=max_int;
			max_int:=min_int;
		ELSE
			x:=min_int;
		END IF;
		WHILE x<=max_int LOOP
			returned=returned||x::varchar;
			x:=x+1;
		END LOOP;
	ELSIF TRIM(param) ~ '^[0-9]+$' THEN 
		returned=returned||TRIM(param)::varchar;
	ELSIF TRIM(param) LIKE '%,%' THEN 
		returned= regexp_split_to_array(param,',');
	ELSIF TRIM(param) LIKE '%.%' THEN 
		returned= regexp_split_to_array(param,'.');
	ELSIF TRIM(param) LIKE '%;%' THEN 
		returned= regexp_split_to_array(param,';');
	
	END IF;
	return returned;
end
$_$;


ALTER FUNCTION darwin2.fct_rmca_regex_numeric_interval_to_array(param character varying) OWNER TO darwin2;

--
-- TOC entry 789 (class 1255 OID 18909)
-- Name: fct_rmca_regexp_matches_one_line(character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_regexp_matches_one_line(main_text character varying, pattern character varying) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
returned varchar[];
BEGIN
select array_agg(i) INTO returned
from (
 select (regexp_matches(main_text, pattern, 'g'))[1] i 
)  t;
RETURN returned;
END
$$;


ALTER FUNCTION darwin2.fct_rmca_regexp_matches_one_line(main_text character varying, pattern character varying) OWNER TO darwin2;

--
-- TOC entry 1569 (class 1255 OID 18910)
-- Name: fct_rmca_report_invertebrates_rtf(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_report_invertebrates_rtf(integer, integer) RETURNS TABLE(country_tag_value character varying, taxon_name character varying, aggregated_str character varying)
    LANGUAGE sql
    AS $_$
SELECT 


specimens.gtu_country_tag_value, specimens.taxon_name, 
string_agg(btrim(regexp_replace(((((((
COALESCE
(

COALESCE(specimens.specimen_count_males_min::text || '♂'::text, ''::text) || 
(' '::text || specimens.specimen_count_females_min::text|| '♀'::text||':') ,'')|| 
 (COALESCE(' '::text || 
 replace(
 regexp_replace(
array_to_string(filter_2_arrays_by_key(tags, group_types, '{administrative area, administrative, area}'),', ') 
 
 , ';AFRICA'::text, ''::text, 
 'i'::text)
 , ';'::text, ' '::text), ''::text)))
  || 
 COALESCE((', '::text || gtu.elevation::character varying::text) || COALESCE(gtu.elevation_unit, 'm'::character varying)::text, ''::text)) || 
        CASE
            WHEN upper(gtu.coordinates_source::text) = 'DD'::text THEN COALESCE(((((', '::text || ABS(gtu.latitude)::text) || 
            CASE
                WHEN gtu.latitude < 0::double precision THEN 'S'::text
                ELSE 'N'::text
            END) || ' '::text) || ABS(gtu.longitude)::text) || 
            CASE
                WHEN gtu.longitude < 0::double precision THEN 'W'::text
                ELSE 'E'::text
            END, ''::text)
            WHEN upper(gtu.coordinates_source::text) = 'DMS'::text THEN 
 

            --'coord_placeholder'
            ', '||COALESCE(gtu.latitude_dms_degree::text||'°','')||COALESCE(gtu.latitude_dms_minutes::text||'''','')||COALESCE(gtu.latitude_dms_seconds::text||'"','')
            ||CASE
                WHEN gtu.latitude_dms_direction >= 1 THEN 'N'::text
                WHEN gtu.latitude_dms_direction <= (-1) THEN 'S'::text
                ELSE ''
            END
            ||
            ', '||COALESCE(gtu.longitude_dms_degree::text||'°','')||COALESCE(gtu.longitude_dms_minutes::text||'''','')||COALESCE(gtu.longitude_dms_seconds::text||'"','')
            ||CASE
                WHEN gtu.longitude_dms_direction >= 1 THEN 'E'::text
                WHEN gtu.longitude_dms_direction <= (-1) THEN '>'::text
                ELSE ''
            END
            
            WHEN upper(gtu.coordinates_source::text) = 'UTM'::text THEN COALESCE(((((', '::text || gtu.latitude_utm::text) || ' '::text) || gtu.longitude_utm::text) || ' '::text) || gtu.utm_zone::text, ''::text)
            ELSE 

             --'coord_placeholder DMS by default'
            ', '||COALESCE(gtu.latitude_dms_degree::text||'°','')||COALESCE(gtu.latitude_dms_minutes::text||'''','')||COALESCE(gtu.latitude_dms_seconds::text||'"','')
            ||CASE
                WHEN gtu.latitude_dms_direction >= 1 THEN 'N'::text
                WHEN gtu.latitude_dms_direction <= (-1) THEN 'S'::text
                ELSE ''
            END
            ||
            ', '||COALESCE(gtu.longitude_dms_degree::text||'°','')||COALESCE(gtu.longitude_dms_minutes::text||'''','')||COALESCE(gtu.longitude_dms_seconds::text||'"','')
            ||CASE
                WHEN gtu.longitude_dms_direction >= 1 THEN 'E'::text
                WHEN gtu.longitude_dms_direction <= (-1) THEN '>'::text
                ELSE ''
            END
        END) 

--date
	||
	COALESCE(', '||fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask)
	||CASE
			WHEN specimens.gtu_to_date_mask>0 THEN
			' to '||fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask)
			ELSE
			''
			END
	 , '')
	 ||COALESCE(', '||array_to_string(filter_2_arrays_by_key(tags, group_types, '{administrative area, administrative, area}', true),', '),'')
--tags loc
	
        || COALESCE(', '::text || fct_rmca_get_people_name_related_to_specimen(specimens.id, 'collector'::character varying)::text, ''::text)) || ' ('::text) || COALESCE((((COALESCE(c2.code_prefix, ''::character varying)::text || 
        COALESCE(c2.code_prefix_separator, ''::character varying)::text) || 
        COALESCE(c2.code, ''::character varying)::text) || COALESCE(c2.code_suffix_separator, ''::character varying)::text) || COALESCE(c2.code_suffix, ''::character varying)::text, ''::text)) || ')'::text


        , '\s{2,}'::text, ' '::text)), '; '::text) 
        AS string_agg
   FROM specimens
   LEFT JOIN gtu ON specimens.gtu_ref = gtu.id
   LEFT JOIN catalogue_people c ON specimens.id = c.record_id AND c.referenced_relation::text = 'specimens'::text AND c.people_type::text = 'collector'::text
   LEFT JOIN people p ON c.people_ref = p.id
   LEFT JOIN codes c2 ON c2.referenced_relation::text = 'specimens'::text AND c2.code_category::text = 'main'::text AND specimens.id = c2.record_id 
   LEFT JOIN (SELECT array_agg(tag order by group_ref) tags, array_agg(group_type order by group_ref) group_types, gtu_ref FROM tags GROUP BY gtu_ref   ) tags ON gtu.id=tags.gtu_ref
  WHERE (specimens.id IN ( SELECT fct_rmca_dynamic_saved_search($2, $1) AS fct_rmca_dynamic_saved_search))
  GROUP BY specimens.gtu_country_tag_value, specimens.taxon_name;
$_$;


ALTER FUNCTION darwin2.fct_rmca_report_invertebrates_rtf(integer, integer) OWNER TO darwin2;

--
-- TOC entry 1570 (class 1255 OID 18911)
-- Name: fct_rmca_retrieve_taxa_in_collection_fastly_array(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_retrieve_taxa_in_collection_fastly_array(integer) RETURNS SETOF integer[]
    LANGUAGE sql
    AS $_$
SELECT DISTINCT array_agg(id) FROM taxonomy 
                 INNER JOIN
                (
                       SELECT distinct unnest(string_to_array(taxon_path||'/'||taxon_ref::varchar, '/'))  as key_taxon from specimens where  collection_ref =$1 OR collection_path LIKE '%/'||$1||'/%'
                       
                      
                        AND taxon_path is not null 
                ) AS specimens
                        ON
                        taxonomy.id::text = specimens.key_taxon
                        $_$;


ALTER FUNCTION darwin2.fct_rmca_retrieve_taxa_in_collection_fastly_array(integer) OWNER TO darwin2;

--
-- TOC entry 1571 (class 1255 OID 18912)
-- Name: fct_rmca_retrieve_taxa_not_in_collection_fastly_array(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_retrieve_taxa_not_in_collection_fastly_array() RETURNS SETOF integer[]
    LANGUAGE sql
    AS $$
SELECT DISTINCT array_agg(taxonomy.id) FROM taxonomy 
                LEFT JOIN specimens ON taxonomy.id=specimens.taxon_ref WHERE specimens.id IS NULL;
                        $$;


ALTER FUNCTION darwin2.fct_rmca_retrieve_taxa_not_in_collection_fastly_array() OWNER TO darwin2;

--
-- TOC entry 1572 (class 1255 OID 18913)
-- Name: fct_rmca_return_loans_by_status(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_return_loans_by_status(character varying) RETURNS integer[]
    LANGUAGE sql
    AS $_$
	select array_agg(loan_ref) from loan_status WHERE status=$1 ;
    $_$;


ALTER FUNCTION darwin2.fct_rmca_return_loans_by_status(character varying) OWNER TO darwin2;

--
-- TOC entry 1573 (class 1255 OID 18914)
-- Name: fct_rmca_return_loans_not_in_status(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_return_loans_not_in_status(character varying) RETURNS integer[]
    LANGUAGE sql
    AS $_$
        with a as
	(select loan_ref from loan_status WHERE status=$1 )
	SELECT array_agg(loans.id) FROM loans LEFT JOIN a On loans.id=a.loan_ref WHERE a.loan_Ref IS NULL;
	;
    $_$;


ALTER FUNCTION darwin2.fct_rmca_return_loans_not_in_status(character varying) OWNER TO darwin2;

--
-- TOC entry 1574 (class 1255 OID 18915)
-- Name: fct_rmca_sort_taxon_get_parent_level(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_get_parent_level(id_taxon integer, id_level integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned int;
 arr varchar[];
 path_elem varchar;
 tmp_level int;
BEGIN
	returned:=-1;
	arr:= regexp_split_to_array((SELECt path FROM taxonomy where id=id_taxon),'/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		SELECT level_ref INTO tmp_level FROM taxonomy WHERE id= COALESCE(NULLIF(path_elem,''),'-1')::int;
		IF tmp_level=id_level THEN
			RETURN path_elem::int;
		END if;
      END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_get_parent_level(id_taxon integer, id_level integer) OWNER TO darwin2;

--
-- TOC entry 739 (class 1255 OID 18916)
-- Name: fct_rmca_sort_taxon_get_parent_level_text(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_get_parent_level_text(id_taxon integer, id_level integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;
 arr varchar[];
 path_elem varchar;
 tmp_level int;
 tmp_name varchar;
BEGIN
	returned:=NULL;
	arr:= regexp_split_to_array((SELECt path FROM darwin2.taxonomy where id=id_taxon),'/');
	--added if lower taxon known is family
	SELECT level_ref,name INTO tmp_level,tmp_name FROM darwin2.taxonomy WHERE id= COALESCE(NULLIF(id_taxon::text,''),'-1')::int;
	IF tmp_level=id_level THEN
			RETURN tmp_name;
	END if;
	--end added
	FOR path_elem IN SELECT unnest(arr)
	LOOP
		SELECT level_ref,name INTO tmp_level,tmp_name FROM darwin2.taxonomy WHERE id= COALESCE(NULLIF(path_elem,''),'-1')::int;
		IF tmp_level=id_level THEN
			RETURN tmp_name;
		END if;
	END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_get_parent_level_text(id_taxon integer, id_level integer) OWNER TO darwin2;

--
-- TOC entry 1575 (class 1255 OID 18917)
-- Name: fct_rmca_sort_taxon_path_alphabetically(character varying, integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically(path character varying, last_level integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
 level integer;
 name_rank varchar;
 full_name varchar;
BEGIN
	returned ='';
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			IF with_rank = FALSE THEN
				SELECT name_indexed, level_ref, name INTO tmp, level, full_name FROM taxonomy where taxonomy.id=path_elem::int;
				IF level>= last_level then
					IF is_indexed=FALSE THEN
						tmp:=full_name;
					END IF;
					returned=returned||'/'||tmp;
				END IF;
			ELSE
				SELECT name_indexed, level_ref, level_name, name INTO tmp, level, name_rank , full_name FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id where taxonomy.id=path_elem::int;
				IF level>= last_level then
					IF is_indexed=FALSE THEN
						tmp:=full_name;
					END IF;
					returned=returned||'/'||tmp||' ('||name_rank||')';
				END IF;
			END IF;
		END IF;
      END LOOP;

	return returned||'/';
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically(path character varying, last_level integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1576 (class 1255 OID 18918)
-- Name: fct_rmca_sort_taxon_path_alphabetically_hstore(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore(path character varying) RETURNS public.hstore
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned hstore;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
 level integer;
 name_rank varchar;
 full_name varchar;
BEGIN
	returned =''::hstore;
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			
				SELECT name_indexed, level_ref, level_name, name INTO tmp, level, name_rank , full_name FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id where taxonomy.id=path_elem::int;
					
				returned=returned||hstore(name_rank ,full_name );
				
			
		END IF;
      END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore(path character varying) OWNER TO darwin2;

--
-- TOC entry 1577 (class 1255 OID 18919)
-- Name: fct_rmca_sort_taxon_path_alphabetically_hstore_key(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore_key(path character varying) RETURNS public.hstore
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned hstore;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
 level integer;
 name_rank varchar;
 full_name varchar;
BEGIN
	returned =''::hstore;
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			
				SELECT name_indexed, level_ref, level_name, name INTO tmp, level, name_rank , full_name FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id where taxonomy.id=path_elem::int;
					
				returned=returned||hstore(level::varchar ,full_name );
				
			
		END IF;
      END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore_key(path character varying) OWNER TO darwin2;

--
-- TOC entry 1578 (class 1255 OID 18920)
-- Name: fct_rmca_sort_taxon_path_alphabetically_not_indexed(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_not_indexed(path character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
BEGIN
	returned ='';
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			SELECT name INTO tmp FROM taxonomy where id=path_elem::int;
			returned=returned||'/'||tmp;
		END IF;
      END LOOP;

	return returned||'/';
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_not_indexed(path character varying) OWNER TO darwin2;

--
-- TOC entry 1579 (class 1255 OID 18921)
-- Name: fct_rmca_sort_taxon_path_alphabetically_staging(integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging(taxon_id integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;

 tmp varchar;
 tmp_id integer;
 tmp_level integer;
 kingdom_given boolean;
 kingdom_id integer;
 kingdom_name varchar;

  domain_given boolean;
   domain_name varchar;
    name_rank varchar;
BEGIN
	returned ='';
	
	tmp_id:=taxon_id;
	kingdom_given :=FALSE;
	domain_given :=FALSE;
	while tmp_id is not null
	LOOP 
		SELECT name, parent_ref_internal, level_ref, level_name INTO tmp, tmp_id, tmp_level, name_rank FROM staging_catalogue 
			INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id
			WHERE staging_catalogue.id=tmp_id;
		IF tmp_level=2 THEN
			kingdom_given = true;
		END IF;
		IF tmp_level=1 THEN
			domain_given = true;
		END IF;
		--raise notice '%', returned;
		--raise notice '%', tmp_id;
		IF is_indexed=TRUE THEN
			tmp:=fulltoindex(tmp, false);
		END IF;
		IF with_rank = FALSE THEN
			returned := tmp||'/'||returned;
		ELSE
			returned := tmp||' ('||name_rank||')'||'/'||returned;
		END IF;
	END LOOP;
	IF kingdom_given = FALSE THEN
		SELECT fulltoindex(taxonomy.name, false), taxonomy.id INTO kingdom_name, kingdom_id FROM taxonomy INNER JOIN imports ON taxonomy.id=imports.taxonomy_kingdom::int INNER JOIN staging_catalogue ON imports.id=staging_catalogue.import_ref WHERE staging_catalogue.id=taxon_id;
		IF with_rank = TRUE THEN
			kingdom_name:= kingdom_name||' (kingdom)';
		END If;
		returned :=  kingdom_name||'/'||returned;
		
		IF domain_given = FALSE THEN
		SELECT fulltoindex(taxonomy.name, false) INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			IF with_rank = TRUE THEN
				domain_name:= domain_name||' (domain)';
			END If;
			returned :=  domain_name||'/'||returned;
		END IF;
	END IF;


	return '/'||returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging(taxon_id integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1580 (class 1255 OID 18922)
-- Name: fct_rmca_sort_taxon_path_alphabetically_staging_merge(integer, integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging_merge(taxon_id integer, req_import_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  --ftheeten 2019 02 21
 returned varchar;

 tmp varchar;
 tmp_id integer;
 tmp_level integer;
 kingdom_given boolean;
 kingdom_id integer;
 kingdom_name varchar;

  domain_given boolean;
  domain_name varchar;
  name_rank varchar;
  in_taxonomy boolean;
  taxonomy_id integer; 
  taxonomy_path varchar; 
  is_reference boolean;
  darwin_path varchar; 
BEGIN

	in_taxonomy :=false;
	returned ='';
	tmp_id:=taxon_id;
	kingdom_given :=FALSE;
	domain_given :=FALSE;
	
	while tmp_id is not null AND in_taxonomy IS FALSE
	LOOP 
		taxonomy_id := NULL;

		SELECT staging_catalogue.name, parent_ref_internal, staging_catalogue.level_ref, level_name, taxonomy.id, taxonomy.path  INTO tmp, tmp_id, tmp_level, name_rank, taxonomy_id, taxonomy_path FROM staging_catalogue 
			INNER JOIN catalogue_levels ON staging_catalogue.level_ref=catalogue_levels.id
			LEFT JOIN imports ON  staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy ON fulltoindex(staging_catalogue.name,false)=fulltoindex(taxonomy.name,false)
			AND  staging_catalogue.level_ref=taxonomy.level_ref
			AND taxonomy.metadata_ref=specimen_taxonomy_ref
			WHERE staging_catalogue.id=tmp_id;
			raise notice '% %',tmp, tmp_level;
		
		IF tmp_level=2 THEN
			kingdom_given = true;
		END IF;
		IF tmp_level=1 THEN
			domain_given = true;
		END IF;
		--raise notice '%', returned;
		--raise notice '%', tmp_id;
		IF is_indexed=TRUE THEN
			tmp:=fulltoindex(tmp, false);
		END IF;
		
		IF in_taxonomy = FALSE THEN

			
			IF taxonomy_id IS NOT NULL THEN
				--merge
				raise notice 'merge';
				SELECT fct_rmca_sort_taxon_path_alphabetically INTO darwin_path FROM  fct_rmca_sort_taxon_path_alphabetically(taxonomy_path||taxonomy_id::varchar
				,
				1 , with_rank, is_indexed
				);
				kingdom_given = true;
				domain_given = true;
				returned := darwin_path||returned;
				in_taxonomy:=TRUE;
				return returned;
				
			END IF;
		ELSE
			IF with_rank = FALSE THEN
				returned := tmp||'/'||returned;
			ELSE
				returned := tmp||' ('||name_rank||')'||'/'||returned;
			END IF;
		END IF;
	END LOOP;
	
	IF kingdom_given = FALSE THEN
		-- 2019 02 19
		IF is_indexed =TRUE THEN
			SELECT fulltoindex(taxonomy.name, false), taxonomy.id INTO kingdom_name, kingdom_id FROM taxonomy INNER JOIN imports ON taxonomy.id=imports.taxonomy_kingdom::int INNER JOIN staging_catalogue ON imports.id=staging_catalogue.import_ref WHERE staging_catalogue.id=taxon_id;
		ELSE
			SELECT taxonomy.name, taxonomy.id INTO kingdom_name, kingdom_id FROM taxonomy INNER JOIN imports ON taxonomy.id=imports.taxonomy_kingdom::int INNER JOIN staging_catalogue ON imports.id=staging_catalogue.import_ref WHERE staging_catalogue.id=taxon_id;
		END IF;
		IF with_rank = TRUE THEN
			kingdom_name:= kingdom_name||' (kingdom)';
		END If;
		returned :=  kingdom_name||'/'||returned;
		
		IF domain_given = FALSE THEN
				-- 2019 02 19
			IF is_indexed =TRUE THEN
				SELECT fulltoindex(taxonomy.name, false) INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			ELSE
				SELECT taxonomy.name INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			END IF;
			IF with_rank = TRUE THEN
				domain_name:= domain_name||' (domain)';
			END If;
			returned :=  domain_name||'/'||returned;
		END IF;
	END IF;


	return '/'||returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging_merge(taxon_id integer, req_import_ref integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1581 (class 1255 OID 18923)
-- Name: fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(integer, integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(taxon_id integer, req_import_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  --ftheeten 2019 02 21
 returned varchar;

 tmp varchar;
 tmp_id integer;
 tmp_level integer;
 kingdom_given boolean;
 kingdom_id integer;
 kingdom_name varchar;

  domain_given boolean;
  domain_name varchar;
  name_rank varchar;
  in_taxonomy boolean;
  taxonomy_id integer; 
  is_reference boolean; 
BEGIN

	in_taxonomy :=false;
	SELECT COALESCE(taxonomy_metadata.is_reference_taxonomy,FALSE) INTO is_reference FROM taxonomy_metadata LEFT JOIN imports ON taxonomy_metadata.id=imports.specimen_taxonomy_ref AND imports.id=req_import_ref LIMIT 1;
	returned ='';
	IF is_reference = FALSE THEN
		RAISE EXCEPTION 'Not a reference taxonomy';
	END IF ;
	tmp_id:=taxon_id;
	kingdom_given :=FALSE;
	domain_given :=FALSE;
	
	while tmp_id is not null
	LOOP 
		taxonomy_id := NULL;
		IF in_taxonomy THEN
			SELECT name, parent_ref, level_ref, level_name INTO tmp, tmp_id, tmp_level, name_rank  FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id
			WHERE taxonomy.id=tmp_id;
		ELSE
			SELECT name, parent_ref_internal, level_ref, level_name INTO tmp, tmp_id, tmp_level, name_rank FROM staging_catalogue 
			INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id
			WHERE staging_catalogue.id=tmp_id;
		END IF;
		IF tmp_level=2 THEN
			kingdom_given = true;
		END IF;
		IF tmp_level=1 THEN
			domain_given = true;
		END IF;
		--raise notice '%', returned;
		--raise notice '%', tmp_id;
		IF is_indexed=TRUE THEN
			tmp:=fulltoindex(tmp, false);
		END IF;
		IF with_rank = FALSE THEN
			returned := tmp||'/'||returned;
		ELSE
			returned := tmp||' ('||name_rank||')'||'/'||returned;
		END IF;
		IF in_taxonomy = FALSE THEN
			SELECT taxonomy.parent_ref INTO taxonomy_id FROM taxonomy LEFT JOIN taxonomy_metadata ON taxonomy.metadata_ref= taxonomy_metadata.id WHERE taxonomy.level_ref=tmp_level AND taxonomy.name=tmp AND taxonomy_metadata.is_reference_taxonomy=TRUE;
			IF taxonomy_id IS NOT NULL THEN
				--merge
				tmp_id:=taxonomy_id;
				in_taxonomy:=TRUE;
			END IF;
		END IF;
	END LOOP;
	IF kingdom_given = FALSE THEN
		-- 2019 02 19
		IF is_indexed =TRUE THEN
			SELECT fulltoindex(taxonomy.name, false), taxonomy.id INTO kingdom_name, kingdom_id FROM taxonomy INNER JOIN imports ON taxonomy.id=imports.taxonomy_kingdom::int INNER JOIN staging_catalogue ON imports.id=staging_catalogue.import_ref WHERE staging_catalogue.id=taxon_id;
		ELSE
			SELECT taxonomy.name, taxonomy.id INTO kingdom_name, kingdom_id FROM taxonomy INNER JOIN imports ON taxonomy.id=imports.taxonomy_kingdom::int INNER JOIN staging_catalogue ON imports.id=staging_catalogue.import_ref WHERE staging_catalogue.id=taxon_id;
		END IF;
		IF with_rank = TRUE THEN
			kingdom_name:= kingdom_name||' (kingdom)';
		END If;
		returned :=  kingdom_name||'/'||returned;
		
		IF domain_given = FALSE THEN
				-- 2019 02 19
			IF is_indexed =TRUE THEN
				SELECT fulltoindex(taxonomy.name, false) INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			ELSE
				SELECT taxonomy.name INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			END IF;
			IF with_rank = TRUE THEN
				domain_name:= domain_name||' (domain)';
			END If;
			returned :=  domain_name||'/'||returned;
		END IF;
	END IF;


	return '/'||returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(taxon_id integer, req_import_ref integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1582 (class 1255 OID 18924)
-- Name: fct_rmca_sort_taxon_path_get_max_level_in_staging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_get_max_level_in_staging(taxon_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned integer;


 tmp_id integer;
BEGIN
	returned =NULL;
	
	tmp_id:=taxon_id;
	while tmp_id is not null
	LOOP 
		SELECT level_ref, parent_ref INTO returned, tmp_id FROM staging_catalogue where id=tmp_id;

		
	END LOOP;

     

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_get_max_level_in_staging(taxon_id integer) OWNER TO darwin2;

--
-- TOC entry 1583 (class 1255 OID 18925)
-- Name: fct_rmca_sort_taxon_path_level_staging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_level_staging(taxon_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;

 tmp varchar;
 tmp_id integer;
 tmp_level integer;
 kingdom_given boolean;
 kingdom_id integer;
 kingdom_name varchar;

  domain_given boolean;
   domain_name varchar;
BEGIN
	returned ='';
	
	tmp_id:=taxon_id;
	kingdom_given :=FALSE;
	domain_given :=FALSE;
	while tmp_id is not null
	LOOP 
		SELECT name, parent_ref_internal, level_ref INTO tmp, tmp_id, tmp_level FROM staging_catalogue where id=tmp_id;
		IF tmp_level=2 THEN
			kingdom_given = true;
		END IF;
		IF tmp_level=1 THEN
			domain_given = true;
		END IF;
		returned := tmp_level::varchar||'/'||returned;
	END LOOP;
	IF kingdom_given = FALSE THEN
		
		returned :=  2::varchar||'/'||returned;
		
		IF domain_given = FALSE THEN
			SELECT fulltoindex(taxonomy.name, false) INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			returned :=  1::varchar||'/'||returned;
		END IF;
	END IF;


	return '/'||returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_level_staging(taxon_id integer) OWNER TO darwin2;

--
-- TOC entry 1584 (class 1255 OID 18926)
-- Name: fct_rmca_statistics_collection_count(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_statistics_collection_count(integer) RETURNS TABLE(collection_ref integer, counter_category text, items character varying, count_items bigint)
    LANGUAGE sql
    AS $_$
SELECT DISTINCT  $1 as collection_id, 'type_count'::text AS counter_category, coalesce(specimens.type,'others') AS items, count(specimens.id) AS count_items
           FROM specimens
            where collection_path||collection_ref::varchar||'/' LIKE '%/'||$1::varchar||'/%'

          GROUP BY  specimens.type
         UNION
         SELECT DISTINCT  $1 as collection_id, 'image_count'::text AS counter_category, coalesce(ext_links.category,'others') AS items, count(ext_links.id) AS count_items
         
           FROM ext_links
           
      JOIN specimens ON ext_links.record_id = specimens.id AND ext_links.referenced_relation::text = 'specimens'::text
      where collection_path||collection_ref::varchar||'/' LIKE '%/'||$1::varchar||'/%'
     GROUP BY  ext_links.category;

$_$;


ALTER FUNCTION darwin2.fct_rmca_statistics_collection_count(integer) OWNER TO darwin2;

--
-- TOC entry 746 (class 1255 OID 18927)
-- Name: fct_rmca_taxo_all_occurences_of_parent_in_staging(integer, character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxo_all_occurences_of_parent_in_staging(req_import_ref integer, p_name character varying, p_level_ref integer) RETURNS integer[]
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	check_hierarchies RECORD;
	returned  integer[];
	parents  integer[];
	
BEGIN 

	select array_agg(parent_ref) into  parents  from staging_catalogue where 
import_ref=req_import_ref and name=p_name and level_ref=p_level_ref;
	returned=returned||parents;	
		
	FOR check_hierarchies IN select array_agg(parent_ref) as parents  from staging_catalogue where 
import_ref=req_import_ref  AND id = ANY ( parents)
	LOOP 	
		IF check_hierarchies.parents IS NULL THEN
			EXIT;
		END IF;
		parents:=check_hierarchies.parents;
		returned=returned||parents;
		
	END LOOP;		
	
		
	RETURN returned;
END;


 $$;


ALTER FUNCTION darwin2.fct_rmca_taxo_all_occurences_of_parent_in_staging(req_import_ref integer, p_name character varying, p_level_ref integer) OWNER TO darwin2;

--
-- TOC entry 747 (class 1255 OID 18928)
-- Name: fct_rmca_taxo_copy_darwin_path_in_staging(integer, character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxo_copy_darwin_path_in_staging(req_import_ref integer, p_name character varying, p_level_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	check_hierarchies RECORD;
	returned  integer[];
	parent  integer;
	
BEGIN 

	/*select array_agg(parent_ref) into  parents  from staging_catalogue where 
import_ref=req_import_ref and name=p_name and level_ref=p_level_ref;
	returned=returned||parents;	
	*/
	parent:=NULL;	
	FOR check_hierarchies IN SELECT taxonomy.*, base_id from taxonomy 
		INNER JOIN
		(
		SELECT UNNEST(fct_remove_null_array_elem(string_to_array(path, '/','')))  as ref_taxon, taxonomy.id as base_id from taxonomy where name =p_name and level_ref=p_level_ref
		) b
		ON taxonomy.id::varchar = ref_taxon
		INNER JOIN taxonomy_metadata
			ON taxonomy.metadata_ref=taxonomy_metadata.id
			AND taxonomy_metadata.is_reference_taxonomy=true
			ORDER BY level_ref
		
		LOOP 	
			INSERT INTO staging_catalogue (import_ref, name, level_ref, parent_ref, catalogue_ref , parent_updated)
			VALUES(req_import_ref, check_hierarchies.name,check_hierarchies.level_ref, parent ,check_hierarchies.id, true  ) RETURNING id;
			parent:=id;
			
		
		END LOOP;
		UPDATE 	staging_catalogue SET parent_ref=parent, catalogue_ref=base_id, parent_updated=true WHERE	import_ref=req_import_ref AND name= p_name and level_ref=p_level_ref;
	
		
	RETURN returned;
END;


 $$;


ALTER FUNCTION darwin2.fct_rmca_taxo_copy_darwin_path_in_staging(req_import_ref integer, p_name character varying, p_level_ref integer) OWNER TO darwin2;

--
-- TOC entry 762 (class 1255 OID 18929)
-- Name: fct_rmca_taxo_staging_path_in_reference(integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxo_staging_path_in_reference(id_staging_taxon integer, exclude_invalid_entries boolean DEFAULT false) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar[];
 returned_tmp varchar;
 returned_name varchar;
 returned_ids_staging varchar;

 staging_path_name varchar;
 staging_path_level varchar;
 staging_path_level_array int[];
 staging_path_name_array varchar[];
 parent integer;
 i integer;
 tmp_id integer;
 tmp_name_path varchar;
 name_tmp varchar;
 level_tmp varchar;
  level_tmp_char varchar;
  level_of_parent_staging int;
  level_of_parent_taxonomy int;
  
 id_main_taxon integer;
 staging_path_found boolean;
 array_ids integer[];
 array_ids_string varchar;
 last_id varchar;
 last_id_set boolean;
 catalogue_ref_tmp integer;
 import_ref_tmp integer;
 parent_updated_tmp boolean;
 parent_updated_refs_array integer[];
 taxon_found_in_staging boolean;
BEGIN
--raise notice 'entry';
	SELECT parent_updated INTO parent_updated_tmp FROM  staging_catalogue WHERE id=tmp_id;
	IF parent_updated_tmp=true THEN
		return NULL;
	END IF;
		tmp_id:= id_staging_taxon;
		i:=0;
		parent:=-1;

		--staging_path_name:='/';
		--staging_path_level:='/';
		
		--array_ids_string:='/'||tmp_id||'/';
		array_ids:=tmp_id||array_ids;
		WHILE parent is not null and i<30 LOOP
			SELECT parent_ref, name, level_ref, catalogue_ref, import_ref  INTO parent, name_tmp, level_of_parent_staging , catalogue_ref_tmp, import_ref_tmp FROM staging_catalogue WHERE id=tmp_id --and catalogue_ref is NULL 
			LIMIT 1;
			
			IF parent is not null THEN
				
				IF catalogue_ref_tmp IS NULL THEN
					tmp_id:=parent;
				ELSE
					--raise notice 'append';
					SELECT id into tmp_id FROM  staging_catalogue WHERE import_ref=import_ref_tmp AND catalogue_ref=parent; --AND parent_updated=TRUE;
					parent_updated_refs_array:=parent||parent_updated_refs_array;
				END IF;
				IF tmp_id IS NOT NULL THEN
					
					array_ids := tmp_id||array_ids;
					--raise notice '%',array_ids_string;
				END IF;
			END IF;
			
			staging_path_name_array:= name_tmp::varchar||staging_path_name_array;
			--raise notice '%',staging_path_name;
			staging_path_level_array:= level_of_parent_staging||staging_path_level_array;
			
			i:=i+1;
		END LOOP;
		--raise notice '%', staging_path_name_array;
		--raise notice '%', staging_path_level_array;
		--raise notice '%', array_ids;
		--raise notice '%', parent_updated_refs_array;
		/*IF staging_path_name='/' OR
		staging_path_level='/' OR 
		array_ids_string='/' THEN
			RETURN NULL;
		END IF;*/
		
		IF ARRAY_LENGTH(staging_path_name_array,1)=0 OR
		ARRAY_LENGTH(staging_path_level_array,1)=0 OR 
		ARRAY_LENGTH(array_ids,1)=0 THEN
			RETURN NULL;
		END IF;
		--staging_path_level_array:=string_to_array(staging_path_level, '/');
		--staging_path_name_array:=string_to_array(staging_path_name, '/');
		--array_ids=string_to_array(array_ids_string, '/');
		
		returned_tmp:='/';
		returned_name:='/';
		returned_ids_staging='/';
		staging_path_found:=false;
		taxon_found_in_staging:=false;
		last_id_set:=false;
--raise notice 'staging_path_name_array %', staging_path_name_array;
		IF ARRAY_LENGTH(staging_path_level_array, 1)=ARRAY_LENGTH(staging_path_name_array, 1) THEN
			FOR i IN  1..ARRAY_LENGTH(staging_path_name_array,1) LOOP
				--RAISe NOTICE '%d', i;
				--RAISe NOTICE '%d', ARRAY_LENGTH(staging_path_name_array,1);
				--RAISe NOTICE '%d', ARRAY_LENGTH(parent_updated_refs_array,1);
				tmp_name_path:=staging_path_name_array[i];
--raise notice 'tmp_name_path %',tmp_name_path;
				IF LENGTH(tmp_name_path)>0 THEN
				
					--raise notice 'TEST';
					level_tmp_char:=staging_path_level_array[i];
					--taxonomic parent already in staging
					IF ARRAY_LENGTH( parent_updated_refs_array ,1)> 0 AND i < ARRAY_LENGTH( parent_updated_refs_array ,1) THEN
						
						id_main_taxon:=parent_updated_refs_array[i];
						--raise notice 'id_main_taxon %', id_main_taxon;
						taxon_found_in_staging:=true;
					--find taxonomuic parent from string
					ELSE
						taxon_found_in_staging:=false;

						IF exclude_invalid_entries=true THEN
							
							SELECT taxonomy.id INTO id_main_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE taxonomy_metadata.is_reference_taxonomy=true AND fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int AND status !='invalid' LIMIT 1;
						
						ELSE
							SELECT taxonomy.id INTO id_main_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE taxonomy_metadata.is_reference_taxonomy=true AND fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int LIMIT 1;
						END IF;
					END IF;
					IF id_main_taxon IS NULL THEN
						--raise notice 'NOT_FOUND';
						returned_tmp:= returned_tmp||'NOT_FOUND/';
						staging_path_found:=false;
					ELSE						
						--RAISE NOTICE 'FOUND';
						returned_tmp:= returned_tmp||id_main_taxon::varchar||'/';
						returned_name:=returned_name||tmp_name_path||'/';
						returned_ids_staging:=returned_ids_staging||array_ids[i]::varchar||'/';
						
						last_id:=array_ids[i];
						staging_path_found:=TRUE;
					END IF;
					IF staging_path_found=TRUE THEN
						IF exclude_invalid_entries=true AND taxon_found_in_staging=false THEN
							
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp AND status !='invalid';
						ELSIF taxon_found_in_staging=false THEN
						
						--raise notice 'returned_tmp : %',returned_tmp; 
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp;
							IF NOT FOUND THEN
								PERFORM id FROM taxonomy WHERE path||id::varchar||'/'LIKE '%'||returned_tmp;
							END IF;
						--ELSE
						--	RAISE NOTICE 'NO check';
						END IF;
						IF FOUND OR taxon_found_in_staging=true THEN
							--RAISE NOTICE 'DEF';
							--parent path found in taxonomy (longest prefix)

							--eg for complete path in staging /97909/97910/97911/97912/97913/97914/97922/ )
							--eg. /1/5/5953/5954/5955/
							returned[1]:=returned_tmp;
							--string trascription of the path
							--eg. /Eucaryota/Animalia/CHORDATA/ACTINOPTERYGII/PERCIFORMES/
							returned[2]:=returned_name;
							--path corresponding to the longest taxonomical prefix with the staging ids
							--/97909/97910/97911/97912/97913/
							returned[3]:=returned_ids_staging;
							--lowest taxon of the path 
							--eg. 97913
							returned[4]:=last_id;
							--path the parents in staging not found in taxonomy (remainded of the longest prefix)
							--eg. /97914/97922/ 
							IF(i<ARRAY_LENGTH(array_ids,1)) THEN
								returned[5]:='/'||array_to_string(array_ids[i+1:ARRAY_LENGTH(array_ids,1)],'/')||'/';
							ELSE
								
								returned[5]:='/';
							END IF;
							--SUBSTRING(array_ids_string FROM  POSITION ('/'||last_id||'/' IN array_ids_string) + LENGTH('/'||last_id));
						ELSE
							--RAISE NOTICE 'EXIT 1';
							RETURN returned;
						END IF;
					ELSE 
						--RAISE NOTICE 'EXIT 2';
						RETURN returned;
					END IF;
				END IF;
				
			END LOOP;
		END IF;
--RAISE NOTICE 'EXIT 3';
	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_taxo_staging_path_in_reference(id_staging_taxon integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 763 (class 1255 OID 18932)
-- Name: fct_rmca_taxonomy_common_path_staging_in_darwin(integer, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_common_path_staging_in_darwin(req_import_ref integer, status_to_exclude character varying DEFAULT 'DUMMY'::character varying) RETURNS TABLE(alpha_path_staging character varying, level_path_staging character varying, found_name character varying, taxonomy_found_path text, taxonomy_longuest_found_path text, taxonomy_lowest_id integer)
    LANGUAGE sql
    AS $_$

SELECT distinct
a.alpha_path_staging,
a.level_path_staging,
(array_agg(b.name order by length(b.alpha_path_staging) ))[1] ,
(array_agg(b.path||b.id::varchar order by length(b.alpha_path_staging) ))[1] ,
(array_agg(b.alpha_path_staging order by length(b.alpha_path_staging) ))[1] ,
(array_agg(b.id order by length(b.alpha_path_staging) ))[1] 
FROM 

(SELECT DISTINCT 
alpha_path_staging
, taxonomy.name,
taxonomy.path, taxonomy.id,
level_path_staging
from (select *, fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue.id)  alpha_path_staging, fct_rmca_sort_taxon_path_level_staging(staging_catalogue.id) as level_path_staging from staging_catalogue where staging_catalogue.import_ref= $1)  staging_catalogue 
 LEFT JOIN 

 (select taxonomy.id, path, name, taxonomy, fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar||'/') alpha_path from taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id where taxonomy_metadata.is_reference_taxonomy=true
AND status != $2
) taxonomy
ON 
alpha_path_staging= alpha_path

 ORDER BY alpha_path_staging
) a

LEFT JOIN

(SELECT DISTINCT 
alpha_path_staging
, taxonomy.name,
taxonomy.path, taxonomy.id,
length(alpha_path_staging) as length_path
from (select *, fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue.id)  alpha_path_staging from staging_catalogue where staging_catalogue.import_ref= $1)  staging_catalogue 
 LEFT JOIN 

 (select taxonomy.id, path, name, taxonomy, fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar||'/') alpha_path from taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id where taxonomy_metadata.is_reference_taxonomy=true
AND status != $2
) taxonomy
ON 
alpha_path_staging= alpha_path


 ORDER BY alpha_path_staging
) b
ON a.alpha_path_staging like b.alpha_path_staging ||'%'
group by
a.alpha_path_staging,
a.level_path_staging
order by alpha_path_staging;
$_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_common_path_staging_in_darwin(req_import_ref integer, status_to_exclude character varying) OWNER TO darwin2;

--
-- TOC entry 1533 (class 1255 OID 18933)
-- Name: fct_rmca_taxonomy_common_path_staging_in_darwin_id(integer, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_common_path_staging_in_darwin_id(req_id integer, status_to_exclude character varying DEFAULT 'DUMMY'::character varying) RETURNS TABLE(alpha_path_staging character varying, level_path_staging character varying, found_name character varying, taxonomy_found_path text, taxonomy_longuest_found_path text, taxonomy_lowest_id integer)
    LANGUAGE sql
    AS $_$

SELECT distinct
a.alpha_path_staging,
a.level_path_staging,
(array_agg(b.name order by length(b.alpha_path_staging) ))[1] ,
(array_agg(b.path||b.id::varchar order by length(b.alpha_path_staging) ))[1] ,
(array_agg(b.alpha_path_staging order by length(b.alpha_path_staging) ))[1] ,
(array_agg(b.id order by length(b.alpha_path_staging) ))[1] 
FROM 

(SELECT DISTINCT 
alpha_path_staging
, taxonomy.name,
taxonomy.path, taxonomy.id,
level_path_staging
from (select *, fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue.id)  alpha_path_staging, fct_rmca_sort_taxon_path_level_staging(staging_catalogue.id) as level_path_staging from staging_catalogue where staging_catalogue.id= $1)  staging_catalogue 
 LEFT JOIN 

 (select taxonomy.id, path, name, taxonomy, fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar||'/') alpha_path from taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id where taxonomy_metadata.is_reference_taxonomy=true
AND status != $2
) taxonomy
ON 
alpha_path_staging= alpha_path

 ORDER BY alpha_path_staging
) a

LEFT JOIN

(SELECT DISTINCT 
alpha_path_staging
, taxonomy.name,
taxonomy.path, taxonomy.id,
length(alpha_path_staging) as length_path
from (select *, fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue.id)  alpha_path_staging from staging_catalogue where staging_catalogue.id= $1)  staging_catalogue 
 LEFT JOIN 

 (select taxonomy.id, path, name, taxonomy, fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar||'/') alpha_path from taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id where taxonomy_metadata.is_reference_taxonomy=true
AND status != $2
) taxonomy
ON 
alpha_path_staging= alpha_path


 ORDER BY alpha_path_staging
) b
ON a.alpha_path_staging like b.alpha_path_staging ||'%'
group by
a.alpha_path_staging,
a.level_path_staging
order by alpha_path_staging;
$_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_common_path_staging_in_darwin_id(req_id integer, status_to_exclude character varying) OWNER TO darwin2;

--
-- TOC entry 764 (class 1255 OID 18934)
-- Name: fct_rmca_taxonomy_get_old_synonyms(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_get_old_synonyms(integer) RETURNS TABLE(taxon_id integer, id_log integer, referenced_relation character varying, old_record_id integer, user_name character varying, action character varying, modification_date_time timestamp without time zone, taxon_name character varying)
    LANGUAGE sql
    AS $_$ 
    
with a as (

select * from classification_synonymies where record_id=$1),
b as 
(select classification_synonymies_history.record_id, classification_synonymies_history.group_id, name, classification_synonymies_history.referenced_relation from classification_synonymies_history inner join a on classification_synonymies_history.group_id=a.group_id and classification_synonymies_history.referenced_relation=a.referenced_relation 
inner join taxonomy on classification_synonymies_history.record_id=taxonomy.id
UNION
select classification_synonymies.record_id, classification_synonymies.group_id, name, classification_synonymies.referenced_relation from classification_synonymies inner join a on classification_synonymies.group_id=a.group_id and classification_synonymies.referenced_relation=a.referenced_relation 
inner join taxonomy on classification_synonymies.record_id=taxonomy.id
),
c as
(SELECT classification_synonymies.* FROM classification_synonymies INNER JOIN b ON classification_synonymies.record_id=b.record_id   ),
d as 
(SELECT classification_synonymies_history.* FROM classification_synonymies_history INNER JOIN c ON classification_synonymies_history.record_id=c.record_id   ),
e as 
(SELECT classification_synonymies.*, action, modification_date_time, d.user_name, d.id as id_log, taxonomy.name,  taxonomy.id as taxonomy_id FROM classification_synonymies INNER JOIN d ON classification_synonymies.group_id=d.group_id inner join taxonomy on classification_synonymies.record_id =taxonomy.id  )
select record_id as taxon_id,  id_log, referenced_relation, taxonomy_id, user_name, action,  modification_date_time, name taxon_name  from e;

 $_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_get_old_synonyms(integer) OWNER TO darwin2;

--
-- TOC entry 838 (class 1255 OID 18935)
-- Name: fct_rmca_taxonomy_get_other_synonyms(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_get_other_synonyms(integer) RETURNS TABLE(referenced_relation character varying, record_id integer, id integer, group_id integer, group_name character varying, is_basionym boolean, order_by integer, synonymy_record_id integer, original_synonym boolean)
    LANGUAGE sql
    AS $_$ 

with a as (

select * from classification_synonymies where record_id=$1),
b AS (
select * from classification_synonymies where group_id IN (SELECT DISTINCT group_id FROM a))
,
c as (select *  FROM classification_synonymies 
	WHERE record_id IN (SELECT distinct b.record_id FROM b)
	  AND classification_synonymies.group_id NOT IN (SELECT DISTINCT a.group_id FROM a)
	  AND record_id !=$1
	),
d as (select * from classification_synonymies where group_id in (SELECT distinct c.group_id FROM c) AND record_id !=$1)   
SELECT * FROM  d

 $_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_get_other_synonyms(integer) OWNER TO darwin2;

--
-- TOC entry 1585 (class 1255 OID 18936)
-- Name: fct_rmca_taxonomy_get_staging_hierarchy_recursive(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_get_staging_hierarchy_recursive(integer) RETURNS TABLE(base_id integer, base_level_ref integer, base_name character varying, path character varying)
    LANGUAGE sql
    AS $_$
WITH RECURSIVE  staging_catalogue_tmp
AS

(
SELECT staging_catalogue.id as base_id,staging_catalogue.level_ref as base_level_ref, staging_catalogue.name as base_name, staging_catalogue.id, staging_catalogue.name, 
parent_ref_internal, staging_catalogue.import_ref
, staging_catalogue.level_Ref




 FROM staging_catalogue
LEFT JOIN imports
ON staging_catalogue.import_ref=imports.id


WHERE staging_catalogue.import_ref=$1
UNION
SELECT staging_catalogue_tmp.base_id,  staging_catalogue_tmp.base_level_ref, staging_catalogue_tmp.base_name,  s.id,s.name, s.parent_ref_internal, s.import_Ref
,s.level_Ref
 FROM staging_catalogue s
INNER JOIN staging_catalogue_tmp  
ON  s.id=staging_catalogue_tmp.parent_ref_internal




)


SELECT 
staging_catalogue_tmp.base_id::integer,staging_catalogue_tmp.base_level_ref::integer, staging_catalogue_tmp.base_name::varchar, '/'||string_agg(COALESCE(name||' ('||level_name||')',''), '/' ORDER BY level_ref)||'/'::varchar as path
FROM staging_catalogue_tmp 
LEFT JOIN catalogue_levels
ON level_ref=catalogue_levels.id
GROUP BY staging_catalogue_tmp.base_id,staging_catalogue_tmp.base_level_ref,
staging_catalogue_tmp.base_name

$_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_get_staging_hierarchy_recursive(integer) OWNER TO darwin2;

--
-- TOC entry 1586 (class 1255 OID 18937)
-- Name: fct_rmca_taxonomy_name_level_already_exists(character varying, integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_name_level_already_exists(nameauthor character varying, level_id integer, taxonomy_metadata integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned INTEGER;
	
BEGIN
	returned:=NULL;
	SELECT id  into returned FROM taxonomy WHERE fulltoindex(name)=fulltoindex(nameauthor) and level_ref=level_id AND metadata_ref=taxonomy_metadata LIMIT 1 ;
	--if not found return null
	RETURN returned;
END
$$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_name_level_already_exists(nameauthor character varying, level_id integer, taxonomy_metadata integer) OWNER TO darwin2;

--
-- TOC entry 1587 (class 1255 OID 18938)
-- Name: fct_rmca_taxonomy_remove_last_word(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_remove_last_word(character varying) RETURNS character varying
    LANGUAGE sql
    AS $_$ SELECT trim(
     
    regexp_replace(fct_rmca_taxonomy_try_to_isolate_from_author(fct_rmca_taxonomy_try_to_isolate_from_author($1)), '( [^ ]+$)', '')

    ); $_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_remove_last_word(character varying) OWNER TO darwin2;

--
-- TOC entry 1588 (class 1255 OID 18939)
-- Name: fct_rmca_taxonomy_split_name_author(character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_split_name_author(name character varying, rank_id integer) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$

DECLARE 
--tmp varchar[];
returned varchar[];
name_tmp varchar;
author_tmp varchar;
pos_author int;
BEGIN

	

	IF rank_id <= 41 THEN
		pos_author:=1;
	ELSEIF rank_id>41 and rank_id<=48 THEN
		pos_author:=2;
	ELSEIF rank_id >48 and rank_id <50 THEN
	        -- ftheeten 2018 11 22
		If rank_id=50 THEN
		name:=replace(name,' (L.) ', ' ');
		name:=replace(name,' L. ', ' ');
		name:=replace(name,' var. ', ' ');
		END IF;
		pos_author:=3;
	ELSEIF  rank_id =50 THEN
		returned[1]:=TRIM(regexp_replace(name, '(var\.\s\w+)(.*)', '\1'));
		returned[2]:=TRIM(replace(name, returned[1],''));
		return returned;
	ELSEIF  rank_id >50 THEN
		pos_author:=4;
	END IF;

	
	
	SELECT array_to_string((array_agg(elem))[1:pos_author], ' ') ,  array_to_string((array_agg(elem))[pos_author+1:500],' ') INTO name_tmp, author_tmp FROM 
(SELECT 1 as id, (regexp_matches(trim(name), '([^\s]+(\s\([^0-9]+\)){0,1})','g'))[1] as elem)
a group by id; 
	returned[1]:=name_tmp;
	returned[2]:= author_tmp;

RETURN returned;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_split_name_author(name character varying, rank_id integer) OWNER TO darwin2;

--
-- TOC entry 1589 (class 1255 OID 18940)
-- Name: fct_rmca_taxonomy_split_name_author_old(character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_split_name_author_old(name character varying, rank_id integer) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $_$

DECLARE 
returned varchar[];
name_tmp varchar;
author_tmp varchar;
BEGIN


	IF rank_id <= 41 THEN
		returned[1]:=trim(replace(trim(name), trim(regexp_replace(trim(name), '((?:\S+))','')),''));
	ELSEIF rank_id>41 and rank_id<=48 THEN
		returned[1]:=trim(replace(trim(name), trim(regexp_replace(trim(name), '((?:\S+\s+){1}\S+)','')),''));
	ELSEIF rank_id >48 and rank_id <55 THEN
		returned[1]:=trim(replace(trim(name), trim(regexp_replace(trim(name), '((?:\S+\s+){2}\S+)','')),''));
	END IF;

	IF rank_id <= 41 THEN
		returned[2]:=trim(regexp_replace(trim($1), '((?:\S+))',''));
	ELSEIF rank_id>41 and rank_id<=48 THEN
		returned[2]:=trim(regexp_replace(trim($1), '((?:\S+\s+){1}\S+)',''));
	ELSEIF rank_id >48 and rank_id <55 THEN
		returned[2]:=trim(regexp_replace(trim($1), '((?:\S+\s+){2}\S+)',''));
	END IF;

	

RETURN returned;
END;
$_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_split_name_author_old(name character varying, rank_id integer) OWNER TO darwin2;

--
-- TOC entry 1590 (class 1255 OID 18941)
-- Name: fct_rmca_taxonomy_split_name_author_tmp(character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_split_name_author_tmp(name character varying, rank_id integer) RETURNS TABLE(taxonomy_name_part character varying, taxonomy_author_part character varying)
    LANGUAGE sql
    AS $_$
SELECT CASE WHEN $2 <= 41 THEN
trim(regexp_replace(trim($1), trim(regexp_replace(trim($1), '((?:\S+))','')),''))

WHEN $2>41 and $2<=48 THEN
--between genus and subspecies
trim(regexp_replace(trim($1), trim(regexp_replace(trim($1), '((?:\S+\s+){1}\S+)','')),''))
WHEN $2 >48 and $2 <55 THEN
trim(regexp_replace(trim($1), trim(regexp_replace(trim($1), '((?:\S+\s+){2}\S+)','')),''))
END,

CASE WHEN $2 <= 41 THEN
--genus and above genus
trim(regexp_replace(trim($1), '((?:\S+))',''))
WHEN $2>41 and $2<=48 THEN
--between genus and subspecies
trim(regexp_replace(trim($1), '((?:\S+\s+){1}\S+)',''))
WHEN $2 >48 and $2 <55 THEN
trim(regexp_replace(trim($1), '((?:\S+\s+){2}\S+)',''))
END;
--subspecies and below

$_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_split_name_author_tmp(name character varying, rank_id integer) OWNER TO darwin2;

--
-- TOC entry 1591 (class 1255 OID 18942)
-- Name: fct_rmca_taxonomy_try_to_isolate_from_author(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ /*SELECT 
regexp_replace(
trim(

regexp_replace(

	regexp_replace($1,'\([^\(]*\)$','')

,'(\s[A-Z]).*$','')),

E' (von|van|de|l\')$',''
)

;*/
DECLARE 
	returned varchar;
 BEGIN 
	IF LOWER(name) LIKE '% var. %' THEN
		returned:=TRIM(regexp_replace(name, '(var\.\s\w+)(.*)', '\1'));
	ELSE
		returned:=regexp_replace(
				trim(

				regexp_replace(

					regexp_replace(name,'\([^\(]*\)$','')

				,'(\s[A-Z]).*$','')),

				E' (von|van|de|l\')$',''
				)

				;
	END IF;
	 
	RETURN returned;
 END;

 $_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(name character varying) OWNER TO darwin2;

--
-- TOC entry 1592 (class 1255 OID 18943)
-- Name: fct_rmca_update_child_of_taxon_protected(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_update_child_of_taxon_protected() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	text_path varchar;
	text_to_replace varchar;
BEGIN
    IF TG_OP = 'UPDATE'  THEN

		IF NEW.sensitive_info_withheld <> OLD.sensitive_info_withheld THEN
			   
			UPDATE taxonomy SET sensitive_info_withheld=NEW.sensitive_info_withheld WHERE parent_ref=NEW.ID OR path LIKE '%/'||NEW.id::varchar||'/%' ;
		END IF;
        END IF;

 
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_update_child_of_taxon_protected() OWNER TO darwin2;

--
-- TOC entry 1593 (class 1255 OID 18944)
-- Name: fct_rmca_update_reference_taxo(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_update_reference_taxo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN
--ftheeten 2017 07 03

     IF NEW.is_reference_taxonomy  != OLD.is_reference_taxonomy AND TG_OP = 'UPDATE' THEN
	UPDATE taxonomy SET is_reference_taxonomy= new.is_reference_taxonomy WHERE metadata_ref=NEW.id;
    END IF;
   	    
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_update_reference_taxo() OWNER TO darwin2;

--
-- TOC entry 1526 (class 1255 OID 18945)
-- Name: fct_search_authorized_encoding_collections(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_search_authorized_encoding_collections(user_id integer) RETURNS SETOF integer
    LANGUAGE sql STABLE
    AS $_$
    select collection_ref from collections_rights where user_ref = $1 and db_user_type >= 2;
$_$;


ALTER FUNCTION darwin2.fct_search_authorized_encoding_collections(user_id integer) OWNER TO darwin2;

--
-- TOC entry 1527 (class 1255 OID 18946)
-- Name: fct_search_authorized_view_collections(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_search_authorized_view_collections(user_id integer) RETURNS SETOF integer
    LANGUAGE sql STABLE
    AS $_$
    select collection_ref from collections_rights where user_ref = $1

    UNION

    select id as collection_ref from collections where is_public = true;
$_$;


ALTER FUNCTION darwin2.fct_search_authorized_view_collections(user_id integer) OWNER TO darwin2;

--
-- TOC entry 1528 (class 1255 OID 18947)
-- Name: fct_search_methods(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_search_methods(str_ids character varying) RETURNS SETOF integer
    LANGUAGE sql STABLE
    AS $_$
    select distinct(specimen_ref) from specimen_collecting_methods where collecting_method_ref in (select X::int from regexp_split_to_table($1,',') as X);
$_$;


ALTER FUNCTION darwin2.fct_search_methods(str_ids character varying) OWNER TO darwin2;

--
-- TOC entry 1529 (class 1255 OID 18948)
-- Name: fct_search_tools(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_search_tools(str_ids character varying) RETURNS SETOF integer
    LANGUAGE sql STABLE
    AS $_$
    select distinct(specimen_ref) from specimen_collecting_tools where collecting_tool_ref in (select X::int from regexp_split_to_table($1,',') as X);
$_$;


ALTER FUNCTION darwin2.fct_search_tools(str_ids character varying) OWNER TO darwin2;

--
-- TOC entry 1594 (class 1255 OID 18949)
-- Name: fct_searchcodes(character varying[]); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_searchcodes(VARIADIC character varying[]) RETURNS SETOF integer
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
  sqlString varchar := E'select record_id from codes';
  sqlWhere varchar := '';
  code_part varchar;
  code_from varchar;
  code_to varchar;
  code_category varchar;
  relation varchar;
  word varchar;
BEGIN
  FOR i in 1 .. array_upper( $1, 1 ) BY 5 LOOP
    code_category := $1[i];
    code_part := $1[i+1];
    code_from := $1[i+2];
    code_to := $1[i+3];
    relation := $1[i+4] ;

    IF relation IS DISTINCT FROM '' AND i = 1 THEN
      sqlString := sqlString || ' where referenced_relation=' || quote_literal(relation) ;
    ELSIF i = 1 THEN
      sqlString := sqlString || E' where referenced_relation=\'specimens\''  ;
    END IF ;

    sqlWhere := sqlWhere || ' (code_category = ' || quote_literal(code_category) ;

    IF code_from ~ '^[0-9]+$' and code_to ~ '^[0-9]+$' THEN
      sqlWhere := sqlWhere || ' AND code_num BETWEEN ' || quote_literal(code_from) || ' AND ' || quote_literal(code_to) ;
    END IF;

    IF code_part != '' THEN
      sqlWhere := sqlWhere || ' AND (';
      FOR word IN (SELECT words FROM regexp_split_to_table(code_part, E'\\s+') as words) LOOP
        sqlWhere := sqlWhere || E' full_code_indexed like \'%\' || fullToIndex(' || quote_literal(word) || E') || \'%\' OR';
      END LOOP;
      sqlWhere := substr(sqlWhere,0,length(sqlWhere)-2) || ')';
    END IF;

    sqlWhere := sqlWhere || ') OR ';

  END LOOP;

  sqlString := sqlString || ' AND (' || substr(sqlWhere,0, length(sqlWhere)-2) || ')';
  RAISE INFO 'Sql : %',sqlString ;
  RETURN QUERY EXECUTE sqlString;
END;
$_$;


ALTER FUNCTION darwin2.fct_searchcodes(VARIADIC character varying[]) OWNER TO darwin2;

--
-- TOC entry 1595 (class 1255 OID 18950)
-- Name: fct_set_user(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_set_user(userid integer) RETURNS void
    LANGUAGE sql
    AS $_$
  select set_config('darwin.userid', $1::varchar, false) ;
  select CASE WHEN get_setting('application_name') ~ ' uid:\d+'
    THEN set_config('application_name', regexp_replace(get_setting('application_name') ,'uid:\d+',  'uid:' || $1::varchar), false)
    ELSE set_config('application_name', get_setting('application_name')  || ' uid:' || $1::varchar, false)
    END;
  update users_login_infos set last_seen = now() where user_ref = $1  and login_type='local';
$_$;


ALTER FUNCTION darwin2.fct_set_user(userid integer) OWNER TO darwin2;

--
-- TOC entry 1596 (class 1255 OID 18951)
-- Name: fct_trg_chk_possible_upper_level(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_trg_chk_possible_upper_level() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
   --ftheeten 2017 07 10
   IF TG_OP ='INSERT' OR (TG_OP ='UPDATE' AND (OLD.parent_ref !=NEW.parent_ref OR OLD.level_ref !=NEW.level_ref )) THEN		
	IF fct_chk_possible_upper_level(TG_TABLE_NAME::text, NEW.parent_ref, NEW.level_ref, NEW.id) = false THEN
	RAISE EXCEPTION 'This record does not follow the level hierarchy (NAME is %)', NEW.name;
	END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_trg_chk_possible_upper_level() OWNER TO darwin2;

--
-- TOC entry 1597 (class 1255 OID 18952)
-- Name: fct_trg_rmca_log_specimens_stable_ids(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_trg_rmca_log_specimens_stable_ids() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
	BEGIN
		IF NEW.original_id IS NULL AND TG_OP = 'INSERT' THEN
			NEW.original_id = NEW.specimen_ref;
			UPDATE specimens SET uuid=NEW.uuid WHERE id= NEW.specimen_ref;
			
		ELSE 
			NEW.original_id = OLD.original_id;
			NEW.uuid = OLD.uuid;
		END IF;	
		RETURN NEW;
	END;
$$;


ALTER FUNCTION darwin2.fct_trg_rmca_log_specimens_stable_ids() OWNER TO darwin2;

--
-- TOC entry 1598 (class 1255 OID 18953)
-- Name: fct_trk_log_old_synonyms(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_trk_log_old_synonyms() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  user_id integer;
  user_name varchar;
  taxon_name varchar;
  go_upd boolean;
BEGIN
--RAISE NOTICE '1';
  go_upd:=true;
 IF OLD.referenced_relation='taxonomy' THEN
     IF TG_OP = 'UPDATE' THEN
     --RAISE NOTICE '2';
       IF NOT ROW(NEW.*) IS DISTINCT FROM ROW(OLD.*) THEN
       --RAISE NOTICE '3';
	go_upd:=false;
	END IF;
     END IF;
END IF;
     
    IF go_upd THEN
   	  SELECT COALESCE(get_setting('darwin.userid'),'0')::integer INTO user_id;
	  /*IF user_id = 0 OR  user_id = -1 THEN
	  RAISE NOTICE '4';
	    RETURN NEW;
	  END IF;*/
	  SELECT formated_name INTO user_name FROM users where id=user_id;
	  SELECT name INTO taxon_name FROM taxonomy where id=OLD.record_id;
	  INSERT  into classification_synonymies_history(
            referenced_relation, record_id, id, group_id, group_name, is_basionym, 
            order_by, synonym_record_id, modification_date_time, user_name, 
            taxon_name)
           SELECT
            OLD.referenced_relation,
            OLD.record_id,
            OLD.id,
            OLD.group_id,
	    OLD.group_name,
	    OLD.is_basionym,
	    OLD.order_by,
	    OLD.synonym_record_id,
	    now(),
	     user_name,
	     taxon_name;
	     --  RAISE NOTICE '5';
     END IF;
  IF  TG_OP='UPDATE' OR TG_OP='INSERT' THEN
    --RAISE NOTICE '6';
	RETURN NEW;
  ELSE
    RAISE NOTICE '7';
	RETURN NULL;
  END IF;	
END;
$$;


ALTER FUNCTION darwin2.fct_trk_log_old_synonyms() OWNER TO darwin2;

--
-- TOC entry 1599 (class 1255 OID 18954)
-- Name: fct_trk_log_table(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_trk_log_table() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  user_id integer;
  track_level integer;
  track_fields integer;
  trk_id bigint;
  tbl_row RECORD;
  new_val varchar;
  old_val varchar;
BEGIN
  SELECT COALESCE(get_setting('darwin.track_level'),'10')::integer INTO track_level;
  IF track_level = 0 THEN --NO Tracking
    RETURN NEW;
  ELSIF track_level = 1 THEN -- Track Only Main tables
    IF TG_TABLE_NAME::text NOT IN ('specimens', 'taxonomy', 'chronostratigraphy', 'lithostratigraphy',
      'mineralogy', 'lithology', 'people') THEN
      RETURN NEW;
    END IF;
  END IF;

  SELECT COALESCE(get_setting('darwin.userid'),'0')::integer INTO user_id;
  IF user_id = 0 OR  user_id = -1 THEN
    RETURN NEW;
  END IF;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO users_tracking (referenced_relation, record_id, user_ref, action, modification_date_time, new_value)
        VALUES (TG_TABLE_NAME::text, NEW.id, user_id, 'insert', now(), hstore(NEW)) RETURNING id into trk_id;
  ELSEIF TG_OP = 'UPDATE' THEN

    IF ROW(NEW.*) IS DISTINCT FROM ROW(OLD.*) THEN
    INSERT INTO users_tracking (referenced_relation, record_id, user_ref, action, modification_date_time, new_value, old_value)
        VALUES (TG_TABLE_NAME::text, NEW.id, user_id, 'update', now(), hstore(NEW), hstore(OLD)) RETURNING id into trk_id;
    ELSE
      RAISE info 'unnecessary update on table "%" and id "%"', TG_TABLE_NAME::text, NEW.id;
    END IF;

  ELSEIF TG_OP = 'DELETE' THEN
  
    INSERT INTO users_tracking (referenced_relation, record_id, user_ref, action, modification_date_time, old_value)
      VALUES (TG_TABLE_NAME::text, OLD.id, user_id, 'delete', now(), hstore(OLD));
  END IF;

  RETURN NULL;
END;
$$;


ALTER FUNCTION darwin2.fct_trk_log_table() OWNER TO darwin2;

--
-- TOC entry 1547 (class 1255 OID 18955)
-- Name: fct_unpromotion_impact_prefs(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_unpromotion_impact_prefs() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  saved_search_row RECORD;
BEGIN
  IF NEW.db_user_type IS DISTINCT FROM OLD.db_user_type AND NEW.db_user_type = 1 THEN
    UPDATE preferences
    SET pref_value = subq.fields_available
    FROM (select array_to_string(array(select fields_list
                                       from regexp_split_to_table((SELECT pref_value
                                                                   FROM preferences
                                                                   WHERE user_ref = NEW.id
                                                                     AND pref_key = 'search_cols_specimen'
                                                                   LIMIT 1
                                                                  ), E'\\|') as fields_list
                                       where fields_list not in ('institution_ref', 'building', 'floor', 'room', 'row', 'shelf', 'col', 'container', 'container_type', 'container_storage', 'sub_container', 'sub_container_type', 'sub_container_storage')
                                      ),'|'
                                ) as fields_available
         ) subq
    WHERE user_ref = NEW.id
      AND pref_key = 'search_cols_specimen';
    FOR saved_search_row IN SELECT id, visible_fields_in_result FROM my_saved_searches WHERE user_ref = NEW.id LOOP
      UPDATE my_saved_searches
      SET visible_fields_in_result = subq.fields_available
      FROM (select array_to_string(array(select fields_list
                                         from regexp_split_to_table(saved_search_row.visible_fields_in_result, E'\\|') as fields_list
                                         where fields_list not in ('institution_ref','building', 'floor', 'room', 'row', 'shelf', 'col', 'container', 'container_type', 'container_storage', 'sub_container', 'sub_container_type', 'sub_container_storage')
                                        ),'|'
                                  ) as fields_available
          ) subq
      WHERE id = saved_search_row.id;
    END LOOP;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_unpromotion_impact_prefs() OWNER TO darwin2;

--
-- TOC entry 1548 (class 1255 OID 18956)
-- Name: fct_upd_institution_staging_relationship(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_upd_institution_staging_relationship() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  import_id integer;
  line RECORD ;
BEGIN
 IF get_setting('darwin.upd_people_ref') is null OR  get_setting('darwin.upd_people_ref') = '' THEN
    PERFORM set_config('darwin.upd_people_ref', 'ok', true);
    select s.import_ref INTO import_id FROM staging s, staging_relationship sr WHERE sr.id=OLD.id AND sr.record_id = s.id ;
    UPDATE staging_relationship SET institution_ref = NEW.institution_ref WHERE id IN (
      SELECT sr.id from staging_relationship sr, staging s WHERE sr.institution_name = OLD.institution_name AND s.import_ref = import_id AND
      sr.record_id = s.id
    );
    FOR line IN SELECT s.* FROM staging s, staging_relationship sr WHERE s.id=sr.record_id AND sr.institution_ref = NEW.institution_ref
    LOOP
      UPDATE staging SET status = delete(status,'institution_relationship') where id=line.id;
    END LOOP ;
    PERFORM set_config('darwin.upd_imp_ref', NULL, true);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_upd_institution_staging_relationship() OWNER TO darwin2;

--
-- TOC entry 1606 (class 1255 OID 18957)
-- Name: fct_upd_people_in_flat(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_upd_people_in_flat() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  spec_row RECORD;
  ident RECORD;
  tmp_user text;
BEGIN
 SELECT COALESCE(get_setting('darwin.userid'),'0') INTO tmp_user;
  PERFORM set_config('darwin.userid', '-1', false) ;


  IF TG_OP = 'DELETE' THEN
    IF OLD.people_type = 'collector' THEN
      UPDATE specimens s SET spec_coll_ids = fct_remove_array_elem(spec_coll_ids,ARRAY[OLD.people_ref])
        WHERE id  = OLD.record_id;
    ELSIF OLD.people_type = 'donator' THEN
      UPDATE specimens s SET spec_don_sel_ids = fct_remove_array_elem(spec_don_sel_ids,ARRAY[OLD.people_ref])
        WHERE id  = OLD.record_id;
    ELSIF OLD.people_type = 'identifier' THEN
      SELECT * into ident FROM identifications where id = OLD.record_id;
      IF NOT FOUND Then
        PERFORM set_config('darwin.userid', tmp_user, false) ;
        RETURN OLD;
      END IF;

      UPDATE specimens s SET spec_ident_ids = fct_remove_array_elem(spec_ident_ids,ARRAY[OLD.people_ref])
        WHERE id  = ident.record_id
            AND NOT exists (
              SELECT true FROM catalogue_people cp INNER JOIN identifications i ON cp.record_id = i.id AND cp.referenced_relation = 'identifications'
                WHERE i.record_id = ident.id AND people_ref = OLD.people_ref AND i.referenced_relation = 'specimens'
            );
    END IF;

  ELSIF TG_OP = 'INSERT' THEN --- INSERT

    IF NEW.people_type = 'collector' THEN
      UPDATE specimens s SET spec_coll_ids = array_append(spec_coll_ids,NEW.people_ref)
        WHERE id  = NEW.record_id and NOT (spec_coll_ids && ARRAY[ NEW.people_ref::integer ]);
    ELSIF NEW.people_type = 'donator' THEN
      UPDATE specimens s SET spec_don_sel_ids = array_append(spec_don_sel_ids,NEW.people_ref)
        WHERE id  = NEW.record_id  and NOT (spec_don_sel_ids && ARRAY[ NEW.people_ref::integer ]);
    ELSIF NEW.people_type = 'identifier' THEN
      SELECT * into ident FROM identifications where id = NEW.record_id;

      UPDATE specimens s SET spec_ident_ids = array_append(spec_ident_ids,NEW.people_ref)
          WHERE id  = ident.record_id and NOT (spec_ident_ids && ARRAY[ NEW.people_ref::integer ]);
    END IF;

  ELSIF OLD.people_ref != NEW.people_ref THEN --UPDATE

    IF NEW.people_type = 'collector' THEN
      UPDATE specimens s SET spec_coll_ids = array_append(fct_remove_array_elem(spec_coll_ids ,ARRAY[OLD.people_ref]),NEW.people_ref::integer)
        WHERE id  = NEW.record_id;
    ELSIF NEW.people_type = 'donator' THEN
      UPDATE specimens s SET spec_don_sel_ids = array_append(fct_remove_array_elem(spec_don_sel_ids ,ARRAY[OLD.people_ref]),NEW.people_ref::integer)
        WHERE id  = NEW.record_id;

    ELSIF NEW.people_type = 'identifier' THEN
      SELECT * into ident FROM identifications where id = NEW.record_id;

        SELECT id, spec_ident_ids INTO spec_row FROM specimens WHERE id = ident.record_id;

        IF NOT exists (SELECT 1 from identifications i INNER JOIN catalogue_people c ON c.record_id = i.id AND c.referenced_relation = 'identifications'
          WHERE i.record_id = spec_row.id AND people_ref = OLD.people_ref AND i.referenced_relation = 'specimens' AND c.id != OLD.id
        ) THEN
          spec_row.spec_ident_ids := fct_remove_array_elem(spec_row.spec_ident_ids ,ARRAY[OLD.people_ref]);
        END IF;

        IF NOT spec_row.spec_ident_ids && ARRAY[ NEW.people_ref::integer ] THEN
          spec_row.spec_ident_ids := array_append(spec_row.spec_ident_ids ,NEW.people_ref);
        END IF;

        UPDATE specimens SET spec_ident_ids = spec_row.spec_ident_ids WHERE id = spec_row.id;
    END IF;
    --else  raise info 'ooh';
  END IF;

  PERFORM set_config('darwin.userid', tmp_user, false) ;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_upd_people_in_flat() OWNER TO darwin2;

--
-- TOC entry 1607 (class 1255 OID 18958)
-- Name: fct_upd_people_staging_fields(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_upd_people_staging_fields() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  import_id integer;
BEGIN
 IF get_setting('darwin.upd_people_ref') is null OR  get_setting('darwin.upd_people_ref') = '' THEN
    PERFORM set_config('darwin.upd_people_ref', 'ok', true);
    IF OLD.referenced_relation = 'staging' THEN
      select s.import_ref INTO import_id FROM staging s, staging_people sp WHERE sp.id=OLD.id AND sp.record_id = s.id ;
    ELSEIF OLD.referenced_relation = 'identifications' THEN
      select s.import_ref INTO import_id FROM staging s, staging_people sp, identifications i WHERE sp.id=OLD.id
      AND sp.record_id = i.id AND i.record_id = s.id ;
    ELSE
      select s.import_ref INTO import_id FROM staging s, staging_people sp, collection_maintenance c WHERE sp.id=OLD.id
      AND sp.record_id = c.id AND c.record_id = s.id ;
    END IF;

    UPDATE staging_people SET people_ref = NEW.people_ref WHERE id IN (
      SELECT sp.id from staging_people sp, identifications i, staging s WHERE formated_name = OLD.formated_name AND s.import_ref = import_id
      AND i.record_id = s.id AND sp.referenced_relation = 'identifications' AND sp.record_id = i.id
      UNION
      SELECT sp.id from staging_people sp, staging s WHERE formated_name = OLD.formated_name AND s.import_ref = import_id AND
      sp.record_id = s.id AND sp.referenced_relation = 'staging'
      UNION
      SELECT sp.id from staging_people sp, collection_maintenance c, staging s WHERE formated_name = OLD.formated_name AND s.import_ref = import_id
      AND c.record_id = s.id AND sp.referenced_relation = 'collection_maintenance' AND sp.record_id = c.id
    );
    -- update status field, if all error people are corrected, statut 'people', 'operator' or 'identifiers' will be removed
    PERFORM fct_imp_checker_people(s.*) FROM staging s WHERE import_ref = import_id AND (status::hstore ? 'people' OR status::hstore ? 'identifiers'  OR status::hstore ? 'operator') ;
    PERFORM set_config('darwin.upd_imp_ref', NULL, true);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_upd_people_staging_fields() OWNER TO darwin2;

--
-- TOC entry 1608 (class 1255 OID 18959)
-- Name: fct_upd_staging_fields(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_upd_staging_fields() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF get_setting('darwin.upd_imp_ref') is null OR  get_setting('darwin.upd_imp_ref') = '' THEN
    PERFORM set_config('darwin.upd_imp_ref', 'ok', true);
    IF OLD.taxon_ref IS DISTINCT FROM NEW.taxon_ref AND  NEW.taxon_ref is not null THEN
        SELECT t.id ,t.name, t.level_ref , cl.level_sys_name, t.status, t.extinct
        INTO NEW.taxon_ref,NEW.taxon_name, NEW.taxon_level_ref, NEW.taxon_level_name, NEW.taxon_status, NEW.taxon_extinct
        FROM taxonomy t, catalogue_levels cl
        WHERE cl.id=t.level_ref AND t.id = NEW.taxon_ref;

        UPDATE staging set taxon_ref=NEW.taxon_ref, taxon_name = new.taxon_name, taxon_level_ref=new.taxon_level_ref,
          taxon_level_name=new.taxon_level_name, taxon_status=new.taxon_status, taxon_extinct=new.taxon_extinct,
          status = delete(status,'taxon')

        WHERE
          taxon_name  IS NOT DISTINCT FROM  old.taxon_name AND  taxon_level_ref IS NOT DISTINCT FROM old.taxon_level_ref AND
          taxon_level_name IS NOT DISTINCT FROM old.taxon_level_name AND  taxon_status IS NOT DISTINCT FROM old.taxon_status
          AND  taxon_extinct IS NOT DISTINCT FROM old.taxon_extinct
          AND import_ref = NEW.import_ref;
        NEW.status = delete(NEW.status,'taxon');
    END IF;

    IF OLD.chrono_ref IS DISTINCT FROM NEW.chrono_ref  AND  NEW.chrono_ref is not null THEN
      SELECT c.id, c.name, c.level_ref, cl.level_name, c.status, c.local_naming, c.color, c.upper_bound, c.lower_bound
        INTO NEW.chrono_ref, NEW.chrono_name, NEW.chrono_level_ref, NEW.chrono_level_name, NEW.chrono_status, NEW.chrono_local, NEW.chrono_color, NEW.chrono_upper_bound, NEW.chrono_lower_bound
        FROM chronostratigraphy c, catalogue_levels cl
        WHERE cl.id=c.level_ref AND c.id = NEW.chrono_ref ;

        UPDATE staging set chrono_ref=NEW.chrono_ref, chrono_name = NEW.chrono_name, chrono_level_ref=NEW.chrono_level_ref, chrono_level_name=NEW.chrono_level_name, chrono_status=NEW.chrono_status,
        chrono_local=NEW.chrono_local, chrono_color=NEW.chrono_color, chrono_upper_bound=NEW.chrono_upper_bound, chrono_lower_bound=NEW.chrono_lower_bound,
        status = delete(status,'chrono')

        WHERE
        chrono_name  IS NOT DISTINCT FROM  OLD.chrono_name AND  chrono_level_ref IS NOT DISTINCT FROM OLD.chrono_level_ref AND
        chrono_level_name IS NOT DISTINCT FROM OLD.chrono_level_name AND  chrono_status IS NOT DISTINCT FROM OLD.chrono_status AND
        chrono_local IS NOT DISTINCT FROM OLD.chrono_local AND  chrono_color IS NOT DISTINCT FROM OLD.chrono_color AND
        chrono_upper_bound IS NOT DISTINCT FROM OLD.chrono_upper_bound AND  chrono_lower_bound IS NOT DISTINCT FROM OLD.chrono_lower_bound
        AND import_ref = NEW.import_ref;
        NEW.status = delete(NEW.status,'chrono');

    END IF;

    IF OLD.litho_ref IS DISTINCT FROM NEW.litho_ref  AND  NEW.litho_ref is not null  THEN
      SELECT l.id,l.name, l.level_ref, cl.level_name, l.status, l.local_naming, l.color
      INTO NEW.litho_ref, NEW.litho_name, NEW.litho_level_ref, NEW.litho_level_name, NEW.litho_status, NEW.litho_local, NEW.litho_color
      FROM lithostratigraphy l, catalogue_levels cl
      WHERE cl.id=l.level_ref AND l.id = NEW.litho_ref ;

      UPDATE staging set
        litho_ref=NEW.litho_ref, litho_name=NEW.litho_name, litho_level_ref=NEW.litho_level_ref, litho_level_name=NEW.litho_level_name,
        litho_status=NEW.litho_status, litho_local=NEW.litho_local, litho_color=NEW.litho_color,
        status = delete(status,'litho')

      WHERE
        litho_name IS NOT DISTINCT FROM  OLD.litho_name AND litho_level_ref IS NOT DISTINCT FROM  OLD.litho_level_ref AND
        litho_level_name IS NOT DISTINCT FROM  OLD.litho_level_name AND
        litho_status IS NOT DISTINCT FROM  OLD.litho_status AND litho_local IS NOT DISTINCT FROM  OLD.litho_local AND litho_color IS NOT DISTINCT FROM OLD.litho_color
        AND import_ref = NEW.import_ref;
        NEW.status = delete(NEW.status,'litho');

    END IF;


    IF OLD.lithology_ref IS DISTINCT FROM NEW.lithology_ref  AND  NEW.lithology_ref is not null THEN
      SELECT l.id, l.name, l.level_ref, cl.level_name, l.status, l.local_naming, l.color
      INTO NEW.lithology_ref, NEW.lithology_name, NEW.lithology_level_ref, NEW.lithology_level_name, NEW.lithology_status, NEW.lithology_local, NEW.lithology_color
      FROM lithology l, catalogue_levels cl
      WHERE cl.id=l.level_ref AND l.id = NEW.lithology_ref ;

      UPDATE staging set
        lithology_ref=NEW.lithology_ref, lithology_name=NEW.lithology_name, lithology_level_ref=NEW.lithology_level_ref,
        lithology_level_name=NEW.lithology_level_name, lithology_status=NEW.lithology_status, lithology_local=NEW.lithology_local,
        lithology_color=NEW.lithology_color,
        status = delete(status,'lithology')

      WHERE
        lithology_name IS NOT DISTINCT FROM OLD.lithology_name AND  lithology_level_ref IS NOT DISTINCT FROM OLD.lithology_level_ref AND
        lithology_level_name IS NOT DISTINCT FROM OLD.lithology_level_name AND  lithology_status IS NOT DISTINCT FROM OLD.lithology_status AND  lithology_local IS NOT DISTINCT FROM OLD.lithology_local AND
        lithology_color IS NOT DISTINCT FROM OLD.lithology_color
        AND import_ref = NEW.import_ref;
        NEW.status = delete(NEW.status,'lithology');

    END IF;


    IF OLD.mineral_ref IS DISTINCT FROM NEW.mineral_ref  AND  NEW.mineral_ref is not null THEN
      SELECT m.id, m.name, m.level_ref, cl.level_name, m.status, m.local_naming, m.color, m.path
      INTO NEW.mineral_ref, NEW.mineral_name, NEW.mineral_level_ref, NEW.mineral_level_name, NEW.mineral_status, NEW.mineral_local, NEW.mineral_color, NEW.mineral_path
      FROM mineralogy m, catalogue_levels cl
      WHERE cl.id=m.level_ref AND m.id = NEW.mineral_ref ;

      UPDATE staging set
        mineral_ref=NEW.mineral_ref, mineral_name=NEW.mineral_name, mineral_level_ref=NEW.mineral_level_ref,
        mineral_level_name=NEW.mineral_level_name, mineral_status=NEW.mineral_status, mineral_local=NEW.mineral_local,
        mineral_color=NEW.mineral_color, mineral_path=NEW.mineral_path,
        status = delete(status,'mineral')

      WHERE
        mineral_name IS NOT DISTINCT FROM OLD.mineral_name AND  mineral_level_ref IS NOT DISTINCT FROM OLD.mineral_level_ref AND
        mineral_level_name IS NOT DISTINCT FROM OLD.mineral_level_name AND  mineral_status IS NOT DISTINCT FROM OLD.mineral_status AND  mineral_local IS NOT DISTINCT FROM OLD.mineral_local AND
        mineral_color IS NOT DISTINCT FROM OLD.mineral_color AND  mineral_path IS NOT DISTINCT FROM OLD.mineral_path
        AND import_ref = NEW.import_ref;

        NEW.status = delete(NEW.status,'mineral');

    END IF;

    IF OLD.expedition_ref IS DISTINCT FROM NEW.expedition_ref  AND  NEW.expedition_ref is not null THEN
      SELECT id, "name", expedition_from_date, expedition_to_date, expedition_from_date_mask , expedition_to_date_mask
      INTO NEW.expedition_ref, NEW.expedition_name, NEW.expedition_from_date, NEW.expedition_to_date, NEW.expedition_from_date_mask , NEW.expedition_to_date_mask
      FROM expeditions
      WHERE id = NEW.expedition_ref ;

      UPDATE staging set
        expedition_ref=NEW.expedition_ref, expedition_name=NEW.expedition_name, expedition_from_date=NEW.expedition_from_date,
        expedition_to_date=NEW.expedition_to_date, expedition_from_date_mask=NEW.expedition_from_date_mask , expedition_to_date_mask=NEW.expedition_to_date_mask
      WHERE
        expedition_name IS NOT DISTINCT FROM OLD.expedition_name AND  expedition_from_date IS NOT DISTINCT FROM OLD.expedition_from_date AND
        expedition_to_date IS NOT DISTINCT FROM OLD.expedition_to_date AND  expedition_from_date_mask IS NOT DISTINCT FROM OLD.expedition_from_date_mask  AND
        expedition_to_date_mask IS NOT DISTINCT FROM OLD.expedition_to_date_mask
        AND import_ref = NEW.import_ref;

    END IF;

    IF OLD.institution_ref IS DISTINCT FROM NEW.institution_ref  AND  NEW.institution_ref is not null THEN
      SELECT formated_name INTO NEW.institution_name FROM people WHERE id = NEW.institution_ref ;

      UPDATE staging set institution_ref = NEW.institution_ref, institution_name=NEW.institution_name,
        status = delete(status,'institution')
        WHERE
        institution_name IS NOT DISTINCT FROM OLD.institution_name
        AND import_ref = NEW.import_ref;

        NEW.status = delete(NEW.status,'institution');

    END IF;

    PERFORM set_config('darwin.upd_imp_ref', NULL, true);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_upd_staging_fields() OWNER TO darwin2;

--
-- TOC entry 1609 (class 1255 OID 18962)
-- Name: fct_update_specimen_flat(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_update_specimen_flat() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  cnt integer;
  old_val specimens%ROWTYPE;
  new_val specimens%ROWTYPE;
BEGIN

    IF TG_OP = 'UPDATE' THEN
      old_val = OLD;
      new_val = NEW;
    ELSE --INSERT
      new_val = NEW;
    END IF;

    IF old_val.taxon_ref IS DISTINCT FROM new_val.taxon_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, path, parent_ref, extinct
        INTO NEW.taxon_name, NEW.taxon_name_indexed, NEW.taxon_level_ref, NEW.taxon_level_name, NEW.taxon_status,
          NEW.taxon_path, NEW.taxon_parent_ref, NEW.taxon_extinct
        FROM taxonomy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.taxon_ref;
    END IF;

    IF old_val.chrono_ref IS DISTINCT FROM new_val.chrono_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
      INTO NEW.chrono_name, NEW.chrono_name_indexed, NEW.chrono_level_ref, NEW.chrono_level_name, NEW.chrono_status,
          NEW.chrono_local, NEW.chrono_color, NEW.chrono_path, NEW.chrono_parent_ref
        FROM chronostratigraphy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.chrono_ref;
    END IF;

    IF old_val.litho_ref IS DISTINCT FROM new_val.litho_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
        INTO NEW.litho_name, NEW.litho_name_indexed, NEW.litho_level_ref, NEW.litho_level_name, NEW.litho_status,
          NEW.litho_local, NEW.litho_color, NEW.litho_path, NEW.litho_parent_ref
        FROM lithostratigraphy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.litho_ref;
    END IF;

    IF old_val.lithology_ref IS DISTINCT FROM new_val.lithology_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
        INTO NEW.lithology_name, NEW.lithology_name_indexed, NEW.lithology_level_ref, NEW.lithology_level_name, NEW.lithology_status,
          NEW.lithology_local, NEW.lithology_color, NEW.lithology_path, NEW.lithology_parent_ref
        FROM lithology c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.lithology_ref;
    END IF;

    IF old_val.mineral_ref IS DISTINCT FROM new_val.mineral_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
        INTO NEW.mineral_name, NEW.mineral_name_indexed, NEW.mineral_level_ref, NEW.mineral_level_name, NEW.mineral_status,
          NEW.mineral_local, NEW.mineral_color, NEW.mineral_path, NEW.mineral_parent_ref
        FROM mineralogy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.mineral_ref;
    END IF;


    IF old_val.expedition_ref IS DISTINCT FROM new_val.expedition_ref THEN
      SELECT  name, name_indexed
        INTO NEW.expedition_name, NEW.expedition_name_indexed
        FROM expeditions c
        WHERE c.id = new_val.expedition_ref;
    END IF;

    IF old_val.collection_ref IS DISTINCT FROM new_val.collection_ref THEN
      SELECT collection_type, code, name, is_public, parent_ref, path
        INTO NEW.collection_type, NEW.collection_code, NEW.collection_name, NEW.collection_is_public,
          NEW.collection_parent_ref, NEW.collection_path
        FROM collections c
        WHERE c.id = new_val.collection_ref;
    END IF;

    IF old_val.ig_ref IS DISTINCT FROM new_val.ig_ref THEN
      SELECT  ig_num, ig_num_indexed, ig_date, ig_date_mask
        INTO NEW.ig_num, NEW.ig_num_indexed, NEW.ig_date, NEW.ig_date_mask
        FROM igs c
        WHERE c.id = new_val.ig_ref;
    END IF;

    IF old_val.gtu_ref IS DISTINCT FROM new_val.gtu_ref THEN
  
        --ftheeten 2016 07 07
        SELECT  code,
         elevation, elevation_accuracy,
         tag_values_indexed, location,

         taggr_countries.tag_value, lineToTagArray(taggr_countries.tag_value),
         taggr_provinces.tag_value, lineToTagArray(taggr_provinces.tag_value),
         (select array_to_string(array(select tag from tags where gtu_ref = c.id and LOWER(sub_group_type) not in ('country', 'province')), ';')) as other_gtu_values,
         (select array(select distinct fullToIndex(tag) from tags where gtu_ref = c.id and LOWER(sub_group_type) not in ('country', 'province'))) as other_gtu_values_array

        INTO NEW.gtu_code,
         NEW.gtu_elevation, NEW.gtu_elevation_accuracy, NEW.gtu_tag_values_indexed, NEW.gtu_location,
         NEW.gtu_country_tag_value, NEW.gtu_country_tag_indexed, NEW.gtu_province_tag_value,
         NEW.gtu_province_tag_indexed, NEW.gtu_others_tag_value, NEW.gtu_others_tag_indexed
        FROM gtu c
          LEFT JOIN tag_groups taggr_countries ON c.id = taggr_countries.gtu_ref AND taggr_countries.group_name_indexed = 'administrativearea' AND taggr_countries.sub_group_name_indexed = 'country'
          LEFT JOIN tag_groups taggr_provinces ON c.id = taggr_provinces.gtu_ref AND taggr_provinces.group_name_indexed = 'administrativearea' AND taggr_provinces.sub_group_name_indexed = 'province'
        WHERE c.id = new_val.gtu_ref;
    END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_update_specimen_flat() OWNER TO darwin2;

--
-- TOC entry 1610 (class 1255 OID 18963)
-- Name: fct_update_specimen_flat_bck20160713(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_update_specimen_flat_bck20160713() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  cnt integer;
  old_val specimens%ROWTYPE;
  new_val specimens%ROWTYPE;
BEGIN

    IF TG_OP = 'UPDATE' THEN
      old_val = OLD;
      new_val = NEW;
    ELSE --INSERT
      new_val = NEW;
    END IF;

    IF old_val.taxon_ref IS DISTINCT FROM new_val.taxon_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, path, parent_ref, extinct
        INTO NEW.taxon_name, NEW.taxon_name_indexed, NEW.taxon_level_ref, NEW.taxon_level_name, NEW.taxon_status,
          NEW.taxon_path, NEW.taxon_parent_ref, NEW.taxon_extinct
        FROM taxonomy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.taxon_ref;
    END IF;

    IF old_val.chrono_ref IS DISTINCT FROM new_val.chrono_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
      INTO NEW.chrono_name, NEW.chrono_name_indexed, NEW.chrono_level_ref, NEW.chrono_level_name, NEW.chrono_status,
          NEW.chrono_local, NEW.chrono_color, NEW.chrono_path, NEW.chrono_parent_ref
        FROM chronostratigraphy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.chrono_ref;
    END IF;

    IF old_val.litho_ref IS DISTINCT FROM new_val.litho_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
        INTO NEW.litho_name, NEW.litho_name_indexed, NEW.litho_level_ref, NEW.litho_level_name, NEW.litho_status,
          NEW.litho_local, NEW.litho_color, NEW.litho_path, NEW.litho_parent_ref
        FROM lithostratigraphy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.litho_ref;
    END IF;

    IF old_val.lithology_ref IS DISTINCT FROM new_val.lithology_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
        INTO NEW.lithology_name, NEW.lithology_name_indexed, NEW.lithology_level_ref, NEW.lithology_level_name, NEW.lithology_status,
          NEW.lithology_local, NEW.lithology_color, NEW.lithology_path, NEW.lithology_parent_ref
        FROM lithology c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.lithology_ref;
    END IF;

    IF old_val.mineral_ref IS DISTINCT FROM new_val.mineral_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
        INTO NEW.mineral_name, NEW.mineral_name_indexed, NEW.mineral_level_ref, NEW.mineral_level_name, NEW.mineral_status,
          NEW.mineral_local, NEW.mineral_color, NEW.mineral_path, NEW.mineral_parent_ref
        FROM mineralogy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.mineral_ref;
    END IF;


    IF old_val.expedition_ref IS DISTINCT FROM new_val.expedition_ref THEN
      SELECT  name, name_indexed
        INTO NEW.expedition_name, NEW.expedition_name_indexed
        FROM expeditions c
        WHERE c.id = new_val.expedition_ref;
    END IF;

    IF old_val.collection_ref IS DISTINCT FROM new_val.collection_ref THEN
      SELECT collection_type, code, name, is_public, parent_ref, path
        INTO NEW.collection_type, NEW.collection_code, NEW.collection_name, NEW.collection_is_public,
          NEW.collection_parent_ref, NEW.collection_path
        FROM collections c
        WHERE c.id = new_val.collection_ref;
    END IF;

    IF old_val.ig_ref IS DISTINCT FROM new_val.ig_ref THEN
      SELECT  ig_num, ig_num_indexed, ig_date, ig_date_mask
        INTO NEW.ig_num, NEW.ig_num_indexed, NEW.ig_date, NEW.ig_date_mask
        FROM igs c
        WHERE c.id = new_val.ig_ref;
    END IF;

    IF old_val.gtu_ref IS DISTINCT FROM new_val.gtu_ref THEN
      SELECT  code, gtu_from_date, gtu_from_date_mask,
         gtu_to_date, gtu_to_date_mask,
         elevation, elevation_accuracy,
         tag_values_indexed, location,

         taggr_countries.tag_value, lineToTagArray(taggr_countries.tag_value),
         taggr_provinces.tag_value, lineToTagArray(taggr_provinces.tag_value),
         (select array_to_string(array(select tag from tags where gtu_ref = c.id and sub_group_type not in ('country', 'province')), ';')) as other_gtu_values,
         (select array(select distinct fullToIndex(tag) from tags where gtu_ref = c.id and sub_group_type not in ('country', 'province'))) as other_gtu_values_array

        INTO NEW.gtu_code, NEW.gtu_from_date, NEW.gtu_from_date_mask, NEW.gtu_to_date, NEW.gtu_to_date_mask,
         NEW.gtu_elevation, NEW.gtu_elevation_accuracy, NEW.gtu_tag_values_indexed, NEW.gtu_location,
         NEW.gtu_country_tag_value, NEW.gtu_country_tag_indexed, NEW.gtu_province_tag_value,
         NEW.gtu_province_tag_indexed, NEW.gtu_others_tag_value, NEW.gtu_others_tag_indexed
        FROM gtu c
          LEFT JOIN tag_groups taggr_countries ON c.id = taggr_countries.gtu_ref AND taggr_countries.group_name_indexed = 'administrativearea' AND taggr_countries.sub_group_name_indexed = 'country'
          LEFT JOIN tag_groups taggr_provinces ON c.id = taggr_provinces.gtu_ref AND taggr_provinces.group_name_indexed = 'administrativearea' AND taggr_provinces.sub_group_name_indexed = 'province'
        WHERE c.id = new_val.gtu_ref;
    END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_update_specimen_flat_bck20160713() OWNER TO darwin2;

--
-- TOC entry 1611 (class 1255 OID 18964)
-- Name: fct_update_specimens_flat_related(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_update_specimens_flat_related() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  indCount INTEGER := 0;
  indType BOOLEAN := false;
  tmp_user text;
  collection_text_path varchar;
BEGIN
 SELECT COALESCE(get_setting('darwin.userid'),'0') INTO tmp_user;
  PERFORM set_config('darwin.userid', '-1', false) ;

  IF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'expeditions' THEN
    IF NEW.name_indexed IS DISTINCT FROM OLD.name_indexed THEN
      UPDATE specimens
      SET (expedition_name, expedition_name_indexed) =
          (NEW.name, NEW.name_indexed)
      WHERE expedition_ref = NEW.id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'collections' THEN
    IF OLD.collection_type IS DISTINCT FROM NEW.collection_type
    OR OLD.code IS DISTINCT FROM NEW.code
    OR OLD.name IS DISTINCT FROM NEW.name
    OR OLD.is_public IS DISTINCT FROM NEW.is_public
    OR OLD.path IS DISTINCT FROM NEW.path
    THEN
	  SELECT name_full_path INTO  collection_text_path FROM v_collections_full_path_recursive WHERE  v_collections_full_path_recursive.id=NEW.id;
	  
      UPDATE specimens
      SET (collection_type, collection_code, collection_name, collection_is_public,
          collection_parent_ref, collection_path, 
		  collection_name_full_path
          ) =
          (NEW.collection_type, NEW.code, NEW.name, NEW.is_public,
           NEW.parent_ref, NEW.path, collection_text_path
          )
      WHERE collection_ref = NEW.id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'gtu' THEN

    --ftheeten 206 017 07
    UPDATE specimens
    SET (gtu_code,
         gtu_elevation, gtu_elevation_accuracy,
         gtu_tag_values_indexed, gtu_location,
         --2018 05 07
         gtu_iso3166, gtu_iso3166_subdivision
        ) =
        (NEW.code, 
         NEW.elevation, NEW.elevation_accuracy,
         NEW.tag_values_indexed, NEW.location,
         --2018 05 07
         NEW.iso3166, NEW.iso3166_subdivision
        )
    WHERE gtu_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'igs' THEN
    IF NEW.ig_num_indexed IS DISTINCT FROM OLD.ig_num_indexed OR NEW.ig_date IS DISTINCT FROM OLD.ig_date THEN
      UPDATE specimens
      SET (ig_num, ig_num_indexed, ig_date, ig_date_mask) =
          (NEW.ig_num, NEW.ig_num_indexed, NEW.ig_date, NEW.ig_date_mask)
      WHERE ig_ref = NEW.id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'taxonomy' THEN
   --2nd if because name field block function for other tables
	IF (NEW.name != OLD.name OR NEW.name_indexed != OLD.name_indexed Or
         NEW.level_ref != OLD.level_ref 
         OR NEW.status!= OLD.status OR NEW.path !=OLD.path OR NEW.parent_ref != OLD.parent_ref OR  NEW.extinct!= OLd.extinct)
	  THEN
	    UPDATE specimens
	    SET (taxon_name, taxon_name_indexed,
		 taxon_level_ref, taxon_level_name,
		 taxon_status, taxon_path, taxon_parent_ref, taxon_extinct
		) =
		(NEW.name, NEW.name_indexed,
		 NEW.level_ref, subq.level_name,
		 NEW.status, NEW.path, NEW.parent_ref, NEW.extinct
		)
		FROM
		(SELECT level_name
		 FROM catalogue_levels
		 WHERE id = NEW.level_ref
		) subq
	    WHERE taxon_ref = NEW.id;
	END IF;

  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'chronostratigraphy' THEN
    UPDATE specimens
    SET (chrono_name, chrono_name_indexed,
         chrono_level_ref, chrono_level_name,
         chrono_status,
         chrono_local, chrono_color,
         chrono_path, chrono_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE chrono_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'lithostratigraphy' THEN
    UPDATE specimens
    SET (litho_name, litho_name_indexed,
         litho_level_ref, litho_level_name,
         litho_status,
         litho_local, litho_color,
         litho_path, litho_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE litho_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'lithology' THEN
    UPDATE specimens
    SET (lithology_name, lithology_name_indexed,
         lithology_level_ref, lithology_level_name,
         lithology_status,
         lithology_local, lithology_color,
         lithology_path, lithology_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE lithology_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'mineralogy' THEN
    UPDATE specimens
    SET (mineral_name, mineral_name_indexed,
         mineral_level_ref, mineral_level_name,
         mineral_status,
         mineral_local, mineral_color,
         mineral_path, mineral_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE mineral_ref = NEW.id;

  ELSIF TG_TABLE_NAME = 'tag_groups' THEN
    IF TG_OP = 'INSERT' THEN
      IF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_country_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_province_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF NEW.sub_group_name_indexed NOT IN ('country','province') THEN
      /*Trigger trg_cpy_gtutags_taggroups has already occured and values from tags table should be correct... but really need a check !*/
      /* ftheeten 2017 04 03 handle space in specimens
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag) from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = NEW.gtu_ref;*/
         UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag, true) from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
    ELSIF TG_OP = 'UPDATE' THEN
      IF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'country' AND NEW.sub_group_name_indexed != 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = NULL,
            gtu_country_tag_indexed = NULL
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'province' AND NEW.sub_group_name_indexed != 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = NULL,
            gtu_province_tag_indexed = NULL
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
      IF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_country_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END ||NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_province_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
      IF NEW.sub_group_name_indexed NOT IN ('country','province') THEN
      /*Trigger trg_cpy_gtutags_taggroups has already occured and values from tags table should be correct... but really need a check !*/
      /* ftheeten 2017  04 03 handle spaces in specimens gtu
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag) from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = NEW.gtu_ref;*/
         UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag,true) from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
    ELSIF TG_OP = 'DELETE' THEN
      IF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = NULL,
            gtu_country_tag_indexed = NULL
        WHERE gtu_ref = OLD.gtu_ref;
      ELSIF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = NULL,
            gtu_province_tag_indexed = NULL
        WHERE gtu_ref = OLD.gtu_ref;
      ELSE
        /*Trigger trg_cpy_gtutags_taggroups has already occured and values from tags table should be correct... but really need a check !*/
        /* ftheeten 2017 04 03 handle space in specimens gtu
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = OLD.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag) from tags where gtu_ref = OLD.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = OLD.gtu_ref;*/
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = OLD.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag,true) from tags where gtu_ref = OLD.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = OLD.gtu_ref;
      END IF;
    END IF;
  END IF;
  PERFORM set_config('darwin.userid', tmp_user, false) ;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_update_specimens_flat_related() OWNER TO darwin2;

--
-- TOC entry 1612 (class 1255 OID 18967)
-- Name: fct_update_specimens_flat_related_bck20160713(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_update_specimens_flat_related_bck20160713() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  indCount INTEGER := 0;
  indType BOOLEAN := false;
  tmp_user text;
BEGIN
 SELECT COALESCE(get_setting('darwin.userid'),'0') INTO tmp_user;
  PERFORM set_config('darwin.userid', '-1', false) ;

  IF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'expeditions' THEN
    IF NEW.name_indexed IS DISTINCT FROM OLD.name_indexed THEN
      UPDATE specimens
      SET (expedition_name, expedition_name_indexed) =
          (NEW.name, NEW.name_indexed)
      WHERE expedition_ref = NEW.id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'collections' THEN
    IF OLD.collection_type IS DISTINCT FROM NEW.collection_type
    OR OLD.code IS DISTINCT FROM NEW.code
    OR OLD.name IS DISTINCT FROM NEW.name
    OR OLD.is_public IS DISTINCT FROM NEW.is_public
    OR OLD.path IS DISTINCT FROM NEW.path
    THEN
      UPDATE specimens
      SET (collection_type, collection_code, collection_name, collection_is_public,
          collection_parent_ref, collection_path
          ) =
          (NEW.collection_type, NEW.code, NEW.name, NEW.is_public,
           NEW.parent_ref, NEW.path
          )
      WHERE collection_ref = NEW.id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'gtu' THEN
    UPDATE specimens
    SET (gtu_code, gtu_from_date, gtu_from_date_mask,
         gtu_to_date, gtu_to_date_mask,
         gtu_elevation, gtu_elevation_accuracy,
         gtu_tag_values_indexed, gtu_location
        ) =
        (NEW.code, NEW.gtu_from_date, NEW.gtu_from_date_mask,
         NEW.gtu_to_date, NEW.gtu_to_date_mask,
         NEW.elevation, NEW.elevation_accuracy,
         NEW.tag_values_indexed, NEW.location
        )
    WHERE gtu_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'igs' THEN
    IF NEW.ig_num_indexed IS DISTINCT FROM OLD.ig_num_indexed OR NEW.ig_date IS DISTINCT FROM OLD.ig_date THEN
      UPDATE specimens
      SET (ig_num, ig_num_indexed, ig_date, ig_date_mask) =
          (NEW.ig_num, NEW.ig_num_indexed, NEW.ig_date, NEW.ig_date_mask)
      WHERE ig_ref = NEW.id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'taxonomy' THEN
    UPDATE specimens
    SET (taxon_name, taxon_name_indexed,
         taxon_level_ref, taxon_level_name,
         taxon_status, taxon_path, taxon_parent_ref, taxon_extinct
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status, NEW.path, NEW.parent_ref, NEW.extinct
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE taxon_ref = NEW.id;

  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'chronostratigraphy' THEN
    UPDATE specimens
    SET (chrono_name, chrono_name_indexed,
         chrono_level_ref, chrono_level_name,
         chrono_status,
         chrono_local, chrono_color,
         chrono_path, chrono_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE chrono_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'lithostratigraphy' THEN
    UPDATE specimens
    SET (litho_name, litho_name_indexed,
         litho_level_ref, litho_level_name,
         litho_status,
         litho_local, litho_color,
         litho_path, litho_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE litho_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'lithology' THEN
    UPDATE specimens
    SET (lithology_name, lithology_name_indexed,
         lithology_level_ref, lithology_level_name,
         lithology_status,
         lithology_local, lithology_color,
         lithology_path, lithology_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE lithology_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'mineralogy' THEN
    UPDATE specimens
    SET (mineral_name, mineral_name_indexed,
         mineral_level_ref, mineral_level_name,
         mineral_status,
         mineral_local, mineral_color,
         mineral_path, mineral_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE mineral_ref = NEW.id;

  ELSIF TG_TABLE_NAME = 'tag_groups' THEN
    IF TG_OP = 'INSERT' THEN
      IF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_country_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_province_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF NEW.sub_group_name_indexed NOT IN ('country','province') THEN
      /*Trigger trg_cpy_gtutags_taggroups has already occured and values from tags table should be correct... but really need a check !*/
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag) from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
    ELSIF TG_OP = 'UPDATE' THEN
      IF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'country' AND NEW.sub_group_name_indexed != 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = NULL,
            gtu_country_tag_indexed = NULL
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'province' AND NEW.sub_group_name_indexed != 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = NULL,
            gtu_province_tag_indexed = NULL
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
      IF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_country_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END ||NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_province_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
      IF NEW.sub_group_name_indexed NOT IN ('country','province') THEN
      /*Trigger trg_cpy_gtutags_taggroups has already occured and values from tags table should be correct... but really need a check !*/
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag) from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
    ELSIF TG_OP = 'DELETE' THEN
      IF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = NULL,
            gtu_country_tag_indexed = NULL
        WHERE gtu_ref = OLD.gtu_ref;
      ELSIF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = NULL,
            gtu_province_tag_indexed = NULL
        WHERE gtu_ref = OLD.gtu_ref;
      ELSE
        /*Trigger trg_cpy_gtutags_taggroups has already occured and values from tags table should be correct... but really need a check !*/
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = OLD.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag) from tags where gtu_ref = OLD.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = OLD.gtu_ref;
      END IF;
    END IF;
  END IF;
  PERFORM set_config('darwin.userid', tmp_user, false) ;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_update_specimens_flat_related_bck20160713() OWNER TO darwin2;

--
-- TOC entry 1613 (class 1255 OID 18970)
-- Name: fillvals(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fillvals() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  gturef integer ARRAY;
BEGIN
	  gturef:=array[94890,94897,94898,94899,94908,94945,94946,94947,94948,94952,94953,94954,94955,94956,94961,94963,94965,94966,94986,94992,95008,95009,95010,95014,95028,95029,95030,95032,95069,95071,95073,95077,95078,95079,95081,95082,95087,95088,95089,95090,95091,95092,95093,95094,95095,95127,95129,95132,95133,95134,95135,95136,95137,95140,95141,95142,95144,95145,95146,95147,95148,95149,95153,95155,95156,95157,95161,95162,95165,95166,95167,95168,95169,95174,95175,95177,95185,95197,95198,95199,95200,95201,95202,95203,95204,95208,95209,95212,95213,95215,95218,95221,95222,95225,95232,95240,95242,95247,95251,95253,95254,95255,95256,95257,95261,95262,95267,95268,95269,95270,95271,95273,95274,95275,95278,95279,95280,95281,95282,95290,95294,95295,95299,95300,95301,95302,95304,95305,95308,95309,95315,95316,95318,95320,95324,95325,95349,95352,95353,95355,95359,95361,95363,95366,95383,95396,95402,95404,95406,95413,95420,95421,95423,95424,95425,95438,95439,95443,95444,95445,95446,95447,95454,95458,95459,95460,95461,95464,95465,95466,95468,95470,95472,95474,95477,95478,95479,95484,95485,95486,95487,95488,95493,95500,95501,95502,95503,95504,95505,95506,95507,95508,95510,95511,95513,95515,95518,95522,95523,95525,95526,95527,95528,95530,95533,95534,95535,95536,95537,95538,95540,95542,95543,95544,95548,95550,95551,95552,95556,95558,95560,95562,95564,95568,95570,95572,95574,95576,95577,95578,95582,95585,95589,95590,95591,95592,95594,95634,95635,95637,95638,95639,95640,95641,95642,95645,95646,95648,95650,95656,95659,95661,95662,95664,95667,95670,95674,95675,95676,95677,95689,95694,95696,95699,95704,95707,95708,95709,95715,95722,95728,95729,95730,95731,95733,95734,95739,95745,95748,95752,95755,95756,95758,95762,95763,95765,95774,95778,95779,95780,95781,95782,95785,95786,95790,95794,95796,95797,95803,95807,95811,95813,95818,95820,95822,95825,95828,95829,95835,95838,95840,95841,95843,95845,95849,95851,95855,95857,95860,95866,95867,95873,95874,95875,95876,95877,95879,95880,95886,95887,95889,95890,95892,95893,95895,95896,95897,95899,95901,95904,95907,95914,95920,95922,95924,95926,95927,95930,95933,95934,95936,95937,95939,95942,95943,95946,95947,95954,95955,95957,95958,95959,95960,95961,95962,95963,95964,95965,95967,95969,95970,95972,95975,95977,95979,95984,95985,95986,95992,95994,95995,95996,96001,96002,96003,96004,96005,96006,96007,96008,96009,96011,96012,96013,96014,96016,96018,96022,96023,96024,96026,96027,96028,96029,96030,96031,96032,96033,96034,96035,96051,96052,96053,96054,96055,96056,96057,96058,96061,96062,96064,96065,96066,96071,96072,96073,96075,96076,96077,96080,96082,96083,96084,96085,96086,96087,96088,96089,96090,96091,96092,96093,96094,96095,96096,96098,96099,96101,96102,96103,96104,96109,96111,96112,96113,96115,96125,96126,96127,96128,96146,96149,96150,96152,96153,96155,96158,96163,96165,96168,96169,96170,96176,96177,96178,96179,96180,96181,96182,96183,96184,96185,96190,96192,96193,96195,96198,96199,96200,96202,96203,96204,96205,96206,96207,96209,96210,96211,96212,96213,96214,96218,96222,96226,96227,96229,96230,96233,96234,96236,96237,96239,96241,96242,96244,96246,96247,96248,96250,96251,96252,96253,96254,96255,96263,96266,96269,96270,96271,96273,96275,96280,96282,96283,96285,96289,96293,96295,96299,96301,96308,96309,96312,96319,96322,96325,96330,96331,96336,96337,96338,96339,96341,96342,96343,96344,96345,96346,96347,96350,96351,96355,96358,96360,96361,96363,96364,96365,96368,96369,96370,96372,96375,96376,96379,96381,96385,96386,96388,96394,96396,96406,96407,96408,96410,96411,96412,96415,96416,96417,96422,96423,96426,96428,96429,96432,96440,96445,96449,96450,96452,96454,96457,96458,96461,96463,96470,96474,96476,96477,96478,96479,96480,96482,96484,96485,96486,96487,96488,96490,96491,96493,96494,96495,96497,96498,96499,96500,96501,96503,96508,96511,96513,96514,96515,96516,96519,96521,96522,96523,96524,96525,96526,96527,96528,96531,96533,96536,96537,96538,96542,96544,96549,96550,96551,96552,96555,96556,96558,96566,96569,96571,96575,96578,96580,96581,96583,96585,96592,96593,96595,96596,96597,96599,96600,96601,96602,96603,96604,96605,96606,96612,96613,96615,96616,96617,96618,96619,96620,96621,96622,96627,96630,96631,96634,96635,96636,96639,96640,96644,96645,96646,96647,96648,96649,96650,96651,96652,96653,96654,96655,96656,96657,96658,96659,96661,96662,96663,96667,96671,96672,96674,96676,96677,96678,96680,96686,96687,96689,96690,96691,96692,96693,96694,96695,96696,96697,96698,96699,96701,96702,96710,96711,96712,96713,96714,96715,96719,96721,96722,96758,96769,96770,96775,96776,96777,96778,96779,96780,96782,96783,96784,96786,96787,96788,96789,96791,96803,96805,96806,96807,96808,96810,96811,96812,96813,96814,96815,96818,96825,96826,96828,96829,96831,96832,96833,96834,96836,96837,96838,96840,96841,96842,96843,96844,96845,96846,96851,96857,96858,96859,96860,96864,96865,96866,96867,96868,96869,96870,96871,96872,96873,96874,96875,96876,96877,96878,96879,96880,96881,96882,96883,96884,96885,96886,96887,96892,96893,96896,96897,96900,96901,96902,96903,96904,96905,96907,96910,96911,96912,96913,96914,96916,96919,96920,96921,96922,96924,96926,96928,96933,96934,96936,96937,96938,96944,96947,96958,96963,96970,96971,96973,96974,96975,96976,96977,96978,96979,96980,96981,96982,96984,96986,96987,96989,96990,96991,96992,96993,96994,96996,96997,96998,96999,97001,97003,97004,97005,97006,97007,97008,97009,97010,97011,97012,97015,97017,97018,97019,97020,97021,97022,97023,97026,97027,97029,97030,97031,97032,97033,97034,97035,97036,97038,97041,97043,97045,97051,97052,97053,97054,97055,97056,97057,97058,97059,97060,97061,97064,97065,97066,97067,97069,97072,97075,97078,97082,97083,97085,97092,97102,97103,97108,97111,97117,97118,97119,97121,97125,97129,97130,97131,97132,97133,97136,97137,97138,97139,97141,97143,97146,97148,97149,97150,97151,97152,97153,97154,97155,97157,97158,97159,97160,97161,97162,97163,97165,97166,97167,97168,97169,97170,97171,97172,97173,97174,97175,97179,97182,97184,97187,97189,97190,97192,97193,97195,97196,97197,97198,97199,97200,97202,97203,97204,97206,97208,97209,97210,97211,97213,97214,97215,97217,97219,97220,97221,97222,97226,97227,97229,97230,97242,97244,97246,97272,97273,97274,97276,97279,97280,97282,97283,97287,97288,97290,97291,97298,97302,97303,97304,97305,97306,97307,97308,97309,97313,97314,97315,97318,97319,97320,97321,97323,97325,97327,97328,97331,97332,97334,97335,97336,97337,97339,97340,97341,97344,97345,97346,97348,97355,97358,97359,97362,97364,97365,97367,97368,97369,97370,97373,97374,97386,97387,97388,97390,97393,97394,97395,97397,97403,97407,97408,97410,97411,97412,97416,97417,97418,97419,97420,97421,97424,97426,97427,97430,97431,97432,97436,97437,97438,97439,97441,97444,97448,97449,97452,97455,97460,97461,97462,97466,97467,97468,97469,97470,97476,97485,97486,97487,97488,97489,97492,97493,97497,97498,97499,97500,97505,97519,97520,97522,97523,97525,97529,97539,97540,97542,97545,97546,97549,97552,97556,97557,97558,97562,97567,97573,97574,97575,97576,97577,97578,97579,97581,97583,97584,97587,97589,97590,97591,97592,97594,97595,97596,97597,97599,97601,97603,97604,97605,97612,97614,97615,97618,97622,97623,97624,97627,97628,97630,97632,97635,97637,97638,97639,97641,97648,97651,97655,97657,97658,97660,97661,97664,97665,97667,97668,97669,97671,97672,97674,97679,97684,97685,97696,97698,97699,97701,97703,97706,97709,97711,97712,97713,97715,97716,97718,97722,97724,97726,97727,97728,97729,97732,97734,97737,97738,97743,97744,97749,97750,97751,97752,97753,97754,97755,97760,97761,97762,97767,97769,97770,97771,97772,97773,97774,97776,97777,97781,97784,97785,97786,97788,97789,97790,97791,97793,97794,97796,97797,97798,97799,97800,97802,97804,97805,97806,97807,97817,97818,97823,97825,97827,97829,97830,97832,97834,97836,97838,97839,97841,97842,97843,97849,97851,97852,97867,97869,97872,97873,97876,97886,97887,97888,97896,97901,97906,97907,97909,97911,97912,97914,97915,97916,97919,97921,97922,97925,97927,97928,97929,97930,97931,97932,97939,97957,97962,97966,97967,97970,97975,97985,97992,97993,97996,97998,97999,98001,98005,98010,98012,98013,98014,98016,98017,98018,98019,98020,98022,98023,98024,98027,98029,98030,98035,98046,98049,98050,98052,98060,98061,98062,98065,98068,98074,98075,98076,98079,98081,98087,98088,98092,98095,98096,98098,98099,98100,98102,98104,98105,98106,98107,98116,98117,98125,98127,98148,98166,98172,98178,98196,98197,98198,98204,98210,98219,98221,98223,98224,98240,98241,98243,98245,98250,98251,98252,98253,98254,98255,98256,98258,98259,98261,98262,98265,98267,98272,98273,98282,98283,98284,98285,98286,98289,98291,98296,98297,98299,98300,98301,98303,98304,98310,98311,98332,98333,98334,98337,98339,98342,98343,98344,98345,98349,98351,98353,98354,98357,98364,98366,98368,98370,98378,98382,98388,98389,98399,98400,98401,98402,98404,98405,98408,98409,98411,98412,98413,98414,98416,98418,98419,98421,98424,98425,98427,98429,98430,98432,98434,98435,98440,98443,98444,98446,98447,98448,98450,98451,98455,98458,98459,98460,98461,98462,98463,98464,98465,98466,98472,98473,98474,98476,98478,98479,98482,98489,98491,98492,98494,98495,98496,98498,98499,98501,98505,98506,98510,98511,98513,98514,98515,98516,98518,98528,98529,98530,98531,98532,98533,98535,98542,98543,98544,98546,98552,98555,98556,98557,98558,98559,98561,98562,98565,98568,98572,98574,98577,98582,98585,98586,98587,98591,98593,98595,98600,98602,98603,98604,98605,98606,98608,98610,98613,98614,98616,98621,98622,98623,98629,98631,98633,98637,98639,98645,98647,98648,98652,98653,98657,98658,98660,98663,98664,98665,98666,98667,98669,98670,98672,98677,98679,98684,98686,98687,98689,98694,98696,98697,98702,98707,98711,98712,98713,98715,98716,98717,98719,98720,98724,98725,98726,98728,98730,98731,98733,98734,98735,98744,98746,98747,98749,98750,98752,98758,98761,98771,98772,98773,98785,98788,98792,98793,98798,98801,98802,98805,98806,98807,98808,98809,98810,98811,98812,98815,98823,98824,98825,98828,98830,98831,98833,98834,98835,98836,98837,98839,98840,98841,98842,98843,98844,98845,98847,98849,98851,98853,98854,98856,98858,98862,98864,98865,98866,98867,98868,98869,98870,98871,98872,98874,98885,98886,98892,98894,98895,98897,98901,98905,98908,98913,98916,98917,98920,98926,98927,98931,98935,98936,98937,98939,98942,98943,98947,98948,98949,98950,98952,98954,98955,98956,98957,98967,98983,98987,98988,98996,98997,98999,99003,99005,99006,99007,99008,99009,99010,99011,99012,99013,99015,99020,99022,99023,99025,99026,99028,99033,99035,99036,99037,99039,99040,99042,99043,99044,99047,99049,99050,99051,99052,99053,99054,99056,99057,99091,99092,99096,99109,99112,99115,99118,99123,99126,99128,99129,99130,99132,99135,99137,99139,99140,99143,99147,99148,99150,99152,99154,99156,99157,99160,99171,99179,99180,99181,99182,99188,99189,99190,99196,99197,99198,99199,99201,99202,99204,99205,99210,99211,99213,99214,99217,99218,99219,99220,99222,99224,99233,99234,99249,99250,99265,99267,99268,99269,99271,99272,99281,99282,99283,99287,99288,99296,99314,99324,99325,99326,99328,99329,99330,99333,99334,99335,99336,99338,99339,99340,99342,99343,99345,99346,99347,99348,99350,99351,99353,99354,99355,99357,99359,99360,99366,99370,99376,99379,99381,99382,99388,99390,99391,99392,99393,99401,99411,99413,99432,99433,99435,99436,99443,99450,99451,99459,99461,99464,99473,99474,99479,99480,99483,99488,99490,99496,99498,99499,99501,99505,99507,99508,99510,99511,99513,99515,99516,99530,99535,99536,99543,99544,99545,99546,99547,99565,99575,99580,99584,99585,99586,99589,99590,99591,99593,99595,99596,99599,99600,99602,99604,99606,99607,99612,99614,99622,99624,99626,99628,99629,99630,99631,99633,99634,99639,99641,99644,99653,99654,99655,99656,99657,99658,99659,99660,99662,99663,99664,99665,99667,99668,99669,99670,99671,99675,99676,99677,99679,99686,99689,99690,99693,99697,99698,99701,99702,99703,99705,99706,99707,99708,99709,99710,99711,99712,99713,99714,99715,99716,99717,99718,99719,99720,99724,99725,99726,99729,99730,99731,99732,99742,99743,99744,99750,99753,99758,99759,99761,99763,99768,99769,99771,99773,99774,99775,99778,99788,99789,99792,99794,99806,99810,99812,99813,99822,99826,99835,99836,99837,99838,99839,99840,99844,99849,99850,99853,99854,99855,99856,99857,99859,99860,99862,99865,99868,99870,99873,99875,99876,99877,99878,99879,99880,99882,99883,99884,99885,99886,99887,99888,99889,99890,99891,99893,99895,99896,99899,99901,99902,99907,99908,99910,99911,99913,99914,99915,99916,99917,99918,99919,99925,99934,99935,99937,99945,99946,99949,99951,99952,99954,99958,99964,99966,99975,99977,99978,99993,99995,99996,99998,100004,100008,100011,100015,100020,100021,100029,100030,100031,100036,100039,100042,100047,100055,100060,100063,100067,100070,100072,100083,100086,100090,100095,100100,100118,100119,100120,100121,100123,100124,100125,100127,100128,100129,100130,100136,100137,100138,100140,100141,100142,100143,100144,100145,100147,100148,100152,100153,100154,100156,100170,100174,100176,100179,100182,100185,100199,100218,100219,100221,100222,100224,100232,100235,100236,100237,100238,100255,100257,100259,100263,100270,100271,100272,100273,100284,100287,100288,100289,100291,100292,100293,100295,100325,100330,100333,100346,100349,100369,100370,100371,100372,100373,100374,100375,100410,100431,100436,100439,100440,100441,100442,100443,100445,100447,100449,100450,100451,100453,100454,100458,100459,100460,100461,100464,100466,100467,100468,100474,100480,100481,100482,100487,100489,100490,100491,100492,100493,100494,100495,100496,100500,100507,100511,100512,100513,100514,100515,100516,100518,100527,100549,100550,100551,100552,100553,100554,100555,100556,100557,100558,100559,100560,100564,100565,100566,100567,100568,100569,100570,100571,100572,100573,100575,100576,100577,100578,100579,100583,100586,100587,100588,100591,100592,100593,100594,100596,100597,100598,100608,100609,100610,100611,100612,100613,100617,100618,100622,100638,100645,100647,100648,100652,100655,100792,100793,100794,100796,100797,100801,100802,100812,100813,100816,100817,100820,100821,100822,100826,100827,100828,100829,100830,100858,100859,101019,101020,101022,101023,101060,101163,101348,101349,101350,101363,101393,101398,101403,101406,101462,101470,101473,101475,101476,101478,101487,101490,101494,101497,101503,101505,101586,101587,101632,101633,101635,101636,101637,101639,101763,101764,101765,101766,101767,101768,101806,101808,101854,101871,101872,101878,101899,101900,101904,101905,101906,101931,101932,101934,101936,101938,101955,101957,101958,101959,101960,101961,101965,101967,101970,101974,101975,101988,101991,101994,101995,102053,102054,102055,102061,102063,102067,102068,102069,102070,102072,102186,102189,102194,102203,102204,102207,102211,102213,102218,102231,102244,102248,102398,102399,102431,102432,102433,102434,102435,102436,102437,102438,102440,102441,102444,102445,102446,102447,102448,102449,102450,102451,102453,102454,102455,102456,102459,102461,102462,102492,102493,102494,102496,102498,102499,102501,102503,102504,102510,102527,102546,102547,102548,102618,102619,102620,102624,102625,102631,102654,102658,102695,102696,102698,102700,102701,102702,102704,102705,102716,102717,102784,102789,102858,102860,102861,102862,102877,102881,102895,102897,102902,102905,102907,102908,102925,102926,102927,102928,102929,102933,103016,103070,103443,103445,103448,103449,103450,103451,103452,103995,103996,103997,103998,103999,104048,104049,104050,104058,104065,104067,104076,104077,104078,104079,104080,104081,104082,104083,104085,104086,104087,104094,104095,104096,104097,104100,104101,104104,104106,104107,104110,104114,104120,104121,104127,104130,104131,104132,104133,104135,104136,104137,104138,104140,104142,104178,104182,104188,104227,104233,104234,104235,104258,104260,104269,104272,104273,104274,104275,104279,104280,104281,104282,104283,104998,105002,105021,105103,105104,105105,105106,105107,105108,105109,105110,105207,105873,105874,105875,105879,105887,105901,105902,106218,106219,106220,106221,106222,106223,106224,106225,106226,106243,106248,106249,106250,106252,106307,106317,106423,106427,106428,106430,106434,106441,106442,106443,106445,106446,106447,106489,106490,106491,106492,106494,106495,106501,106502,106503,106622,106624,106630,106636,106637,106661,106664,106665,106666,106667,106668,106673,106675,106677,106678,106679,106684,106686,106689,106691,106692,106693,106694,106733,106735,106736,106751,106752,106754,106755,106756,106757,106810,106812,106813,106814,106826,106827,106829,106830,106833,106834,106835,106839,106840,106843,106846,106850,106882,106884,106885,106886,106888,106889,106890,106891,106892,106896,106897,106898,106899,106900,106901,106904,106905,106906,106907,106911,106912,106914,106920,106922,106923,106925,106932,106933,106935,106937,106938,106940,106941,106946,106950,106951,106956,106969,106995,106996,106997,106998,107034,107036,107038,107039,107049,107050,107051,107052,107053,107054,107056,107057,107058,107059,107061,107064,107067,107069,107070,107083,107084,107086,107087,107090,107091,107094,107131,107136,107138,107139,107148,107156,107157,107159,107162,107163,107169,107170,107179,107180,107181,107182,107183,107184,107185,107187,107188,107192,107194,107196,107199,107200,107201,107203,107204,107207,107211,107213,107215,107216,107219,107220,107221,107224,107226,107243,107244,107245,107246,107255,107259,107261,107265,107268,107269,107270,107271,107273,107274,107276,107277,107282,107289,107297,107298,107300,107301,107302,107303,107379,107380,107381,107382,107384,107385,107386,107389,107402,107403,107404,107405,107406,107407,107408,107412,108113,108115,108116,108117,108118,108119,108120,108280,108804,108805,109253,109254,109255,109256,109257,109262,109263,109289,109290,109318,109319,109320,109321,109323,109324,109326,109327,109328,109329,109331,109332,109333,109334,109335,109336,109337,109338,109339,109340,109341,109342,109343,109344,109345,109346,109395,109396,109398,109406,109409,109415,109416,109417,109420,109421,109423,109456,109457,109459,109460,109480,109482,109483,109521,109530,109531,109532,109535,109538,109539,109541,109542,109567,109570,109572,109573,109574,109576,109579,109580,109584,109585,109586,109587,109634,109832,109833,110547,110548,110549,110551,110555,110557,110558,110560,110562,110563,110564,110565,110566,110567,110568,110570,110571,110573,110575,110576,110577,110578,110579,110580,110581,110582,110585,110586,110589,110590,110591,110592,110596,110597,110598,110599,110600,110602,110603,110604,110605,110608,111296,111297,111303,111304,111305,111306,111309,111496,111535,112407,112408,112411,112526,112527,112528,114387,114389,114390,114391,114394,114399,114400,114401,114402,114403,114404,114408,114410,114411,114413,114441,114442,114661,115121,115123,115124,115125,115787,115789,115792,115793,115794,115795,115797,115798,115799,115800,115802,115803,115805,115981,116545,116995,117124,117335,117766,118665,118666,118667,118668,118670,118672,118673,118674,118676,118677,118678,118680,118681,119018,119019,119020,119024,119025,119026,119285];

	for r in 0..3000 loop
		
		INSERT INTO comments(referenced_relation, record_id, id, notion_concerned, comment, comment_indexed)
				VALUES ('gtu', gturef[r+1],1412584+r, 'position information', 'Congo Belge', 'congobelge');
	END LOOP;
END;
$$;


ALTER FUNCTION darwin2.fillvals() OWNER TO darwin2;

--
-- TOC entry 1614 (class 1255 OID 18973)
-- Name: filter_2_arrays_by_key(character varying[], character varying[], character varying[], boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.filter_2_arrays_by_key(p_array_values character varying[], p_array_keys character varying[], p_array_selected_keys character varying[], exclude_mode boolean DEFAULT false) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned varchar[];
	i integer;
	
BEGIN 
	
	IF ARRAY_LENGTH(p_array_values ,1)=ARRAY_LENGTH(p_array_keys ,1)  THEN
		FOR i IN 1 .. ARRAY_UPPER(p_array_values,1 )
		LOOP
			IF exclude_mode =false THEN
				IF p_array_keys[i] = any(p_array_selected_keys) THEN
					returned:=returned||p_array_values[i];
				END IF;
			ELSE
				IF p_array_keys[i] <> all(p_array_selected_keys) THEN
					returned:=returned||p_array_values[i];
				END IF;
			END IF;
		END LOOP;
	END IF;
	RETURN returned;

END;
$$;


ALTER FUNCTION darwin2.filter_2_arrays_by_key(p_array_values character varying[], p_array_keys character varying[], p_array_selected_keys character varying[], exclude_mode boolean) OWNER TO darwin2;

--
-- TOC entry 1600 (class 1255 OID 18974)
-- Name: fulltoindex(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fulltoindex(to_indexed character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
BEGIN
   return fulltoindex(to_indexed, false);
END;
$$;


ALTER FUNCTION darwin2.fulltoindex(to_indexed character varying) OWNER TO darwin2;

--
-- TOC entry 1601 (class 1255 OID 18975)
-- Name: fulltoindex(character varying, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fulltoindex(to_indexed character varying, keep_space boolean) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    temp_string varchar;
BEGIN
    -- Investigate https://launchpad.net/postgresql-unaccent
    temp_string := to_indexed;
    temp_string := translate(temp_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
    temp_string := translate(temp_string, 'èééêëēĕėęěĒĔĖĘĚ', 'eeeeeeeeeeeeeee');
    temp_string := translate(temp_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
    temp_string := translate(temp_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
    temp_string := translate(temp_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
    temp_string := REPLACE(temp_string, 'Œ', 'oe');
    temp_string := REPLACE(temp_string, 'Ӕ', 'ae');
    temp_string := REPLACE(temp_string, 'œ', 'oe');
    temp_string := REPLACE(temp_string, 'æ', 'ae');
    temp_string := REPLACE(temp_string, 'ë', 'e');
    temp_string := REPLACE(temp_string, 'ï', 'i');
    temp_string := REPLACE(temp_string, 'ö', 'o');
    temp_string := REPLACE(temp_string, 'ü', 'u');
--     temp_string := REPLACE(temp_string, E'\'', '');
--     temp_string := REPLACE(temp_string, '"', '');
    temp_string := REPLACE(temp_string, 'ñ', 'n');
    temp_string := REPLACE(temp_string,chr(946),'b');
    temp_string := TRANSLATE(temp_string,'Ð','d');
    temp_string := TRANSLATE(temp_string,'ó','o');
    temp_string := TRANSLATE(temp_string,'ę','e');
    temp_string := TRANSLATE(temp_string,'ā','a');
    temp_string := TRANSLATE(temp_string,'ē','e');
    temp_string := TRANSLATE(temp_string,'ī','i');
    temp_string := TRANSLATE(temp_string,'ō','o');
    temp_string := TRANSLATE(temp_string,'ū','u');
    temp_string := TRANSLATE(temp_string,'ş','s');
    temp_string := TRANSLATE(temp_string,'Ş','s');
--     temp_string := TRANSLATE(temp_string,'†','');
--     temp_string := TRANSLATE(temp_string,chr(52914),'');
--ftheeten 2015 02 15

--ftheeten 2017 01 22
temp_string := TRANSLATE(temp_string,'-',' ');
temp_string := TRANSLATE(temp_string,'''',' ');
    -- FROM 160 to 255 ASCII
    temp_string := TRANSLATE(temp_string, ' ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ',
      '  cL YS sCa  -R     Zu .z   EeY?AAAAAAACEEEEIIII NOOOOOxOUUUUYTBaaaaaaaceeeeiiii nooooo/ouuuuyty');
    --Remove ALL none alphanumerical char
    if keep_space= false then
    temp_string := lower(regexp_replace(temp_string,'[^[:alnum:]]','', 'g'));
    else
        temp_string := lower(regexp_replace(temp_string,'[^[:alnum:]\s]','', 'g'));
	temp_string :=regexp_replace(temp_string,'(\s{2,})',' ', 'g');
	
    end if;
    return temp_string;
END;
$$;


ALTER FUNCTION darwin2.fulltoindex(to_indexed character varying, keep_space boolean) OWNER TO darwin2;

--
-- TOC entry 1602 (class 1255 OID 18976)
-- Name: fulltoindex_array(character varying[]); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fulltoindex_array(to_indexed character varying[]) RETURNS character varying[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
BEGIN
   return fulltoindex_array(to_indexed, false);
END;
$$;


ALTER FUNCTION darwin2.fulltoindex_array(to_indexed character varying[]) OWNER TO darwin2;

--
-- TOC entry 1603 (class 1255 OID 18977)
-- Name: fulltoindex_array(character varying[], boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fulltoindex_array(to_indexed character varying[], keep_space boolean) RETURNS character varying[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    temp_string varchar[];
    i int;
BEGIN
	temp_string:='{}';
	FOR i IN 1 .. array_upper(to_indexed, 1)
	LOOP
		if to_indexed[i] <> '' then
		temp_string:=temp_string||fulltoindex(to_indexed[i], keep_space);
		end if;
	END LOOP;
    return temp_string;
END;
$$;


ALTER FUNCTION darwin2.fulltoindex_array(to_indexed character varying[], keep_space boolean) OWNER TO darwin2;

--
-- TOC entry 1604 (class 1255 OID 18978)
-- Name: get_import_row(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.get_import_row() RETURNS integer
    LANGUAGE sql SECURITY DEFINER
    AS $$

UPDATE imports SET state = 'loading' FROM (
  SELECT * FROM (
    SELECT  * FROM imports i1 WHERE i1.state = 'to_be_loaded' ORDER BY i1.created_at asc, id asc OFFSET 0 --thats important
  ) i2
  WHERE pg_try_advisory_lock('imports'::regclass::integer, i2.id)
  LIMIT 1
) i3
WHERE imports.id = i3.id RETURNING i3.id;
$$;


ALTER FUNCTION darwin2.get_import_row() OWNER TO darwin2;

--
-- TOC entry 1605 (class 1255 OID 18979)
-- Name: get_setting(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.get_setting(param text, OUT value text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$BEGIN
  SELECT current_setting(param) INTO value;
  EXCEPTION
  WHEN UNDEFINED_OBJECT THEN
    value := NULL;
END;$$;


ALTER FUNCTION darwin2.get_setting(param text, OUT value text) OWNER TO darwin2;

--
-- TOC entry 791 (class 1255 OID 18980)
-- Name: getspecificparentforlevel(character varying, character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.getspecificparentforlevel(referenced_relation character varying, path character varying, level_searched character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  response template_classifications.name%TYPE := '';
BEGIN
  EXECUTE
  'SELECT name ' ||
  ' FROM '
  || quote_ident(lower(referenced_relation)) || ' cat '
  ' INNER JOIN catalogue_levels ON cat.level_ref = catalogue_levels.id '
  ' WHERE level_name = '
  || quote_literal(lower(level_searched)) ||
  '   AND cat.id IN (SELECT i_id::integer FROM regexp_split_to_table(' || quote_literal(path) || E', E''\/'') as i_id WHERE i_id != '''')'
  INTO response;
  RETURN response;
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Error in getSpecificParentForLevel: %', SQLERRM;
    RETURN response;
END;
$$;


ALTER FUNCTION darwin2.getspecificparentforlevel(referenced_relation character varying, path character varying, level_searched character varying) OWNER TO darwin2;

--
-- TOC entry 795 (class 1255 OID 18981)
-- Name: gettagsindexedasarray(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.gettagsindexedasarray(taglist character varying) RETURNS character varying[]
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT array_agg(tags) FROM (SELECT lineToTagRows($1) as tags) as subQuery;
$_$;


ALTER FUNCTION darwin2.gettagsindexedasarray(taglist character varying) OWNER TO darwin2;

--
-- TOC entry 1615 (class 1255 OID 18982)
-- Name: is_property_unit_in_group(text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.is_property_unit_in_group(searched_unit text, property_unit text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$

  SELECT CASE
  WHEN $1 IN ('Kt', 'Beaufort', 'm/s')
    AND  $2  IN ('Kt', 'Beaufort', 'm/s')
    THEN TRUE
  WHEN $1 IN ( 'g', 'hg', 'kg', 'ton', 'dg', 'cg', 'mg', 'lb', 'lbs', 'pound' , 'ounce' , 'grain')
    AND  $2  IN ( 'g', 'hg', 'kg', 'ton', 'dg', 'cg', 'mg', 'lb', 'lbs', 'pound' , 'ounce' , 'grain')
    THEN TRUE

  WHEN $1 IN ('m³', 'l', 'cm³', 'ml', 'mm³' ,'µl' , 'µm³' , 'km³', 'Ml' , 'hl')
    AND  $2  IN ( 'g', 'hg', 'kg', 'ton', 'dg', 'cg', 'mg', 'lb', 'lbs', 'pound' , 'ounce' , 'grain')
    THEN TRUE

  WHEN $1 IN ('K', '°C', '°F', '°Ra', '°Re', '°r', '°N', '°Rø', '°De')
    AND  $2  IN ('K', '°C', '°F', '°Ra', '°Re', '°r', '°N', '°Rø', '°De')
    THEN TRUE

  WHEN $1 IN ('m', 'dm', 'cm', 'mm', 'µm', 'nm', 'pm', 'fm', 'am', 'zm', 'ym', 'am', 'dam', 'hm', 'km', 'Mm', 'Gm', 'Tm', 'Pm', 'Em', 'Zm', 'Ym', 'mam', 'mom', 'Å', 'ua', 'ch', 'fathom', 'fermi', 'ft', 'in', 'K', 'l.y.', 'ly', 'µ', 'mil', 'mi', 'nautical mi', 'pc', 'point', 'pt', 'pica', 'rd', 'yd', 'arp', 'lieue', 'league', 'cal', 'twp', 'p', 'P', 'fur', 'brasse', 'vadem', 'fms')
    AND  $2  IN ('m', 'dm', 'cm', 'mm', 'µm', 'nm', 'pm', 'fm', 'am', 'zm', 'ym', 'am', 'dam', 'hm', 'km', 'Mm', 'Gm', 'Tm', 'Pm', 'Em', 'Zm', 'Ym', 'mam', 'mom', 'Å', 'ua', 'ch', 'fathom', 'fermi', 'ft', 'in', 'K', 'l.y.', 'ly', 'µ', 'mil', 'mi', 'nautical mi', 'pc', 'point', 'pt', 'pica', 'rd', 'yd', 'arp', 'lieue', 'league', 'cal', 'twp', 'p', 'P', 'fur', 'brasse', 'vadem', 'fms')
    THEN TRUE
  ELSE FALSE END;
$_$;


ALTER FUNCTION darwin2.is_property_unit_in_group(searched_unit text, property_unit text) OWNER TO darwin2;

--
-- TOC entry 1616 (class 1255 OID 18983)
-- Name: isinteger(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.isinteger(text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE x integer;
BEGIN
    x = $1::integer;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;
$_$;


ALTER FUNCTION darwin2.isinteger(text) OWNER TO darwin2;

--
-- TOC entry 1617 (class 1255 OID 18984)
-- Name: isnumeric(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.isnumeric(text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE x NUMERIC;
BEGIN
    x = $1::NUMERIC;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;
$_$;


ALTER FUNCTION darwin2.isnumeric(text) OWNER TO darwin2;

--
-- TOC entry 1618 (class 1255 OID 18985)
-- Name: linetotagarray(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.linetotagarray(line text) RETURNS character varying[]
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
select array_agg(tags_list) FROM (SELECT lineToTagRows($1) AS tags_list ) as x;
$_$;


ALTER FUNCTION darwin2.linetotagarray(line text) OWNER TO darwin2;

--
-- TOC entry 1619 (class 1255 OID 18986)
-- Name: linetotagrows(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.linetotagrows(line text) RETURNS SETOF character varying
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT distinct(fulltoIndex(tags)) FROM regexp_split_to_table($1, ';') as tags WHERE fulltoIndex(tags) != '' ;
$_$;


ALTER FUNCTION darwin2.linetotagrows(line text) OWNER TO darwin2;

--
-- TOC entry 1620 (class 1255 OID 18987)
-- Name: linetotagrowsformatconserved(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.linetotagrowsformatconserved(line text) RETURNS SETOF character varying
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT distinct on (fulltoIndex(tags)) tags FROM regexp_split_to_table($1, ';') as tags WHERE fulltoIndex(tags) != '' ;
$_$;


ALTER FUNCTION darwin2.linetotagrowsformatconserved(line text) OWNER TO darwin2;

--
-- TOC entry 1621 (class 1255 OID 18988)
-- Name: point_equal(point, point); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.point_equal(point, point) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT
CASE WHEN $1[0] = $2[0] AND $1[1] = $2[1] THEN true
ELSE false END;$_$;


ALTER FUNCTION darwin2.point_equal(point, point) OWNER TO darwin2;

--
-- TOC entry 1622 (class 1255 OID 18989)
-- Name: rmca_array_reverse(anyarray); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_array_reverse(anyarray) RETURNS anyarray
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT ARRAY(
    SELECT $1[i]
    FROM generate_subscripts($1,1) AS s(i)
    ORDER BY i DESC
);
$_$;


ALTER FUNCTION darwin2.rmca_array_reverse(anyarray) OWNER TO darwin2;

--
-- TOC entry 1710 (class 1255 OID 1887034)
-- Name: rmca_cast_staging_gtu_date_to_mask(timestamp without time zone, time without time zone, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_cast_staging_gtu_date_to_mask(p_date timestamp without time zone, p_time time without time zone, date_resolution character varying) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
	date_returned timestamp;
	mask_returned varchar;
	returned varchar[];
BEGIN

	SELECT 
	CASE WHEN p_time is not null then 63
		WHEN LOWER(date_resolution)='day' THEN 56
		WHEN LOWER(date_resolution)='month' THEN 48
		WHEN LOWER(date_resolution)='year' THEN 32
		ELSE
		NULL
		END into mask_returned;
	
	SELECT CASE WHEN p_time is not null then  p_date+ p_time
		WHEN LOWER(date_resolution)='day' THEN p_date
		WHEN LOWER(date_resolution)='month' THEN date_trunc('month', p_date)
		WHEN LOWER(date_resolution)='year' THEN date_trunc('year', p_date)
		ELSE
		NULL
		END into date_returned
		;
			
	returned :=ARRAY[date_returned::varchar, mask_returned::varchar];
	return returned;
END;
$$;


ALTER FUNCTION darwin2.rmca_cast_staging_gtu_date_to_mask(p_date timestamp without time zone, p_time time without time zone, date_resolution character varying) OWNER TO darwin2;

--
-- TOC entry 1709 (class 1255 OID 1887035)
-- Name: rmca_clean_gtu_imports(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_clean_gtu_imports(p_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE 
	returned boolean;
begin
	DELETE FROM staging_gtu_tag_groups WHERE staging_gtu_tag_groups.staging_gtu_ref
	IN
		(SELECT id FROM staging_gtu WHERE import_ref= p_import_ref AND gtu_ref IS NOT NULL AND imported=true AND (import_exception='imported' OR import_exception LIKE '%.imported' OR import_exception LIKE 'imported.%'))
	;
	DELETE FROM staging_gtu WHERE import_ref= p_import_ref AND gtu_ref IS NOT NULL AND imported=true AND (import_exception='imported' OR import_exception LIKE '%.imported' OR import_exception LIKE 'imported.%' );
	return true;
end;

$$;


ALTER FUNCTION darwin2.rmca_clean_gtu_imports(p_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1623 (class 1255 OID 18990)
-- Name: rmca_create_links_between_labels(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_create_links_between_labels(p_coll_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN 



INSERT INTO specimens_relationships
(specimen_ref, relationship_type, unit_type, specimen_related_ref, unit)
SELECT   bsp.id, 'other_identification', 'specimens', csp.id, '%'
FROM specimens a
  INNER JOIN 
	codes b
	    ON a.id=b.record_id
	      AND b.referenced_relation='specimens'
	        and a.collection_ref=p_coll_ref 
	        and b.code_category='main'
	        
    INNER JOIN 
	codes c
	    ON c.code similar to regexp_replace(b.code, '\_id\_[a-z]','', 'g')||'_id_[a-z]'
	      AND c.referenced_relation='specimens'
	         
	        and c.code_category='main'
                and b.id<>c.id
     INNER JOIN specimens bsp
     ON bsp.id=b.record_id
      and bsp.collection_ref=p_coll_ref 
     INNER JOIN specimens csp
     ON csp.id=c.record_id   
     and
     csp.collection_ref=p_coll_ref    
where b.code similar to '%\_id\_[a-z]';

/* effacer le diff du code */

UPDATE codes SET code=code_without_label_diff

FROM (

SELECT b.id, b.code, regexp_replace(b.code,  '\_id\_[a-z]$', '', 'g') as code_without_label_diff FROM specimens a
  INNER JOIN codes b
	    ON a.id=b.record_id
	      AND b.referenced_relation='specimens'
	        and a.collection_ref=p_coll_ref and code_category='main'
	         where code similar to '%\_id\_[a-z]') foo
	         where foo.id=codes.id


;

END;
$_$;


ALTER FUNCTION darwin2.rmca_create_links_between_labels(p_coll_ref integer) OWNER TO darwin2;

--
-- TOC entry 1625 (class 1255 OID 18991)
-- Name: rmca_create_missing_people_in_staging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_create_missing_people_in_staging(p_import_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE
	curs1 record;
	tmpid int;
	
BEGIN 
	DROP TABLE if EXISTs tmp_people_import_rmca;
	CREATE TEMPORARY TABLE tmp_people_import_rmca(pk int, name varchar);
	RAISE NOTICE 'Different peoples %', (SELECT COUNT(DISTINCT formated_name) from staging a
		--inner join codes b
		--on referenced_relation='staging'
		--and a.id=b.record_id
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging'
		where a.to_import='f' 
		and people_ref is null
		and a.import_ref=p_import_ref);
	RAISE NOTICE 'linked specimens to be imported %', (SELECT COUNT(formated_name) from staging a
		--inner join codes b
		--on referenced_relation='staging'
		--and a.id=b.record_id
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging'
		where a.to_import='f' 
		and people_ref is null
		and a.import_ref=p_import_ref);
	FOR curs1 IN SELECT DISTINCT formated_name from staging a
		--inner join codes b
		--on referenced_relation='staging'
		--and a.id=b.record_id
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging'
		where a.to_import='f' 
		and people_ref is null
		and a.import_ref=p_import_ref 
		
		

		LOOP
		
		RAISE NOTICE '%', curs1.formated_name;
		RAISE NOTICE 'people with this name %', (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) );
		RAISE NOTICE 'people split %',  (SELECT regexp_split_to_array(curs1.formated_name, ' '));
		IF  (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) )=0 THEN
            INSERT INTO people (family_name, import_ref) VALUES (curs1.formated_name, p_import_ref) RETURNING id INTO tmpid;
            INSERT INTO tmp_people_import_rmca (pk, name) VALUES(tmpid, curs1.formated_name);
		ELSE
           INSERT INTO tmp_people_import_rmca (pk, name) SELECT id, family_name FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) LIMIT 1;
        END IF;
		
	END LOOP;
	DELETE FROM tmp_people_import_rmca;

	RAISE NOTICE  'GO identifications';
	UPDATE staging_people SET people_ref=tmp_people_import_rmca.pk FROM (SELECT pk, name FROM tmp_people_import_rmca ) AS tmp_people_import_rmca WHERE staging_people.formated_name=tmp_people_import_rmca.name 
	and referenced_relation='staging'
		
		and people_ref is null
		and record_id IN (SELECT id FROM staging WHERE staging.import_ref=p_import_ref AND to_import='f' )
		
		;

		FOR curs1 IN 
		SELECT distinct formated_name from staging a
		--inner join codes b
		--on b.referenced_relation='staging'
		--and a.id=b.record_id
		INNER JOIN identifications c
		ON c.record_id=a.id
		AND c.referenced_relation='staging'
		INNER JOIN
		staging_people d
		ON d.referenced_relation='identifications'
		AND c.id=d.record_id
		and people_ref is null
		where a.to_import='f' 

		and a.import_ref=p_import_ref
		
		

		LOOP
		
		RAISE NOTICE '%', curs1.formated_name;
		RAISE NOTICE 'people ident with this name %', (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) );
		RAISE NOTICE 'people ident split %',  (SELECT regexp_split_to_array(curs1.formated_name, ' '));
		IF  (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) )=0 THEN
            RAISE NOTICE 'INSERT %', curs1.formated_name;
                INSERT INTO people (family_name, import_ref) VALUES (curs1.formated_name, p_import_ref) RETURNING id INTO tmpid;
                INSERT INTO tmp_people_import_rmca (pk, name) VALUES(tmpid, curs1.formated_name);
		ELSE    
            INSERT INTO tmp_people_import_rmca (pk, name) SELECT id, family_name FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) LIMIT 1;
        END IF;
		
	END LOOP;
		UPDATE staging_people SET people_ref=tmp_people_import_rmca_alias.id FROM (SELECT id, family_name FROM people) AS tmp_people_import_rmca_alias 
		WHERE formated_name=tmp_people_import_rmca_alias.family_name 
		--and referenced_relation='identifications'
		
		and people_ref is null
		 
		
		;
	DROP TABLE  tmp_people_import_rmca;

	--clean staging status for identifications (2018 09 05)
		UPDATE staging SET status=status - 'identifiers'::varchar  WHERE id IN
		(
		SELECT identifications.record_id from staging_people 
		INNER JOIN
		identifications

		ON staging_people.referenced_relation='identifications' 
		AND staging_people.record_id = identifications.id
		WHERE identifications.referenced_relation='staging'
		AND identifications.record_id IN  (select id FROM staging WHERE staging.import_ref=p_import_ref)
		AND staging_people.people_ref IS NOT NULL 

		)
		;
	-- clean staging status for other peoples (2018 09 05)
			UPDATE staging SET status=status - 'people'::varchar  WHERE id IN (SELECT record_id from staging_people WHERE referenced_relation='staging'  AND staging_people.people_ref IS NOT NULL AND record_id IN (SELECT id FROM staging WHERe staging.import_ref = p_import_ref)
		);

	-- TO DO : clean staging status for operators

END;

$$;


ALTER FUNCTION darwin2.rmca_create_missing_people_in_staging(p_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1626 (class 1255 OID 18992)
-- Name: rmca_delete_specimens_from_collection(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_delete_specimens_from_collection(p_coll_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
 auto_increment BOOLEAN;
 last_value INTEGER;
 last_true_value INTEGER;
BEGIN 


ALTER table properties disable trigger user; 
ALTER table comments disable trigger user; 
RAISE NOTICE 'before delete properties %', (SELECT count(*) FROM properties);
DELETE FROM properties WHERE record_id IN (SELECT id FROM specimens WHERE collection_ref=p_coll_ref) AND referenced_relation= 'specimens';
RAISE NOTICE 'after delete properties (specimens) %', (SELECT count(*) FROM properties);


RAISE NOTICE 'before delete comments %', (SELECT count(*) FROM comments);
DELETE FROM comments WHERE record_id IN (SELECT id FROM specimens WHERE collection_ref=p_coll_ref) AND referenced_relation='specimens';
RAISE NOTICE 'afet delete comments (specimens) %', (SELECT count(*) FROM comments);


RAISE NOTICE 'before delete properties %', (SELECT count(*) FROM properties);
DELETE FROM properties WHERE record_id IN (SELECT id FROM staging WHERE import_ref IN (SELECT id FROM imports WHERE collection_ref=p_coll_ref)) AND referenced_relation= 'staging';
RAISE NOTICE 'after delete properties (staging) %', (SELECT count(*) FROM properties);

RAISE NOTICE 'before delete comments %', (SELECT count(*) FROM comments);
DELETE FROM comments WHERE record_id IN (SELECT id FROM staging WHERE import_ref IN (SELECT id FROM imports WHERE collection_ref=p_coll_ref)) AND referenced_relation= 'staging';
RAISE NOTICE 'after delete comments (staging) %', (SELECT count(*) FROM comments);

RAISE NOTICE 'before delete properties %', (SELECT count(*) FROM comments);
DELETE
  FROM properties where referenced_relation ='staging_info' and record_id in (SELECT id FROM staging_info WHERE staging_ref IN (SELECT id FROM staging WHERE import_ref IN (SELECT id FROM imports WHERE collection_ref=p_coll_ref)) )  AND referenced_relation= 'staging_info';
RAISE NOTICE 'after delete properties (staging_info) %', (SELECT count(*) FROM properties);

RAISE NOTICE 'before delete comments %', (SELECT count(*) FROM comments);
DELETE
  FROM comments where referenced_relation ='staging_info' and record_id in (SELECT id FROM staging_info WHERE staging_ref IN (SELECT id FROM staging WHERE import_ref IN (SELECT id FROM imports WHERE collection_ref=p_coll_ref)) )  AND referenced_relation= 'staging_info';
RAISE NOTICE 'after  delete comments (staging_info) %', (SELECT count(*) FROM comments);

ALTER table properties enable trigger user; 
ALTER table comments enable trigger user; 

RAISE NOTICE 'before delete tags %', (SELECT count(*) FROM tags);
DELETE FROM tags WHERE gtu_ref IN (SELECT id FROM gtu WHERE id in (SELECT gtu_ref FROM specimens WHERE collection_ref=p_coll_ref) );
RAISE NOTICE 'after delete tags %', (SELECT count(*) FROM tags);
/*
RAISE NOTICE 'before delete tag_groups %', (SELECT count(*) FROM tag_groups);
DELETE FROM tag_groups WHERE gtu_ref IN (SELECT id FROM gtu WHERE id in (SELECT gtu_ref FROM specimens WHERE collection_ref=p_coll_ref) );
RAISE NOTICE 'after delete tag_groups %', (SELECT count(*) FROM tag_groups);
*/


RAISE NOTICE 'before delete staging_info %', (SELECT count(*) FROM staging_info);
DELETE FROM staging_info WHERE staging_ref IN (SELECT distinct gtu_ref FROM staging   WHERE import_ref IN (SELECT id FROM imports WHERE collection_ref=p_coll_ref));
RAISE NOTICE 'after delete staging_info %', (SELECT count(*) FROM staging_info);

ALTER TABLE identifications DISABLE TRIGGER user ;

RAISE NOTICE 'before delete identifications (specimens) %', (SELECT count(*) FROM identifications);
DELETE FROM identifications WHERE referenced_relation='specimens' AND record_id IN (SELECT id FROM specimens WHERE collection_ref=p_coll_ref);

RAISE NOTICE 'after delete identifications (specimens) %', (SELECT count(*) FROM identifications);

ALTER TABLE identifications ENABLE  TRIGGER user;

RAISE NOTICE 'before delete identifications (staging) %', (SELECT count(*) FROM identifications);
DELETE FROM identifications WHERE referenced_relation='staging' AND record_id IN (SELECT id FROM staging WHERE import_ref IN (SELECT id FROM imports WHERE collection_ref=p_coll_ref));
RAISE NOTICE 'atfer delete identifications (staging) %', (SELECT count(*) FROM identifications);


--DELETE FROM taxonomy WHERE id IN (SELECT taxon)

--DELETE FROM gtu WHERE id in (SELECT gtu_ref FROM specimens WHERE collection_ref=p_coll_ref) ;

--DELETE FROM igs WHERE id in (SELECT if_ref FROM specimens WHERE collection_ref=p_coll_ref) ;

ALTER TABLE specimens DISABLE TRIGGER trg_chk_specimencollectionallowed;

RAISE NOTICE 'update specimens nullify FKs';
UPDATE specimens SET gtu_ref=NULL, taxon_ref=NULL, ig_ref=NULL WHERE collection_ref=p_coll_ref;

ALTER TABLE specimens ENABLE TRIGGER trg_chk_specimencollectionallowed;

RAISE NOTICE 'update staging nullify FKs';
UPDATE staging SET gtu_ref=NULL, taxon_ref=NULL, ig_ref=NULL WHERE id IN (SELECT id FROM staging WHERE import_ref IN (SELECT id FROM imports WHERE collection_ref=p_coll_ref)) ;

/*
ALTER TABLE taxonomy DISABLE TRIGGER user;
RAISE NOTICE 'before delete taxonomy %', (SELECT count(*) FROM taxonomy);
DELETE FROM taxonomy WHERE coalesce(id,-1) NOT in (SELECT coalesce(taxon_ref,-2) FROM specimens) AND coalesce(id,-1) not in (SELECT coalesce(parent_ref, -2) FROM taxonomy) and coalesce(id,-1) NOT in (SELECT coalesce(record_id,-2) FROM classification_synonymies);--AND id NOT in (SELECT taxon_ref FROM staging);
RAISE NOTICE 'after delete taxonomy %', (SELECT count(*) FROM taxonomy);
ALTER TABLE taxonomy ENABLE TRIGGER user;
*/

RAISE NOTICE 'before delete gtu %', (SELECT count(*) FROM gtu);
--DELETE FROM gtu WHERE id NOT in (SELECT gtu_ref FROM specimens) AND id NOT in (SELECT gtu_ref FROM staging);
RAISE NOTICE 'ater delete gtu %', (SELECT count(*) FROM gtu);


RAISE NOTICE 'before delete igs %', (SELECT count(*) FROM igs);

DELETE FROM igs WHERE id  in (SELECT ig_ref FROM specimens where collection_ref=p_coll_ref) AND id  in (SELECT ig_ref FROM staging where import_ref  in (select id from imports where collection_ref=p_coll_ref));

RAISE NOTICE 'after delete igs %', (SELECT count(*) FROM igs);

RAISE NOTICE 'before delete specimens_relationshipes %', (SELECT count(*) FROM specimens_relationships);
DELETE FROM specimens_relationships WHERE unit_type='specimens' AND (specimen_ref IN (SELECT id FROM specimens WHERE collection_ref=p_coll_ref) OR specimen_related_ref IN (SELECT id FROM specimens WHERE collection_ref=p_coll_ref));
RAISE NOTICE 'after delete specimens_relationshipes %', (SELECT count(*) FROM specimens_relationships);

RAISE NOTICE 'before delete staging %', (SELECT count(*) FROM staging);
DELETE FROM staging WHERE import_ref IN (SELECT id FROM imports WHERE collection_ref=p_coll_ref);
RAISE NOTICE 'after  delete staging %', (SELECT count(*) FROM staging);


ALTER TABLE storage_parts DISABLE TRIGGER user;
RAISE NOTICE 'before delete storage_parts %', (SELECT count(*) FROM storage_parts);
DELETE FROM storage_parts where specimen_ref in (select id from specimens WHERE collection_ref=p_coll_ref);
RAISE NOTICE 'after delete storage_parts %', (SELECT count(*) FROM storage_parts);
--DELETE FROM collections WHERE id=p_coll_ref;
ALTER TABLE storage_parts ENABLE TRIGGER user;

ALTER TABLE specimens DISABLE TRIGGER user;
RAISE NOTICE 'before delete specimens %', (SELECT count(*) FROM specimens);
DELETE FROM specimens WHERE collection_ref=p_coll_ref;
RAISE NOTICE 'after delete specimens %', (SELECT count(*) FROM specimens);
--DELETE FROM collections WHERE id=p_coll_ref;
ALTER TABLE specimens ENABLE TRIGGER user;

SELECT code_auto_increment, code_last_value INTO auto_increment, last_value FROM collections WHERE id=p_coll_ref;
IF auto_increment = TRUE THEN
	SELECT MAX(code_num) INTO last_true_value FROM codes WHERE code_category='main' AND referenced_relation='specimens' AND record_id in (select id FROM specimens WHERE   collection_ref=p_coll_ref);
	IF last_true_value IS NOT NULL THEN
		UPDATE collections SET code_last_value=last_true_value WHERE id=p_coll_ref;
	ELSE
		UPDATE collections SET code_last_value=0 WHERE id=p_coll_ref;
	END IF;
	
END IF;

END;
$$;


ALTER FUNCTION darwin2.rmca_delete_specimens_from_collection(p_coll_ref integer) OWNER TO darwin2;

--
-- TOC entry 1627 (class 1255 OID 18993)
-- Name: rmca_dms_to_dd(character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_dms_to_dd(coord_dms character varying, direction character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
DECLARE
	deg_path integer;
	decimal_part double precision;
	sign integer;
	returned double precision;
	go boolean;
	acc varchar[];
BEGIN

	
	coord_dms:=replace(coord_dms, ',','.');
	
	go:=false;
	acc :=regexp_matches(UPPER(coord_dms), '(-?\s*[^\d]*[\d]+\.\d+)\s*°?\s*(N|S|W|E)');
        if ARRAY_LENGTH(acc,1)>0 THEN
		returned:=fct_cast_to_real(acc[1]);
		
		IF LOWER(direction)='latitude' THEN
			IF POSITION('S' IN  UPPER(coord_dms))>0 THEN
				returned=returned*-1;
			END IF;
		ELSEIF LOWER(direction)='longitude' THEN
			IF POSITION('W' IN  UPPER(coord_dms))>0 THEN
				returned=returned*-1;
			END IF;
		END IF;
		return returned;
        END IF;
	acc :=regexp_matches(coord_dms, '[^\d]*(\d+\.\d+)°$');
	IF ARRAY_LENGTH(acc,1)>0 THEN

		RETURN acc[1]::double precision; 
	END IF;
	returned:=fct_cast_to_real(coord_dms);
	IF returned IS NOT NULL THEN
		IF LOWER(direction)='latitude' THEN
			IF POSITION('S' IN  UPPER(coord_dms))>0 THEN
				returned=returned*-1;
			END IF;
		ELSEIF LOWER(direction)='longitude' THEN
			IF POSITION('W' IN  UPPER(coord_dms))>0 THEN
				returned=returned*-1;
			END IF;
		END IF;
		RETURN returned;
	END IF;
	acc :=regexp_matches(coord_dms, '[^\d]*(\d+)°');
	--raise notice '%', acc;
	if ARRAY_LENGTH(acc,1)>0 THEN
		go:=true;
		returned:=acc[1]::double precision;
		acc :=regexp_matches(coord_dms, '°\s*([\.\d]+)''');
		if ARRAY_LENGTH(acc,1)>0 THEN
			decimal_part=acc[1]::double precision/60;
			returned:=returned+decimal_part;
			acc :=regexp_matches(coord_dms, '''\s*([\.\d]+)\s*"');
			if ARRAY_LENGTH(acc,1)>0 THEN
				decimal_part=acc[1]::double precision/3600;
				returned:=returned+decimal_part;
			END IF;
		END IF;
		IF LOWER(direction)='latitude' THEN
			IF POSITION('S' IN  UPPER(coord_dms))>0 THEN
				returned=returned*-1;
			END IF;
		ELSEIF LOWER(direction)='longitude' THEN
			IF POSITION('W' IN  UPPER(coord_dms))>0 THEN
				returned=returned*-1;
			END IF;
		END IF;
		
	END IF;
	
	
	return returned;
END;
$_$;


ALTER FUNCTION darwin2.rmca_dms_to_dd(coord_dms character varying, direction character varying) OWNER TO darwin2;

--
-- TOC entry 1628 (class 1255 OID 18994)
-- Name: rmca_dms_to_text(integer, double precision, double precision, integer, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_dms_to_text(degrees integer, minutes double precision, seconds double precision, direction integer, lat_lon character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned varchar;
BEGIN
	returned='';
	IF LOWER(FORMAT) = 'dms' THEN
		IF COALESCE(TRIM(degrees),'') != '' THEN
			returned:=returned||TRIM(degrees)||'° ';
			IF COALESCE(TRIM(minutes),'') != '' THEN
				returned:=returned||TRIM(minutes)||''' ';
				IF COALESCE(TRIM(seconds),'') != '' THEN
					returned:=returned||TRIM(seconds)||'" ';
				END IF;
			END IF;
			IF LOWER(lat_lon)='lat' THEN
				IF direction<0 THEN
					returned:=returned||'S';
				ELSE
					returned:=returned||'N';
				END IF;
			ELSIF LOWER(lat_lon)='lon' THEN
				IF direction<0 THEN
					returned:=returned||'W';
				ELSE
					returned:=returned||'E';
				END IF;
			END IF;
		END IF;
	ELSE 
		--implicitely DD
		IF LOWER(lat_lon)='lat' THEN
				IF direction<0 THEN
					returned:=latitude::varchar||'S';
				ELSE
					returned:=latitude::varchar||'N';
				END IF;
		ELSIF LOWER(lat_lon)='lon' THEN
				IF direction<0 THEN
					returned:=longitude::varchar||'W';
				ELSE
					returned:=longitude::varchar||'E';
				END IF;
			END IF;
	END IF;
	return TRIM(returned);
END;
$$;


ALTER FUNCTION darwin2.rmca_dms_to_text(degrees integer, minutes double precision, seconds double precision, direction integer, lat_lon character varying) OWNER TO darwin2;

--
-- TOC entry 1629 (class 1255 OID 18995)
-- Name: rmca_dms_to_text(character varying, integer, double precision, double precision, integer, double precision, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_dms_to_text(coordinates_format character varying, degrees integer, minutes double precision, seconds double precision, direction integer, coord_decimal double precision, lat_lon character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned varchar;
BEGIN
	returned='';
	IF LOWER(coordinates_format) = 'dms' THEN
		IF degrees is not null THEN
			returned:=returned||TRIM(degrees::varchar)||'° ';
			IF minutes is not null THEN
				returned:=returned||TRIM(minutes::varchar)||''' ';
				IF seconds is not null THEN
					returned:=returned||TRIM(seconds::varchar)||'" ';
				END IF;
			END IF;
			IF LOWER(lat_lon)='lat' THEN
				IF direction<0 THEN
					returned:=returned||'S';
				ELSE
					returned:=returned||'N';
				END IF;
			ELSIF LOWER(lat_lon)='lon' THEN
				IF direction<0 THEN
					returned:=returned||'W';
				ELSE
					returned:=returned||'E';
				END IF;
			END IF;
		END IF;
	ELSE 
		--implicitely DD
		IF LOWER(lat_lon)='lat' THEN
				IF direction<0 THEN
					returned:=coord_decimal::varchar||' S';
				ELSE
					returned:=coord_decimal::varchar||' N';
				END IF;
		ELSIF LOWER(lat_lon)='lon' THEN
				IF direction<0 THEN
					returned:=coord_decimal::varchar||' W';
				ELSE
					returned:=coord_decimal::varchar||' E';
				END IF;
			END IF;
	END IF;
	return TRIM(returned);
END;
$$;


ALTER FUNCTION darwin2.rmca_dms_to_text(coordinates_format character varying, degrees integer, minutes double precision, seconds double precision, direction integer, coord_decimal double precision, lat_lon character varying) OWNER TO darwin2;

--
-- TOC entry 1632 (class 1255 OID 18996)
-- Name: rmca_dmscheck_syntax(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	acc varchar[];
       returned boolean;
       decimal_conv double precision;
BEGIN
		
       
        IF coord_dms IS NULL THEN
		RETURN NULL;
        END IF;
         returned:=false;
         coord_dms:=replace(coord_dms, ',','.');
        decimal_conv:=fct_cast_to_real(coord_dms);
	IF decimal_conv IS NOT NULL THEN
		RETURN true;
	END IF;

	acc :=regexp_matches(UPPER(coord_dms), '(-?\s*[^\d]*[\d]+\.\d+)\s*°?\s*(N|S|W|E)');
        if ARRAY_LENGTH(acc,1)>0 THEN
		return true;
        END IF;
      
	acc :=regexp_matches(coord_dms, '[^\d]*(\d+)°');
	
	if ARRAY_LENGTH(acc,1)>0 THEN
		
		returned:=true;
		acc :=regexp_matches(coord_dms, '°\s*([\.\d]+\s*)''');
		if ARRAY_LENGTH(acc,1)>0 THEN
			returned:=true;
			acc :=regexp_matches(coord_dms, '''\s*([\.\d]+\s*)"');
			if ARRAY_LENGTH(acc,1)>0 THEN
				returned:=true;
			ELSE
				acc :=regexp_matches(coord_dms, '''\s*([\.\d]+\s*)');
				IF ARRAY_LENGTH(acc,1)>0 THEN
					returned:=false;
				END IF;
			END IF;
		ELSE 
			acc :=regexp_matches(coord_dms, '°\s*([\.\d]+\s*)');
			IF ARRAY_LENGTH(acc,1)>0 THEN
			returned:=false;
			END IF;
		END IF;
		
	END IF;
	
	return returned;
END;
$$;


ALTER FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) OWNER TO darwin2;

--
-- TOC entry 1630 (class 1255 OID 18997)
-- Name: rmca_get_import_row(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_get_import_row(integer) RETURNS integer
    LANGUAGE sql SECURITY DEFINER
    AS $_$

UPDATE imports SET state = 'loading' FROM (
  SELECT * FROM (
    SELECT  * FROM imports i1 WHERE i1.state = 'to_be_loaded' AND i1.id=$1 ORDER BY i1.created_at asc, id asc OFFSET 0 --thats important
  ) i2
  WHERE pg_try_advisory_lock('imports'::regclass::integer, i2.id)
  LIMIT 1
) i3
WHERE imports.id = i3.id RETURNING i3.id;
$_$;


ALTER FUNCTION darwin2.rmca_get_import_row(integer) OWNER TO darwin2;

--
-- TOC entry 1631 (class 1255 OID 18998)
-- Name: rmca_get_locality_tag_from_specimen(integer, character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_get_locality_tag_from_specimen(integer, character varying, character varying) RETURNS TABLE(tag character varying)
    LANGUAGE sql
    AS $_$
SELECT DISTINCT tag

FROM specimens
LEFT OUTER JOIN
tags
ON specimens.gtu_ref=tags.gtu_ref
WHERE specimens.id=$1
and  LOWER(group_type) LIKE LOWER($2)
and LOWER(sub_group_type) LIKE lower($3)
$_$;


ALTER FUNCTION darwin2.rmca_get_locality_tag_from_specimen(integer, character varying, character varying) OWNER TO darwin2;

--
-- TOC entry 1705 (class 1255 OID 1885694)
-- Name: rmca_import_gtu_create_missing_people_in_staging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_import_gtu_create_missing_people_in_staging(p_import_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	curs1 record;
	tmpid int;
	
BEGIN 
	DROP TABLE if EXISTs tmp_people_import_rmca;
	CREATE TEMPORARY TABLE tmp_people_import_rmca(pk int, name varchar);
	RAISE NOTICE 'Different peoples %', (SELECT COUNT(DISTINCT formated_name) from staging_gtu a
		
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging_gtu'
		where-- a.to_import='f' 
		--and 
		people_ref is null
		and a.import_ref=p_import_ref);
	RAISE NOTICE 'linked specimens to be imported %', (SELECT COUNT(formated_name) from staging_gtu a
		
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging_gtu'
		where --a.to_import='f' 
		--and 
		people_ref is null
		and a.import_ref=p_import_ref);
	FOR curs1 IN SELECT DISTINCT formated_name from staging_gtu a
		
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging_gtu'
		where --a.to_import='f' 
		--and 
		people_ref is null
		and a.import_ref=p_import_ref 
		
		

		LOOP
		
		RAISE NOTICE '%', curs1.formated_name;
		RAISE NOTICE 'people with this name %', (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) );
		RAISE NOTICE 'people split %',  (SELECT regexp_split_to_array(curs1.formated_name, ' '));
		IF  (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) )=0 THEN
            INSERT INTO people (family_name) VALUES (curs1.formated_name) RETURNING id INTO tmpid;
            INSERT INTO tmp_people_import_rmca (pk, name) VALUES(tmpid, curs1.formated_name);
		ELSE
           INSERT INTO tmp_people_import_rmca (pk, name) SELECT id, family_name FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) LIMIT 1;
        END IF;
		
	END LOOP;
	DELETE FROM tmp_people_import_rmca;

	RAISE NOTICE  'GO identifications';
	UPDATE staging_people SET people_ref=tmp_people_import_rmca.pk FROM (SELECT pk, name FROM tmp_people_import_rmca ) AS tmp_people_import_rmca WHERE staging_people.formated_name=tmp_people_import_rmca.name 
	and referenced_relation='staging_gtu'
		
		and people_ref is null
		and record_id IN (SELECT id FROM staging_gtu WHERE staging_gtu.import_ref=p_import_ref --AND to_import='f'
		 )
		
		;

		FOR curs1 IN 
		SELECT distinct formated_name from staging_gtu a
		--inner join codes b
		--on b.referenced_relation='staging'
		--and a.id=b.record_id
		INNER JOIN identifications c
		ON c.record_id=a.id
		AND c.referenced_relation='staging_gtu'
		INNER JOIN
		staging_people d
		ON d.referenced_relation='identifications'
		AND c.id=d.record_id
		and people_ref is null
		where --a.to_import='f' 

		--and 
		a.import_ref=p_import_ref
		
		

		LOOP
		
		RAISE NOTICE '%', curs1.formated_name;
		RAISE NOTICE 'people ident with this name %', (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) );
		RAISE NOTICE 'people ident split %',  (SELECT regexp_split_to_array(curs1.formated_name, ' '));
		IF  (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) )=0 THEN
            RAISE NOTICE 'INSERT %', curs1.formated_name;
                INSERT INTO people (family_name) VALUES (curs1.formated_name) RETURNING id INTO tmpid;
                INSERT INTO tmp_people_import_rmca (pk, name) VALUES(tmpid, curs1.formated_name);
		ELSE    
            INSERT INTO tmp_people_import_rmca (pk, name) SELECT id, family_name FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) LIMIT 1;
        END IF;
		
	END LOOP;
		UPDATE staging_people SET people_ref=tmp_people_import_rmca_alias.id FROM (SELECT id, family_name FROM people) AS tmp_people_import_rmca_alias 
		WHERE formated_name=tmp_people_import_rmca_alias.family_name 
		--and referenced_relation='identifications'
		
		and people_ref is null
		
		
		;
	DROP TABLE  tmp_people_import_rmca;

END;
$$;


ALTER FUNCTION darwin2.rmca_import_gtu_create_missing_people_in_staging(p_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1706 (class 1255 OID 1885686)
-- Name: rmca_import_gtu_force(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_import_gtu_force(p_staging_gtu_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
        curs record;
	curs2 record;
        expedition varchar;
        expedition_id integer;

        gtu_id integer;
        collection_id integer;
	returned integer;
	error_msg varchar;

BEGIN
	returned := NULL;
	error_msg :='imported';
    FOR curs IN SELECT staging_gtu.* from staging_gtu WHERE id = p_staging_gtu_id		
    LOOP
    
        raise notice 'test %', curs.sampling_code;
		
					
		SELECT collection_ref INTO collection_id FROM darwin2.imports WHERE id=curs.import_ref;
                expedition :=NULL;
                expedition_id :=NULL;
               
                gtu_id :=NULL;

                raise notice 'go';                
               
                expedition:=curs.expeditions[1];
                raise notice 'expedition : %', expedition;
                expedition_id:=NULL;
                IF expedition IS NOT NULL THEN
                    SELECT id into expedition_id FROM expeditions WHERE fulltoindex(name)= fulltoindex(expedition) ;
                    IF NOT FOUND THEN
                        raise notice 'insert %', expedition;
                        INSERT INTO expeditions (name) VALUES (expedition) RETURNING id INTO expedition_id;
                    END IF;
                END IF;
                --RAISE NOTICE 'exp_id %', expedition_id;
             
                
                INSERT INTO gtu(
                    code,
                    
                    tag_values_indexed, 
                    latitude, 
                    longitude, --lat_long_accuracy, 
					lat_long_accuracy,
                    
                     elevation, elevation_accuracy, import_ref, collection_ref,
                  
                    collector_refs,
					expedition_ref
                     )
                VALUES ( 
                curs.sampling_code, 
                
                (SELECT array_agg(tag_value) FROM staging_gtu_tag_groups WHERE staging_gtu_ref=curs.id),
                
                rmca_dms_to_dd(curs.latitude1, 'latitude'), 
                rmca_dms_to_dd(curs.longitude1, 'longitude'),
                curs.coordinates_accuracy,
                curs.sampling_elevation_start, curs.sampling_elevation_accuracy, curs.import_ref, collection_id,
               
                (SELECT array_agg(people_ref) FROM staging_people WHERE referenced_relation='staging_gtu' AND record_id=curs.id),
					expedition_id
                ) RETURNING id INTO gtu_id;

                IF curs.collectors IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'collectors', curs.collectors,'' );
                END IF;
                IF curs.expeditions IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'expeditions', curs.expeditions,'');
                END IF;
                IF curs.ig_num IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'ig_num', curs.ig_num,'' );
                END IF;
                IF curs.station_type IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'station_type', curs.station_type,'' );
                END IF;
                IF curs.sampling_field_number IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_field_number', curs.sampling_field_number,'' );
                END IF;
                IF curs.event_cluster_code IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'event_cluster_code', curs.event_cluster_code,'' );
                END IF;
                IF curs.event_order IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'event_order', curs.event_order,'' );
                END IF;
                IF curs.iso3166 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'iso3166', curs.iso3166,'' );
                END IF;
                IF curs.iso3166_subdivision IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'iso3166_subdivision', curs.iso3166_subdivision ,'');
                END IF;
                IF curs.locality_text IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'locality_text', curs.locality_text,'' );
                END IF;
                IF curs.ecology_text IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'ecology_text', curs.ecology_text ,'');
                END IF;
                IF curs.coordinates_format IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_format', curs.coordinates_format,'' );
                END IF;
                IF curs.latitude1 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'latitude1', curs.latitude1,'' );
                END IF;
                IF curs.longitude1 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'longitude1', curs.longitude1,'' );
                END IF;
                IF curs.latitude2 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'latitude2', curs.latitude2,'' );
                END IF;
                IF curs.longitude2 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'longitude2', curs.longitude2 ,'');
                END IF;
                IF curs.gis_type IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'gis_type', curs.gis_type,'' );
                END IF;
                IF curs.coordinates_datum IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_datum', curs.coordinates_datum ,'');
                END IF;
                IF curs.coordinates_original IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_original', curs.coordinates_original,'' );
                END IF;
                IF curs.coordinates_accuracy_text IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_accuracy_text', curs.coordinates_accuracy_text,'' );
                END IF;
                IF curs.station_baseline_elevation IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'station_baseline_elevation', curs.station_baseline_elevation,'' );
                END IF;
                IF curs.station_baseline_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'station_baseline_accuracy', curs.station_baseline_accuracy,'' );
                END IF;

                IF curs.sampling_elevation_start IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_elevation_start', curs.sampling_elevation_start,'' );
                END IF;

                IF curs.sampling_elevation_end IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_elevation_end', curs.sampling_elevation_end,'' );
                END IF;

                IF curs.sampling_elevation_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_elevation_accuracy', curs.sampling_elevation_accuracy,'' );
                END IF;

                IF curs.original_elevation_data IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'original_elevation_data', curs.original_elevation_data,'' );
                END IF;

                IF curs.sampling_depth_start IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_depth_start', curs.sampling_depth_start,'' );
                END IF;

                IF curs.sampling_depth_end IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_depth_end', curs.sampling_depth_end,'' );
                END IF;

                IF curs.sampling_depth_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_depth_accuracy', curs.sampling_depth_accuracy,'' );
                END IF;

                IF curs.original_depth_data IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'original_depth_data', curs.original_depth_data ,'');
                END IF;

                IF curs.sampling_method IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_method', curs.sampling_method,'' );
                END IF;

                IF curs.sampling_fixation IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_fixation', curs.sampling_fixation,'' );
                END IF;

                UPDATE properties SET referenced_relation='gtu', record_id=gtu_id WHERE referenced_relation='staging_gtu' AND record_id=curs.id;

                UPDATE comments SET referenced_relation='gtu', record_id=gtu_id WHERE referenced_relation='staging_gtu' AND record_id=curs.id;
		                BEGIN
                    INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value) SELECT DISTINCT gtu_id, staging_gtu_tag_groups.group_name, staging_gtu_tag_groups.sub_group_name, STRING_AGG(DISTINCT staging_gtu_tag_groups.tag_value,'.')  FROM staging_gtu_tag_groups WHERE staging_gtu_ref =curs.id AND tag_value IS NOT NULL GROUP BY gtu_id, group_name,sub_group_name; 
                EXCEPTION WHEN unique_violation THEN
                                        UPDATE staging_gtu SET imported=true, import_exception='ERROR : UNICITY problem in locality tag', gtu_ref=gtu_id WHERE  staging_gtu.sampling_code=curs.sampling_code AND staging_gtu.import_ref = curs.import_ref;
                END; 	
                        --ftheeten countries 2018 09 25
                BEGIN
                    INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name,  tag_value) SELECT 
                    DISTINCT gtu_id, 'administrative', 'country', array_to_string(countries, '.') FROM staging_gtu WHERE id =curs.id AND countries IS NOT NULL ;
                EXCEPTION WHEN unique_violation THEN
                    -- Do nothing, and loop to try the UPDATE again.
                    UPDATE staging_gtu SET imported=true, import_exception='ERROR : UNICITY problem in country tag', gtu_ref=gtu_id WHERE  staging_gtu.sampling_code=curs.sampling_code AND staging_gtu.import_ref = curs.import_ref;
                END; 
               UPDATE staging_gtu SET imported=true, import_exception='imported' , gtu_ref=gtu_id WHERE id=p_staging_gtu_id  ;
				
			/*FOR curs2 IN SELECT id, gtu_ref, collecting_date_begin, collecting_date_begin_mask, collecting_date_end, collecting_date_end_mask, collecting_time_begin, collecting_time_end    FROM staging_gtu 
					WHERE  ( collecting_date_begin IS NOT NULL OR collecting_date_begin_mask IS NOT NULL OR  
				   collecting_date_end IS NOT NULL OR   collecting_date_end_mask IS NOT NULL OR  collecting_time_begin IS NOT NULL OR 
				   collecting_time_end IS NOT NULL)  AND staging_gtu.id = curs.id
					LOOP 
						INSERT INTO temporal_information (
							 gtu_ref, from_date_mask, from_date, to_date_mask, 
							to_date) VALUES (curs2.gtu_ref, 
							CASE WHEN  UPPER(curs2.collecting_date_begin_mask) = 'DAY' THEN
							 56
							 WHEN  UPPER(curs2.collecting_date_begin_mask) = 'MONTH' THEN
							48
							 WHEN  UPPER(curs2.collecting_date_begin_mask) = 'YEAR' THEN
							32
							 WHEN  curs2.collecting_time_begin IS NOT NULL THEN
							 63

					   ELSE  
						0
						   END 
							, 

							COALESCE(curs2.collecting_date_begin,'0001-01-01 00:00:00'::timestamp without time zone) + COALESCE(curs2.collecting_time_begin,'00:00:00') , 

							CASE WHEN  UPPER(curs2.collecting_date_end_mask) = 'DAY' THEN
							 56
							 WHEN  UPPER(curs2.collecting_date_end_mask) = 'MONTH' THEN
							48
							 WHEN  UPPER(curs2.collecting_date_end_mask) = 'YEAR' THEN
							32
							 WHEN  curs2.collecting_time_end IS NOT NULL THEN
							 63

					   ELSE  
						0
						   END 

							, COALESCE(curs2.collecting_date_end, '2038-12-31 00:00:00'::timestamp without time zone) + COALESCE(curs2.collecting_time_end,'00:00:00'));
							error_msg :='imported_with_date';
							
					END LOOP;*/
					UPDATE staging_gtu SET imported=true, import_exception=COALESCE(import_exception||'.')||error_msg   WHERE id=curs.id ;            
			END LOOP;
		
	
        
			
           
	returned :=gtu_id;
	RETURN returned;
END;
$$;


ALTER FUNCTION darwin2.rmca_import_gtu_force(p_staging_gtu_id integer) OWNER TO darwin2;

--
-- TOC entry 1707 (class 1255 OID 1885689)
-- Name: rmca_import_gtu_in_darwin_fast(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    curs record;
    curs2 record;
    expedition varchar;
    expedition_id integer;
    expedition_array integer[];
    gtu_id integer;
    collection_id integer; 
    userid integer;       
BEGIN
--import abcd 
select user_ref into userid from imports where id=p_import_ref ;
  PERFORM set_config('darwin.userid',userid::varchar, false) ;
    UPDATE staging_gtu set status=''::public.hstore, import_exception=NULL WHERE import_ref = p_import_ref AND imported=FALSE;
    DROP TABLE if EXISTs tmp_codes;
    DROP TABLE if EXISTs tmp_coord_errors;
   CREATE TEMPORARY TABLE tmp_codes(
	code varchar
	);
    --ftheeten 2019 01 31
   CREATE TEMPORARY TABLE tmp_coord_errors(
	code varchar
	);
    SELECT collection_ref INTO collection_id FROM darwin2.imports WHERE id=p_import_ref;

       -- ftheeten 2019 01 31
       INSERT INTO tmp_coord_errors (code) SELECT staging_gtu.sampling_code FROM staging_gtu WHERE (darwin2.rmca_dmscheck_syntax(latitude1)=false OR darwin2.rmca_dmscheck_syntax(longitude1)=false
       OR darwin2.rmca_dmscheck_syntax(latitude2)=false OR darwin2.rmca_dmscheck_syntax(longitude2)=false) AND import_ref = p_import_ref;

       UPDATE staging_gtu SET status = status ||hstore('wrong_dms_coordinate_format' , 'check_long1_lat1_long2_lat2') ,
	import_exception=COALESCE(import_exception, 'wrong_dms_coordinate_format')   WHERE darwin2.rmca_dmscheck_syntax(latitude1)=false OR darwin2.rmca_dmscheck_syntax(longitude1)=false
       OR darwin2.rmca_dmscheck_syntax(latitude2)=false OR darwin2.rmca_dmscheck_syntax(longitude2)=false AND import_ref = p_import_ref ;
    
	FOR curs IN SELECT  DISTINCT 
         min(id) as id, array_agg(id ORDER BY id) as group_id,
import_ref,  date_included, tags_merged, sensitive_information_withheld, gtu_ref, station_type, sampling_code, sampling_field_number, event_cluster_code, event_order, ig_num, ig_num_indexed, collections, collectors, expeditions, collection_refs, collector_refs, expedition_refs, iso3166, iso3166_subdivision, countries, tags, tags_indexed, locality_text, locality_text_indexed, ecology_text, ecology_text_indexed, coordinates_format, latitude1, longitude1, latitude2, longitude2, gis_type, coordinates_wkt, coordinates_datum, coordinates_proj_ref, coordinates_original, coordinates_accuracy, coordinates_accuracy_text, station_baseline_elevation, station_baseline_accuracy, sampling_elevation_start, sampling_elevation_end, sampling_elevation_accuracy, original_elevation_data, sampling_depth_start, sampling_depth_end, sampling_depth_accuracy, original_depth_data, sampling_method, sampling_fixation, imported,
MIN(pos_in_file) as pos_in_file,
import_exception,
comments,
properties
FROM
(SELECT DISTINCT staging_gtu.id as id, staging_gtu.import_ref,  staging_gtu.date_included, staging_gtu.tags_merged, staging_gtu.sensitive_information_withheld, staging_gtu.gtu_ref, staging_gtu.station_type, staging_gtu.sampling_code, staging_gtu.sampling_field_number, staging_gtu.event_cluster_code, staging_gtu.event_order, staging_gtu.ig_num, staging_gtu.ig_num_indexed, staging_gtu.collections, staging_gtu.collectors, staging_gtu.expeditions, staging_gtu.collection_refs, staging_gtu.collector_refs, staging_gtu.expedition_refs, staging_gtu.iso3166, staging_gtu.iso3166_subdivision, staging_gtu.countries, staging_gtu.tags, staging_gtu.tags_indexed, staging_gtu.locality_text, staging_gtu.locality_text_indexed, staging_gtu.ecology_text, staging_gtu.ecology_text_indexed, staging_gtu.coordinates_format, staging_gtu.latitude1, staging_gtu.longitude1, staging_gtu.latitude2, staging_gtu.longitude2, staging_gtu.gis_type, staging_gtu.coordinates_wkt, staging_gtu.coordinates_datum, staging_gtu.coordinates_proj_ref, staging_gtu.coordinates_original, staging_gtu.coordinates_accuracy, staging_gtu.coordinates_accuracy_text, staging_gtu.station_baseline_elevation, staging_gtu.station_baseline_accuracy, staging_gtu.sampling_elevation_start, staging_gtu.sampling_elevation_end, staging_gtu.sampling_elevation_accuracy, staging_gtu.original_elevation_data, staging_gtu.sampling_depth_start, staging_gtu.sampling_depth_end, staging_gtu.sampling_depth_accuracy, staging_gtu.original_depth_data, staging_gtu.sampling_method, staging_gtu.sampling_fixation, staging_gtu.imported, 
       MIN(staging_gtu.pos_in_file) as pos_in_file , staging_gtu.import_exception ,
       string_agg(DISTINCT btrim((COALESCE(c.notion_concerned, ''::character varying)::text || ' : '::text) || COALESCE(c.comment)), '|'::text ORDER BY

        btrim((COALESCE(c.notion_concerned, ''::character varying)::text || ' : '::text) || COALESCE(c.comment)), '|'::text 

        ) AS comments,
       string_agg(DISTINCT btrim(((COALESCE((properties.property_type::text || COALESCE(' - '::text || properties.applies_to::text, ''::text)) || ' : '::text, ''::text) || COALESCE(properties.lower_value, ''::character varying)::text) || COALESCE('-'::text || properties.upper_value::text, ''::text)) || COALESCE(' '::text || properties.property_unit::text, ''::text)), '|'::text

        ORDER BY btrim(((COALESCE((properties.property_type::text || COALESCE(' - '::text || properties.applies_to::text, ''::text)) || ' : '::text, ''::text) || COALESCE(properties.lower_value, ''::character varying)::text) || COALESCE('-'::text || properties.upper_value::text, ''::text)) || COALESCE(' '::text || properties.property_unit::text, ''::text)), '|'::text
        ) AS properties
   

       FROM staging_gtu 
		LEFT JOIN gtu
		ON 
			LOWER(staging_gtu.sampling_code)=LOWER(code)
			--ftheeten 2019 01 31 remove date in linking with gtu
			
		LEFT JOIN comments c ON
		 c.referenced_relation = 'staging_gtu' AND c.record_id=staging_gtu.id
		 LEFT JOIN properties ON
		 properties.referenced_relation = 'staging_gtu' AND properties.record_id=staging_gtu.id
		WHERE staging_gtu.import_ref = p_import_ref
		AND gtu.id IS NULL
		AND staging_gtu.imported=FALSE 
        GROUP BY staging_gtu.id, staging_gtu.import_ref, staging_gtu.date_included, staging_gtu.tags_merged, staging_gtu.sensitive_information_withheld, staging_gtu.gtu_ref, staging_gtu.station_type, staging_gtu.sampling_code, staging_gtu.sampling_field_number, staging_gtu.event_cluster_code, staging_gtu.event_order, staging_gtu.ig_num, staging_gtu.ig_num_indexed, staging_gtu.collections, staging_gtu.collectors, staging_gtu.expeditions, staging_gtu.collection_refs, staging_gtu.collector_refs, staging_gtu.expedition_refs, staging_gtu.iso3166, staging_gtu.iso3166_subdivision, staging_gtu.countries, staging_gtu.tags, staging_gtu.tags_indexed, staging_gtu.locality_text, staging_gtu.locality_text_indexed, staging_gtu.ecology_text, staging_gtu.ecology_text_indexed, staging_gtu.coordinates_format, staging_gtu.latitude1, staging_gtu.longitude1, staging_gtu.latitude2, staging_gtu.longitude2, staging_gtu.gis_type, staging_gtu.coordinates_wkt, staging_gtu.coordinates_datum, staging_gtu.coordinates_proj_ref, staging_gtu.coordinates_original, staging_gtu.coordinates_accuracy, staging_gtu.coordinates_accuracy_text, staging_gtu.station_baseline_elevation, staging_gtu.station_baseline_accuracy, staging_gtu.sampling_elevation_start, staging_gtu.sampling_elevation_end, staging_gtu.sampling_elevation_accuracy, staging_gtu.original_elevation_data, staging_gtu.sampling_depth_start, staging_gtu.sampling_depth_end, staging_gtu.sampling_depth_accuracy, staging_gtu.original_depth_data, staging_gtu.sampling_method, staging_gtu.sampling_fixation, staging_gtu.imported, staging_gtu.import_exception)  a 
        GROUP bY
        import_ref, date_included, tags_merged, sensitive_information_withheld, gtu_ref, station_type, sampling_code, sampling_field_number, event_cluster_code, event_order, ig_num, ig_num_indexed, collections, collectors, expeditions, collection_refs, collector_refs, expedition_refs, iso3166, iso3166_subdivision, countries, tags, tags_indexed, locality_text, locality_text_indexed, ecology_text, ecology_text_indexed, coordinates_format, latitude1, longitude1, latitude2, longitude2, gis_type, coordinates_wkt, coordinates_datum, coordinates_proj_ref, coordinates_original, coordinates_accuracy, coordinates_accuracy_text, station_baseline_elevation, station_baseline_accuracy, sampling_elevation_start, sampling_elevation_end, sampling_elevation_accuracy, original_elevation_data, sampling_depth_start, sampling_depth_end, sampling_depth_accuracy, original_depth_data, sampling_method, sampling_fixation, imported,
import_exception,
comments,
properties     
        ORDER BY sampling_code 

       
    LOOP
    
        --raise notice 'test %', curs.sampling_code;
        --raise notice 'count %',  (SELECT COUNT(*) FROM (SELECT * FROM tmp_coord_errors WHERE 
		--	tmp_coord_errors.code=curs.sampling_code) a);
        PERFORM * FROM (SELECT * FROM tmp_codes WHERE 
			tmp_codes.code=curs.sampling_code UNION SELECT * FROM tmp_coord_errors WHERE 
			tmp_coord_errors.code=curs.sampling_code) a;
			
					
        IF NOT FOUND THEN
                   expedition :=NULL;
                   expedition_id :=NULL;
                   expedition_array := ARRAY[]::integer[];
                   gtu_id :=NULL;

                --raise notice 'go';
                
                --INSERT INTO tmp_codes(code) VALUES(curs.sampling_code);
                expedition:=curs.expeditions[1];
                --raise notice 'expedition : %', expedition;
                expedition_id:=NULL;
                IF expedition IS NOT NULL THEN
                    SELECT id into expedition_id FROM expeditions WHERE fullToIndex(expeditions.name)= fullToIndex(expedition) ;
					--RAISE NOTICE 'found exp_id %', expedition_id;
                    IF expedition_id IS NULL THEN
                        --raise notice 'insert %', expedition;
                        INSERT INTO expeditions (name) VALUES (expedition) RETURNING id INTO expedition_id;
                    END IF;
                END IF;
                --RAISE NOTICE 'exp_id %', expedition_id;
                expedition_array=expedition_array|| expedition_id;
                --IMPORTATION
		SELECT rmca_import_gtu_force(curs.id) INTO gtu_id;
		UPDATE staging_gtu SET imported= TRUE, import_exception=COALESCE(import_exception||'. ','')||'duplicate_inside_file' WHERE id=ANY(array_remove(curs.group_id, curs.group_id[1]));

		--ELSE 
		--	UPDATE staging_gtu SET imported= FALSE, import_exception='duplicate_sampling_code_with_differences_in_data' WHERE id=curs.id ;
	    --END IF;
		
		
		FOR curs2 IN SELECT 
		id, gtu_ref, collecting_date_begin, collecting_date_begin_mask, collecting_date_end, collecting_date_end_mask, collecting_time_begin, collecting_time_end    FROM staging_gtu 
		WHERE( collecting_date_begin IS NOT NULL OR collecting_date_begin_mask IS NOT NULL OR  
       collecting_date_end IS NOT NULL OR   collecting_date_end_mask IS NOT NULL OR  collecting_time_begin IS NOT NULL OR 
       collecting_time_end IS NOT NULL)  
       AND 
       staging_gtu.id = ANY(array_remove(curs.group_id, curs.group_id[1]))
		LOOP 
			INSERT INTO temporal_information (
				 gtu_ref, from_date_mask, from_date, to_date_mask, 
				to_date) VALUES (

				gtu_id, 
				CASE WHEN  UPPER(curs2.collecting_date_begin_mask) = 'DAY' THEN
				 56
				 WHEN  UPPER(curs2.collecting_date_begin_mask) = 'MONTH' THEN
				48
				 WHEN  UPPER(curs2.collecting_date_begin_mask) = 'YEAR' THEN
				32
				 WHEN  curs2.collecting_time_begin IS NOT NULL THEN
				 63

		   ELSE  
			0
			   END 
				, 

				COALESCE(curs2.collecting_date_begin,'0001-01-01 00:00:00'::timestamp without time zone) + COALESCE(curs2.collecting_time_begin,'00:00:00') , 

				CASE WHEN  UPPER(curs2.collecting_date_end_mask) = 'DAY' THEN
				 56
				 WHEN  UPPER(curs2.collecting_date_end_mask) = 'MONTH' THEN
				48
				 WHEN  UPPER(curs2.collecting_date_end_mask) = 'YEAR' THEN
				32
				 WHEN  curs2.collecting_time_end IS NOT NULL THEN
				 63

		   ELSE  
			0
			   END 

				, COALESCE(curs2.collecting_date_end, '2038-12-31 00:00:00'::timestamp without time zone) + COALESCE(curs2.collecting_time_end,'00:00:00'));
				UPDATE staging_gtu SET import_exception=COALESCE(import_exception||'. ','')||'date_imported_and_merged',  gtu_ref=gtu_id , status = status ||hstore(ARRAY['duplicate_code', 'gtu_id']::varchar[], ARRAY['duplicate_in_file',gtu_id]::varchar[]) WHERE id=curs2.id;
		END LOOP;
		INSERT INTO tmp_codes(code) VALUES(curs.sampling_code);
	    ELSE
		--UPDATE staging_gtu SET imported=false, import_exception='duplicate_code_inside_file_with_other_data' WHERE id=curs2.id AND id !=ALL(curs.group_id);
	    END IF;
    END LOOP;

	
		FOR curs IN SELECT staging_gtu.id as id,
		gtu.id AS gtu_id 

from staging_gtu 
	
		LEFT JOIN gtu
		ON 
			LOWER(staging_gtu.sampling_code)=LOWER(code)

		WHERE staging_gtu.import_ref = p_import_ref 
		AND gtu.id IS NOT NULL --NOT NULL as we are looking the duplicates in DB
		AND staging_gtu.imported=FALSE 
		AND gtu.import_ref = p_import_ref
		GROUP BY

		staging_gtu.id, staging_gtu.import_ref, status, date_included, tags_merged, sensitive_information_withheld, 
		       gtu_ref, station_type, sampling_code, sampling_field_number, 
		       event_cluster_code, event_order, ig_num, ig_num_indexed, collections, 
		       collectors, expeditions, collection_refs, staging_gtu.collector_refs, staging_gtu.expedition_refs, 
		       staging_gtu.iso3166, staging_gtu.iso3166_subdivision, countries, tags, tags_indexed, 
		       locality_text, locality_text_indexed, ecology_text, ecology_text_indexed, 
		       coordinates_format, latitude1, longitude1, latitude2, longitude2, 
		       gis_type, coordinates_wkt, coordinates_datum, coordinates_proj_ref, 
		       coordinates_original, coordinates_accuracy, coordinates_accuracy_text, 
		       station_baseline_elevation, station_baseline_accuracy, sampling_elevation_start, 
		       sampling_elevation_end, sampling_elevation_accuracy, original_elevation_data, 
		       sampling_depth_start, sampling_depth_end, sampling_depth_accuracy, 
		       original_depth_data, collecting_date_begin, collecting_date_begin_mask, 
		       collecting_date_end, collecting_date_end_mask, collecting_time_begin, 
		       collecting_time_end, sampling_method, sampling_fixation, imported, 
		       pos_in_file, import_exception, gtu.id
	LOOP 
		UPDATE staging_gtu SET status = status ||hstore(ARRAY['code_already_in_file', 'staging_gtu_id', 'gtu_id']::varchar[], ARRAY['duplicate_with_database',curs.id ,curs.gtu_id]::varchar[]), import_exception=COALESCE(import_exception||'. ','')||'code_already_in_file_with_other_data' WHERE id=curs.id;
	END LOOP;
    
	FOR curs IN SELECT staging_gtu.*, string_agg(gtu.id::varchar,'; '::varchar ORDER BY gtu.id) as gtu_ids 

from staging_gtu 
	
		LEFT JOIN gtu
		ON 
			LOWER(staging_gtu.sampling_code)=LOWER(code)

		WHERE staging_gtu.import_ref = p_import_ref 
		AND gtu.id IS NOT NULL --NOT NULL as we are looking the duplicates in DB
		AND staging_gtu.imported=FALSE 
		AND COALESCE(gtu.import_ref,-1) != p_import_ref
		GROUP BY

		staging_gtu.id, staging_gtu.import_ref, status, date_included, tags_merged, sensitive_information_withheld, 
		       gtu_ref, station_type, sampling_code, sampling_field_number, 
		       event_cluster_code, event_order, ig_num, ig_num_indexed, collections, 
		       collectors, expeditions, collection_refs, staging_gtu.collector_refs, staging_gtu.expedition_refs, 
		       staging_gtu.iso3166, staging_gtu.iso3166_subdivision, countries, tags, tags_indexed, 
		       locality_text, locality_text_indexed, ecology_text, ecology_text_indexed, 
		       coordinates_format, latitude1, longitude1, latitude2, longitude2, 
		       gis_type, coordinates_wkt, coordinates_datum, coordinates_proj_ref, 
		       coordinates_original, coordinates_accuracy, coordinates_accuracy_text, 
		       station_baseline_elevation, station_baseline_accuracy, sampling_elevation_start, 
		       sampling_elevation_end, sampling_elevation_accuracy, original_elevation_data, 
		       sampling_depth_start, sampling_depth_end, sampling_depth_accuracy, 
		       original_depth_data, collecting_date_begin, collecting_date_begin_mask, 
		       collecting_date_end, collecting_date_end_mask, collecting_time_begin, 
		       collecting_time_end, sampling_method, sampling_fixation, imported, 
		       pos_in_file, import_exception
	LOOP 
		UPDATE staging_gtu SET status = status ||hstore(ARRAY['code_already_in_database', 'gtu_id']::varchar[], ARRAY['duplicate_with_database',curs.gtu_ids]::varchar[]), import_exception=COALESCE(import_exception||'. ','')||'duplicate_code' WHERE id=curs.id;
	END LOOP;

	--2019 02 28 
	UPDATE imports SET state='pending' WHERE id=p_import_ref;
	PERFORM rmca_clean_gtu_imports(p_import_ref);

END;
$$;


ALTER FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 796 (class 1255 OID 18999)
-- Name: rmca_migrate_rmca_align_seq(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_migrate_rmca_align_seq() RETURNS integer
    LANGUAGE plpgsql
    AS $$
    Declare returned int;
    rec_seq record;
 
   cur_seq  CURSOR FOR SELECT REPLACE(REPLACE(column_default,'nextval(''',''),'''::regclass)','') as seq_name, table_name, column_name from information_schema.columns where column_default like 'nextval%' and table_schema='darwin2' order by table_name;



  metadata_tmp integer;
  var_table bigint;
    var_seq bigint;
    BEGIN
       set search_path='darwin2';
    returned:=-1;
    --attention, the index esof specimens in the rbins are bound to some functions
    SET search_path TO darwin2;
      OPEN cur_seq;
      
 
   LOOP
    -- fetch row into the film
      FETCH cur_seq INTO rec_seq;
    -- exit when no more row to fetch
      EXIT WHEN NOT FOUND;
	EXECUTE 'SELECT MAX('||rec_seq.column_name||')+1 FROM darwin2.'||rec_seq.table_name||';' INTO var_table;
	EXECUTE 'SELECT  last_value FROM darwin2.'||rec_seq.seq_name||';' INTO var_seq;

	RAISE notice E'seq: % \t table:% \ t seq % \t count %', rec_seq.seq_name,rec_seq.table_name ,var_seq, var_table;
	RAISE notice E'DIFF %',var_table-var_seq;
	
 
   END LOOP;
	returned:=0;
      return returned;


      
    END;
    $$;


ALTER FUNCTION darwin2.rmca_migrate_rmca_align_seq() OWNER TO darwin2;

--
-- TOC entry 1633 (class 1255 OID 19000)
-- Name: rmca_move_host_from_specimens_to_taxa(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_move_host_from_specimens_to_taxa(p_collection_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN 

INSERT INTO 
properties 
(
referenced_relation, 
record_id,
property_type, 
applies_to,
date_from,
is_quantitative,
lower_value,
upper_value
)

select distinct 
'taxonomy',
taxon_ref,
 pa.property_type, 
'taxonomy',
current_timestamp,
false,
 lower_value ,
 upper_value

 from properties pa 
LEFT join specimens
ON record_id=specimens.id
where referenced_relation='specimens' and property_type ilike 'host%' AND specimens.collection_ref=p_collection_ref
and (select count(*) FROM properties pb where pb.referenced_relation='taxonomy' and pa.property_type=pb.property_type and pa.lower_value=pb.lower_value and record_id=taxon_ref)=0;

INSERT INTO 
properties 
(
referenced_relation, 
record_id,
property_type, 
applies_to,
date_from,
date_from_mask,
is_quantitative,
lower_value,
upper_value
)

select distinct
'taxonomy',
taxonomy.id,
 'Parasite - Species', 
'taxonomy',
current_timestamp,
56,
false,
 taxon_name, 
 upper_value

 from properties pa
inner join taxonomy
on
(lower(taxonomy.name)  ~* (lower(lower_value)||'( |$)'))::boolean
inner join
specimens
on
record_id=specimens.id
where referenced_relation='specimens' 

and 
(
lower(property_type)='host - taxon name'
or 
lower(property_type)='host - species'
)
and (select count(*) FROM properties pb where pb.referenced_relation='taxonomy' and pb.property_type='Parasite - Species' and pb.lower_value=taxon_name and record_id=taxonomy.id)=0
AND specimens.collection_ref=p_collection_ref
;

END;
$_$;


ALTER FUNCTION darwin2.rmca_move_host_from_specimens_to_taxa(p_collection_ref integer) OWNER TO darwin2;

--
-- TOC entry 1634 (class 1255 OID 19001)
-- Name: rmca_reinit_statistical_view(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_reinit_statistical_view() RETURNS integer
    LANGUAGE sql
    AS $$
TRUNCATE tv_reporting_count_all_specimens_by_collection_year_ig;
TRUNCATE tv_reporting_count_all_specimens_type_by_collection_ref_year_ig;
TRUNCATE tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig;

INSERT INTO  tv_reporting_count_all_specimens_by_collection_year_ig SELECT * FROM v_reporting_count_all_specimens_by_collection_year_ig;
INSERT INTO  tv_reporting_count_all_specimens_type_by_collection_ref_year_ig SELECT * FROM v_reporting_count_all_specimens_type_by_collection_ref_year_ig;
INSERT INTO  tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig SELECT * FROM v_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig;
INSERT INTO  tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_igall SELECT * FROM v_reporting_taxa_in_specimen_per_rank_collection_ref_year_igall;

SELECT 0 as result;

$$;


ALTER FUNCTION darwin2.rmca_reinit_statistical_view() OWNER TO darwin2;

--
-- TOC entry 1635 (class 1255 OID 19002)
-- Name: rmca_taxonomy_create_missing_species_subspecies(character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_taxonomy_create_missing_species_subspecies(taxon_name_param character varying, taxonomy_to_search integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
 parent_rank integer[];
 parents integer[];
 returned integer;
 level_to_create int;
 parent_to_create int;
 
 
begin
	returned:=-1;
	IF taxonomy_to_search IS NOT NULL THEN
		SELECT  array_agg(distinct taxonomy.id order by taxonomy.id)  , array_agg(distinct level_ref)
		INTO parents, parent_rank FROM staging
		LEFT OUTER JOIN
		taxonomy
		ON fulltoindex(fct_rmca_taxonomy_remove_last_word(taxon_name_param), false
		)=taxonomy.name_indexed
		WHERE metadata_ref=  taxonomy_to_search
		GROUP by staging.taxon_name LIMIT 1;
	ELSE
	 SELECT  array_agg(distinct taxonomy.id order by taxonomy.id), array_agg(distinct level_ref), (array_agg(metadata_ref))[1]
		INTO parents, parent_rank, taxonomy_to_search
		FROM staging
		LEFT OUTER JOIN
		taxonomy
		ON fulltoindex(fct_rmca_taxonomy_remove_last_word(taxon_name_param), false
		)=taxonomy.name_indexed		
		GROUP by staging.taxon_name LIMIT 1;
		taxonomy_to_search:=0;
	
	END IF;
   --work only for subspecies-species or species->genus
	IF ARRAY_LENGTH(parents,1)=1 AND (parent_rank[1] = 41 OR parent_rank[1] = 48) THEN
		parent_to_create :=parents[1];

		IF parent_rank[1] = 41 THEN
			level_to_create :=48;
		ELSIF  parent_rank[1] = 48 THEN
			level_to_create :=49;
		END IF;
		--raise notice  'create % %',taxon_name_param, parent_to_create;
		INSERT INTO taxonomy (name, level_ref, parent_ref, metadata_ref) VALUES(taxon_name_param, level_to_create,
			parent_to_create, taxonomy_to_search) returning id into returned;
			return returned;
		
		
		
	END IF;
	
	
return returned;
	EXCEPTION 
	WHEN  others THEN
		RAISE NOTICE 'Error inserting %', taxon_name_param;
	return -1;
END

$$;


ALTER FUNCTION darwin2.rmca_taxonomy_create_missing_species_subspecies(taxon_name_param character varying, taxonomy_to_search integer) OWNER TO darwin2;

--
-- TOC entry 1639 (class 1255 OID 19003)
-- Name: rmca_taxonomy_create_missing_species_subspecies_loop(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_taxonomy_create_missing_species_subspecies_loop(import_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
	returned boolean;
	curs_staging CURSOR FOR select * FROM  staging WHERE  import_ref=import_id AND staging.status->'taxon'='not_found';
	rec_staging RECORD;
	taxonomy_ref integer;
	taxon_id integer;
        level_ref_imp integer;
        level_name_imp varchar;

	
begin
	returned:=false;
	SELECT specimen_taxonomy_ref INTO taxonomy_ref FROM imports WHERE id=import_id;
	OPEN curs_staging;
		LOOP
			FETCH curs_staging INTO rec_staging;
			
			
			EXIT WHEN NOT FOUND;
			
	
			
			SELECT rmca_taxonomy_create_missing_species_subspecies(rec_staging.taxon_name, taxonomy_ref) into taxon_id;
			IF taxon_id <> -1 THEN

				SELECT level_ref, level_name INTO level_ref_imp, level_name_imp FROM taxonomy INNER JOIN 				catalogue_levels ON
				level_ref=catalogue_levels.id WHERE taxonomy.id=taxon_id LIMIT 1;
				
				UPDATE staging set taxon_ref=taxon_id, taxon_name = rec_staging.taxon_name, taxon_level_ref=
				level_ref_imp,
				taxon_level_name=level_name_imp,
				status = delete(status,'taxon')
				WHERE
				taxon_name  IS NOT DISTINCT FROM  rec_staging.taxon_name
				AND status->'taxon'='not_found' 
				AND import_ref =  import_id;
        
			END IF;
			returned=true;
			
		END LOOP;
	CLOSE curs_staging;
	IF returned=true THEN
		SELECT fct_importer_abcd(import_id) into returned;
	END IF;
	return returned;
end
$$;


ALTER FUNCTION darwin2.rmca_taxonomy_create_missing_species_subspecies_loop(import_id integer) OWNER TO darwin2;

--
-- TOC entry 1640 (class 1255 OID 19004)
-- Name: rmca_update_parent_code(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_update_parent_code() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN
    IF NEW.code_ai_inherit = TRUE AND NEW.code_last_value > OLD.code_last_value THEN
		PERFORM darwin2.fct_rmca_collection_update_autoincrements_hierarchy(NEW.id, NEW.code_last_value);
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.rmca_update_parent_code() OWNER TO darwin2;

--
-- TOC entry 1637 (class 1255 OID 206023)
-- Name: rowcount_all(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rowcount_all(schema_name text DEFAULT 'public'::text) RETURNS TABLE(table_name text, cnt bigint)
    LANGUAGE plpgsql
    AS $$
declare
 table_name text;
begin
  for table_name in SELECT c.relname FROM pg_class c
    JOIN pg_namespace s ON (c.relnamespace=s.oid)
    WHERE c.relkind = 'r' AND s.nspname=schema_name
  LOOP
    RETURN QUERY EXECUTE format('select cast(%L as text),count(*) from %I.%I',
       table_name, schema_name, table_name);
  END LOOP;
end
$$;


ALTER FUNCTION darwin2.rowcount_all(schema_name text) OWNER TO darwin2;

--
-- TOC entry 1641 (class 1255 OID 19005)
-- Name: sha1(bytea); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.sha1(bytea) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
        RETURN ENCODE(DIGEST($1, 'sha1'), 'hex');
END;
$_$;


ALTER FUNCTION darwin2.sha1(bytea) OWNER TO darwin2;

--
-- TOC entry 1642 (class 1255 OID 19006)
-- Name: touniquestr(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.touniquestr(to_indexed character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
    temp_string varchar;
BEGIN
    -- Investigate https://launchpad.net/postgresql-unaccent
    temp_string := to_indexed;
    temp_string := TRANSLATE(temp_string, E'  ¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿×&|@"\'#(§^!{})°$*][£µ`%+=~/.,?;:\\<>ł€¶ŧ←↓→«»¢“”_-','');
     --Remove ALL none alphanumerical char like # or '
    temp_string := lower(temp_string);
    return substring(temp_string from 0 for 40);
END;
$_$;


ALTER FUNCTION darwin2.touniquestr(to_indexed character varying) OWNER TO darwin2;

--
-- TOC entry 1644 (class 1255 OID 19007)
-- Name: touniquestr(character varying, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.touniquestr(to_indexed character varying, keep_space boolean) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
    temp_string varchar;
BEGIN
    -- Investigate https://launchpad.net/postgresql-unaccent
    temp_string := to_indexed;
    if keep_space =false then
    temp_string := TRANSLATE(temp_string, E'  ¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿×&|@"\'#(§^!{})°$*][£µ`%+=~/.,?;:\\<>ł€¶ŧ←↓→«»¢“”_-','');
        --ftheeten 2016 02 29
     temp_string :=regexp_replace(temp_string,'(\s{2,})',' ', 'g');
    else
    --temp_string := TRANSLATE(temp_string, E' ¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿×&|@"\'#(§^!{})°$*][£µ`%+=~/.,?;:\\<>ł€¶ŧ←↓→«»¢“”_-','');
   --ftheeten 2016 02 29 
        temp_string :=regexp_replace(temp_string,'-',' ', 'g');
        temp_string :=regexp_replace(temp_string,'''',' ', 'g');
temp_string := TRANSLATE(temp_string, E'¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿×&|@"\'#(§^!{})°$*][£µ`%+=~/.,?;:\\<>ł€¶ŧ←↓→«»¢“”_','');
    end if;
     --Remove ALL none alphanumerical char like # or '
    temp_string := lower(temp_string);
    --ftheeten 2016 02 29
     temp_string :=regexp_replace(temp_string,'(\s{2,})',' ', 'g');
    return substring(temp_string from 0 for 40);
END;

$_$;


ALTER FUNCTION darwin2.touniquestr(to_indexed character varying, keep_space boolean) OWNER TO darwin2;

--
-- TOC entry 1645 (class 1255 OID 19008)
-- Name: trg_del_dict(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_del_dict() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldfield RECORD;
  newfield RECORD;
BEGIN

    IF TG_OP = 'UPDATE' THEN
      oldfield = OLD;
      newfield = NEW;
    ELSE --DELETE
      oldfield = OLD;
      execute 'select * from ' || TG_TABLE_NAME::text || ' where id = -15 ' into newfield;
    END IF;
    IF TG_TABLE_NAME = 'codes' THEN
      PERFORM fct_del_in_dict('codes','code_prefix_separator', oldfield.code_prefix_separator, newfield.code_prefix_separator);
      PERFORM fct_del_in_dict('codes','code_suffix_separator', oldfield.code_suffix_separator, newfield.code_suffix_separator);
            --ftheeten 2016 09 15
      IF oldfield.referenced_relation='specimens' AND oldfield.code_category='main' THEN
	UPDATE specimens SET main_code_indexed= NULL WHERE id=oldfield.record_id;
      END IF;
    ELSIF TG_TABLE_NAME = 'collection_maintenance' THEN
      PERFORM fct_del_in_dict('collection_maintenance','action_observation', oldfield.action_observation, newfield.action_observation);
    ELSIF TG_TABLE_NAME = 'identifications' THEN
      PERFORM fct_del_in_dict('identifications','determination_status', oldfield.determination_status, newfield.determination_status);
    ELSIF TG_TABLE_NAME = 'people' THEN
      PERFORM fct_del_in_dict('people','sub_type', oldfield.sub_type, newfield.sub_type);
      PERFORM fct_del_in_dict('people','title', oldfield.title, newfield.title);
    ELSIF TG_TABLE_NAME = 'people_addresses' THEN
      PERFORM fct_del_in_dict('people_addresses','country', oldfield.country, newfield.country);
      --ftheeten 2018 03 26
   ELSIF TG_TABLE_NAME = 'loans' THEN
      PERFORM fct_del_in_dict('loans','country_receiver', oldfield.country_receiver, newfield.country_receiver);
    ELSIF TG_TABLE_NAME = 'insurances' THEN
      PERFORM fct_del_in_dict('insurances','insurance_currency', oldfield.insurance_currency, newfield.insurance_currency);
    ELSIF TG_TABLE_NAME = 'mineralogy' THEN
      PERFORM fct_del_in_dict('mineralogy','cristal_system', oldfield.cristal_system, newfield.cristal_system);
    ELSIF TG_TABLE_NAME = 'specimens' THEN
      PERFORM fct_del_in_dict('specimens','type', oldfield.type, newfield.type);
      PERFORM fct_del_in_dict('specimens','type_group', oldfield.type_group, newfield.type_group);
      PERFORM fct_del_in_dict('specimens','type_search', oldfield.type_search, newfield.type_search);
      PERFORM fct_del_in_dict('specimens','sex', oldfield.sex, newfield.sex);
      PERFORM fct_del_in_dict('specimens','state', oldfield.state, newfield.state);
      PERFORM fct_del_in_dict('specimens','stage', oldfield.stage, newfield.stage);
      PERFORM fct_del_in_dict('specimens','social_status', oldfield.social_status, newfield.social_status);
      PERFORM fct_del_in_dict('specimens','rock_form', oldfield.rock_form, newfield.rock_form);
	--ftheeten 2016 08 24
      --PERFORM fct_del_in_dict('specimens','container_type', oldfield.container_type, newfield.container_type);
      --PERFORM fct_del_in_dict('specimens','sub_container_type', oldfield.sub_container_type, newfield.sub_container_type);
      ---PERFORM fct_del_in_dict('specimens','specimen_part', oldfield.specimen_part, newfield.specimen_part);
      --PERFORM fct_del_in_dict('specimens','specimen_status', oldfield.specimen_status, newfield.specimen_status);

      --PERFORM fct_del_in_dict('specimens','shelf', oldfield.shelf, newfield.shelf);
      --PERFORM fct_del_in_dict('specimens','col', oldfield.col, newfield.col);
      --PERFORM fct_del_in_dict('specimens','row', oldfield.row, newfield.row);
      --PERFORM fct_del_in_dict('specimens','room', oldfield.room, newfield.room);
      --PERFORM fct_del_in_dict('specimens','floor', oldfield.floor, newfield.floor);
      --PERFORM fct_del_in_dict('specimens','building', oldfield.building, newfield.building);

      --PERFORM fct_del_in_dict_dept('specimens','container_storage', oldfield.container_storage, newfield.container_storage,
      --  oldfield.container_type, newfield.container_type, 'container_type' );
      --PERFORM fct_del_in_dict_dept('specimens','sub_container_storage', oldfield.sub_container_storage, newfield.sub_container_storage,
      --  oldfield.sub_container_type, newfield.sub_container_type, 'sub_container_type' );
     --ftheeten 2016 09 28
     ELSIF TG_TABLE_NAME = 'storage_parts' THEN

      PERFORM fct_del_in_dict('storage_parts','container_type', oldfield.container_type, newfield.container_type);
      PERFORM fct_del_in_dict('storage_parts','sub_container_type', oldfield.sub_container_type, newfield.sub_container_type);
      PERFORM fct_del_in_dict('storage_parts','specimen_part', oldfield.specimen_part, newfield.specimen_part);
      PERFORM fct_del_in_dict('storage_parts','specimen_status', oldfield.specimen_status, newfield.specimen_status);

      PERFORM fct_del_in_dict('storage_parts','shelf', oldfield.shelf, newfield.shelf);
      PERFORM fct_del_in_dict('storage_parts','col', oldfield.col, newfield.col);
      PERFORM fct_del_in_dict('storage_parts','row', oldfield.row, newfield.row);
      PERFORM fct_del_in_dict('storage_parts','room', oldfield.room, newfield.room);
      PERFORM fct_del_in_dict('storage_parts','floor', oldfield.floor, newfield.floor);
      PERFORM fct_del_in_dict('storage_parts','building', oldfield.building, newfield.building);

      PERFORM fct_del_in_dict_dept('specimens','container_storage', oldfield.container_storage, newfield.container_storage,
        oldfield.container_type, newfield.container_type, 'container_type' );
      PERFORM fct_del_in_dict_dept('specimens','sub_container_storage', oldfield.sub_container_storage, newfield.sub_container_storage,
        oldfield.sub_container_type, newfield.sub_container_type, 'sub_container_type' );
    ELSIF TG_TABLE_NAME = 'specimens_relationships' THEN
      PERFORM fct_del_in_dict('specimens_relationships','relationship_type', oldfield.relationship_type, newfield.relationship_type);
    ELSIF TG_TABLE_NAME = 'users' THEN
      PERFORM fct_del_in_dict('users','title', oldfield.title, newfield.title);
      PERFORM fct_del_in_dict('users','sub_type', oldfield.sub_type, newfield.sub_type);
    ELSIF TG_TABLE_NAME = 'users_addresses' THEN
      PERFORM fct_del_in_dict('users_addresses','country', oldfield.country, newfield.country);

    ELSIF TG_TABLE_NAME = 'loan_status' THEN
      PERFORM fct_del_in_dict('loan_status','status', oldfield.status, newfield.status);

    ELSIF TG_TABLE_NAME = 'properties' THEN

      PERFORM fct_del_in_dict_dept('properties','property_type', oldfield.property_type, newfield.property_type,
        oldfield.referenced_relation, newfield.referenced_relation, 'referenced_relation' );
      PERFORM fct_del_in_dict_dept('properties','applies_to', oldfield.applies_to, newfield.applies_to,
        oldfield.property_type, newfield.property_type, 'property_type' );
      PERFORM fct_del_in_dict_dept('properties','property_unit', oldfield.property_unit, newfield.property_unit,
        oldfield.property_type, newfield.property_type, 'property_type' );

    ELSIF TG_TABLE_NAME = 'tag_groups' THEN
      PERFORM fct_del_in_dict_dept('tag_groups','sub_group_name', oldfield.sub_group_name, newfield.sub_group_name,
        oldfield.group_name, newfield.group_name, 'group_name' );
    ELSIF TG_TABLE_NAME = 'identifiers' THEN
       PERFORM fct_del_in_dict('identifiers','protocol', oldfield.protocol, newfield.protocol);
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.trg_del_dict() OWNER TO darwin2;

--
-- TOC entry 1647 (class 1255 OID 19009)
-- Name: trg_ins_update_dict(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_ins_update_dict() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldfield RECORD;
  newfield RECORD;
 --ftheeten 2018 02 07
 dpt_new_val varchar;
 
  
BEGIN

    IF TG_OP = 'UPDATE' THEN
      oldfield = OLD;
      newfield = NEW;
    ELSE --INSERT
      newfield = NEW;
      execute 'select * from ' || TG_TABLE_NAME::text || ' where id = -15 ' into oldfield;
    END IF;
    IF TG_TABLE_NAME = 'codes' THEN
      PERFORM fct_add_in_dict('codes','code_prefix_separator', oldfield.code_prefix_separator, newfield.code_prefix_separator);
      PERFORM fct_add_in_dict('codes','code_suffix_separator', oldfield.code_suffix_separator, newfield.code_suffix_separator);
      --ftheeten 2016 09 15
      IF newfield.referenced_relation='specimens' AND newfield.code_category='main' THEN
	--UPDATE specimens SET main_code_indexed= fullToIndex(COALESCE(newfield.code_prefix,'') || COALESCE(newfield.code::text,'') || COALESCE(newfield.code_suffix,'') ) WHERE id=newfield.record_id;
      
	  UPDATE specimens SET main_code_indexed= coalesce(lpad(substr(
		  NULLIF(regexp_replace(
			  fullToIndex(COALESCE(newfield.code_prefix,'') 
						  || COALESCE(newfield.code::text,'') ||
						  COALESCE(newfield.code_suffix,'') )
			  
			  , '\D', '', 'g'), ''),1,9)
	,10,'0'),'')||fullToIndex(COALESCE(newfield.code_prefix,'') 
						  || COALESCE(newfield.code::text,'') ||
						  COALESCE(newfield.code_suffix,'') )
						  WHERE id=newfield.record_id;
	  END IF;
	 
    ELSIF TG_TABLE_NAME = 'collection_maintenance' THEN
      PERFORM fct_add_in_dict('collection_maintenance','action_observation', oldfield.action_observation, newfield.action_observation);
    ELSIF TG_TABLE_NAME = 'identifications' THEN
      PERFORM fct_add_in_dict('identifications','determination_status', oldfield.determination_status, newfield.determination_status);
    ELSIF TG_TABLE_NAME = 'people' THEN
      PERFORM fct_add_in_dict('people','sub_type', oldfield.sub_type, newfield.sub_type);
      PERFORM fct_add_in_dict('people','title', oldfield.title, newfield.title);
    ELSIF TG_TABLE_NAME = 'people_addresses' THEN
      PERFORM fct_add_in_dict('people_addresses','country', oldfield.country, newfield.country);
    --ftheeten 2018 03 26 (for country in loans)
    ELSIF TG_TABLE_NAME = 'loans' THEN
      PERFORM fct_add_in_dict('loans','country_receiver', oldfield.country_receiver, newfield.country_receiver);  
    ELSIF TG_TABLE_NAME = 'insurances' THEN
      PERFORM fct_add_in_dict('insurances','insurance_currency', oldfield.insurance_currency, newfield.insurance_currency);
    ELSIF TG_TABLE_NAME = 'mineralogy' THEN
      PERFORM fct_add_in_dict('mineralogy','cristal_system', oldfield.cristal_system, newfield.cristal_system);
    ELSIF TG_TABLE_NAME = 'specimens' THEN
      
      PERFORM fct_add_in_dict('specimens','type', oldfield.type, newfield.type);
      PERFORM fct_add_in_dict('specimens','type_group', oldfield.type_group, newfield.type_group);
      PERFORM fct_add_in_dict('specimens','type_search', oldfield.type_search, newfield.type_search);
      PERFORM fct_add_in_dict('specimens','sex', oldfield.sex, newfield.sex);
      PERFORM fct_add_in_dict('specimens','state', oldfield.state, newfield.state);
      PERFORM fct_add_in_dict('specimens','stage', oldfield.stage, newfield.stage);
      PERFORM fct_add_in_dict('specimens','social_status', oldfield.social_status, newfield.social_status);
      PERFORM fct_add_in_dict('specimens','rock_form', oldfield.rock_form, newfield.rock_form);

/*
IF newfield.type  is not NULL and oldfield.type IS DISTINCT FROM newfield.type THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'specimens', 'type', newfield.type WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'specimens'
        AND dict_field = 'type'
        AND dict_value =  newfield.type)
    );
    END If;

    IF newfield.type_group  is not NULL and oldfield.type_group IS DISTINCT FROM newfield.type_group THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'specimens', 'type_group', newfield.type_group WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'specimens'
        AND dict_field = 'type_group'
        AND dict_value =  newfield.type_group)
    );
    END If;

    IF newfield.type_search  is not NULL and oldfield.type_group IS DISTINCT FROM newfield.type_search THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'specimens', 'type_search', newfield.type_search WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'specimens'
        AND dict_field = 'type_search'
        AND dict_value =  newfield.type_search)
    );
    END If;

    IF newfield.sex  is not NULL and oldfield.sex IS DISTINCT FROM newfield.sex THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'specimens', 'sex', newfield.sex WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'specimens'
        AND dict_field = 'sex'
        AND dict_value =  newfield.sex)
    );
    END If;

    
    IF newfield.state  is not NULL and oldfield.state IS DISTINCT FROM newfield.state THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'specimens', 'state', newfield.state WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'specimens'
        AND dict_field = 'state'
        AND dict_value =  newfield.state)
    );
    END If;
      
    IF newfield.stage  is not NULL and oldfield.stage IS DISTINCT FROM newfield.stage THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'specimens', 'stage', newfield.stage WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'specimens'
        AND dict_field = 'stage'
        AND dict_value =  newfield.stage)
    );
    END If;
      
    IF newfield.social_status  is not NULL and oldfield.social_status IS DISTINCT FROM newfield.social_status THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'specimens', 'social_status', newfield.social_status WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'specimens'
        AND dict_field = 'social_status'
        AND dict_value =  newfield.social_status)
    );
    END If;

        IF newfield.rock_form  is not NULL and oldfield.rock_form IS DISTINCT FROM newfield.rock_form THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'specimens', 'rock_form', newfield.rock_form WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'specimens'
        AND dict_field = 'rock_form'
        AND dict_value =  newfield.rock_form)
    );
    END If;
      */
      
      
      

      --PERFORM fct_add_in_dict('specimens','container_type', oldfield.container_type, newfield.container_type);
      --PERFORM fct_add_in_dict('specimens','sub_container_type', oldfield.sub_container_type, newfield.sub_container_type);
      --PERFORM fct_add_in_dict('specimens','specimen_part', oldfield.specimen_part, newfield.specimen_part);
      --PERFORM fct_add_in_dict('specimens','specimen_status', oldfield.specimen_status, newfield.specimen_status);

      --PERFORM fct_add_in_dict('specimens','shelf', oldfield.shelf, newfield.shelf);
      --PERFORM fct_add_in_dict('specimens','col', oldfield.col, newfield.col);
      --PERFORM fct_add_in_dict('specimens','row', oldfield.row, newfield.row);
      --PERFORM fct_add_in_dict('specimens','room', oldfield.room, newfield.room);
      --PERFORM fct_add_in_dict('specimens','floor', oldfield.floor, newfield.floor);
      --PERFORM fct_add_in_dict('specimens','building', oldfield.building, newfield.building);

      --PERFORM fct_add_in_dict_dept('specimens','container_storage', oldfield.container_storage, newfield.container_storage,
     --   oldfield.container_type, newfield.container_type);
     -- PERFORM fct_add_in_dict_dept('specimens','sub_container_storage', oldfield.sub_container_storage, newfield.sub_container_storage,
     --   oldfield.sub_container_type, newfield.sub_container_type);

    ELSIF TG_TABLE_NAME = 'specimens_relationships' THEN
      PERFORM fct_add_in_dict('specimens_relationships','relationship_type', oldfield.relationship_type, newfield.relationship_type);
    ELSIF TG_TABLE_NAME = 'users' THEN
      PERFORM fct_add_in_dict('users','title', oldfield.title, newfield.title);
      PERFORM fct_add_in_dict('users','sub_type', oldfield.sub_type, newfield.sub_type);
    ELSIF TG_TABLE_NAME = 'users_addresses' THEN
      PERFORM fct_add_in_dict('users_addresses','country', oldfield.country, newfield.country);

    ELSIF TG_TABLE_NAME = 'loan_status' THEN
      PERFORM fct_add_in_dict('loan_status','status', oldfield.status, newfield.status);
     ELSIF TG_TABLE_NAME = 'identifiers' THEN
       PERFORM fct_add_in_dict('identifiers','protocol', oldfield.protocol, newfield.protocol);

    ELSIF TG_TABLE_NAME = 'properties' THEN

      PERFORM fct_add_in_dict_dept('properties','property_type', oldfield.property_type, newfield.property_type,
        oldfield.referenced_relation, newfield.referenced_relation);
      PERFORM fct_add_in_dict_dept('properties','applies_to', oldfield.applies_to, newfield.applies_to,
        oldfield.property_type, newfield.property_type);
      PERFORM fct_add_in_dict_dept('properties','property_unit', oldfield.property_unit, newfield.property_unit,
        oldfield.property_type, newfield.property_type);

    ELSIF TG_TABLE_NAME = 'tag_groups' THEN
      PERFORM fct_add_in_dict_dept('tag_groups','sub_group_name', oldfield.sub_group_name, newfield.sub_group_name,
        oldfield.group_name, newfield.group_name);

--rmca 201608 24

     ELSIF TG_TABLE_NAME = 'storage_parts' THEN
        PERFORM fct_add_in_dict('storage_parts','container_type', oldfield.container_type, newfield.container_type);
/*IF newfield.container_type  is not NULL and oldfield.container_type IS DISTINCT FROM newfield.container_type THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'container_type', newfield.container_type WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'container_type'
        AND dict_value =  newfield.container_type)
    );
    END If;
*/
        
     PERFORM fct_add_in_dict('storage_parts','sub_container_type', oldfield.sub_container_type, newfield.sub_container_type);
/*     IF newfield.sub_container_type  is not NULL and oldfield.sub_container_type IS DISTINCT FROM newfield.sub_container_type THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'sub_container_type', newfield.sub_container_type WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'sub_container_type'
        AND dict_value =  newfield.sub_container_type)
    );
    END If;*/

      PERFORM fct_add_in_dict('storage_parts','specimen_part', oldfield.specimen_part, newfield.specimen_part);
      /*IF newfield.specimen_part  is not NULL and oldfield.specimen_part IS DISTINCT FROM newfield.specimen_part THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'specimen_part', newfield.specimen_part WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'specimen_part'
        AND dict_value =  newfield.specimen_part)
    );
    END If;*/

      PERFORM fct_add_in_dict('storage_parts','specimen_status', oldfield.specimen_status, newfield.specimen_status);
/*IF newfield.specimen_status  is not NULL and oldfield.specimen_status IS DISTINCT FROM newfield.specimen_status THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'specimen_status', newfield.specimen_status WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'specimen_status'
        AND dict_value =  newfield.specimen_status)
    );
    END If;*/

      PERFORM fct_add_in_dict('storage_parts','shelf', oldfield.shelf, newfield.shelf);
/*IF newfield.shelf  is not NULL and oldfield.shelf IS DISTINCT FROM newfield.shelf THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'shelf', newfield.shelf WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'shelf'
        AND dict_value =  newfield.shelf)
    );
    END If;
     */ 
      
      PERFORM fct_add_in_dict('storage_parts','col', oldfield.col, newfield.col);
     /* IF newfield.col  is not NULL and oldfield.col IS DISTINCT FROM newfield.col THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'col', newfield.col WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'col'
        AND dict_value =  newfield.col)
    );
    END If;
     */ 
      PERFORM fct_add_in_dict('storage_parts','row', oldfield.row, newfield.row);
   /*  IF newfield.row  is not NULL and oldfield.row IS DISTINCT FROM newfield.row THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'row', newfield.row WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'row'
        AND dict_value =  newfield.row)
    );
    END If;*/
      
     PERFORM fct_add_in_dict('storage_parts','room', oldfield.room, newfield.room);
     /*IF newfield.room  is not NULL and oldfield.room IS DISTINCT FROM newfield.room THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'room', newfield.room WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'room'
        AND dict_value =  newfield.room)
    );
    END If;*/
      
      PERFORM fct_add_in_dict('storage_parts','floor', oldfield.floor, newfield.floor);
      /*IF newfield.floor  is not NULL and oldfield.floor IS DISTINCT FROM newfield.floor THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'floor', newfield.floor WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'floor'
        AND dict_value =  newfield.floor)
    );
    END If;*/

      
      PERFORM fct_add_in_dict('storage_parts','building', oldfield.building, newfield.building);
/*IF newfield.building  is not NULL and oldfield.building IS DISTINCT FROM newfield.building THEN
	INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT 'storage_parts', 'building', newfield.building WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'building'
        AND dict_value =  newfield.building)
    );
    END If;
     */ 

      PERFORM fct_add_in_dict_dept('storage_parts','container_storage', oldfield.container_storage, newfield.container_storage,
        oldfield.container_type, newfield.container_type);

/*
IF NOT (newfield.container_storage is NULL OR ( oldfield.container_storage IS NOT DISTINCT FROM newfield.container_storage AND oldfield.container_type IS NOT DISTINCT FROM newfield.container_type ))
 THEN  
  
  dpt_new_val := coalesce(newfield.container_type,'');

     INSERT INTO flat_dict (referenced_relation, dict_field, dict_value, dict_depend)
    (
      SELECT 'storage_parts' , 'container_storage', newfield.container_storage , dpt_new_val
      WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'container_storage'
        AND dict_value = newfield.container_storage
        AND dict_depend = dpt_new_val
      )
    );
    
END IF;*/
       
      PERFORM fct_add_in_dict_dept('storage_parts','sub_container_storage', oldfield.sub_container_storage, newfield.sub_container_storage,
        oldfield.sub_container_type, newfield.sub_container_type);
/*
IF NOT (newfield.sub_container_storage is NULL OR ( oldfield.sub_container_storage IS NOT DISTINCT FROM newfield.sub_container_storage AND oldfield.sub_container_type IS NOT DISTINCT FROM newfield.sub_container_type ))
 THEN  
  
  dpt_new_val := coalesce(newfield.sub_container_type,'');

     INSERT INTO flat_dict (referenced_relation, dict_field, dict_value, dict_depend)
    (
      SELECT 'storage_parts' , 'sub_container_storage', newfield.sub_container_storage , dpt_new_val
      WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = 'storage_parts'
        AND dict_field = 'sub_container_storage'
        AND dict_value = newfield.sub_container_storage
        AND dict_depend = dpt_new_val
      )
    );
    
END IF;
*/

    END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.trg_ins_update_dict() OWNER TO darwin2;

--
-- TOC entry 1646 (class 1255 OID 19012)
-- Name: trg_rmca_create_uuid(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_rmca_create_uuid() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN 
INSERT INTO specimens_stable_ids (specimen_ref, specimen_fk) VALUEs (NEW.id, NEW.id);
RETURN NEW;
END
$$;


ALTER FUNCTION darwin2.trg_rmca_create_uuid() OWNER TO darwin2;

--
-- TOC entry 1530 (class 1255 OID 19013)
-- Name: trg_rmca_del_import_related(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_rmca_del_import_related() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN

 IF TG_OP='DELETE' OR (TG_OP='UPDATE' AND NEW.state='deleted' ) THEN
	--DELETE FROM properties WHERE referenced_relation='staging_gtu' AND record_id IN (SELECT id FROM staging_gtu WHERE import_ref= OLD.id ) ;
	--DELETE FROM comments WHERE referenced_relation='staging_gtu' AND record_id IN (SELECT id FROM staging_gtu WHERE import_ref= OLD.id ) ;
	--DELETE FROM staging_people WHERE referenced_relation='staging_gtu' AND record_id IN (SELECT id FROM staging_gtu WHERE import_ref= OLD.id ) ;
	--DELETE FROM staging_gtu_tag_groups WHERE staging_gtu_ref IN (SELECT id FROM staging_gtu WHERE import_ref= OLD.id ) ;
	--DELETE FROM staging_gtu WHERE import_ref=OLD.id;
	--PERFORM setval('darwin2.staging_gtu_id_seq', (SELECT MAX(id)+1 FROM staging_gtu) , false);
  
 END IF;
 IF TG_OP='DELETE' THEN
  RETURN OLD;
 ELSEIF TG_OP='UPDATE' THEN
  RETURN NEW;
 END IF;
 RETURN OLD;
END;
$$;


ALTER FUNCTION darwin2.trg_rmca_del_import_related() OWNER TO darwin2;

--
-- TOC entry 1534 (class 1255 OID 19014)
-- Name: trg_rmca_delete_specimen_storage(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_rmca_delete_specimen_storage() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldfield RECORD;

BEGIN

    IF TG_OP = 'DELETE' AND TG_TABLE_NAME = 'specimens' THEN
    
        DELETE FROM storage_parts WHERE specimen_ref=OLD.id;
    END IF;
	RETURN old;
END;
$$;


ALTER FUNCTION darwin2.trg_rmca_delete_specimen_storage() OWNER TO darwin2;

--
-- TOC entry 1535 (class 1255 OID 19015)
-- Name: trg_rmca_import_taxonomy_history(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_rmca_import_taxonomy_history() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN
IF TG_OP='INSERT' THEN
	NEW.history_taxonomy =hstore(NEW.specimen_taxonomy_ref::varchar ,now()::varchar);
ELSIF TG_OP='UPDATE' THEN
	IF OLD.history_taxonomy IS NULL THEN
		NEW.history_taxonomy =hstore(NEW.specimen_taxonomy_ref::varchar ,now()::varchar);
	ELSE 
		IF NEW.specimen_taxonomy_ref!= OLD.specimen_taxonomy_ref  THEN
			NEW.history_taxonomy =OLD.history_taxonomy||hstore(NEW.specimen_taxonomy_ref::varchar ,now()::varchar);
			UPDATE staging SET specimen_taxonomy_ref=NEW.specimen_taxonomy_ref WHERE taxon_ref IS NULL AND import_ref=NEW.id;
		END IF;
	END IF ;
 END IF;
 
 RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.trg_rmca_import_taxonomy_history() OWNER TO darwin2;

--
-- TOC entry 1536 (class 1255 OID 19016)
-- Name: trg_rmca_ins_update_people_and_address(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_rmca_ins_update_people_and_address() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  newfield RECORD; 
  idres integer;
  
BEGIN
    newfield = NEW;
 
    IF TG_TABLE_NAME = 'loans' THEN
      idres = fct_rmca_add_in_people('f',newfield.institution_receiver);  
      RAISE NOTICE 'id=(%)', idres;
      PERFORM fct_rmca_add_in_people_address(idres,newfield.address_receiver,newfield.zip_receiver,newfield.city_receiver,newfield.country_receiver);  
    END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.trg_rmca_ins_update_people_and_address() OWNER TO darwin2;

--
-- TOC entry 1537 (class 1255 OID 19017)
-- Name: trg_rmca_issue_storage_insert(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_rmca_issue_storage_insert() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldfield RECORD;
  newfield RECORD;
BEGIN

    IF TG_OP = 'INSERT' OR  TG_OP = 'UPDATE' THEN
	 --oldfield = OLD;
         newfield = NEW;
	 IF TG_TABLE_NAME = 'storage_parts' THEN
		IF newfield.institution_ref is NULL THEN
			--RETURN NULL;
		END IF;
	 END IF;

    END IF;
     IF  TG_OP = 'UPDATE' THEN
	oldfield = OLD;
         newfield = NEW;
	 IF TG_TABLE_NAME = 'storage_parts' THEN
		IF newfield.institution_ref is NULL THEN
			--RETURN OLD;
		END IF;
	 END IF;

    END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.trg_rmca_issue_storage_insert() OWNER TO darwin2;

--
-- TOC entry 1624 (class 1255 OID 19018)
-- Name: rmca_migrate_rbins_rmca_align_seq(); Type: FUNCTION; Schema: public; Owner: darwin2
--

CREATE FUNCTION public.rmca_migrate_rbins_rmca_align_seq() RETURNS integer
    LANGUAGE plpgsql
    AS $$
    Declare returned int;
    rec_seq record;
 
   cur_seq  CURSOR FOR SELECT REPLACE(REPLACE(column_default,'nextval(''',''),'''::regclass)','') as seq_name, table_name, column_name from information_schema.columns where column_default like 'nextval%' and table_schema='darwin2' order by table_name;



  metadata_tmp integer;
    BEGIN
       set search_path='darwin2';
    returned:=-1;
    --attention, the index esof specimens in the rbins are bound to some functions
    SET search_path TO darwin2;
      OPEN cur_seq;
 
   LOOP
    -- fetch row into the film
      FETCH cur_seq INTO rec_seq;
    -- exit when no more row to fetch
      EXIT WHEN NOT FOUND;
	RAISE notice E'seq: % \t table:% \ t count', rec_seq.seq_name,rec_seq.table_name ;
       EXECUTE 'SELECT setval(''darwin2.'||rec_seq.seq_name||''', (SELECT MAX('||rec_seq.column_name||')+1 FROM darwin2.'||rec_seq.table_name||') , false);';
 
   END LOOP;
	returned:=0;
      return returned;


      
    END;
    $$;


ALTER FUNCTION public.rmca_migrate_rbins_rmca_align_seq() OWNER TO darwin2;

--
-- TOC entry 1648 (class 1255 OID 19019)
-- Name: trg_del_dict(); Type: FUNCTION; Schema: public; Owner: darwin2
--

CREATE FUNCTION public.trg_del_dict() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldfield RECORD;
  newfield RECORD;
BEGIN

    IF TG_OP = 'UPDATE' THEN
      oldfield = OLD;
      newfield = NEW;
    ELSE --DELETE
      oldfield = OLD;
      execute 'select * from ' || TG_TABLE_NAME::text || ' where id = -15 ' into newfield;
    END IF;
    IF TG_TABLE_NAME = 'codes' THEN
      PERFORM fct_del_in_dict('codes','code_prefix_separator', oldfield.code_prefix_separator, newfield.code_prefix_separator);
      PERFORM fct_del_in_dict('codes','code_suffix_separator', oldfield.code_suffix_separator, newfield.code_suffix_separator);
            --ftheeten 2016 09 15
      IF oldfield.referenced_relation='specimens' AND oldfield.code_category='main' THEN
                UPDATE specimens SET main_code_indexed= NULL WHERE id=oldfield.record_id;
      END IF;
    ELSIF TG_TABLE_NAME = 'collection_maintenance' THEN
      PERFORM fct_del_in_dict('collection_maintenance','action_observation', oldfield.action_observation, newfield.action_observation);
    ELSIF TG_TABLE_NAME = 'identifications' THEN
      PERFORM fct_del_in_dict('identifications','determination_status', oldfield.determination_status, newfield.determination_status);
    ELSIF TG_TABLE_NAME = 'people' THEN
      PERFORM fct_del_in_dict('people','sub_type', oldfield.sub_type, newfield.sub_type);
      PERFORM fct_del_in_dict('people','title', oldfield.title, newfield.title);
    ELSIF TG_TABLE_NAME = 'people_addresses' THEN
      PERFORM fct_del_in_dict('people_addresses','country', oldfield.country, newfield.country);
    ELSIF TG_TABLE_NAME = 'insurances' THEN
      PERFORM fct_del_in_dict('insurances','insurance_currency', oldfield.insurance_currency, newfield.insurance_currency);
    ELSIF TG_TABLE_NAME = 'mineralogy' THEN
      PERFORM fct_del_in_dict('mineralogy','cristal_system', oldfield.cristal_system, newfield.cristal_system);
    ELSIF TG_TABLE_NAME = 'specimens' THEN
      PERFORM fct_del_in_dict('specimens','type', oldfield.type, newfield.type);
      PERFORM fct_del_in_dict('specimens','type_group', oldfield.type_group, newfield.type_group);
      PERFORM fct_del_in_dict('specimens','type_search', oldfield.type_search, newfield.type_search);
      PERFORM fct_del_in_dict('specimens','sex', oldfield.sex, newfield.sex);
      PERFORM fct_del_in_dict('specimens','state', oldfield.state, newfield.state);
      PERFORM fct_del_in_dict('specimens','stage', oldfield.stage, newfield.stage);
      PERFORM fct_del_in_dict('specimens','social_status', oldfield.social_status, newfield.social_status);
      PERFORM fct_del_in_dict('specimens','rock_form', oldfield.rock_form, newfield.rock_form);

      PERFORM fct_del_in_dict('specimens','container_type', oldfield.container_type, newfield.container_type);
      PERFORM fct_del_in_dict('specimens','sub_container_type', oldfield.sub_container_type, newfield.sub_container_type);
      PERFORM fct_del_in_dict('specimens','specimen_part', oldfield.specimen_part, newfield.specimen_part);
      PERFORM fct_del_in_dict('specimens','specimen_status', oldfield.specimen_status, newfield.specimen_status);

      PERFORM fct_del_in_dict('specimens','shelf', oldfield.shelf, newfield.shelf);
      PERFORM fct_del_in_dict('specimens','col', oldfield.col, newfield.col);
      PERFORM fct_del_in_dict('specimens','row', oldfield.row, newfield.row);
      PERFORM fct_del_in_dict('specimens','room', oldfield.room, newfield.room);
      PERFORM fct_del_in_dict('specimens','floor', oldfield.floor, newfield.floor);
      PERFORM fct_del_in_dict('specimens','building', oldfield.building, newfield.building);

      PERFORM fct_del_in_dict_dept('specimens','container_storage', oldfield.container_storage, newfield.container_storage,
        oldfield.container_type, newfield.container_type, 'container_type' );
      PERFORM fct_del_in_dict_dept('specimens','sub_container_storage', oldfield.sub_container_storage, newfield.sub_container_storage,
        oldfield.sub_container_type, newfield.sub_container_type, 'sub_container_type' );

    ELSIF TG_TABLE_NAME = 'specimens_relationships' THEN
      PERFORM fct_del_in_dict('specimens_relationships','relationship_type', oldfield.relationship_type, newfield.relationship_type);
    ELSIF TG_TABLE_NAME = 'users' THEN
      PERFORM fct_del_in_dict('users','title', oldfield.title, newfield.title);
      PERFORM fct_del_in_dict('users','sub_type', oldfield.sub_type, newfield.sub_type);
    ELSIF TG_TABLE_NAME = 'users_addresses' THEN
      PERFORM fct_del_in_dict('users_addresses','country', oldfield.country, newfield.country);

    ELSIF TG_TABLE_NAME = 'loan_status' THEN
      PERFORM fct_del_in_dict('loan_status','status', oldfield.status, newfield.status);

    ELSIF TG_TABLE_NAME = 'properties' THEN

      PERFORM fct_del_in_dict_dept('properties','property_type', oldfield.property_type, newfield.property_type,
        oldfield.referenced_relation, newfield.referenced_relation, 'referenced_relation' );
      PERFORM fct_del_in_dict_dept('properties','applies_to', oldfield.applies_to, newfield.applies_to,
        oldfield.property_type, newfield.property_type, 'property_type' );
      PERFORM fct_del_in_dict_dept('properties','property_unit', oldfield.property_unit, newfield.property_unit,
        oldfield.property_type, newfield.property_type, 'property_type' );

    ELSIF TG_TABLE_NAME = 'tag_groups' THEN
      PERFORM fct_del_in_dict_dept('tag_groups','sub_group_name', oldfield.sub_group_name, newfield.sub_group_name,
        oldfield.group_name, newfield.group_name, 'group_name' );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.trg_del_dict() OWNER TO darwin2;

--
-- TOC entry 1649 (class 1255 OID 19020)
-- Name: trg_ins_update_dict(); Type: FUNCTION; Schema: public; Owner: darwin2
--

CREATE FUNCTION public.trg_ins_update_dict() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldfield RECORD;
  newfield RECORD;
BEGIN

    IF TG_OP = 'UPDATE' THEN
      oldfield = OLD;
      newfield = NEW;
    ELSE --INSERT
      newfield = NEW;
      execute 'select * from ' || TG_TABLE_NAME::text || ' where id = -15 ' into oldfield;
    END IF;
    IF TG_TABLE_NAME = 'codes' THEN
      PERFORM fct_add_in_dict('codes','code_prefix_separator', oldfield.code_prefix_separator, newfield.code_prefix_separator);
      PERFORM fct_add_in_dict('codes','code_suffix_separator', oldfield.code_suffix_separator, newfield.code_suffix_separator);
      --ftheeten 2016 09 15
      IF newfield.referenced_relation='specimens' AND newfield.code_category='main' THEN
                UPDATE specimens SET main_code_indexed= fullToIndex(COALESCE(newfield.code_prefix,'') || COALESCE(newfield.code::text,'') || COALESCE(newfield.code_suffix,'') ) WHERE id=newfield.record_id;
      END IF;
    ELSIF TG_TABLE_NAME = 'collection_maintenance' THEN
      PERFORM fct_add_in_dict('collection_maintenance','action_observation', oldfield.action_observation, newfield.action_observation);
    ELSIF TG_TABLE_NAME = 'identifications' THEN
      PERFORM fct_add_in_dict('identifications','determination_status', oldfield.determination_status, newfield.determination_status);
    ELSIF TG_TABLE_NAME = 'people' THEN
      PERFORM fct_add_in_dict('people','sub_type', oldfield.sub_type, newfield.sub_type);
      PERFORM fct_add_in_dict('people','title', oldfield.title, newfield.title);
    ELSIF TG_TABLE_NAME = 'people_addresses' THEN
      PERFORM fct_add_in_dict('people_addresses','country', oldfield.country, newfield.country);
    ELSIF TG_TABLE_NAME = 'insurances' THEN
      PERFORM fct_add_in_dict('insurances','insurance_currency', oldfield.insurance_currency, newfield.insurance_currency);
    ELSIF TG_TABLE_NAME = 'mineralogy' THEN
      PERFORM fct_add_in_dict('mineralogy','cristal_system', oldfield.cristal_system, newfield.cristal_system);
    ELSIF TG_TABLE_NAME = 'specimens' THEN
      PERFORM fct_add_in_dict('specimens','type', oldfield.type, newfield.type);
      PERFORM fct_add_in_dict('specimens','type_group', oldfield.type_group, newfield.type_group);
      PERFORM fct_add_in_dict('specimens','type_search', oldfield.type_search, newfield.type_search);
      PERFORM fct_add_in_dict('specimens','sex', oldfield.sex, newfield.sex);
      PERFORM fct_add_in_dict('specimens','state', oldfield.state, newfield.state);
      PERFORM fct_add_in_dict('specimens','stage', oldfield.stage, newfield.stage);
      PERFORM fct_add_in_dict('specimens','social_status', oldfield.social_status, newfield.social_status);
      PERFORM fct_add_in_dict('specimens','rock_form', oldfield.rock_form, newfield.rock_form);

      PERFORM fct_add_in_dict('specimens','container_type', oldfield.container_type, newfield.container_type);
      PERFORM fct_add_in_dict('specimens','sub_container_type', oldfield.sub_container_type, newfield.sub_container_type);
      PERFORM fct_add_in_dict('specimens','specimen_part', oldfield.specimen_part, newfield.specimen_part);
      PERFORM fct_add_in_dict('specimens','specimen_status', oldfield.specimen_status, newfield.specimen_status);

      PERFORM fct_add_in_dict('specimens','shelf', oldfield.shelf, newfield.shelf);
      PERFORM fct_add_in_dict('specimens','col', oldfield.col, newfield.col);
      PERFORM fct_add_in_dict('specimens','row', oldfield.row, newfield.row);
      PERFORM fct_add_in_dict('specimens','room', oldfield.room, newfield.room);
      PERFORM fct_add_in_dict('specimens','floor', oldfield.floor, newfield.floor);
      PERFORM fct_add_in_dict('specimens','building', oldfield.building, newfield.building);

      PERFORM fct_add_in_dict_dept('specimens','container_storage', oldfield.container_storage, newfield.container_storage,
        oldfield.container_type, newfield.container_type);
      PERFORM fct_add_in_dict_dept('specimens','sub_container_storage', oldfield.sub_container_storage, newfield.sub_container_storage,
        oldfield.sub_container_type, newfield.sub_container_type);

    ELSIF TG_TABLE_NAME = 'specimens_relationships' THEN
      PERFORM fct_add_in_dict('specimens_relationships','relationship_type', oldfield.relationship_type, newfield.relationship_type);
    ELSIF TG_TABLE_NAME = 'users' THEN
      PERFORM fct_add_in_dict('users','title', oldfield.title, newfield.title);
      PERFORM fct_add_in_dict('users','sub_type', oldfield.sub_type, newfield.sub_type);
    ELSIF TG_TABLE_NAME = 'users_addresses' THEN
      PERFORM fct_add_in_dict('users_addresses','country', oldfield.country, newfield.country);

    ELSIF TG_TABLE_NAME = 'loan_status' THEN
      PERFORM fct_add_in_dict('loan_status','status', oldfield.status, newfield.status);

    ELSIF TG_TABLE_NAME = 'properties' THEN

      PERFORM fct_add_in_dict_dept('properties','property_type', oldfield.property_type, newfield.property_type,
        oldfield.referenced_relation, newfield.referenced_relation);
      PERFORM fct_add_in_dict_dept('properties','applies_to', oldfield.applies_to, newfield.applies_to,
        oldfield.property_type, newfield.property_type);
      PERFORM fct_add_in_dict_dept('properties','property_unit', oldfield.property_unit, newfield.property_unit,
        oldfield.property_type, newfield.property_type);

    ELSIF TG_TABLE_NAME = 'tag_groups' THEN
      PERFORM fct_add_in_dict_dept('tag_groups','sub_group_name', oldfield.sub_group_name, newfield.sub_group_name,
        oldfield.group_name, newfield.group_name);

    END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.trg_ins_update_dict() OWNER TO darwin2;

--
-- TOC entry 3937 (class 2617 OID 19021)
-- Name: =; Type: OPERATOR; Schema: darwin2; Owner: darwin2
--

CREATE OPERATOR darwin2.= (
    FUNCTION = darwin2.point_equal,
    LEFTARG = point,
    RIGHTARG = point
);


ALTER OPERATOR darwin2.= (point, point) OWNER TO darwin2;

--
-- TOC entry 250 (class 1259 OID 19022)
-- Name: bck_specimens_crustacae_20210319; Type: TABLE; Schema: clean; Owner: darwin2
--

CREATE TABLE clean.bck_specimens_crustacae_20210319 (
    id integer,
    collection_ref integer,
    expedition_ref integer,
    gtu_ref integer,
    taxon_ref integer,
    litho_ref integer,
    chrono_ref integer,
    lithology_ref integer,
    mineral_ref integer,
    acquisition_category character varying,
    acquisition_date_mask integer,
    acquisition_date date,
    station_visible boolean,
    ig_ref integer,
    type character varying,
    type_group character varying,
    type_search character varying,
    sex character varying,
    stage character varying,
    state character varying,
    social_status character varying,
    rock_form character varying,
    room character varying,
    shelf character varying,
    specimen_count_min integer,
    specimen_count_max integer,
    spec_ident_ids integer[],
    spec_coll_ids integer[],
    spec_don_sel_ids integer[],
    collection_type character varying,
    collection_code character varying,
    collection_name character varying,
    collection_is_public boolean,
    collection_parent_ref integer,
    collection_path character varying,
    expedition_name character varying,
    expedition_name_indexed character varying,
    gtu_code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_tag_values_indexed character varying[],
    gtu_country_tag_value character varying,
    gtu_country_tag_indexed character varying[],
    gtu_province_tag_value character varying,
    gtu_province_tag_indexed character varying[],
    gtu_others_tag_value character varying,
    gtu_others_tag_indexed character varying[],
    gtu_elevation double precision,
    gtu_elevation_accuracy double precision,
    gtu_location point,
    taxon_name character varying,
    taxon_name_indexed character varying,
    taxon_level_ref integer,
    taxon_level_name character varying,
    taxon_status character varying,
    taxon_path character varying,
    taxon_parent_ref integer,
    taxon_extinct boolean,
    litho_name character varying,
    litho_name_indexed character varying,
    litho_level_ref integer,
    litho_level_name character varying,
    litho_status character varying,
    litho_local boolean,
    litho_color character varying,
    litho_path character varying,
    litho_parent_ref integer,
    chrono_name character varying,
    chrono_name_indexed character varying,
    chrono_level_ref integer,
    chrono_level_name character varying,
    chrono_status character varying,
    chrono_local boolean,
    chrono_color character varying,
    chrono_path character varying,
    chrono_parent_ref integer,
    lithology_name character varying,
    lithology_name_indexed character varying,
    lithology_level_ref integer,
    lithology_level_name character varying,
    lithology_status character varying,
    lithology_local boolean,
    lithology_color character varying,
    lithology_path character varying,
    lithology_parent_ref integer,
    mineral_name character varying,
    mineral_name_indexed character varying,
    mineral_level_ref integer,
    mineral_level_name character varying,
    mineral_status character varying,
    mineral_local boolean,
    mineral_color character varying,
    mineral_path character varying,
    mineral_parent_ref integer,
    ig_num character varying,
    ig_num_indexed character varying,
    ig_date_mask integer,
    ig_date date,
    specimen_count_males_min integer,
    specimen_count_males_max integer,
    specimen_count_females_min integer,
    specimen_count_females_max integer,
    specimen_count_juveniles_min integer,
    specimen_count_juveniles_max integer,
    main_code_indexed character varying,
    category character varying,
    institution_ref integer,
    building character varying,
    floor character varying,
    "row" character varying,
    col character varying,
    container character varying,
    sub_container character varying,
    container_type character varying,
    sub_container_type character varying,
    container_storage character varying,
    sub_container_storage character varying,
    surnumerary boolean,
    object_name text,
    object_name_indexed text,
    specimen_status character varying,
    valid_label boolean,
    label_created_on character varying,
    label_created_by character varying,
    specimen_creation_date timestamp without time zone,
    import_ref integer,
    gtu_iso3166 character varying,
    gtu_iso3166_subdivision character varying,
    nagoya character varying
);


ALTER TABLE clean.bck_specimens_crustacae_20210319 OWNER TO darwin2;

--
-- TOC entry 251 (class 1259 OID 19028)
-- Name: catalogue_people_bck2021; Type: TABLE; Schema: clean; Owner: darwin2
--

CREATE TABLE clean.catalogue_people_bck2021 (
    referenced_relation character varying,
    record_id integer,
    id integer,
    people_type character varying,
    people_sub_type character varying,
    order_by integer,
    people_ref integer
);


ALTER TABLE clean.catalogue_people_bck2021 OWNER TO darwin2;

--
-- TOC entry 252 (class 1259 OID 19034)
-- Name: crustacae_2021_clean_date; Type: TABLE; Schema: clean; Owner: darwin2
--

CREATE TABLE clean.crustacae_2021_clean_date (
    unitid character varying,
    original_collection_date character varying,
    collectionstartday character varying,
    collectionstartmonth character varying,
    collectionstartyear character varying,
    collectionendday character varying,
    collectionendmonth character varying,
    collectionendyear character varying
);


ALTER TABLE clean.crustacae_2021_clean_date OWNER TO darwin2;

--
-- TOC entry 253 (class 1259 OID 19040)
-- Name: ident_pb_20210125; Type: TABLE; Schema: clean; Owner: darwin2
--

CREATE TABLE clean.ident_pb_20210125 (
    filename character varying,
    unitid character varying,
    people_role character varying,
    people_name character varying,
    people_fk integer,
    specimen_fk integer,
    id integer,
    specimen_fks integer[],
    imp_id integer,
    unnest_fk integer,
    cat_people_relation character varying,
    cat_people_record_id integer,
    cat_people_id integer,
    people_type character varying,
    people_sub_type character varying,
    people_ref integer,
    is_physical boolean,
    sub_type character varying,
    formated_name character varying,
    formated_name_indexed character varying,
    formated_name_unique character varying,
    title character varying,
    family_name character varying,
    given_name character varying,
    additional_names character varying,
    birth_date_mask integer,
    birth_date date,
    gender character(1),
    people_id integer,
    end_date_mask integer,
    end_date date,
    activity_date_from_mask integer,
    activity_date_from date,
    activity_date_to_mask integer,
    activity_date_to date,
    name_formated_indexed character varying,
    import_ref integer,
    ident_relation character varying,
    ident_record_id integer,
    ident_id integer,
    notion_concerned character varying,
    notion_date timestamp without time zone,
    notion_date_mask integer,
    value_defined character varying,
    value_defined_indexed character varying,
    determination_status character varying
);


ALTER TABLE clean.ident_pb_20210125 OWNER TO darwin2;

--
-- TOC entry 254 (class 1259 OID 19046)
-- Name: identifications_bck2021; Type: TABLE; Schema: clean; Owner: darwin2
--

CREATE TABLE clean.identifications_bck2021 (
    referenced_relation character varying,
    record_id integer,
    id integer,
    notion_concerned character varying,
    notion_date timestamp without time zone,
    notion_date_mask integer,
    value_defined character varying,
    value_defined_indexed character varying,
    determination_status character varying,
    order_by integer
);


ALTER TABLE clean.identifications_bck2021 OWNER TO darwin2;

--
-- TOC entry 255 (class 1259 OID 19052)
-- Name: people_align_debug_bck2021; Type: TABLE; Schema: clean; Owner: darwin2
--

CREATE TABLE clean.people_align_debug_bck2021 (
    filename character varying,
    unitid character varying,
    people_role character varying,
    people_name character varying,
    people_fk integer,
    specimen_fk integer
);


ALTER TABLE clean.people_align_debug_bck2021 OWNER TO darwin2;

--
-- TOC entry 256 (class 1259 OID 19058)
-- Name: specimens_bck2021; Type: TABLE; Schema: clean; Owner: darwin2
--

CREATE TABLE clean.specimens_bck2021 (
    id integer,
    collection_ref integer,
    expedition_ref integer,
    gtu_ref integer,
    taxon_ref integer,
    litho_ref integer,
    chrono_ref integer,
    lithology_ref integer,
    mineral_ref integer,
    acquisition_category character varying,
    acquisition_date_mask integer,
    acquisition_date date,
    station_visible boolean,
    ig_ref integer,
    type character varying,
    type_group character varying,
    type_search character varying,
    sex character varying,
    stage character varying,
    state character varying,
    social_status character varying,
    rock_form character varying,
    room character varying,
    shelf character varying,
    specimen_count_min integer,
    specimen_count_max integer,
    spec_ident_ids integer[],
    spec_coll_ids integer[],
    spec_don_sel_ids integer[],
    collection_type character varying,
    collection_code character varying,
    collection_name character varying,
    collection_is_public boolean,
    collection_parent_ref integer,
    collection_path character varying,
    expedition_name character varying,
    expedition_name_indexed character varying,
    gtu_code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_tag_values_indexed character varying[],
    gtu_country_tag_value character varying,
    gtu_country_tag_indexed character varying[],
    gtu_province_tag_value character varying,
    gtu_province_tag_indexed character varying[],
    gtu_others_tag_value character varying,
    gtu_others_tag_indexed character varying[],
    gtu_elevation double precision,
    gtu_elevation_accuracy double precision,
    gtu_location point,
    taxon_name character varying,
    taxon_name_indexed character varying,
    taxon_level_ref integer,
    taxon_level_name character varying,
    taxon_status character varying,
    taxon_path character varying,
    taxon_parent_ref integer,
    taxon_extinct boolean,
    litho_name character varying,
    litho_name_indexed character varying,
    litho_level_ref integer,
    litho_level_name character varying,
    litho_status character varying,
    litho_local boolean,
    litho_color character varying,
    litho_path character varying,
    litho_parent_ref integer,
    chrono_name character varying,
    chrono_name_indexed character varying,
    chrono_level_ref integer,
    chrono_level_name character varying,
    chrono_status character varying,
    chrono_local boolean,
    chrono_color character varying,
    chrono_path character varying,
    chrono_parent_ref integer,
    lithology_name character varying,
    lithology_name_indexed character varying,
    lithology_level_ref integer,
    lithology_level_name character varying,
    lithology_status character varying,
    lithology_local boolean,
    lithology_color character varying,
    lithology_path character varying,
    lithology_parent_ref integer,
    mineral_name character varying,
    mineral_name_indexed character varying,
    mineral_level_ref integer,
    mineral_level_name character varying,
    mineral_status character varying,
    mineral_local boolean,
    mineral_color character varying,
    mineral_path character varying,
    mineral_parent_ref integer,
    ig_num character varying,
    ig_num_indexed character varying,
    ig_date_mask integer,
    ig_date date,
    specimen_count_males_min integer,
    specimen_count_males_max integer,
    specimen_count_females_min integer,
    specimen_count_females_max integer,
    specimen_count_juveniles_min integer,
    specimen_count_juveniles_max integer,
    main_code_indexed character varying,
    category character varying,
    institution_ref integer,
    building character varying,
    floor character varying,
    "row" character varying,
    col character varying,
    container character varying,
    sub_container character varying,
    container_type character varying,
    sub_container_type character varying,
    container_storage character varying,
    sub_container_storage character varying,
    surnumerary boolean,
    object_name text,
    object_name_indexed text,
    specimen_status character varying,
    valid_label boolean,
    label_created_on character varying,
    label_created_by character varying,
    specimen_creation_date timestamp without time zone,
    import_ref integer,
    gtu_iso3166 character varying,
    gtu_iso3166_subdivision character varying,
    nagoya character varying
);


ALTER TABLE clean.specimens_bck2021 OWNER TO darwin2;

--
-- TOC entry 257 (class 1259 OID 19064)
-- Name: v_crustacae_align_date_begin; Type: VIEW; Schema: clean; Owner: darwin2
--

CREATE VIEW clean.v_crustacae_align_date_begin AS
 SELECT 56 AS code,
    crustacae_2021_clean_date.unitid,
    crustacae_2021_clean_date.original_collection_date,
    crustacae_2021_clean_date.collectionstartday,
    crustacae_2021_clean_date.collectionstartmonth,
    crustacae_2021_clean_date.collectionstartyear,
    crustacae_2021_clean_date.collectionendday,
    crustacae_2021_clean_date.collectionendmonth,
    crustacae_2021_clean_date.collectionendyear
   FROM clean.crustacae_2021_clean_date
  WHERE ((crustacae_2021_clean_date.collectionstartday IS NOT NULL) AND (crustacae_2021_clean_date.collectionstartmonth IS NOT NULL) AND (crustacae_2021_clean_date.collectionstartyear IS NOT NULL))
UNION
 SELECT 48 AS code,
    crustacae_2021_clean_date.unitid,
    crustacae_2021_clean_date.original_collection_date,
    crustacae_2021_clean_date.collectionstartday,
    crustacae_2021_clean_date.collectionstartmonth,
    crustacae_2021_clean_date.collectionstartyear,
    crustacae_2021_clean_date.collectionendday,
    crustacae_2021_clean_date.collectionendmonth,
    crustacae_2021_clean_date.collectionendyear
   FROM clean.crustacae_2021_clean_date
  WHERE ((crustacae_2021_clean_date.collectionstartday IS NULL) AND (crustacae_2021_clean_date.collectionstartmonth IS NOT NULL) AND (crustacae_2021_clean_date.collectionstartyear IS NOT NULL))
UNION
 SELECT 32 AS code,
    crustacae_2021_clean_date.unitid,
    crustacae_2021_clean_date.original_collection_date,
    crustacae_2021_clean_date.collectionstartday,
    crustacae_2021_clean_date.collectionstartmonth,
    crustacae_2021_clean_date.collectionstartyear,
    crustacae_2021_clean_date.collectionendday,
    crustacae_2021_clean_date.collectionendmonth,
    crustacae_2021_clean_date.collectionendyear
   FROM clean.crustacae_2021_clean_date
  WHERE ((crustacae_2021_clean_date.collectionstartday IS NULL) AND (crustacae_2021_clean_date.collectionstartmonth IS NULL) AND (crustacae_2021_clean_date.collectionstartyear IS NOT NULL));


ALTER TABLE clean.v_crustacae_align_date_begin OWNER TO darwin2;

--
-- TOC entry 258 (class 1259 OID 19069)
-- Name: v_crustacae_align_date_end; Type: VIEW; Schema: clean; Owner: darwin2
--

CREATE VIEW clean.v_crustacae_align_date_end AS
 SELECT 56 AS code,
    crustacae_2021_clean_date.unitid,
    crustacae_2021_clean_date.original_collection_date,
    crustacae_2021_clean_date.collectionstartday,
    crustacae_2021_clean_date.collectionstartmonth,
    crustacae_2021_clean_date.collectionstartyear,
    crustacae_2021_clean_date.collectionendday,
    crustacae_2021_clean_date.collectionendmonth,
    crustacae_2021_clean_date.collectionendyear
   FROM clean.crustacae_2021_clean_date
  WHERE ((crustacae_2021_clean_date.collectionendday IS NOT NULL) AND (crustacae_2021_clean_date.collectionendmonth IS NOT NULL) AND (crustacae_2021_clean_date.collectionendyear IS NOT NULL))
UNION
 SELECT 48 AS code,
    crustacae_2021_clean_date.unitid,
    crustacae_2021_clean_date.original_collection_date,
    crustacae_2021_clean_date.collectionstartday,
    crustacae_2021_clean_date.collectionstartmonth,
    crustacae_2021_clean_date.collectionstartyear,
    crustacae_2021_clean_date.collectionendday,
    crustacae_2021_clean_date.collectionendmonth,
    crustacae_2021_clean_date.collectionendyear
   FROM clean.crustacae_2021_clean_date
  WHERE ((crustacae_2021_clean_date.collectionendday IS NULL) AND (crustacae_2021_clean_date.collectionendmonth IS NOT NULL) AND (crustacae_2021_clean_date.collectionendyear IS NOT NULL))
UNION
 SELECT 32 AS code,
    crustacae_2021_clean_date.unitid,
    crustacae_2021_clean_date.original_collection_date,
    crustacae_2021_clean_date.collectionstartday,
    crustacae_2021_clean_date.collectionstartmonth,
    crustacae_2021_clean_date.collectionstartyear,
    crustacae_2021_clean_date.collectionendday,
    crustacae_2021_clean_date.collectionendmonth,
    crustacae_2021_clean_date.collectionendyear
   FROM clean.crustacae_2021_clean_date
  WHERE ((crustacae_2021_clean_date.collectionendday IS NULL) AND (crustacae_2021_clean_date.collectionendmonth IS NULL) AND (crustacae_2021_clean_date.collectionendyear IS NOT NULL));


ALTER TABLE clean.v_crustacae_align_date_end OWNER TO darwin2;

--
-- TOC entry 526 (class 1259 OID 1745951)
-- Name: wood_biology2022_coordinates; Type: TABLE; Schema: clean; Owner: darwin2
--

CREATE TABLE clean.wood_biology2022_coordinates (
    unitid character varying,
    latitude_decimal character varying,
    longitude_decimal character varying,
    longitude_text character varying,
    latitude_text character varying
);


ALTER TABLE clean.wood_biology2022_coordinates OWNER TO darwin2;

--
-- TOC entry 544 (class 1259 OID 1881175)
-- Name: wood_biology2022_ctrltaxa; Type: TABLE; Schema: clean; Owner: darwin2
--

CREATE TABLE clean.wood_biology2022_ctrltaxa (
    tw character varying,
    taxon character varying
);


ALTER TABLE clean.wood_biology2022_ctrltaxa OWNER TO darwin2;

--
-- TOC entry 259 (class 1259 OID 19074)
-- Name: bibliography; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.bibliography (
    id integer NOT NULL,
    title character varying NOT NULL,
    title_indexed character varying NOT NULL,
    type character varying NOT NULL,
    abstract character varying DEFAULT ''::character varying NOT NULL,
    year integer,
    reference character varying,
    doi character varying
);


ALTER TABLE darwin2.bibliography OWNER TO darwin2;

--
-- TOC entry 6802 (class 0 OID 0)
-- Dependencies: 259
-- Name: TABLE bibliography; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.bibliography IS 'List of expeditions made to collect specimens';


--
-- TOC entry 6803 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN bibliography.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.id IS 'Unique identifier';


--
-- TOC entry 6804 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN bibliography.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.title IS 'bibliography title';


--
-- TOC entry 6805 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN bibliography.title_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.title_indexed IS 'Indexed form of title';


--
-- TOC entry 6806 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN bibliography.type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.type IS 'bibliography type : article, book, booklet';


--
-- TOC entry 6807 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN bibliography.abstract; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.abstract IS 'optional abstract of the bibliography';


--
-- TOC entry 6808 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN bibliography.year; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.year IS 'The year of publication (or, if unpublished, the year of creation)';


--
-- TOC entry 260 (class 1259 OID 19081)
-- Name: bibliography_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.bibliography_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.bibliography_id_seq OWNER TO darwin2;

--
-- TOC entry 6809 (class 0 OID 0)
-- Dependencies: 260
-- Name: bibliography_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.bibliography_id_seq OWNED BY darwin2.bibliography.id;


--
-- TOC entry 261 (class 1259 OID 19083)
-- Name: template_table_record_ref; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_table_record_ref (
    referenced_relation character varying NOT NULL,
    record_id integer NOT NULL
);


ALTER TABLE darwin2.template_table_record_ref OWNER TO darwin2;

--
-- TOC entry 6810 (class 0 OID 0)
-- Dependencies: 261
-- Name: TABLE template_table_record_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_table_record_ref IS 'Template called to add referenced_relation and record_id fields';


--
-- TOC entry 6811 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN template_table_record_ref.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_table_record_ref.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 6812 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN template_table_record_ref.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_table_record_ref.record_id IS 'Id of record concerned';


--
-- TOC entry 262 (class 1259 OID 19089)
-- Name: catalogue_bibliography; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.catalogue_bibliography (
    id integer NOT NULL,
    bibliography_ref integer NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.catalogue_bibliography OWNER TO darwin2;

--
-- TOC entry 6813 (class 0 OID 0)
-- Dependencies: 262
-- Name: TABLE catalogue_bibliography; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.catalogue_bibliography IS 'List of people of catalogues units - Taxonomy, Chronostratigraphy,...';


--
-- TOC entry 6814 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN catalogue_bibliography.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_bibliography.referenced_relation IS 'Identifier-Name of table the units come from';


--
-- TOC entry 6815 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN catalogue_bibliography.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_bibliography.record_id IS 'Identifier of record concerned in table concerned';


--
-- TOC entry 6816 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN catalogue_bibliography.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_bibliography.id IS 'Unique identifier of record';


--
-- TOC entry 6817 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN catalogue_bibliography.bibliography_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_bibliography.bibliography_ref IS 'Reference of the biblio concerned - id field of people table';


--
-- TOC entry 263 (class 1259 OID 19095)
-- Name: catalogue_bibliography_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.catalogue_bibliography_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.catalogue_bibliography_id_seq OWNER TO darwin2;

--
-- TOC entry 6818 (class 0 OID 0)
-- Dependencies: 263
-- Name: catalogue_bibliography_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.catalogue_bibliography_id_seq OWNED BY darwin2.catalogue_bibliography.id;


--
-- TOC entry 264 (class 1259 OID 19097)
-- Name: catalogue_levels_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.catalogue_levels_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.catalogue_levels_id_seq OWNER TO darwin2;

--
-- TOC entry 6819 (class 0 OID 0)
-- Dependencies: 264
-- Name: catalogue_levels_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.catalogue_levels_id_seq OWNED BY darwin2.catalogue_levels.id;


--
-- TOC entry 265 (class 1259 OID 19099)
-- Name: catalogue_people; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.catalogue_people (
    id integer NOT NULL,
    people_type character varying DEFAULT 'author'::character varying NOT NULL,
    people_sub_type character varying DEFAULT ''::character varying NOT NULL,
    order_by integer DEFAULT 1 NOT NULL,
    people_ref integer NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.catalogue_people OWNER TO darwin2;

--
-- TOC entry 6820 (class 0 OID 0)
-- Dependencies: 265
-- Name: TABLE catalogue_people; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.catalogue_people IS 'List of people of catalogues units - Taxonomy, Chronostratigraphy,...';


--
-- TOC entry 6821 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN catalogue_people.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.referenced_relation IS 'Identifier-Name of table the units come from';


--
-- TOC entry 6822 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN catalogue_people.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.record_id IS 'Identifier of record concerned in table concerned';


--
-- TOC entry 6823 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN catalogue_people.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.id IS 'Unique identifier of record';


--
-- TOC entry 6824 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN catalogue_people.people_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.people_type IS 'Type of "people" associated to the catalogue unit: authors, collectors, defined,  ...';


--
-- TOC entry 6825 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN catalogue_people.people_sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.people_sub_type IS 'Type of "people" associated to the catalogue unit: Main author, corrector, taking the sense from,...';


--
-- TOC entry 6826 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN catalogue_people.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.order_by IS 'Integer used to order the persons in a list';


--
-- TOC entry 6827 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN catalogue_people.people_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.people_ref IS 'Reference of person concerned - id field of people table';


--
-- TOC entry 266 (class 1259 OID 19108)
-- Name: catalogue_people_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.catalogue_people_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.catalogue_people_id_seq OWNER TO darwin2;

--
-- TOC entry 6828 (class 0 OID 0)
-- Dependencies: 266
-- Name: catalogue_people_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.catalogue_people_id_seq OWNED BY darwin2.catalogue_people.id;


--
-- TOC entry 267 (class 1259 OID 19110)
-- Name: catalogue_relationships; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.catalogue_relationships (
    id integer NOT NULL,
    referenced_relation character varying NOT NULL,
    record_id_1 integer NOT NULL,
    record_id_2 integer NOT NULL,
    relationship_type character varying DEFAULT 'recombined from'::character varying NOT NULL,
    CONSTRAINT chk_not_related_to_self CHECK ((record_id_1 <> record_id_2))
);


ALTER TABLE darwin2.catalogue_relationships OWNER TO darwin2;

--
-- TOC entry 6829 (class 0 OID 0)
-- Dependencies: 267
-- Name: TABLE catalogue_relationships; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.catalogue_relationships IS 'Stores the relationships between records of a table - current name, original combination, ...';


--
-- TOC entry 6830 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN catalogue_relationships.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_relationships.referenced_relation IS 'Reference of the table a relationship is defined for';


--
-- TOC entry 6831 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN catalogue_relationships.record_id_1; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_relationships.record_id_1 IS 'Identifier of record in relation with an other one (record_id_2)';


--
-- TOC entry 6832 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN catalogue_relationships.record_id_2; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_relationships.record_id_2 IS 'Identifier of record in relation with an other one (record_id_1)';


--
-- TOC entry 6833 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN catalogue_relationships.relationship_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_relationships.relationship_type IS 'Type of relation between record 1 and record 2 - current name, original combination, ...';


--
-- TOC entry 268 (class 1259 OID 19118)
-- Name: catalogue_relationships_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.catalogue_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.catalogue_relationships_id_seq OWNER TO darwin2;

--
-- TOC entry 6834 (class 0 OID 0)
-- Dependencies: 268
-- Name: catalogue_relationships_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.catalogue_relationships_id_seq OWNED BY darwin2.catalogue_relationships.id;


--
-- TOC entry 269 (class 1259 OID 19120)
-- Name: check_dates_danny; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.check_dates_danny (
    unitid character varying,
    accessionnumber character varying,
    acquisitiontype character varying,
    acquiredfrom character varying,
    acquisitionday character varying,
    acquisitionmonth character varying,
    acquisitionyear character varying,
    collectedby character varying,
    collectionstartday character varying,
    collectionstartmonth character varying,
    collectionstartyear character varying,
    collectionendday character varying,
    collectionendmonth character varying,
    collectionendyear character varying
);


ALTER TABLE darwin2.check_dates_danny OWNER TO darwin2;

--
-- TOC entry 270 (class 1259 OID 19126)
-- Name: chronostratigraphy; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.chronostratigraphy (
    id integer NOT NULL,
    lower_bound numeric(10,3),
    upper_bound numeric(10,3),
    CONSTRAINT fct_chk_onceinpath_chronostratigraphy CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.chronostratigraphy OWNER TO darwin2;

--
-- TOC entry 6835 (class 0 OID 0)
-- Dependencies: 270
-- Name: TABLE chronostratigraphy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.chronostratigraphy IS 'List of chronostratigraphic units';


--
-- TOC entry 6836 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN chronostratigraphy.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.name IS 'Classification unit name';


--
-- TOC entry 6837 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN chronostratigraphy.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 6838 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN chronostratigraphy.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 6839 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN chronostratigraphy.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 6840 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN chronostratigraphy.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 6841 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN chronostratigraphy.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 6842 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN chronostratigraphy.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 6843 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN chronostratigraphy.lower_bound; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.lower_bound IS 'Lower age boundary in years';


--
-- TOC entry 6844 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN chronostratigraphy.upper_bound; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.upper_bound IS 'Upper age boundary in years';


--
-- TOC entry 271 (class 1259 OID 19136)
-- Name: chronostratigraphy_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.chronostratigraphy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.chronostratigraphy_id_seq OWNER TO darwin2;

--
-- TOC entry 6845 (class 0 OID 0)
-- Dependencies: 271
-- Name: chronostratigraphy_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.chronostratigraphy_id_seq OWNED BY darwin2.chronostratigraphy.id;


--
-- TOC entry 272 (class 1259 OID 19138)
-- Name: classification_keywords; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.classification_keywords (
    id integer NOT NULL,
    keyword_type character varying DEFAULT 'name'::character varying NOT NULL,
    keyword character varying NOT NULL,
    keyword_indexed character varying NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.classification_keywords OWNER TO darwin2;

--
-- TOC entry 6846 (class 0 OID 0)
-- Dependencies: 272
-- Name: TABLE classification_keywords; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.classification_keywords IS 'Help user to tag-label each part of full name in classifications';


--
-- TOC entry 6847 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN classification_keywords.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_keywords.referenced_relation IS 'Name of classifification table: taxonomy, lithology,...';


--
-- TOC entry 6848 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN classification_keywords.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_keywords.record_id IS 'Id of record concerned';


--
-- TOC entry 6849 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN classification_keywords.keyword_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_keywords.keyword_type IS 'Keyword type: name, year, authoritative keyword,...';


--
-- TOC entry 6850 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN classification_keywords.keyword; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_keywords.keyword IS 'Keyword';


--
-- TOC entry 273 (class 1259 OID 19145)
-- Name: classification_keywords_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.classification_keywords_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.classification_keywords_id_seq OWNER TO darwin2;

--
-- TOC entry 6851 (class 0 OID 0)
-- Dependencies: 273
-- Name: classification_keywords_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.classification_keywords_id_seq OWNED BY darwin2.classification_keywords.id;


--
-- TOC entry 274 (class 1259 OID 19147)
-- Name: classification_synonymies; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.classification_synonymies (
    id integer NOT NULL,
    group_id integer NOT NULL,
    group_name character varying NOT NULL,
    is_basionym boolean DEFAULT false,
    order_by integer DEFAULT 0 NOT NULL,
    synonym_record_id integer,
    original_synonym boolean
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.classification_synonymies OWNER TO darwin2;

--
-- TOC entry 6852 (class 0 OID 0)
-- Dependencies: 274
-- Name: TABLE classification_synonymies; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.classification_synonymies IS 'Table containing classification synonymies';


--
-- TOC entry 6853 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN classification_synonymies.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.referenced_relation IS 'Classification table concerned';


--
-- TOC entry 6854 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN classification_synonymies.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.record_id IS 'Id of record placed in group as a synonym';


--
-- TOC entry 6855 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN classification_synonymies.group_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.group_id IS 'Id given to group';


--
-- TOC entry 6856 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN classification_synonymies.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.group_name IS 'Name of group under which synonyms are placed';


--
-- TOC entry 6857 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN classification_synonymies.is_basionym; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.is_basionym IS 'If record is a basionym';


--
-- TOC entry 6858 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN classification_synonymies.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.order_by IS 'Order by used to qualify order amongst synonyms - used mainly for senio and junior synonyms';


--
-- TOC entry 275 (class 1259 OID 19155)
-- Name: classification_synonymies_group_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.classification_synonymies_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.classification_synonymies_group_id_seq OWNER TO darwin2;

--
-- TOC entry 276 (class 1259 OID 19157)
-- Name: classification_synonymies_history; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.classification_synonymies_history (
    id integer NOT NULL,
    group_id integer NOT NULL,
    group_name character varying NOT NULL,
    is_basionym boolean DEFAULT false,
    order_by integer DEFAULT 0 NOT NULL,
    synonym_record_id integer,
    modification_date_time timestamp without time zone,
    user_name character varying,
    taxon_name character varying,
    action character varying
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.classification_synonymies_history OWNER TO darwin2;

--
-- TOC entry 277 (class 1259 OID 19165)
-- Name: classification_synonymies_history_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.classification_synonymies_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.classification_synonymies_history_id_seq OWNER TO darwin2;

--
-- TOC entry 6859 (class 0 OID 0)
-- Dependencies: 277
-- Name: classification_synonymies_history_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.classification_synonymies_history_id_seq OWNED BY darwin2.classification_synonymies_history.id;


--
-- TOC entry 278 (class 1259 OID 19167)
-- Name: classification_synonymies_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.classification_synonymies_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.classification_synonymies_id_seq OWNER TO darwin2;

--
-- TOC entry 6860 (class 0 OID 0)
-- Dependencies: 278
-- Name: classification_synonymies_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.classification_synonymies_id_seq OWNED BY darwin2.classification_synonymies.id;


--
-- TOC entry 279 (class 1259 OID 19169)
-- Name: codes; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.codes (
    id integer NOT NULL,
    code_category character varying DEFAULT 'main'::character varying NOT NULL,
    code_prefix character varying,
    code_prefix_separator character varying,
    code character varying,
    code_suffix character varying,
    code_suffix_separator character varying,
    full_code_indexed character varying NOT NULL,
    code_date timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone NOT NULL,
    code_date_mask integer DEFAULT 0 NOT NULL,
    code_num integer DEFAULT 0,
    code_num_bigint bigint
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.codes OWNER TO darwin2;

--
-- TOC entry 6861 (class 0 OID 0)
-- Dependencies: 279
-- Name: TABLE codes; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.codes IS 'Template used to construct the specimen codes tables';


--
-- TOC entry 6862 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.referenced_relation IS 'Reference name of table concerned';


--
-- TOC entry 6863 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.record_id IS 'Identifier of record concerned';


--
-- TOC entry 6864 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.id IS 'Unique identifier of a code';


--
-- TOC entry 6865 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.code_category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_category IS 'Category of code: main, secondary, temporary,...';


--
-- TOC entry 6866 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.code_prefix; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_prefix IS 'Code prefix - entire code if all alpha, begining character part if code is made of characters and numeric parts';


--
-- TOC entry 6867 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.code_prefix_separator; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_prefix_separator IS 'Separtor used between code core and code prefix';


--
-- TOC entry 6868 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code IS 'Numerical part of code - but not forced: if users want to use it as alphanumerical code - possible too';


--
-- TOC entry 6869 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.code_suffix; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_suffix IS 'For codes made of characters and numerical parts, this field stores the last alpha part of code';


--
-- TOC entry 6870 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.code_suffix_separator; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_suffix_separator IS 'Separtor used between code core and code suffix';


--
-- TOC entry 6871 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.full_code_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.full_code_indexed IS 'Full code composition by code_prefix, code and code suffix concatenation and indexed for unique check purpose';


--
-- TOC entry 6872 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.code_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_date IS 'Date of code creation (fuzzy date)';


--
-- TOC entry 6873 (class 0 OID 0)
-- Dependencies: 279
-- Name: COLUMN codes.code_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_date_mask IS 'Mask used for code date';


--
-- TOC entry 280 (class 1259 OID 19179)
-- Name: codes_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.codes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.codes_id_seq OWNER TO darwin2;

--
-- TOC entry 6874 (class 0 OID 0)
-- Dependencies: 280
-- Name: codes_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.codes_id_seq OWNED BY darwin2.codes.id;


--
-- TOC entry 281 (class 1259 OID 19181)
-- Name: codes_tmp_duplicates; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.codes_tmp_duplicates (
    full_code_indexed character varying
);


ALTER TABLE darwin2.codes_tmp_duplicates OWNER TO darwin2;

--
-- TOC entry 282 (class 1259 OID 19187)
-- Name: collecting_methods; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collecting_methods (
    id integer NOT NULL,
    method character varying NOT NULL,
    method_indexed character varying NOT NULL,
    CONSTRAINT chk_collecting_methods_method CHECK (((method)::text <> ''::text))
);


ALTER TABLE darwin2.collecting_methods OWNER TO darwin2;

--
-- TOC entry 6875 (class 0 OID 0)
-- Dependencies: 282
-- Name: TABLE collecting_methods; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collecting_methods IS 'List of all available collecting methods';


--
-- TOC entry 6876 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN collecting_methods.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_methods.id IS 'Unique identifier of a collecting method';


--
-- TOC entry 6877 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN collecting_methods.method; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_methods.method IS 'Method used';


--
-- TOC entry 6878 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN collecting_methods.method_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_methods.method_indexed IS 'Indexed form of method used - for ordering and filtering purposes';


--
-- TOC entry 283 (class 1259 OID 19194)
-- Name: collecting_methods_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collecting_methods_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collecting_methods_id_seq OWNER TO darwin2;

--
-- TOC entry 6879 (class 0 OID 0)
-- Dependencies: 283
-- Name: collecting_methods_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.collecting_methods_id_seq OWNED BY darwin2.collecting_methods.id;


--
-- TOC entry 284 (class 1259 OID 19196)
-- Name: collecting_tools; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collecting_tools (
    id integer NOT NULL,
    tool character varying NOT NULL,
    tool_indexed character varying NOT NULL,
    CONSTRAINT chk_collecting_tools_tool CHECK (((tool)::text <> ''::text))
);


ALTER TABLE darwin2.collecting_tools OWNER TO darwin2;

--
-- TOC entry 6880 (class 0 OID 0)
-- Dependencies: 284
-- Name: TABLE collecting_tools; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collecting_tools IS 'List of all available collecting tools';


--
-- TOC entry 6881 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN collecting_tools.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_tools.id IS 'Unique identifier of a collecting tool';


--
-- TOC entry 6882 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN collecting_tools.tool; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_tools.tool IS 'Tool used';


--
-- TOC entry 6883 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN collecting_tools.tool_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_tools.tool_indexed IS 'Indexed form of tool used - for ordering and filtering purposes';


--
-- TOC entry 285 (class 1259 OID 19203)
-- Name: collecting_tools_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collecting_tools_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collecting_tools_id_seq OWNER TO darwin2;

--
-- TOC entry 6884 (class 0 OID 0)
-- Dependencies: 285
-- Name: collecting_tools_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.collecting_tools_id_seq OWNED BY darwin2.collecting_tools.id;


--
-- TOC entry 286 (class 1259 OID 19205)
-- Name: collection_maintenance; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collection_maintenance (
    id integer NOT NULL,
    people_ref integer,
    category character varying DEFAULT 'action'::character varying NOT NULL,
    action_observation character varying NOT NULL,
    description character varying,
    description_indexed text,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    modification_date_mask integer DEFAULT 0 NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.collection_maintenance OWNER TO darwin2;

--
-- TOC entry 6885 (class 0 OID 0)
-- Dependencies: 286
-- Name: TABLE collection_maintenance; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collection_maintenance IS 'History of specimen maintenance';


--
-- TOC entry 6886 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN collection_maintenance.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.referenced_relation IS 'Reference of table a maintenance entry has been created for';


--
-- TOC entry 6887 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN collection_maintenance.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.record_id IS 'ID of record a maintenance entry has been created for';


--
-- TOC entry 6888 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN collection_maintenance.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.id IS 'Unique identifier of a specimen maintenance';


--
-- TOC entry 6889 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN collection_maintenance.people_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.people_ref IS 'Reference of person having done an action or an observation';


--
-- TOC entry 6890 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN collection_maintenance.category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.category IS 'Action or Observation';


--
-- TOC entry 6891 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN collection_maintenance.action_observation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.action_observation IS 'Action or observation done';


--
-- TOC entry 6892 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN collection_maintenance.description; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.description IS 'Complementary description';


--
-- TOC entry 6893 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN collection_maintenance.description_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.description_indexed IS 'indexed form of description field';


--
-- TOC entry 6894 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN collection_maintenance.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.modification_date_time IS 'Last update date/time';


--
-- TOC entry 287 (class 1259 OID 19214)
-- Name: collection_maintenance_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collection_maintenance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collection_maintenance_id_seq OWNER TO darwin2;

--
-- TOC entry 6895 (class 0 OID 0)
-- Dependencies: 287
-- Name: collection_maintenance_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.collection_maintenance_id_seq OWNED BY darwin2.collection_maintenance.id;


--
-- TOC entry 288 (class 1259 OID 19216)
-- Name: collections; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collections (
    id integer NOT NULL,
    collection_type character varying DEFAULT 'mix'::character varying NOT NULL,
    code character varying NOT NULL,
    name character varying NOT NULL,
    name_indexed character varying NOT NULL,
    institution_ref integer NOT NULL,
    main_manager_ref integer NOT NULL,
    staff_ref integer,
    parent_ref integer,
    path character varying NOT NULL,
    code_auto_increment boolean DEFAULT false NOT NULL,
    code_last_value integer DEFAULT 0 NOT NULL,
    code_prefix character varying,
    code_prefix_separator character varying,
    code_suffix character varying,
    code_suffix_separator character varying,
    code_specimen_duplicate boolean DEFAULT false NOT NULL,
    is_public boolean DEFAULT true NOT NULL,
    code_mask character varying,
    loan_auto_increment boolean DEFAULT true NOT NULL,
    loan_last_value integer DEFAULT 0 NOT NULL,
    code_ai_inherit boolean DEFAULT false,
    code_auto_increment_for_insert_only boolean DEFAULT true NOT NULL,
    nagoya character varying DEFAULT 'Not defined'::character varying,
    allow_duplicates boolean,
    CONSTRAINT chk_main_manager_ref CHECK ((main_manager_ref > 0)),
    CONSTRAINT fct_chk_onceinpath_collections CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
);


ALTER TABLE darwin2.collections OWNER TO darwin2;

--
-- TOC entry 6896 (class 0 OID 0)
-- Dependencies: 288
-- Name: TABLE collections; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collections IS 'List of all collections encoded in DaRWIN 2';


--
-- TOC entry 6897 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.id IS 'Unique identifier of a collection';


--
-- TOC entry 6898 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.collection_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.collection_type IS 'Type of collection: physical for a collection of only physical objects, observations for a collection of only observations, mix for any kind of entry catalogued in collection';


--
-- TOC entry 6899 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code IS 'Code given to collection';


--
-- TOC entry 6900 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.name IS 'Collection name';


--
-- TOC entry 6901 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.name_indexed IS 'Collection name indexed';


--
-- TOC entry 6902 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.institution_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.institution_ref IS 'Reference of institution current collection belongs to - id field of people table';


--
-- TOC entry 6903 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.main_manager_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.main_manager_ref IS 'Reference of collection main manager - id field of users table';


--
-- TOC entry 6904 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.staff_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.staff_ref IS 'Reference of staff member, scientist responsible - id field of users table';


--
-- TOC entry 6905 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.parent_ref IS 'Recursive reference to collection table itself to represent collection parenty/hierarchy';


--
-- TOC entry 6906 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.path IS 'Descriptive path for collection hierarchy, each level separated by a /';


--
-- TOC entry 6907 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code_auto_increment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_auto_increment IS 'Flag telling if the numerical part of a code has to be incremented or not';


--
-- TOC entry 6908 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code_last_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_last_value IS 'Value of the last numeric code given in this collection when auto increment is/was activated';


--
-- TOC entry 6909 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code_prefix; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_prefix IS 'Default code prefix to be used for specimens encoded in this collection';


--
-- TOC entry 6910 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code_prefix_separator; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_prefix_separator IS 'Character chain used to separate code prefix from code core';


--
-- TOC entry 6911 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code_suffix; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_suffix IS 'Default code suffix to be used for specimens encoded in this collection';


--
-- TOC entry 6912 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code_suffix_separator; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_suffix_separator IS 'Character chain used to separate code suffix from code core';


--
-- TOC entry 6913 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code_specimen_duplicate; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_specimen_duplicate IS 'Flag telling if the whole specimen code has to be copied when you do a duplicate';


--
-- TOC entry 6914 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.is_public; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.is_public IS 'Flag telling if the collection can be found in the public search';


--
-- TOC entry 6915 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code_ai_inherit; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_ai_inherit IS 'jm herpers 2017 11 08';


--
-- TOC entry 6916 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN collections.code_auto_increment_for_insert_only; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_auto_increment_for_insert_only IS 'Flag telling if the autoincremented code insertion has to be done only after insertion of specimens or also after updates of specimens';


--
-- TOC entry 289 (class 1259 OID 19234)
-- Name: collections_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collections_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collections_id_seq OWNER TO darwin2;

--
-- TOC entry 6917 (class 0 OID 0)
-- Dependencies: 289
-- Name: collections_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.collections_id_seq OWNED BY darwin2.collections.id;


--
-- TOC entry 290 (class 1259 OID 19236)
-- Name: collections_rights; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collections_rights (
    id integer NOT NULL,
    db_user_type smallint DEFAULT 1 NOT NULL,
    collection_ref integer DEFAULT 0 NOT NULL,
    user_ref integer DEFAULT 0 NOT NULL
);


ALTER TABLE darwin2.collections_rights OWNER TO darwin2;

--
-- TOC entry 6918 (class 0 OID 0)
-- Dependencies: 290
-- Name: TABLE collections_rights; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collections_rights IS 'List of rights of given users on given collections';


--
-- TOC entry 6919 (class 0 OID 0)
-- Dependencies: 290
-- Name: COLUMN collections_rights.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections_rights.id IS 'Unique identifier for collection rights';


--
-- TOC entry 6920 (class 0 OID 0)
-- Dependencies: 290
-- Name: COLUMN collections_rights.db_user_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections_rights.db_user_type IS 'Integer is representing a role: 1 for registered user, 2 for encoder, 4 for collection manager, 8 for system admin,...';


--
-- TOC entry 6921 (class 0 OID 0)
-- Dependencies: 290
-- Name: COLUMN collections_rights.collection_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections_rights.collection_ref IS 'Reference of collection concerned - id field of collections table';


--
-- TOC entry 6922 (class 0 OID 0)
-- Dependencies: 290
-- Name: COLUMN collections_rights.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections_rights.user_ref IS 'Reference of user - id field of users table';


--
-- TOC entry 291 (class 1259 OID 19242)
-- Name: collections_rights_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collections_rights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collections_rights_id_seq OWNER TO darwin2;

--
-- TOC entry 6923 (class 0 OID 0)
-- Dependencies: 291
-- Name: collections_rights_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.collections_rights_id_seq OWNED BY darwin2.collections_rights.id;


--
-- TOC entry 292 (class 1259 OID 19244)
-- Name: comments; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.comments (
    id integer NOT NULL,
    notion_concerned character varying NOT NULL,
    comment text NOT NULL,
    comment_indexed text NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.comments OWNER TO darwin2;

--
-- TOC entry 6924 (class 0 OID 0)
-- Dependencies: 292
-- Name: TABLE comments; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.comments IS 'Comments associated to a record of a given table (and maybe a given field) on a given subject';


--
-- TOC entry 6925 (class 0 OID 0)
-- Dependencies: 292
-- Name: COLUMN comments.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.referenced_relation IS 'Reference-Name of table a comment is posted for';


--
-- TOC entry 6926 (class 0 OID 0)
-- Dependencies: 292
-- Name: COLUMN comments.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.record_id IS 'Identifier of the record concerned';


--
-- TOC entry 6927 (class 0 OID 0)
-- Dependencies: 292
-- Name: COLUMN comments.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.id IS 'Unique identifier of a comment';


--
-- TOC entry 6928 (class 0 OID 0)
-- Dependencies: 292
-- Name: COLUMN comments.notion_concerned; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.notion_concerned IS 'Notion concerned by comment';


--
-- TOC entry 6929 (class 0 OID 0)
-- Dependencies: 292
-- Name: COLUMN comments.comment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.comment IS 'Comment';


--
-- TOC entry 6930 (class 0 OID 0)
-- Dependencies: 292
-- Name: COLUMN comments.comment_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.comment_indexed IS 'indexed form of comment field';


--
-- TOC entry 293 (class 1259 OID 19250)
-- Name: comments_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.comments_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.comments_id_seq OWNER TO darwin2;

--
-- TOC entry 6931 (class 0 OID 0)
-- Dependencies: 293
-- Name: comments_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.comments_id_seq OWNED BY darwin2.comments.id;


--
-- TOC entry 294 (class 1259 OID 19252)
-- Name: db_version; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.db_version (
    id integer NOT NULL,
    update_at timestamp without time zone DEFAULT now()
);


ALTER TABLE darwin2.db_version OWNER TO darwin2;

--
-- TOC entry 6932 (class 0 OID 0)
-- Dependencies: 294
-- Name: TABLE db_version; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.db_version IS 'Table holding the database version and update date';


--
-- TOC entry 534 (class 1259 OID 1757568)
-- Name: dissco_continents_to_countries; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.dissco_continents_to_countries (
    continent character varying,
    country_in_darwin character varying
);


ALTER TABLE darwin2.dissco_continents_to_countries OWNER TO darwin2;

--
-- TOC entry 295 (class 1259 OID 19256)
-- Name: domain_name; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.domain_name (
    fulltoindex character varying
);


ALTER TABLE darwin2.domain_name OWNER TO darwin2;

--
-- TOC entry 296 (class 1259 OID 19262)
-- Name: expeditions; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.expeditions (
    id integer NOT NULL,
    name character varying NOT NULL,
    name_indexed character varying NOT NULL,
    expedition_from_date_mask integer DEFAULT 0 NOT NULL,
    expedition_from_date date DEFAULT '0001-01-01'::date NOT NULL,
    expedition_to_date_mask integer DEFAULT 0 NOT NULL,
    expedition_to_date date DEFAULT '2038-12-31'::date NOT NULL
);


ALTER TABLE darwin2.expeditions OWNER TO darwin2;

--
-- TOC entry 6933 (class 0 OID 0)
-- Dependencies: 296
-- Name: TABLE expeditions; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.expeditions IS 'List of expeditions made to collect specimens';


--
-- TOC entry 6934 (class 0 OID 0)
-- Dependencies: 296
-- Name: COLUMN expeditions.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.id IS 'Unique identifier of an expedition';


--
-- TOC entry 6935 (class 0 OID 0)
-- Dependencies: 296
-- Name: COLUMN expeditions.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.name IS 'Expedition name';


--
-- TOC entry 6936 (class 0 OID 0)
-- Dependencies: 296
-- Name: COLUMN expeditions.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.name_indexed IS 'Indexed form of expedition name';


--
-- TOC entry 6937 (class 0 OID 0)
-- Dependencies: 296
-- Name: COLUMN expeditions.expedition_from_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.expedition_from_date_mask IS 'Contains the Mask flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6938 (class 0 OID 0)
-- Dependencies: 296
-- Name: COLUMN expeditions.expedition_from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.expedition_from_date IS 'Start date of the expedition';


--
-- TOC entry 6939 (class 0 OID 0)
-- Dependencies: 296
-- Name: COLUMN expeditions.expedition_to_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.expedition_to_date_mask IS 'Contains the Mask flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6940 (class 0 OID 0)
-- Dependencies: 296
-- Name: COLUMN expeditions.expedition_to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.expedition_to_date IS 'End date of the expedition';


--
-- TOC entry 297 (class 1259 OID 19272)
-- Name: expeditions_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.expeditions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.expeditions_id_seq OWNER TO darwin2;

--
-- TOC entry 6941 (class 0 OID 0)
-- Dependencies: 297
-- Name: expeditions_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.expeditions_id_seq OWNED BY darwin2.expeditions.id;


--
-- TOC entry 298 (class 1259 OID 19274)
-- Name: ext_links; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.ext_links (
    id integer NOT NULL,
    url character varying NOT NULL,
    comment text,
    comment_indexed text,
    category character varying,
    contributor character varying,
    disclaimer character varying,
    license character varying,
    display_order integer
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.ext_links OWNER TO darwin2;

--
-- TOC entry 6942 (class 0 OID 0)
-- Dependencies: 298
-- Name: TABLE ext_links; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.ext_links IS 'External link possibly refereced for a specific relation';


--
-- TOC entry 6943 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN ext_links.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.referenced_relation IS 'Reference-Name of table a comment is posted for';


--
-- TOC entry 6944 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN ext_links.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.record_id IS 'Identifier of the record concerned';


--
-- TOC entry 6945 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN ext_links.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.id IS 'Unique identifier of a comment';


--
-- TOC entry 6946 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN ext_links.url; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.url IS 'External URL';


--
-- TOC entry 6947 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN ext_links.comment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.comment IS 'Comment';


--
-- TOC entry 6948 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN ext_links.comment_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.comment_indexed IS 'indexed form of comment field';


--
-- TOC entry 299 (class 1259 OID 19280)
-- Name: ext_links_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.ext_links_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.ext_links_id_seq OWNER TO darwin2;

--
-- TOC entry 6949 (class 0 OID 0)
-- Dependencies: 299
-- Name: ext_links_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.ext_links_id_seq OWNED BY darwin2.ext_links.id;


--
-- TOC entry 519 (class 1259 OID 1416645)
-- Name: fix_date_kin_feb2022; Type: TABLE; Schema: darwin2; Owner: postgres
--

CREATE TABLE darwin2.fix_date_kin_feb2022 (
    num character varying NOT NULL,
    identificationyear character varying,
    secondary_code character varying,
    coll_day_begin character varying,
    coll_month_begin character varying,
    coll_year_begin character varying,
    coll_day_end character varying,
    coll_month_end character varying,
    coll_year_end character varying
);


ALTER TABLE darwin2.fix_date_kin_feb2022 OWNER TO postgres;

--
-- TOC entry 300 (class 1259 OID 19282)
-- Name: flat_dict; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.flat_dict (
    id integer NOT NULL,
    referenced_relation character varying NOT NULL,
    dict_field character varying NOT NULL,
    dict_value character varying NOT NULL,
    dict_depend character varying DEFAULT ''::character varying NOT NULL
);


ALTER TABLE darwin2.flat_dict OWNER TO darwin2;

--
-- TOC entry 6951 (class 0 OID 0)
-- Dependencies: 300
-- Name: TABLE flat_dict; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.flat_dict IS 'Flat table compiling all small distinct values for a faster search like types, code prefixes ,...';


--
-- TOC entry 6952 (class 0 OID 0)
-- Dependencies: 300
-- Name: COLUMN flat_dict.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.flat_dict.referenced_relation IS 'The table where the value come from';


--
-- TOC entry 6953 (class 0 OID 0)
-- Dependencies: 300
-- Name: COLUMN flat_dict.dict_field; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.flat_dict.dict_field IS 'the field name of where the value come from';


--
-- TOC entry 6954 (class 0 OID 0)
-- Dependencies: 300
-- Name: COLUMN flat_dict.dict_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.flat_dict.dict_value IS 'the distinct value';


--
-- TOC entry 301 (class 1259 OID 19289)
-- Name: flat_dict_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.flat_dict_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.flat_dict_id_seq OWNER TO darwin2;

--
-- TOC entry 6955 (class 0 OID 0)
-- Dependencies: 301
-- Name: flat_dict_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.flat_dict_id_seq OWNED BY darwin2.flat_dict.id;


--
-- TOC entry 302 (class 1259 OID 19291)
-- Name: gtu; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.gtu (
    id integer NOT NULL,
    code character varying DEFAULT ''::character varying NOT NULL,
    gtu_from_date_mask integer DEFAULT 0,
    gtu_from_date timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone,
    gtu_to_date_mask integer DEFAULT 0,
    gtu_to_date timestamp without time zone DEFAULT '2038-12-31 00:00:00'::timestamp without time zone,
    tag_values_indexed character varying[],
    latitude double precision,
    longitude double precision,
    lat_long_accuracy double precision,
    location point,
    elevation double precision,
    elevation_accuracy double precision,
    latitude_dms_degree integer,
    latitude_dms_minutes double precision,
    latitude_dms_seconds double precision,
    latitude_dms_direction integer,
    longitude_dms_degree integer,
    longitude_dms_minutes double precision,
    longitude_dms_seconds double precision,
    longitude_dms_direction integer,
    latitude_utm double precision,
    longitude_utm double precision,
    utm_zone character varying,
    coordinates_source character varying,
    elevation_unit character varying(4),
    gtu_creation_date timestamp without time zone DEFAULT now(),
    import_ref integer,
    iso3166 character varying,
    iso3166_subdivision character varying,
    wkt_str character varying,
    nagoya character varying DEFAULT 'Not defined'::character varying,
    collection_ref integer,
    collector_refs integer[],
    expedition_refs integer[],
    geom public.geometry,
    expedition_ref integer,
    CONSTRAINT rmca_check_dms_lat_deg CHECK (((latitude_dms_degree IS NULL) OR ((coordinates_source)::text = 'ISSUE'::text) OR ((latitude_dms_degree >= '-90'::integer) AND (latitude_dms_degree <= 90)))),
    CONSTRAINT rmca_check_dms_lat_min CHECK (((latitude_dms_minutes IS NULL) OR ((coordinates_source)::text = 'ISSUE'::text) OR ((latitude_dms_minutes >= (0)::double precision) AND (latitude_dms_minutes <= (60)::double precision)))),
    CONSTRAINT rmca_check_dms_lat_sec CHECK (((latitude_dms_seconds IS NULL) OR ((coordinates_source)::text = 'ISSUE'::text) OR ((latitude_dms_seconds >= (0)::double precision) AND (latitude_dms_seconds <= (60)::double precision)))),
    CONSTRAINT rmca_check_dms_long_deg CHECK (((longitude_dms_degree IS NULL) OR ((coordinates_source)::text = 'ISSUE'::text) OR ((longitude_dms_degree >= '-90'::integer) AND (longitude_dms_degree <= 90)))),
    CONSTRAINT rmca_check_dms_long_min CHECK (((longitude_dms_minutes IS NULL) OR ((coordinates_source)::text = 'ISSUE'::text) OR ((longitude_dms_minutes >= (0)::double precision) AND (longitude_dms_minutes <= (60)::double precision)))),
    CONSTRAINT rmca_check_dms_long_sec CHECK (((longitude_dms_seconds IS NULL) OR ((coordinates_source)::text = 'ISSUE'::text) OR ((longitude_dms_seconds >= (0)::double precision) AND (longitude_dms_seconds <= (60)::double precision))))
);


ALTER TABLE darwin2.gtu OWNER TO darwin2;

--
-- TOC entry 6956 (class 0 OID 0)
-- Dependencies: 302
-- Name: TABLE gtu; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.gtu IS 'Location or sampling units - GeoTemporalUnits';


--
-- TOC entry 6957 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.id IS 'Unique identifier of a location or sampling unit';


--
-- TOC entry 6958 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.code IS 'Code given - for sampling units - takes id if none defined';


--
-- TOC entry 6959 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.gtu_from_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.gtu_from_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6960 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.gtu_from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.gtu_from_date IS 'composed from date of the GTU';


--
-- TOC entry 6961 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.gtu_to_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.gtu_to_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6962 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.gtu_to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.gtu_to_date IS 'composed to date of the GTU';


--
-- TOC entry 6963 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.tag_values_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.tag_values_indexed IS 'Array of all tags associated to gtu (indexed form)';


--
-- TOC entry 6964 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.latitude; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.latitude IS 'Latitude of the gtu';


--
-- TOC entry 6965 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.longitude; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.longitude IS 'longitude of the gtu';


--
-- TOC entry 6966 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.lat_long_accuracy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.lat_long_accuracy IS 'Accuracy in meter of both lat & long';


--
-- TOC entry 6967 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.elevation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.elevation IS 'Elevation from the level of the sea in meter';


--
-- TOC entry 6968 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN gtu.elevation_accuracy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.elevation_accuracy IS 'Accuracy in meter of the elevation';


--
-- TOC entry 303 (class 1259 OID 19310)
-- Name: gtu_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.gtu_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.gtu_id_seq OWNER TO darwin2;

--
-- TOC entry 6969 (class 0 OID 0)
-- Dependencies: 303
-- Name: gtu_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.gtu_id_seq OWNED BY darwin2.gtu.id;


--
-- TOC entry 304 (class 1259 OID 19312)
-- Name: identifications; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.identifications (
    id integer NOT NULL,
    notion_concerned character varying NOT NULL,
    notion_date timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone NOT NULL,
    notion_date_mask integer DEFAULT 0 NOT NULL,
    value_defined character varying,
    value_defined_indexed character varying NOT NULL,
    determination_status character varying,
    order_by integer DEFAULT 1 NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.identifications OWNER TO darwin2;

--
-- TOC entry 6970 (class 0 OID 0)
-- Dependencies: 304
-- Name: TABLE identifications; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.identifications IS 'History of identifications';


--
-- TOC entry 6971 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.referenced_relation IS 'Reference of table an identification is introduced for';


--
-- TOC entry 6972 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.record_id IS 'Id of record concerned by an identification entry';


--
-- TOC entry 6973 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.id IS 'Unique identifier of an identification';


--
-- TOC entry 6974 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.notion_concerned; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.notion_concerned IS 'Type of entry: Identification on a specific concern';


--
-- TOC entry 6975 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.notion_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.notion_date IS 'Date of identification or preparation';


--
-- TOC entry 6976 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.notion_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.notion_date_mask IS 'Date/Time mask used for identification date fuzzyness';


--
-- TOC entry 6977 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.value_defined; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.value_defined IS 'When making identification, stores the value resulting of this identification';


--
-- TOC entry 6978 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.value_defined_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.value_defined_indexed IS 'Indexed form of value_defined field';


--
-- TOC entry 6979 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.determination_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.determination_status IS 'Status of identification - can either be a percentage of certainty or a code describing the identification step in the process';


--
-- TOC entry 6980 (class 0 OID 0)
-- Dependencies: 304
-- Name: COLUMN identifications.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.order_by IS 'Integer used to order the identifications when no date entered';


--
-- TOC entry 305 (class 1259 OID 19321)
-- Name: identifications_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.identifications_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.identifications_id_seq OWNER TO darwin2;

--
-- TOC entry 6981 (class 0 OID 0)
-- Dependencies: 305
-- Name: identifications_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.identifications_id_seq OWNED BY darwin2.identifications.id;


--
-- TOC entry 306 (class 1259 OID 19323)
-- Name: identifiers; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.identifiers (
    id integer NOT NULL,
    protocol character varying,
    value character varying,
    creation_date timestamp with time zone DEFAULT now() NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.identifiers OWNER TO darwin2;

--
-- TOC entry 307 (class 1259 OID 19330)
-- Name: identifiers_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.identifiers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.identifiers_id_seq OWNER TO darwin2;

--
-- TOC entry 6983 (class 0 OID 0)
-- Dependencies: 307
-- Name: identifiers_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.identifiers_id_seq OWNED BY darwin2.identifiers.id;


--
-- TOC entry 308 (class 1259 OID 19332)
-- Name: igs; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.igs (
    id integer NOT NULL,
    ig_num character varying NOT NULL,
    ig_num_indexed character varying NOT NULL,
    ig_date_mask integer DEFAULT 0 NOT NULL,
    ig_date date DEFAULT '0001-01-01'::date NOT NULL
);


ALTER TABLE darwin2.igs OWNER TO darwin2;

--
-- TOC entry 6984 (class 0 OID 0)
-- Dependencies: 308
-- Name: TABLE igs; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.igs IS 'Inventory table - register all ig (inventory general) numbers given in RBINS';


--
-- TOC entry 6985 (class 0 OID 0)
-- Dependencies: 308
-- Name: COLUMN igs.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.igs.id IS 'Unique identifier of an ig reference';


--
-- TOC entry 6986 (class 0 OID 0)
-- Dependencies: 308
-- Name: COLUMN igs.ig_num; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.igs.ig_num IS 'IG number';


--
-- TOC entry 6987 (class 0 OID 0)
-- Dependencies: 308
-- Name: COLUMN igs.ig_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.igs.ig_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6988 (class 0 OID 0)
-- Dependencies: 308
-- Name: COLUMN igs.ig_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.igs.ig_date IS 'Date of ig number creation';


--
-- TOC entry 309 (class 1259 OID 19340)
-- Name: igs_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.igs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.igs_id_seq OWNER TO darwin2;

--
-- TOC entry 6989 (class 0 OID 0)
-- Dependencies: 309
-- Name: igs_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.igs_id_seq OWNED BY darwin2.igs.id;


--
-- TOC entry 310 (class 1259 OID 19342)
-- Name: import_fruitfly_drybarcodes_20211006; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.import_fruitfly_drybarcodes_20211006 (
    id character varying,
    _2didnumber character varying,
    cabinet character varying,
    drawer character varying,
    specimenid character varying,
    sex character varying,
    tubeidfrozencollection character varying
);


ALTER TABLE darwin2.import_fruitfly_drybarcodes_20211006 OWNER TO darwin2;

--
-- TOC entry 311 (class 1259 OID 19348)
-- Name: imports; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.imports (
    id integer NOT NULL,
    user_ref integer NOT NULL,
    format character varying NOT NULL,
    collection_ref integer,
    filename character varying NOT NULL,
    state character varying DEFAULT ''::character varying NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone,
    initial_count integer DEFAULT 0 NOT NULL,
    is_finished boolean DEFAULT false NOT NULL,
    errors_in_import text,
    template_version text,
    exclude_invalid_entries boolean DEFAULT false NOT NULL,
    specimen_taxonomy_ref integer,
    taxonomy_name character varying,
    creation_date date,
    creation_date_mask integer,
    definition_taxonomy text,
    is_reference_taxonomy boolean,
    source_taxonomy character varying,
    url_website_taxonomy character varying,
    url_webservice_taxonomy character varying,
    working boolean,
    mime_type character varying,
    taxonomy_kingdom character varying,
    history_taxonomy public.hstore,
    merge_gtu boolean,
    add_collection_prefix boolean,
    sensitive_information_withheld boolean,
    gtu_include_date boolean,
    gtu_tags_in_merge boolean,
    source_database character varying
);


ALTER TABLE darwin2.imports OWNER TO darwin2;

--
-- TOC entry 6990 (class 0 OID 0)
-- Dependencies: 311
-- Name: TABLE imports; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.imports IS 'Table used to check the state of the date coming from an uploaded file';


--
-- TOC entry 6991 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.user_ref IS 'The referenced user id';


--
-- TOC entry 6992 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.format; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.format IS 'The import template to use for the imported file';


--
-- TOC entry 6993 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.collection_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.collection_ref IS 'The collection associated';


--
-- TOC entry 6994 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.filename; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.filename IS 'The filename of the file to proceed';


--
-- TOC entry 6995 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.state; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.state IS 'the state of the processing the file';


--
-- TOC entry 6996 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.created_at; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.created_at IS 'Creation of the file';


--
-- TOC entry 6997 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.updated_at; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.updated_at IS 'When the data has been modified lately';


--
-- TOC entry 6998 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.initial_count; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.initial_count IS 'Number of rows of staging when the import was created';


--
-- TOC entry 6999 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.is_finished; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.is_finished IS 'Boolean to mark if the import is finished or still need some operations';


--
-- TOC entry 7000 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN imports.exclude_invalid_entries; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.exclude_invalid_entries IS 'Tell if, for this import, match should exclude the invalid units';


--
-- TOC entry 312 (class 1259 OID 19359)
-- Name: imports_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.imports_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.imports_id_seq OWNER TO darwin2;

--
-- TOC entry 7001 (class 0 OID 0)
-- Dependencies: 312
-- Name: imports_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.imports_id_seq OWNED BY darwin2.imports.id;


--
-- TOC entry 313 (class 1259 OID 19361)
-- Name: informative_workflow; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.informative_workflow (
    id integer NOT NULL,
    user_ref integer,
    formated_name character varying DEFAULT 'anonymous'::character varying NOT NULL,
    status character varying DEFAULT 'suggestion'::character varying NOT NULL,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    is_last boolean DEFAULT true NOT NULL,
    comment character varying NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.informative_workflow OWNER TO darwin2;

--
-- TOC entry 7002 (class 0 OID 0)
-- Dependencies: 313
-- Name: TABLE informative_workflow; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.informative_workflow IS 'Workflow information for each record encoded';


--
-- TOC entry 7003 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN informative_workflow.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 7004 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN informative_workflow.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.record_id IS 'ID of record a workflow is defined for';


--
-- TOC entry 7005 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN informative_workflow.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.user_ref IS 'Reference of user - id field of users table';


--
-- TOC entry 7006 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN informative_workflow.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.formated_name IS 'used to allow non registered user to add a workflow';


--
-- TOC entry 7007 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN informative_workflow.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.status IS 'Record status number: to correct, to be corrected or published ';


--
-- TOC entry 7008 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN informative_workflow.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.modification_date_time IS 'Date and time of status change - last date/time is used as actual status, but helps also to keep an history of status change';


--
-- TOC entry 7009 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN informative_workflow.is_last; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.is_last IS 'a flag witch allow us to know if the workflow for this referenced_relation/record id is the latest';


--
-- TOC entry 7010 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN informative_workflow.comment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.comment IS 'Complementary comments';


--
-- TOC entry 314 (class 1259 OID 19371)
-- Name: informative_workflow_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.informative_workflow_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.informative_workflow_id_seq OWNER TO darwin2;

--
-- TOC entry 7011 (class 0 OID 0)
-- Dependencies: 314
-- Name: informative_workflow_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.informative_workflow_id_seq OWNED BY darwin2.informative_workflow.id;


--
-- TOC entry 315 (class 1259 OID 19373)
-- Name: insurances; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.insurances (
    id integer NOT NULL,
    insurance_value numeric(16,2) NOT NULL,
    insurance_currency character varying DEFAULT '€'::character varying NOT NULL,
    date_from_mask integer DEFAULT 0 NOT NULL,
    date_from date DEFAULT '0001-01-01'::date NOT NULL,
    date_to_mask integer DEFAULT 0 NOT NULL,
    date_to date DEFAULT '2038-12-31'::date NOT NULL,
    insurer_ref integer,
    contact_ref integer,
    CONSTRAINT chk_chk_insurances CHECK ((insurance_value > (0)::numeric))
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.insurances OWNER TO darwin2;

--
-- TOC entry 7012 (class 0 OID 0)
-- Dependencies: 315
-- Name: TABLE insurances; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.insurances IS 'List of insurances values for given specimen or the loan';


--
-- TOC entry 7013 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN insurances.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 7014 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN insurances.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.record_id IS 'Identifier of record concerned';


--
-- TOC entry 7015 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN insurances.insurance_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.insurance_value IS 'Insurance value';


--
-- TOC entry 7016 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN insurances.insurance_currency; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.insurance_currency IS 'Currency used with insurance value';


--
-- TOC entry 7017 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN insurances.insurer_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.insurer_ref IS 'Reference of the insurance firm an insurance have been subscripted at';


--
-- TOC entry 316 (class 1259 OID 19385)
-- Name: insurances_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.insurances_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.insurances_id_seq OWNER TO darwin2;

--
-- TOC entry 7018 (class 0 OID 0)
-- Dependencies: 316
-- Name: insurances_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.insurances_id_seq OWNED BY darwin2.insurances.id;


--
-- TOC entry 317 (class 1259 OID 19387)
-- Name: lithology; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.lithology (
    id integer NOT NULL,
    CONSTRAINT fct_chk_onceinpath_lithology CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.lithology OWNER TO darwin2;

--
-- TOC entry 7019 (class 0 OID 0)
-- Dependencies: 317
-- Name: TABLE lithology; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.lithology IS 'List of lithologic units';


--
-- TOC entry 7020 (class 0 OID 0)
-- Dependencies: 317
-- Name: COLUMN lithology.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.name IS 'Classification unit name';


--
-- TOC entry 7021 (class 0 OID 0)
-- Dependencies: 317
-- Name: COLUMN lithology.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 7022 (class 0 OID 0)
-- Dependencies: 317
-- Name: COLUMN lithology.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 7023 (class 0 OID 0)
-- Dependencies: 317
-- Name: COLUMN lithology.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 7024 (class 0 OID 0)
-- Dependencies: 317
-- Name: COLUMN lithology.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 7025 (class 0 OID 0)
-- Dependencies: 317
-- Name: COLUMN lithology.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 7026 (class 0 OID 0)
-- Dependencies: 317
-- Name: COLUMN lithology.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 318 (class 1259 OID 19397)
-- Name: lithology_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.lithology_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.lithology_id_seq OWNER TO darwin2;

--
-- TOC entry 7027 (class 0 OID 0)
-- Dependencies: 318
-- Name: lithology_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.lithology_id_seq OWNED BY darwin2.lithology.id;


--
-- TOC entry 319 (class 1259 OID 19399)
-- Name: lithostratigraphy; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.lithostratigraphy (
    id integer NOT NULL,
    CONSTRAINT fct_chk_onceinpath_lithostratigraphy CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.lithostratigraphy OWNER TO darwin2;

--
-- TOC entry 7028 (class 0 OID 0)
-- Dependencies: 319
-- Name: TABLE lithostratigraphy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.lithostratigraphy IS 'List of lithostratigraphic units';


--
-- TOC entry 7029 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN lithostratigraphy.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.name IS 'Classification unit name';


--
-- TOC entry 7030 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN lithostratigraphy.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 7031 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN lithostratigraphy.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 7032 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN lithostratigraphy.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 7033 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN lithostratigraphy.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 7034 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN lithostratigraphy.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 7035 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN lithostratigraphy.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 320 (class 1259 OID 19409)
-- Name: lithostratigraphy_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.lithostratigraphy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.lithostratigraphy_id_seq OWNER TO darwin2;

--
-- TOC entry 7036 (class 0 OID 0)
-- Dependencies: 320
-- Name: lithostratigraphy_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.lithostratigraphy_id_seq OWNED BY darwin2.lithostratigraphy.id;


--
-- TOC entry 321 (class 1259 OID 19411)
-- Name: loan_history; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loan_history (
    id integer NOT NULL,
    loan_ref integer NOT NULL,
    referenced_table text NOT NULL,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    record_line public.hstore
);


ALTER TABLE darwin2.loan_history OWNER TO darwin2;

--
-- TOC entry 7037 (class 0 OID 0)
-- Dependencies: 321
-- Name: TABLE loan_history; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loan_history IS 'Table is a snapshot of an entire loan and related informations at a certain time';


--
-- TOC entry 7038 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN loan_history.loan_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_history.loan_ref IS 'Mandatory Reference to a loan';


--
-- TOC entry 7039 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN loan_history.referenced_table; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_history.referenced_table IS 'Mandatory Reference to the table refereced';


--
-- TOC entry 7040 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN loan_history.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_history.modification_date_time IS 'date of the modification';


--
-- TOC entry 7041 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN loan_history.record_line; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_history.record_line IS 'hstore containing the whole line of referenced_table';


--
-- TOC entry 322 (class 1259 OID 19418)
-- Name: loan_history_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loan_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loan_history_id_seq OWNER TO darwin2;

--
-- TOC entry 7042 (class 0 OID 0)
-- Dependencies: 322
-- Name: loan_history_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.loan_history_id_seq OWNED BY darwin2.loan_history.id;


--
-- TOC entry 323 (class 1259 OID 19420)
-- Name: loan_items; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loan_items (
    id integer NOT NULL,
    loan_ref integer NOT NULL,
    ig_ref integer,
    from_date date,
    to_date date,
    specimen_ref integer NOT NULL,
    details character varying DEFAULT ''::character varying,
    specimen_count_tot integer,
    specimen_count_males integer,
    specimen_count_females integer,
    specimen_count_juveniles integer,
    specimen_part character varying,
    specimen_count character varying
);


ALTER TABLE darwin2.loan_items OWNER TO darwin2;

--
-- TOC entry 7043 (class 0 OID 0)
-- Dependencies: 323
-- Name: TABLE loan_items; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loan_items IS 'Table holding an item of a loan. It may be a part from darwin or only an generic item';


--
-- TOC entry 7044 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN loan_items.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.id IS 'Unique identifier of record';


--
-- TOC entry 7045 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN loan_items.loan_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.loan_ref IS 'Mandatory Reference to a loan';


--
-- TOC entry 7046 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN loan_items.ig_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.ig_ref IS 'Optional ref to an IG stored in the igs table';


--
-- TOC entry 7047 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN loan_items.from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.from_date IS 'Date when the item was sended';


--
-- TOC entry 7048 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN loan_items.to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.to_date IS 'Date when the item was recieved back';


--
-- TOC entry 7049 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN loan_items.specimen_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.specimen_ref IS 'Optional reference to a Darwin Part';


--
-- TOC entry 7050 (class 0 OID 0)
-- Dependencies: 323
-- Name: COLUMN loan_items.details; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.details IS 'Textual details describing the item';


--
-- TOC entry 324 (class 1259 OID 19427)
-- Name: loan_items_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loan_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loan_items_id_seq OWNER TO darwin2;

--
-- TOC entry 7051 (class 0 OID 0)
-- Dependencies: 324
-- Name: loan_items_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.loan_items_id_seq OWNED BY darwin2.loan_items.id;


--
-- TOC entry 325 (class 1259 OID 19429)
-- Name: loan_rights; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loan_rights (
    id integer NOT NULL,
    loan_ref integer NOT NULL,
    user_ref integer NOT NULL,
    has_encoding_right boolean DEFAULT false NOT NULL
);


ALTER TABLE darwin2.loan_rights OWNER TO darwin2;

--
-- TOC entry 7052 (class 0 OID 0)
-- Dependencies: 325
-- Name: TABLE loan_rights; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loan_rights IS 'Table describing rights into an entire loan (if user is in the table he has at least viewing rights)';


--
-- TOC entry 7053 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN loan_rights.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_rights.id IS 'Unique identifier of record';


--
-- TOC entry 7054 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN loan_rights.loan_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_rights.loan_ref IS 'Mandatory Reference to a loan';


--
-- TOC entry 7055 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN loan_rights.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_rights.user_ref IS 'Mandatory Reference to a user';


--
-- TOC entry 7056 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN loan_rights.has_encoding_right; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_rights.has_encoding_right IS 'Bool saying if the user can edit a loan';


--
-- TOC entry 326 (class 1259 OID 19433)
-- Name: loan_rights_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loan_rights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loan_rights_id_seq OWNER TO darwin2;

--
-- TOC entry 7057 (class 0 OID 0)
-- Dependencies: 326
-- Name: loan_rights_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.loan_rights_id_seq OWNED BY darwin2.loan_rights.id;


--
-- TOC entry 327 (class 1259 OID 19435)
-- Name: loan_status; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loan_status (
    id integer NOT NULL,
    loan_ref integer NOT NULL,
    user_ref integer NOT NULL,
    status character varying DEFAULT 'new'::character varying NOT NULL,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    comment character varying DEFAULT ''::character varying NOT NULL,
    is_last boolean DEFAULT true NOT NULL
);


ALTER TABLE darwin2.loan_status OWNER TO darwin2;

--
-- TOC entry 7058 (class 0 OID 0)
-- Dependencies: 327
-- Name: TABLE loan_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loan_status IS 'Table describing various states of a loan';


--
-- TOC entry 7059 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN loan_status.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.id IS 'Unique identifier of record';


--
-- TOC entry 7060 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN loan_status.loan_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.loan_ref IS 'Mandatory Reference to a loan';


--
-- TOC entry 7061 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN loan_status.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.user_ref IS 'Mandatory Reference to a user';


--
-- TOC entry 7062 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN loan_status.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.status IS 'Current status of the loan in a list (new, closed, running, ...)';


--
-- TOC entry 7063 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN loan_status.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.modification_date_time IS 'date of the modification';


--
-- TOC entry 7064 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN loan_status.comment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.comment IS 'comment of the status modification';


--
-- TOC entry 7065 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN loan_status.is_last; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.is_last IS 'flag telling which line is the current line';


--
-- TOC entry 328 (class 1259 OID 19445)
-- Name: loan_status_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loan_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loan_status_id_seq OWNER TO darwin2;

--
-- TOC entry 7066 (class 0 OID 0)
-- Dependencies: 328
-- Name: loan_status_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.loan_status_id_seq OWNED BY darwin2.loan_status.id;


--
-- TOC entry 329 (class 1259 OID 19447)
-- Name: loans; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loans (
    id integer NOT NULL,
    name character varying DEFAULT ''::character varying NOT NULL,
    description character varying DEFAULT ''::character varying NOT NULL,
    search_indexed text NOT NULL,
    from_date date,
    to_date date,
    extended_to_date date,
    collection_ref integer,
    address_receiver character varying,
    institution_receiver character varying,
    country_receiver character varying,
    zip_receiver character varying,
    city_receiver character varying(50),
    collection_manager character varying,
    collection_manager_title character varying,
    collection_manager_mail character varying,
    non_cites boolean
);


ALTER TABLE darwin2.loans OWNER TO darwin2;

--
-- TOC entry 7067 (class 0 OID 0)
-- Dependencies: 329
-- Name: TABLE loans; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loans IS 'Table holding an entire loan made of multiple loan items may also be linked to other table as comment, properties , ...';


--
-- TOC entry 7068 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN loans.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.id IS 'Unique identifier of record';


--
-- TOC entry 7069 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN loans.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.name IS 'Global name of the loan. May be a sort of code of other naming scheme';


--
-- TOC entry 7070 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN loans.description; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.description IS 'Description of the meaning of the loan';


--
-- TOC entry 7071 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN loans.search_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.search_indexed IS 'indexed getting Description and title of the loan';


--
-- TOC entry 7072 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN loans.from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.from_date IS 'Date of the start of the loan';


--
-- TOC entry 7073 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN loans.to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.to_date IS 'Planned date of the end of the loan';


--
-- TOC entry 330 (class 1259 OID 19455)
-- Name: loans_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loans_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loans_id_seq OWNER TO darwin2;

--
-- TOC entry 7074 (class 0 OID 0)
-- Dependencies: 330
-- Name: loans_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.loans_id_seq OWNED BY darwin2.loans.id;


--
-- TOC entry 331 (class 1259 OID 19457)
-- Name: mineralogy; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.mineralogy (
    id integer NOT NULL,
    code character varying NOT NULL,
    classification character varying DEFAULT 'strunz'::character varying NOT NULL,
    formule character varying,
    formule_indexed character varying,
    cristal_system character varying,
    CONSTRAINT fct_chk_onceinpath_mineralogy CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.mineralogy OWNER TO darwin2;

--
-- TOC entry 7075 (class 0 OID 0)
-- Dependencies: 331
-- Name: TABLE mineralogy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.mineralogy IS 'List of mineralogic units';


--
-- TOC entry 7076 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.name IS 'Classification unit name';


--
-- TOC entry 7077 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 7078 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 7079 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 7080 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 7081 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 7082 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 7083 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.code IS 'Classification code given to mineral - in classification chosen - Strunz by default';


--
-- TOC entry 7084 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.classification; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.classification IS 'Classification system used to describe mineral: strunz, dana,...';


--
-- TOC entry 7085 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.formule; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.formule IS 'Chemical formulation';


--
-- TOC entry 7086 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.formule_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.formule_indexed IS 'Indexed form of foumule field';


--
-- TOC entry 7087 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN mineralogy.cristal_system; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.cristal_system IS 'Cristal system defining the mineral structure: isometric, hexagonal,...';


--
-- TOC entry 332 (class 1259 OID 19468)
-- Name: mineralogy_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.mineralogy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.mineralogy_id_seq OWNER TO darwin2;

--
-- TOC entry 7088 (class 0 OID 0)
-- Dependencies: 332
-- Name: mineralogy_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.mineralogy_id_seq OWNED BY darwin2.mineralogy.id;


--
-- TOC entry 333 (class 1259 OID 19470)
-- Name: multimedia; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.multimedia (
    id integer NOT NULL,
    is_digital boolean DEFAULT true NOT NULL,
    type character varying DEFAULT 'image'::character varying NOT NULL,
    sub_type character varying,
    title character varying NOT NULL,
    description character varying DEFAULT ''::character varying NOT NULL,
    uri character varying,
    filename character varying,
    search_indexed text NOT NULL,
    creation_date date DEFAULT '0001-01-01'::date NOT NULL,
    creation_date_mask integer DEFAULT 0 NOT NULL,
    mime_type character varying NOT NULL,
    visible boolean DEFAULT true NOT NULL,
    publishable boolean DEFAULT true NOT NULL,
    extracted_info text,
    technical_parameters character varying,
    internet_protocol character varying,
    field_observations character varying,
    external_uri character varying,
    import_ref integer
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.multimedia OWNER TO darwin2;

--
-- TOC entry 7089 (class 0 OID 0)
-- Dependencies: 333
-- Name: TABLE multimedia; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.multimedia IS 'Stores all multimedia objects encoded in DaRWIN 2.0';


--
-- TOC entry 7090 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 7091 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.record_id IS 'Identifier of record concerned';


--
-- TOC entry 7092 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.id IS 'Unique identifier of a multimedia object';


--
-- TOC entry 7093 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.is_digital; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.is_digital IS 'Flag telling if the object is digital (true) or physical (false)';


--
-- TOC entry 7094 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.type IS 'Main multimedia object type: image, sound, video,...';


--
-- TOC entry 7095 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.sub_type IS 'Characterization of object type: article, publication in serie, book, glass plate,...';


--
-- TOC entry 7096 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.title IS 'Title of the multimedia object';


--
-- TOC entry 7097 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.description; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.description IS 'Description of the current object';


--
-- TOC entry 7098 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.uri; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.uri IS 'URI of object if digital';


--
-- TOC entry 7099 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.filename; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.filename IS 'The original name of the saved file';


--
-- TOC entry 7100 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.search_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.search_indexed IS 'indexed form of title and description fields together';


--
-- TOC entry 7101 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.creation_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.creation_date IS 'Object creation date';


--
-- TOC entry 7102 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.creation_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.creation_date_mask IS 'Mask used for object creation date display';


--
-- TOC entry 7103 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.mime_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.mime_type IS 'Mime/Type of the linked digital object';


--
-- TOC entry 7104 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.visible; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.visible IS 'Flag telling if the related file has been chosen to be publically visible or not';


--
-- TOC entry 7105 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN multimedia.publishable; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.publishable IS 'Flag telling if the related file has been chosen as a prefered item for publication - Would be for example used for preselection of media published for Open Up project';


--
-- TOC entry 334 (class 1259 OID 19483)
-- Name: multimedia_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.multimedia_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.multimedia_id_seq OWNER TO darwin2;

--
-- TOC entry 7106 (class 0 OID 0)
-- Dependencies: 334
-- Name: multimedia_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.multimedia_id_seq OWNED BY darwin2.multimedia.id;


--
-- TOC entry 335 (class 1259 OID 19485)
-- Name: multimedia_todelete; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.multimedia_todelete (
    id integer NOT NULL,
    uri text
);


ALTER TABLE darwin2.multimedia_todelete OWNER TO darwin2;

--
-- TOC entry 7107 (class 0 OID 0)
-- Dependencies: 335
-- Name: TABLE multimedia_todelete; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.multimedia_todelete IS 'Table here to save deleted multimedia files waiting for a deletion on the disk';


--
-- TOC entry 7108 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN multimedia_todelete.uri; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia_todelete.uri IS 'URI of the file to delete';


--
-- TOC entry 336 (class 1259 OID 19491)
-- Name: multimedia_todelete_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.multimedia_todelete_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.multimedia_todelete_id_seq OWNER TO darwin2;

--
-- TOC entry 7109 (class 0 OID 0)
-- Dependencies: 336
-- Name: multimedia_todelete_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.multimedia_todelete_id_seq OWNED BY darwin2.multimedia_todelete.id;


--
-- TOC entry 366 (class 1259 OID 19661)
-- Name: specimens; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimens (
    id integer NOT NULL,
    collection_ref integer NOT NULL,
    expedition_ref integer,
    gtu_ref integer,
    taxon_ref integer,
    litho_ref integer,
    chrono_ref integer,
    lithology_ref integer,
    mineral_ref integer,
    acquisition_category character varying DEFAULT ''::character varying NOT NULL,
    acquisition_date_mask integer DEFAULT 0 NOT NULL,
    acquisition_date date DEFAULT '0001-01-01'::date NOT NULL,
    station_visible boolean DEFAULT true NOT NULL,
    ig_ref integer,
    type character varying DEFAULT 'specimen'::character varying NOT NULL,
    type_group character varying DEFAULT 'specimen'::character varying NOT NULL,
    type_search character varying DEFAULT 'specimen'::character varying NOT NULL,
    sex character varying DEFAULT 'undefined'::character varying NOT NULL,
    stage character varying DEFAULT 'undefined'::character varying NOT NULL,
    state character varying DEFAULT 'not applicable'::character varying NOT NULL,
    social_status character varying DEFAULT 'not applicable'::character varying NOT NULL,
    rock_form character varying DEFAULT 'not applicable'::character varying NOT NULL,
    room character varying,
    shelf character varying,
    specimen_count_min integer DEFAULT 1 NOT NULL,
    specimen_count_max integer DEFAULT 1 NOT NULL,
    spec_ident_ids integer[] DEFAULT '{}'::integer[] NOT NULL,
    spec_coll_ids integer[] DEFAULT '{}'::integer[] NOT NULL,
    spec_don_sel_ids integer[] DEFAULT '{}'::integer[] NOT NULL,
    collection_type character varying,
    collection_code character varying,
    collection_name character varying,
    collection_is_public boolean,
    collection_parent_ref integer,
    collection_path character varying,
    expedition_name character varying,
    expedition_name_indexed character varying,
    gtu_code character varying,
    gtu_from_date_mask integer DEFAULT 0,
    gtu_from_date timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone,
    gtu_to_date_mask integer DEFAULT 0,
    gtu_to_date timestamp without time zone DEFAULT '2038-12-31 00:00:00'::timestamp without time zone,
    gtu_tag_values_indexed character varying[],
    gtu_country_tag_value character varying,
    gtu_country_tag_indexed character varying[],
    gtu_province_tag_value character varying,
    gtu_province_tag_indexed character varying[],
    gtu_others_tag_value character varying,
    gtu_others_tag_indexed character varying[],
    gtu_elevation double precision,
    gtu_elevation_accuracy double precision,
    gtu_location point,
    taxon_name character varying,
    taxon_name_indexed character varying,
    taxon_level_ref integer,
    taxon_level_name character varying,
    taxon_status character varying,
    taxon_path character varying,
    taxon_parent_ref integer,
    taxon_extinct boolean,
    litho_name character varying,
    litho_name_indexed character varying,
    litho_level_ref integer,
    litho_level_name character varying,
    litho_status character varying,
    litho_local boolean,
    litho_color character varying,
    litho_path character varying,
    litho_parent_ref integer,
    chrono_name character varying,
    chrono_name_indexed character varying,
    chrono_level_ref integer,
    chrono_level_name character varying,
    chrono_status character varying,
    chrono_local boolean,
    chrono_color character varying,
    chrono_path character varying,
    chrono_parent_ref integer,
    lithology_name character varying,
    lithology_name_indexed character varying,
    lithology_level_ref integer,
    lithology_level_name character varying,
    lithology_status character varying,
    lithology_local boolean,
    lithology_color character varying,
    lithology_path character varying,
    lithology_parent_ref integer,
    mineral_name character varying,
    mineral_name_indexed character varying,
    mineral_level_ref integer,
    mineral_level_name character varying,
    mineral_status character varying,
    mineral_local boolean,
    mineral_color character varying,
    mineral_path character varying,
    mineral_parent_ref integer,
    ig_num character varying,
    ig_num_indexed character varying,
    ig_date_mask integer,
    ig_date date,
    specimen_count_males_min integer,
    specimen_count_males_max integer,
    specimen_count_females_min integer,
    specimen_count_females_max integer,
    specimen_count_juveniles_min integer,
    specimen_count_juveniles_max integer,
    main_code_indexed character varying,
    category character varying DEFAULT 'physical'::character varying,
    institution_ref integer,
    building character varying,
    floor character varying,
    "row" character varying,
    col character varying,
    container character varying,
    sub_container character varying,
    container_type character varying DEFAULT 'container'::character varying,
    sub_container_type character varying DEFAULT 'container'::character varying,
    container_storage character varying DEFAULT 'dry'::character varying,
    sub_container_storage character varying DEFAULT 'dry'::character varying,
    surnumerary boolean DEFAULT false,
    object_name text,
    object_name_indexed text DEFAULT ''::text,
    specimen_status character varying DEFAULT 'good state'::character varying,
    valid_label boolean,
    label_created_on character varying,
    label_created_by character varying,
    specimen_creation_date timestamp without time zone DEFAULT now(),
    import_ref integer,
    gtu_iso3166 character varying,
    gtu_iso3166_subdivision character varying,
    nagoya character varying DEFAULT 'not defined'::character varying,
    uuid uuid,
    collection_name_full_path character varying,
    CONSTRAINT chk_chk_specimen_part_min CHECK ((specimen_count_min >= 0)),
    CONSTRAINT chk_chk_specimen_parts_minmax CHECK ((specimen_count_min <= specimen_count_max))
);


ALTER TABLE darwin2.specimens OWNER TO darwin2;

--
-- TOC entry 7110 (class 0 OID 0)
-- Dependencies: 366
-- Name: TABLE specimens; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.specimens IS 'Specimens or batch of specimens stored in collection';


--
-- TOC entry 7111 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.id IS 'Unique identifier of a specimen or batch of specimens';


--
-- TOC entry 7112 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.collection_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.collection_ref IS 'Reference of collection the specimen is grouped under - id field of collections table';


--
-- TOC entry 7113 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.expedition_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.expedition_ref IS 'When acquisition category is expedition, contains the reference of the expedition having conducted to the current specimen capture - id field of expeditions table';


--
-- TOC entry 7114 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.gtu_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_ref IS 'Reference of the sampling location the specimen is coming from - id field of gtu table';


--
-- TOC entry 7115 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.taxon_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.taxon_ref IS 'When encoding a ''living'' specimen, contains the reference of the taxon unit defining the specimen - id field of taxonomy table';


--
-- TOC entry 7116 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.litho_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.litho_ref IS 'When encoding a rock, mineral or paleontologic specimen, contains the reference of lithostratigraphic unit the specimen have been found into - id field of lithostratigraphy table';


--
-- TOC entry 7117 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.chrono_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.chrono_ref IS 'When encoding a rock, mineral or paleontologic specimen, contains the reference of chronostratigraphic unit the specimen have been found into - id field of chronostratigraphy table';


--
-- TOC entry 7118 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.lithology_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.lithology_ref IS 'Reference of a rock classification unit associated to the specimen encoded - id field of lithology table';


--
-- TOC entry 7119 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.mineral_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.mineral_ref IS 'Reference of a mineral classification unit associated to the specimen encoded - id field of mineralogy table';


--
-- TOC entry 7120 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.acquisition_category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.acquisition_category IS 'Describe how the specimen was collected: expedition, donation,...';


--
-- TOC entry 7121 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.acquisition_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.acquisition_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 7122 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.acquisition_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.acquisition_date IS 'Date Composed (if possible) of the acquisition';


--
-- TOC entry 7123 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.station_visible; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.station_visible IS 'Flag telling if the sampling location can be visible or must be hidden for the specimen encoded';


--
-- TOC entry 7124 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.ig_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.ig_ref IS 'Reference of ig number this specimen has been associated to';


--
-- TOC entry 7125 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.type IS 'Special status given to specimen: holotype, paratype,...';


--
-- TOC entry 7126 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.type_group; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.type_group IS 'For some special status, a common appelation is used - ie: topotype and cotype are joined into a common appelation of syntype';


--
-- TOC entry 7127 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.type_search; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.type_search IS 'On the interface, the separation in all special status is not suggested for non official appelations. For instance, an unified grouping name is provided: type for non official appelation,...';


--
-- TOC entry 7128 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.sex; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.sex IS 'sex: male , female,...';


--
-- TOC entry 7129 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.stage; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.stage IS 'stage: adult, juvenile,...';


--
-- TOC entry 7130 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.state; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.state IS 'state - a sex complement: ovigerous, pregnant,...';


--
-- TOC entry 7131 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.social_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.social_status IS 'For social specimens, give the social status/role of the specimen in colony';


--
-- TOC entry 7132 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.rock_form; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.rock_form IS 'For rock specimens, a descriptive form can be given: polygonous,...';


--
-- TOC entry 7133 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.room; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.room IS 'Room the specimen is stored in';


--
-- TOC entry 7134 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.shelf; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.shelf IS 'Shelf the specimen is stored in';


--
-- TOC entry 7135 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.specimen_count_min; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.specimen_count_min IS 'Minimum number of specimens';


--
-- TOC entry 7136 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.specimen_count_max; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.specimen_count_max IS 'Maximum number of specimens';


--
-- TOC entry 7137 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.gtu_from_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_from_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 7138 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.gtu_from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_from_date IS 'composed from date of the GTU';


--
-- TOC entry 7139 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.gtu_to_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_to_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 7140 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.gtu_to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_to_date IS 'composed to date of the GTU';


--
-- TOC entry 7141 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.category IS 'Type of specimen encoded: a physical object stored in collections, an observation, a figurate specimen,...';


--
-- TOC entry 7142 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.building; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.building IS 'Building the specimen is stored in';


--
-- TOC entry 7143 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.floor; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.floor IS 'Floor the specimen is stored in';


--
-- TOC entry 7144 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens."row"; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens."row" IS 'Row the specimen is stored in';


--
-- TOC entry 7145 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.container; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.container IS 'Container the specimen is stored in';


--
-- TOC entry 7146 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.sub_container; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.sub_container IS 'Sub-Container the specimen is stored in';


--
-- TOC entry 7147 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.container_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.container_type IS 'Type of container: box, plateau-caisse,...';


--
-- TOC entry 7148 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.sub_container_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.sub_container_type IS 'Type of sub-container: slide, needle,...';


--
-- TOC entry 7149 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.container_storage; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.container_storage IS 'Conservative medium used: formol, alcohool, dry,...';


--
-- TOC entry 7150 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.sub_container_storage; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.sub_container_storage IS 'Conservative medium used: formol, alcohool, dry,...';


--
-- TOC entry 7151 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.surnumerary; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.surnumerary IS 'Tells if this specimen has been added after first inventory';


--
-- TOC entry 7152 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN specimens.specimen_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.specimen_status IS 'Specimen status: good state, lost, damaged,...';


--
-- TOC entry 373 (class 1259 OID 19729)
-- Name: storage_parts; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.storage_parts (
    id integer NOT NULL,
    category character varying DEFAULT 'physical'::character varying NOT NULL,
    specimen_ref integer NOT NULL,
    specimen_part character varying DEFAULT 'specimen'::character varying NOT NULL,
    institution_ref integer,
    building character varying,
    floor character varying,
    room character varying,
    "row" character varying,
    col character varying,
    shelf character varying,
    container character varying,
    sub_container character varying,
    container_type character varying DEFAULT 'container'::character varying NOT NULL,
    sub_container_type character varying DEFAULT 'container'::character varying NOT NULL,
    container_storage character varying DEFAULT 'dry'::character varying NOT NULL,
    sub_container_storage character varying DEFAULT 'dry'::character varying NOT NULL,
    surnumerary boolean DEFAULT false NOT NULL,
    object_name text,
    object_name_indexed text DEFAULT ''::text NOT NULL,
    specimen_status character varying DEFAULT 'good state'::character varying NOT NULL,
    complete boolean DEFAULT true NOT NULL
);


ALTER TABLE darwin2.storage_parts OWNER TO darwin2;

--
-- TOC entry 7153 (class 0 OID 0)
-- Dependencies: 373
-- Name: COLUMN storage_parts.specimen_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.storage_parts.specimen_status IS 'Specimen status: good state, lost, damaged,...';


--
-- TOC entry 7154 (class 0 OID 0)
-- Dependencies: 373
-- Name: COLUMN storage_parts.complete; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.storage_parts.complete IS 'Flag telling if specimen is complete or not';


--
-- TOC entry 522 (class 1259 OID 1417980)
-- Name: v_specimens_mids; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_specimens_mids AS
 SELECT specimens.id,
    btrim((((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text)) AS main_code,
    specimens.category,
    specimens.collection_ref,
    specimens.expedition_ref,
    specimens.gtu_ref,
    specimens.taxon_ref,
    specimens.litho_ref,
    specimens.chrono_ref,
    specimens.lithology_ref,
    specimens.mineral_ref,
    specimens.acquisition_category,
    specimens.acquisition_date_mask,
    specimens.acquisition_date,
    specimens.station_visible,
    specimens.ig_ref,
    specimens.type,
    specimens.type_group,
    specimens.type_search,
    specimens.sex,
    specimens.stage,
    specimens.state,
    specimens.social_status,
    specimens.rock_form,
    storage_parts.specimen_part,
    storage_parts.complete,
    storage_parts.institution_ref,
    storage_parts.building,
    storage_parts.floor,
    storage_parts.room,
    storage_parts."row",
    storage_parts.shelf,
    storage_parts.container,
    storage_parts.sub_container,
    storage_parts.container_type,
    storage_parts.sub_container_type,
    storage_parts.container_storage,
    storage_parts.sub_container_storage,
    storage_parts.surnumerary,
    storage_parts.specimen_status,
    specimens.specimen_count_min,
    specimens.specimen_count_max,
    specimens.object_name,
    specimens.object_name_indexed,
    specimens.spec_ident_ids,
    specimens.spec_coll_ids,
    specimens.spec_don_sel_ids,
    specimens.collection_type,
    specimens.collection_code,
    specimens.collection_name,
    specimens.collection_is_public,
    specimens.collection_parent_ref,
    specimens.collection_path,
    specimens.expedition_name,
    specimens.expedition_name_indexed,
    specimens.gtu_code,
    specimens.gtu_from_date_mask,
    specimens.gtu_from_date,
    specimens.gtu_to_date_mask,
    specimens.gtu_to_date,
    specimens.gtu_tag_values_indexed,
    specimens.gtu_country_tag_value,
    specimens.gtu_country_tag_indexed,
    specimens.gtu_province_tag_value,
    specimens.gtu_province_tag_indexed,
    specimens.gtu_others_tag_value,
    specimens.gtu_others_tag_indexed,
    specimens.gtu_elevation,
    specimens.gtu_elevation_accuracy,
    specimens.taxon_name,
    specimens.taxon_name_indexed,
    specimens.taxon_level_ref,
    specimens.taxon_level_name,
    specimens.taxon_status,
    specimens.taxon_path,
    specimens.taxon_parent_ref,
    specimens.taxon_extinct,
    specimens.litho_name,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 34) AS family,
    specimens.litho_name_indexed,
    specimens.litho_level_ref,
    specimens.litho_level_name,
    specimens.litho_status,
    specimens.litho_local,
    specimens.litho_color,
    specimens.litho_path,
    specimens.litho_parent_ref,
    specimens.chrono_name,
    specimens.chrono_name_indexed,
    specimens.chrono_level_ref,
    specimens.chrono_level_name,
    specimens.chrono_status,
    specimens.chrono_local,
    specimens.chrono_color,
    specimens.chrono_path,
    specimens.chrono_parent_ref,
    specimens.lithology_name,
    specimens.lithology_name_indexed,
    specimens.lithology_level_ref,
    specimens.lithology_level_name,
    specimens.lithology_status,
    specimens.lithology_local,
    specimens.lithology_color,
    specimens.lithology_path,
    specimens.lithology_parent_ref,
    specimens.mineral_name,
    specimens.mineral_name_indexed,
    specimens.mineral_level_ref,
    specimens.mineral_level_name,
    specimens.mineral_status,
    specimens.mineral_local,
    specimens.mineral_color,
    specimens.mineral_path,
    specimens.mineral_parent_ref,
    specimens.ig_num,
    specimens.ig_num_indexed,
    specimens.ig_date_mask,
    specimens.ig_date,
    specimens.col,
    specimens.gtu_location,
    specimens.specimen_creation_date,
    specimens.import_ref,
    specimens.main_code_indexed,
    specimens.specimen_count_males_min,
    specimens.specimen_count_males_max,
    specimens.specimen_count_females_min,
    specimens.specimen_count_females_max,
    specimens.specimen_count_juveniles_min,
    specimens.specimen_count_juveniles_max,
    specimens.nagoya,
    specimens.uuid,
        CASE
            WHEN ((codes.id IS NOT NULL) AND (specimens.gtu_country_tag_value IS NOT NULL) AND ((specimens.gtu_province_tag_value IS NOT NULL) OR (specimens.gtu_others_tag_value IS NOT NULL)) AND (specimens.gtu_location IS NOT NULL) AND (collector.id IS NOT NULL) AND (specimens.gtu_from_date <> '0001-01-01 00:00:00'::timestamp without time zone) AND (specimens.type IS NOT NULL) AND (specimens.taxon_ref IS NOT NULL) AND (((storage_parts.container_storage IS NOT NULL) AND (btrim((storage_parts.container_storage)::text) <> ''::text) AND (btrim((storage_parts.container_storage)::text) <> '/'::text) AND (lower((storage_parts.container_storage)::text) <> 'unknown'::text)) OR ((storage_parts.sub_container_storage IS NOT NULL) AND (btrim((storage_parts.sub_container_storage)::text) <> ''::text) AND (btrim((storage_parts.sub_container_storage)::text) <> '/'::text) AND (lower((storage_parts.sub_container_storage)::text) <> 'unknown'::text)))) THEN 2
            WHEN ((specimens.taxon_ref IS NOT NULL) AND (((storage_parts.container_storage IS NOT NULL) AND (btrim((storage_parts.container_storage)::text) <> ''::text) AND (btrim((storage_parts.container_storage)::text) <> '/'::text) AND (lower((storage_parts.container_storage)::text) <> 'unknown'::text)) OR ((storage_parts.sub_container_storage IS NOT NULL) AND (btrim((storage_parts.sub_container_storage)::text) <> ''::text) AND (btrim((storage_parts.sub_container_storage)::text) <> '/'::text) AND (lower((storage_parts.sub_container_storage)::text) <> 'unknown'::text)))) THEN 1
            ELSE 0
        END AS mids_level
   FROM (((darwin2.specimens
     JOIN darwin2.storage_parts ON ((specimens.id = storage_parts.specimen_ref)))
     LEFT JOIN darwin2.codes ON (((specimens.id = codes.record_id) AND ((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text))))
     LEFT JOIN darwin2.catalogue_people collector ON (((specimens.id = collector.record_id) AND ((collector.referenced_relation)::text = 'specimens'::text) AND ((collector.people_type)::text = 'collector'::text))));


ALTER TABLE darwin2.v_specimens_mids OWNER TO darwin2;

--
-- TOC entry 523 (class 1259 OID 1417990)
-- Name: v_specimens_mids_simplified; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_specimens_mids_simplified AS
 SELECT v_specimens_mids.collection_name,
    v_specimens_mids.id,
    v_specimens_mids.type,
    v_specimens_mids.family,
    v_specimens_mids.gtu_country_tag_value,
    v_specimens_mids.gtu_province_tag_value,
    v_specimens_mids.gtu_others_tag_value,
    v_specimens_mids.container_type,
    v_specimens_mids.container_storage,
    v_specimens_mids.mids_level,
    v_specimens_mids.collection_ref
   FROM darwin2.v_specimens_mids;


ALTER TABLE darwin2.v_specimens_mids_simplified OWNER TO darwin2;

--
-- TOC entry 529 (class 1259 OID 1757512)
-- Name: mv_specimens_mids_simplified; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.mv_specimens_mids_simplified AS
 SELECT v_specimens_mids_simplified.collection_name,
    v_specimens_mids_simplified.id,
    v_specimens_mids_simplified.type,
    v_specimens_mids_simplified.family,
    v_specimens_mids_simplified.gtu_country_tag_value,
    v_specimens_mids_simplified.gtu_province_tag_value,
    v_specimens_mids_simplified.gtu_others_tag_value,
    v_specimens_mids_simplified.container_type,
    v_specimens_mids_simplified.container_storage,
    v_specimens_mids_simplified.mids_level,
    v_specimens_mids_simplified.collection_ref
   FROM darwin2.v_specimens_mids_simplified
  WITH NO DATA;


ALTER TABLE darwin2.mv_specimens_mids_simplified OWNER TO darwin2;

--
-- TOC entry 470 (class 1259 OID 20226)
-- Name: v_rmca_collections_path_as_text; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_collections_path_as_text AS
 SELECT collections.id,
    collections.collection_type,
    collections.code,
    collections.name,
    collections.name_indexed,
    collections.institution_ref,
    collections.main_manager_ref,
    collections.parent_ref,
    collections.path,
    collections.code_auto_increment,
    collections.code_last_value,
    collections.code_prefix,
    collections.code_prefix_separator,
    collections.code_suffix,
    collections.code_suffix_separator,
    collections.is_public,
    collections.code_specimen_duplicate,
    collections.staff_ref,
    collections.code_auto_increment_for_insert_only,
    collections.code_mask,
    collections.allow_duplicates,
    string_agg((b.name)::text, '/'::text ORDER BY (collections.coll_path)::integer) AS collection_path_text,
    string_agg((b.code)::text, '/'::text ORDER BY (collections.coll_path)::integer) AS collection_path_code,
    string_agg((b.name_indexed)::text, '/'::text ORDER BY (collections.coll_path)::integer) AS collection_path_indexed,
    (array_agg((b.name)::text ORDER BY (collections.coll_path)::integer))[1] AS collection_main_text,
    (array_agg((b.code)::text ORDER BY (collections.coll_path)::integer))[1] AS collection_main_code,
    (array_agg((b.name_indexed)::text ORDER BY (collections.coll_path)::integer))[1] AS collection_main_indexed
   FROM (( SELECT DISTINCT collections_1.id,
            collections_1.collection_type,
            collections_1.code,
            collections_1.name,
            collections_1.name_indexed,
            collections_1.institution_ref,
            collections_1.main_manager_ref,
            collections_1.parent_ref,
            collections_1.path,
            regexp_split_to_table(btrim(((collections_1.path)::text || ((collections_1.id)::character varying)::text), '/'::text), '/'::text) AS coll_path,
            collections_1.code_auto_increment,
            collections_1.code_last_value,
            collections_1.code_prefix,
            collections_1.code_prefix_separator,
            collections_1.code_suffix,
            collections_1.code_suffix_separator,
            collections_1.is_public,
            collections_1.code_specimen_duplicate,
            collections_1.staff_ref,
            collections_1.code_auto_increment_for_insert_only,
            collections_1.code_mask,
            collections_1.allow_duplicates
           FROM darwin2.collections collections_1) collections
     LEFT JOIN darwin2.collections b ON (((collections.coll_path)::integer = b.id)))
  GROUP BY collections.id, collections.collection_type, collections.code, collections.name, collections.name_indexed, collections.institution_ref, collections.main_manager_ref, collections.parent_ref, collections.path, collections.code_auto_increment, collections.code_last_value, collections.code_prefix, collections.code_prefix_separator, collections.code_suffix, collections.code_suffix_separator, collections.is_public, collections.code_specimen_duplicate, collections.staff_ref, collections.code_auto_increment_for_insert_only, collections.code_mask, collections.allow_duplicates;


ALTER TABLE darwin2.v_rmca_collections_path_as_text OWNER TO darwin2;

--
-- TOC entry 530 (class 1259 OID 1757523)
-- Name: mv_specimens_mids_simplified_coll_hierarchy; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.mv_specimens_mids_simplified_coll_hierarchy AS
 SELECT v_rmca_collections_path_as_text.collection_path_text,
    mv_specimens_mids_simplified.collection_name,
    mv_specimens_mids_simplified.id,
    mv_specimens_mids_simplified.type,
    mv_specimens_mids_simplified.family,
    mv_specimens_mids_simplified.gtu_country_tag_value,
    mv_specimens_mids_simplified.gtu_province_tag_value,
    mv_specimens_mids_simplified.gtu_others_tag_value,
    mv_specimens_mids_simplified.container_type,
    mv_specimens_mids_simplified.container_storage,
    mv_specimens_mids_simplified.mids_level,
    mv_specimens_mids_simplified.collection_ref
   FROM (darwin2.mv_specimens_mids_simplified
     LEFT JOIN darwin2.v_rmca_collections_path_as_text ON ((mv_specimens_mids_simplified.collection_ref = v_rmca_collections_path_as_text.id)))
  WITH NO DATA;


ALTER TABLE darwin2.mv_specimens_mids_simplified_coll_hierarchy OWNER TO darwin2;

--
-- TOC entry 531 (class 1259 OID 1757545)
-- Name: mv_mids_stat_larissa; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.mv_mids_stat_larissa AS
 SELECT DISTINCT mv_specimens_mids_simplified_coll_hierarchy.collection_path_text,
    (string_to_array(mv_specimens_mids_simplified_coll_hierarchy.collection_path_text, '/'::text))[1] AS main_collection,
    (string_to_array(mv_specimens_mids_simplified_coll_hierarchy.collection_path_text, '/'::text))[2] AS sub_collection_1,
    (string_to_array(mv_specimens_mids_simplified_coll_hierarchy.collection_path_text, '/'::text))[3] AS sub_collection_2,
    mv_specimens_mids_simplified_coll_hierarchy.collection_name,
    mv_specimens_mids_simplified_coll_hierarchy.mids_level,
    mv_specimens_mids_simplified_coll_hierarchy.container_type,
    mv_specimens_mids_simplified_coll_hierarchy.container_storage,
    count(*) AS count
   FROM darwin2.mv_specimens_mids_simplified_coll_hierarchy
  GROUP BY mv_specimens_mids_simplified_coll_hierarchy.collection_path_text, mv_specimens_mids_simplified_coll_hierarchy.collection_name, mv_specimens_mids_simplified_coll_hierarchy.container_type, mv_specimens_mids_simplified_coll_hierarchy.container_storage, mv_specimens_mids_simplified_coll_hierarchy.mids_level
  ORDER BY mv_specimens_mids_simplified_coll_hierarchy.collection_path_text, mv_specimens_mids_simplified_coll_hierarchy.collection_name, mv_specimens_mids_simplified_coll_hierarchy.mids_level
  WITH NO DATA;


ALTER TABLE darwin2.mv_mids_stat_larissa OWNER TO darwin2;

--
-- TOC entry 532 (class 1259 OID 1757553)
-- Name: mv_specimens_mids_simplified_coll_hierarchy_2; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.mv_specimens_mids_simplified_coll_hierarchy_2 AS
 SELECT v_rmca_collections_path_as_text.collection_path_text,
    mv_specimens_mids_simplified.collection_name,
    (string_to_array(v_rmca_collections_path_as_text.collection_path_text, '/'::text))[1] AS main_collection,
    (string_to_array(v_rmca_collections_path_as_text.collection_path_text, '/'::text))[2] AS sub_collection,
    (string_to_array(v_rmca_collections_path_as_text.collection_path_text, '/'::text))[3] AS sub_collection_2,
    mv_specimens_mids_simplified.id,
    mv_specimens_mids_simplified.type,
    mv_specimens_mids_simplified.family,
    mv_specimens_mids_simplified.gtu_country_tag_value,
    mv_specimens_mids_simplified.gtu_province_tag_value,
    mv_specimens_mids_simplified.gtu_others_tag_value,
    mv_specimens_mids_simplified.container_type,
    mv_specimens_mids_simplified.container_storage,
    mv_specimens_mids_simplified.mids_level,
    mv_specimens_mids_simplified.collection_ref
   FROM (darwin2.mv_specimens_mids_simplified
     LEFT JOIN darwin2.v_rmca_collections_path_as_text ON ((mv_specimens_mids_simplified.collection_ref = v_rmca_collections_path_as_text.id)))
  WITH NO DATA;


ALTER TABLE darwin2.mv_specimens_mids_simplified_coll_hierarchy_2 OWNER TO darwin2;

--
-- TOC entry 533 (class 1259 OID 1757564)
-- Name: mv_mids_stats_larissa_with_type_country; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.mv_mids_stats_larissa_with_type_country AS
 SELECT DISTINCT mv_specimens_mids_simplified_coll_hierarchy_2.collection_path_text,
    mv_specimens_mids_simplified_coll_hierarchy_2.collection_name,
    mv_specimens_mids_simplified_coll_hierarchy_2.main_collection,
    mv_specimens_mids_simplified_coll_hierarchy_2.sub_collection,
    mv_specimens_mids_simplified_coll_hierarchy_2.sub_collection_2,
    mv_specimens_mids_simplified_coll_hierarchy_2.mids_level,
    mv_specimens_mids_simplified_coll_hierarchy_2.type,
    mv_specimens_mids_simplified_coll_hierarchy_2.gtu_country_tag_value,
    mv_specimens_mids_simplified_coll_hierarchy_2.container_type,
    mv_specimens_mids_simplified_coll_hierarchy_2.container_storage,
    count(*) AS count
   FROM darwin2.mv_specimens_mids_simplified_coll_hierarchy_2
  GROUP BY mv_specimens_mids_simplified_coll_hierarchy_2.collection_path_text, mv_specimens_mids_simplified_coll_hierarchy_2.collection_name, mv_specimens_mids_simplified_coll_hierarchy_2.main_collection, mv_specimens_mids_simplified_coll_hierarchy_2.sub_collection, mv_specimens_mids_simplified_coll_hierarchy_2.sub_collection_2, mv_specimens_mids_simplified_coll_hierarchy_2.mids_level, mv_specimens_mids_simplified_coll_hierarchy_2.type, mv_specimens_mids_simplified_coll_hierarchy_2.gtu_country_tag_value, mv_specimens_mids_simplified_coll_hierarchy_2.container_type, mv_specimens_mids_simplified_coll_hierarchy_2.container_storage;


ALTER TABLE darwin2.mv_mids_stats_larissa_with_type_country OWNER TO darwin2;

--
-- TOC entry 342 (class 1259 OID 19530)
-- Name: template_people; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_people (
    is_physical boolean DEFAULT true NOT NULL,
    sub_type character varying,
    formated_name character varying NOT NULL,
    formated_name_indexed character varying NOT NULL,
    formated_name_unique character varying NOT NULL,
    title character varying DEFAULT ''::character varying NOT NULL,
    family_name character varying NOT NULL,
    given_name character varying,
    additional_names character varying,
    birth_date_mask integer DEFAULT 0 NOT NULL,
    birth_date date DEFAULT '0001-01-01'::date NOT NULL,
    gender character(1),
    CONSTRAINT genders_chk CHECK ((gender = ANY (ARRAY['M'::bpchar, 'F'::bpchar])))
);


ALTER TABLE darwin2.template_people OWNER TO darwin2;

--
-- TOC entry 7156 (class 0 OID 0)
-- Dependencies: 342
-- Name: TABLE template_people; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_people IS 'Template table used to describe user/people tables';


--
-- TOC entry 7157 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.is_physical; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.is_physical IS 'Type of user/person: physical or moral - true is physical, false is moral';


--
-- TOC entry 7158 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.sub_type IS 'Used for moral user/persons: precise nature - public institution, asbl, sprl, sa,...';


--
-- TOC entry 7159 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.formated_name IS 'Complete user/person formated name (with honorific mention, prefixes, suffixes,...) - By default composed with family_name and given_name fields, but can be modified by hand';


--
-- TOC entry 7160 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.formated_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.formated_name_indexed IS 'Indexed form of formated_name field';


--
-- TOC entry 7161 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.formated_name_unique; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.formated_name_unique IS 'Indexed form of formated_name field (for unique index purpose)';


--
-- TOC entry 7162 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.title IS 'Title of a physical user/person like Mr or Mrs or phd,...';


--
-- TOC entry 7163 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.family_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.family_name IS 'Family name for physical user/persons and Organisation name for moral user/persons';


--
-- TOC entry 7164 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.given_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.given_name IS 'User/person''s given name - usually first name';


--
-- TOC entry 7165 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.additional_names; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.additional_names IS 'Any additional names given to user/person';


--
-- TOC entry 7166 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.birth_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.birth_date_mask IS 'Contains the Mask flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 7167 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.birth_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.birth_date IS 'Birth/Creation date composed';


--
-- TOC entry 7168 (class 0 OID 0)
-- Dependencies: 342
-- Name: COLUMN template_people.gender; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.gender IS 'For physical user/persons give the gender: M or F';


--
-- TOC entry 343 (class 1259 OID 19541)
-- Name: people; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people (
    id integer NOT NULL,
    end_date_mask integer DEFAULT 0 NOT NULL,
    end_date date DEFAULT '2038-12-31'::date NOT NULL,
    activity_date_from_mask integer DEFAULT 0 NOT NULL,
    activity_date_from date DEFAULT '0001-01-01'::date NOT NULL,
    activity_date_to_mask integer DEFAULT 0 NOT NULL,
    activity_date_to date DEFAULT '2038-12-31'::date NOT NULL,
    name_formated_indexed character varying DEFAULT ''::character varying NOT NULL,
    import_ref integer
)
INHERITS (darwin2.template_people);


ALTER TABLE darwin2.people OWNER TO darwin2;

--
-- TOC entry 7169 (class 0 OID 0)
-- Dependencies: 343
-- Name: TABLE people; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people IS 'All physical and moral persons used in the application are here stored';


--
-- TOC entry 7170 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.is_physical; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.is_physical IS 'Type of person: physical or moral - true is physical, false is moral';


--
-- TOC entry 7171 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.sub_type IS 'Used for moral persons: precise nature - public institution, asbl, sprl, sa,...';


--
-- TOC entry 7172 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.formated_name IS 'Complete person formated name (with honorific mention, prefixes, suffixes,...) - By default composed with family_name and given_name fields, but can be modified by hand';


--
-- TOC entry 7173 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.formated_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.formated_name_indexed IS 'Indexed form of formated_name field';


--
-- TOC entry 7174 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.title IS 'Title of a physical user/person like Mr or Mrs or phd,...';


--
-- TOC entry 7175 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.family_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.family_name IS 'Family name for physical persons and Organisation name for moral persons';


--
-- TOC entry 7176 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.given_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.given_name IS 'User/person''s given name - usually first name';


--
-- TOC entry 7177 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.additional_names; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.additional_names IS 'Any additional names given to person';


--
-- TOC entry 7178 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.birth_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.birth_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 7179 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.birth_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.birth_date IS 'Day of birth/creation';


--
-- TOC entry 7180 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.gender; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.gender IS 'For physical persons give the gender: M or F';


--
-- TOC entry 7181 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.id IS 'Unique identifier of a person';


--
-- TOC entry 7182 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.end_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.end_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 7183 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.end_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.end_date IS 'End date';


--
-- TOC entry 7184 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.activity_date_from_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.activity_date_from_mask IS 'person general activity period or person activity period in the organization referenced date from mask';


--
-- TOC entry 7185 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.activity_date_from; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.activity_date_from IS 'person general activity period or person activity period in the organization referenced date from';


--
-- TOC entry 7186 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.activity_date_to_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.activity_date_to_mask IS 'person general activity period or person activity period in the organization referenced date to mask';


--
-- TOC entry 7187 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.activity_date_to; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.activity_date_to IS 'person general activity period or person activity period in the organization referenced date to';


--
-- TOC entry 7188 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN people.name_formated_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.name_formated_indexed IS 'The indexed form of given_name and family_name (the inverse of formated_name_indexed for searching)';


--
-- TOC entry 371 (class 1259 OID 19719)
-- Name: specimens_stable_ids_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimens_stable_ids_id_seq
    START WITH 716034
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimens_stable_ids_id_seq OWNER TO darwin2;

--
-- TOC entry 372 (class 1259 OID 19721)
-- Name: specimens_stable_ids; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimens_stable_ids (
    id bigint DEFAULT nextval('darwin2.specimens_stable_ids_id_seq'::regclass) NOT NULL,
    specimen_ref bigint NOT NULL,
    original_id bigint NOT NULL,
    uuid uuid DEFAULT public.uuid_generate_v4(),
    doi character varying,
    specimen_fk bigint
);


ALTER TABLE darwin2.specimens_stable_ids OWNER TO darwin2;

--
-- TOC entry 7189 (class 0 OID 0)
-- Dependencies: 372
-- Name: COLUMN specimens_stable_ids.uuid; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_stable_ids.uuid IS 'UUID column (CETAF field)';


--
-- TOC entry 394 (class 1259 OID 19836)
-- Name: tags; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tags (
    gtu_ref integer NOT NULL,
    group_ref integer NOT NULL,
    group_type character varying NOT NULL,
    sub_group_type character varying NOT NULL,
    tag character varying NOT NULL,
    tag_indexed character varying NOT NULL
);


ALTER TABLE darwin2.tags OWNER TO darwin2;

--
-- TOC entry 7190 (class 0 OID 0)
-- Dependencies: 394
-- Name: TABLE tags; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.tags IS 'List of calculated tags for a groups. This is only for query purpose (filled by triggers)';


--
-- TOC entry 7191 (class 0 OID 0)
-- Dependencies: 394
-- Name: COLUMN tags.gtu_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.gtu_ref IS 'Reference to a Gtu';


--
-- TOC entry 7192 (class 0 OID 0)
-- Dependencies: 394
-- Name: COLUMN tags.group_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.group_ref IS 'Reference of the Group name under which the tag is grouped';


--
-- TOC entry 7193 (class 0 OID 0)
-- Dependencies: 394
-- Name: COLUMN tags.group_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.group_type IS 'Indexed form of a group name';


--
-- TOC entry 7194 (class 0 OID 0)
-- Dependencies: 394
-- Name: COLUMN tags.sub_group_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.sub_group_type IS 'Indexed form of a sub-group name';


--
-- TOC entry 7195 (class 0 OID 0)
-- Dependencies: 394
-- Name: COLUMN tags.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.tag IS 'The readable version of the tag';


--
-- TOC entry 7196 (class 0 OID 0)
-- Dependencies: 394
-- Name: COLUMN tags.tag_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.tag_indexed IS 'The indexed version of the tag';


--
-- TOC entry 539 (class 1259 OID 1867961)
-- Name: v_collections_full_path_recursive; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_collections_full_path_recursive AS
 WITH RECURSIVE collections_path_recursive AS (
         SELECT collections.id,
            collections.collection_type,
            collections.code,
            collections.name,
            collections.name_indexed,
            collections.institution_ref,
            collections.main_manager_ref,
            collections.staff_ref,
            collections.parent_ref,
            collections.path,
            collections.code_auto_increment,
            collections.code_last_value,
            collections.code_prefix,
            collections.code_prefix_separator,
            collections.code_suffix,
            collections.code_suffix_separator,
            collections.code_specimen_duplicate,
            collections.is_public,
            collections.code_mask,
            collections.loan_auto_increment,
            collections.loan_last_value,
            collections.code_ai_inherit,
            collections.code_auto_increment_for_insert_only,
            collections.nagoya,
            collections.allow_duplicates,
            collections.code AS code_full_path,
            collections.name AS name_full_path,
            collections.name_indexed AS name_indexed_full_path
           FROM darwin2.collections
          WHERE (collections.parent_ref IS NULL)
        UNION ALL
         SELECT collections.id,
            collections.collection_type,
            collections.code,
            collections.name,
            collections.name_indexed,
            collections.institution_ref,
            collections.main_manager_ref,
            collections.staff_ref,
            collections.parent_ref,
            collections.path,
            collections.code_auto_increment,
            collections.code_last_value,
            collections.code_prefix,
            collections.code_prefix_separator,
            collections.code_suffix,
            collections.code_suffix_separator,
            collections.code_specimen_duplicate,
            collections.is_public,
            collections.code_mask,
            collections.loan_auto_increment,
            collections.loan_last_value,
            collections.code_ai_inherit,
            collections.code_auto_increment_for_insert_only,
            collections.nagoya,
            collections.allow_duplicates,
            (((collections_path_recursive_1.code_full_path)::text || '/'::text) || (collections.code)::text),
            (((collections_path_recursive_1.name_full_path)::text || '/'::text) || (collections.name)::text),
            (((collections_path_recursive_1.name_indexed_full_path)::text || '/'::text) || (collections.name_indexed)::text)
           FROM (darwin2.collections
             JOIN collections_path_recursive collections_path_recursive_1 ON ((collections.parent_ref = collections_path_recursive_1.id)))
        )
 SELECT collections_path_recursive.id,
    collections_path_recursive.collection_type,
    collections_path_recursive.code,
    collections_path_recursive.name,
    collections_path_recursive.name_indexed,
    collections_path_recursive.institution_ref,
    collections_path_recursive.main_manager_ref,
    collections_path_recursive.staff_ref,
    collections_path_recursive.parent_ref,
    collections_path_recursive.path,
    collections_path_recursive.code_auto_increment,
    collections_path_recursive.code_last_value,
    collections_path_recursive.code_prefix,
    collections_path_recursive.code_prefix_separator,
    collections_path_recursive.code_suffix,
    collections_path_recursive.code_suffix_separator,
    collections_path_recursive.code_specimen_duplicate,
    collections_path_recursive.is_public,
    collections_path_recursive.code_mask,
    collections_path_recursive.loan_auto_increment,
    collections_path_recursive.loan_last_value,
    collections_path_recursive.code_ai_inherit,
    collections_path_recursive.code_auto_increment_for_insert_only,
    collections_path_recursive.nagoya,
    collections_path_recursive.allow_duplicates,
    collections_path_recursive.code_full_path,
    collections_path_recursive.name_full_path,
    collections_path_recursive.name_indexed_full_path
   FROM collections_path_recursive;


ALTER TABLE darwin2.v_collections_full_path_recursive OWNER TO darwin2;

--
-- TOC entry 545 (class 1259 OID 1882666)
-- Name: mv_specimen_public; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.mv_specimen_public AS
 WITH specimens_ori AS (
         SELECT specimens_stable_ids.uuid,
            specimens_1.id,
            (((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text) AS code_display,
            codes.full_code_indexed,
            specimens_1.taxon_path,
            specimens_1.taxon_ref,
            specimens_1.collection_ref,
            specimens_1.gtu_country_tag_indexed,
            specimens_1.gtu_country_tag_value,
            specimens_1.gtu_others_tag_indexed AS localities_indexed,
            specimens_1.gtu_others_tag_value,
            specimens_1.taxon_name,
            specimens_1.sex,
            specimens_1.spec_coll_ids AS collector_ids,
            specimens_1.spec_don_sel_ids AS donator_ids,
            specimens_1.gtu_from_date,
            specimens_1.gtu_from_date_mask,
            specimens_1.gtu_to_date,
            specimens_1.gtu_to_date_mask,
            specimens_1.type AS coll_type,
            unnest(
                CASE
                    WHEN (specimens_1.gtu_country_tag_indexed IS NOT NULL) THEN specimens_1.gtu_country_tag_indexed
                    ELSE '{unknown}'::character varying[]
                END) AS country_unnest,
            ext_links_thumbnails.url AS urls_thumbnails,
            ext_links_thumbnails.category AS image_category_thumbnails,
            ext_links_thumbnails.contributor AS contributor_thumbnails,
            ext_links_thumbnails.disclaimer AS disclaimer_thumbnails,
            ext_links_thumbnails.license AS license_thumbnails,
            ext_links_thumbnails.display_order AS display_order_thumbnails,
            ext_links_image_links.url AS urls_image_links,
            ext_links_image_links.category AS image_category_image_links,
            ext_links_image_links.contributor AS contributor_image_links,
            ext_links_image_links.disclaimer AS disclaimer_image_links,
            ext_links_image_links.license AS license_image_links,
            ext_links_image_links.display_order AS display_order_image_links,
            ext_links_3d_snippets.url AS urls_3d_snippets,
            ext_links_3d_snippets.category AS image_category_3d_snippets,
            ext_links_3d_snippets.contributor AS contributor_3d_snippets,
            ext_links_3d_snippets.disclaimer AS disclaimer_3d_snippets,
            ext_links_3d_snippets.license AS license_3d_snippets,
            ext_links_3d_snippets.display_order AS display_order_3d_snippets,
            specimens_1.gtu_location[1] AS latitude,
            specimens_1.gtu_location[0] AS longitude,
            identifications.notion_date AS identification_date,
            identifications.notion_date_mask AS identification_date_mask,
            (COALESCE((darwin2.fct_mask_date(identifications.notion_date, identifications.notion_date_mask) || ': '::text), ''::text) || (specimens_1.taxon_name)::text) AS history,
            specimens_1.gtu_ref,
            tags.group_type,
            tags.sub_group_type,
            tags.tag,
            (((((tags.group_type)::text || '-'::text) || (tags.sub_group_type)::text) || ':'::text) || (tags.tag)::text) AS tag_locality,
            darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens_1.taxon_ref, 34) AS family,
            darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens_1.taxon_ref, 28) AS t_order,
            darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens_1.taxon_ref, 12) AS class,
            specimens_1.specimen_count_min,
            specimens_1.specimen_count_males_min,
            specimens_1.specimen_count_females_min
           FROM (((((((darwin2.specimens specimens_1
             LEFT JOIN darwin2.codes ON ((((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text) AND (specimens_1.id = codes.record_id))))
             LEFT JOIN darwin2.ext_links ext_links_thumbnails ON (((specimens_1.id = ext_links_thumbnails.record_id) AND ((ext_links_thumbnails.referenced_relation)::text = 'specimens'::text) AND ((ext_links_thumbnails.category)::text = 'thumbnail'::text))))
             LEFT JOIN darwin2.ext_links ext_links_image_links ON (((specimens_1.id = ext_links_image_links.record_id) AND ((ext_links_image_links.referenced_relation)::text = 'specimens'::text) AND ((ext_links_image_links.category)::text = 'image_link'::text))))
             LEFT JOIN darwin2.ext_links ext_links_3d_snippets ON (((specimens_1.id = ext_links_3d_snippets.record_id) AND ((ext_links_3d_snippets.referenced_relation)::text = 'specimens'::text) AND ((ext_links_3d_snippets.category)::text = 'html_3d_snippet'::text))))
             LEFT JOIN darwin2.identifications ON ((((identifications.referenced_relation)::text = 'specimens'::text) AND (specimens_1.id = identifications.record_id) AND ((identifications.notion_concerned)::text = 'taxonomy'::text))))
             LEFT JOIN darwin2.tags ON ((specimens_1.gtu_ref = tags.gtu_ref)))
             LEFT JOIN darwin2.specimens_stable_ids ON ((specimens_1.id = specimens_stable_ids.specimen_ref)))
        ), specimens_tmp AS (
         SELECT specimens_ori.uuid,
            specimens_ori.id,
            specimens_ori.code_display,
            specimens_ori.full_code_indexed,
            specimens_ori.taxon_path,
            specimens_ori.taxon_ref,
            specimens_ori.collection_ref,
            specimens_ori.gtu_country_tag_indexed,
            specimens_ori.gtu_country_tag_value,
            specimens_ori.localities_indexed,
            specimens_ori.gtu_others_tag_value,
            specimens_ori.taxon_name,
            specimens_ori.sex,
            specimens_ori.collector_ids,
            specimens_ori.donator_ids,
            specimens_ori.gtu_from_date,
            specimens_ori.gtu_from_date_mask,
            specimens_ori.gtu_to_date,
            specimens_ori.gtu_to_date_mask,
            specimens_ori.coll_type,
            specimens_ori.country_unnest,
            specimens_ori.urls_thumbnails,
            specimens_ori.image_category_thumbnails,
            specimens_ori.contributor_thumbnails,
            specimens_ori.disclaimer_thumbnails,
            specimens_ori.license_thumbnails,
            specimens_ori.display_order_thumbnails,
            specimens_ori.urls_image_links,
            specimens_ori.image_category_image_links,
            specimens_ori.contributor_image_links,
            specimens_ori.disclaimer_image_links,
            specimens_ori.license_image_links,
            specimens_ori.display_order_image_links,
            specimens_ori.urls_3d_snippets,
            specimens_ori.image_category_3d_snippets,
            specimens_ori.contributor_3d_snippets,
            specimens_ori.disclaimer_3d_snippets,
            specimens_ori.license_3d_snippets,
            specimens_ori.display_order_3d_snippets,
            specimens_ori.latitude,
            specimens_ori.longitude,
            specimens_ori.identification_date,
            specimens_ori.identification_date_mask,
            specimens_ori.history,
            specimens_ori.gtu_ref,
            specimens_ori.group_type,
            specimens_ori.sub_group_type,
            specimens_ori.tag,
            specimens_ori.tag_locality,
            specimens_ori.family,
            specimens_ori.t_order,
            specimens_ori.class,
            specimens_ori.specimen_count_min,
            specimens_ori.specimen_count_males_min,
            specimens_ori.specimen_count_females_min,
            collections.code_full_path AS collection_code_full_path,
            collections.name_full_path AS collection_name_full_path
           FROM ((specimens_ori
             JOIN darwin2.v_collections_full_path_recursive collections ON (((specimens_ori.collection_ref = collections.id) AND (collections.is_public = true))))
             JOIN darwin2.taxonomy ON (((specimens_ori.taxon_ref = taxonomy.id) AND (COALESCE(taxonomy.sensitive_info_withheld, false) = false))))
          WHERE (collections.is_public = true)
        )
 SELECT DISTINCT specimens_tmp.uuid,
    array_agg(DISTINCT specimens_tmp.id) AS ids,
    specimens_tmp.code_display,
    array_agg(DISTINCT specimens_tmp.taxon_path) AS taxon_paths,
    array_agg(DISTINCT specimens_tmp.taxon_ref) AS taxon_ref,
    array_agg(DISTINCT specimens_tmp.taxon_name) AS taxon_name,
    specimens_tmp.sex,
    array_agg(DISTINCT specimens_tmp.history) AS history_identification,
    specimens_tmp.gtu_country_tag_value,
    specimens_tmp.gtu_others_tag_value,
    specimens_tmp.gtu_from_date,
    specimens_tmp.gtu_from_date_mask,
    specimens_tmp.gtu_to_date,
    specimens_tmp.gtu_to_date_mask,
    darwin2.fct_mask_date(specimens_tmp.gtu_to_date, specimens_tmp.gtu_to_date_mask) AS fct_mask_date,
    darwin2.fct_mask_date(specimens_tmp.gtu_from_date, specimens_tmp.gtu_from_date_mask) AS date_from_display,
    darwin2.fct_mask_date(specimens_tmp.gtu_to_date, specimens_tmp.gtu_to_date_mask) AS date_to_display,
    specimens_tmp.coll_type,
    string_agg(DISTINCT (specimens_tmp.urls_thumbnails)::text, '|'::text) AS urls_thumbnails,
    string_agg(DISTINCT (specimens_tmp.image_category_thumbnails)::text, '|'::text) AS image_category_thumbnails,
    string_agg(DISTINCT (specimens_tmp.contributor_thumbnails)::text, '|'::text) AS contributor_thumbnails,
    string_agg(DISTINCT (specimens_tmp.disclaimer_thumbnails)::text, '|'::text) AS disclaimer_thumbnails,
    string_agg(DISTINCT (specimens_tmp.license_thumbnails)::text, '|'::text) AS license_thumbnails,
    string_agg(DISTINCT ((specimens_tmp.display_order_thumbnails)::character varying)::text, '|'::text) AS display_order_thumbnails,
    string_agg(DISTINCT (specimens_tmp.urls_image_links)::text, '|'::text) AS urls_image_links,
    string_agg(DISTINCT (specimens_tmp.image_category_image_links)::text, '|'::text) AS image_category_image_links,
    string_agg(DISTINCT (specimens_tmp.contributor_image_links)::text, '|'::text) AS contributor_image_links,
    string_agg(DISTINCT (specimens_tmp.disclaimer_image_links)::text, '|'::text) AS disclaimer_image_links,
    string_agg(DISTINCT (specimens_tmp.license_image_links)::text, '|'::text) AS license_image_links,
    string_agg(DISTINCT ((specimens_tmp.display_order_image_links)::character varying)::text, '|'::text) AS display_order_image_links,
    string_agg(DISTINCT (specimens_tmp.urls_3d_snippets)::text, '|'::text) AS urls_3d_snippets,
    string_agg(DISTINCT (specimens_tmp.image_category_3d_snippets)::text, '|'::text) AS image_category_3d_snippets,
    string_agg(DISTINCT (specimens_tmp.contributor_3d_snippets)::text, '|'::text) AS contributor_3d_snippets,
    string_agg(DISTINCT (specimens_tmp.disclaimer_3d_snippets)::text, '|'::text) AS disclaimer_3d_snippets,
    string_agg(DISTINCT (specimens_tmp.license_3d_snippets)::text, '|'::text) AS license_3d_snippets,
    string_agg(DISTINCT ((specimens_tmp.display_order_3d_snippets)::character varying)::text, '|'::text) AS display_order_3d_snippets,
    specimens_tmp.longitude,
    specimens_tmp.latitude,
    specimens_tmp.collector_ids,
    ( SELECT array_agg(people.formated_name) AS array_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens_tmp.collector_ids))) AS collectors,
    specimens_tmp.donator_ids,
    ( SELECT array_agg(people.formated_name) AS array_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens_tmp.donator_ids))) AS donators,
    array_agg(DISTINCT (('"'::text || specimens_tmp.tag_locality) || '"'::text)) AS localities,
    string_agg(DISTINCT (specimens_tmp.family)::text, ';'::text) AS family,
    string_agg(DISTINCT (specimens_tmp.t_order)::text, ';'::text) AS t_order,
    string_agg(DISTINCT (specimens_tmp.class)::text, ';'::text) AS class,
    specimens_tmp.specimen_count_min,
    specimens_tmp.specimen_count_males_min,
    specimens_tmp.specimen_count_females_min,
    specimens_tmp.collection_code_full_path,
    specimens_tmp.collection_name_full_path
   FROM specimens_tmp
  GROUP BY specimens_tmp.code_display, specimens_tmp.gtu_country_tag_value, specimens_tmp.gtu_others_tag_value, specimens_tmp.gtu_from_date, specimens_tmp.gtu_from_date_mask, specimens_tmp.gtu_to_date, specimens_tmp.gtu_to_date_mask, specimens_tmp.coll_type, specimens_tmp.longitude, specimens_tmp.latitude, specimens_tmp.collector_ids, specimens_tmp.donator_ids, specimens_tmp.sex, specimens_tmp.specimen_count_min, specimens_tmp.specimen_count_males_min, specimens_tmp.specimen_count_females_min, specimens_tmp.uuid, specimens_tmp.collection_code_full_path, specimens_tmp.collection_name_full_path
  WITH NO DATA;


ALTER TABLE darwin2.mv_specimen_public OWNER TO darwin2;

--
-- TOC entry 528 (class 1259 OID 1757470)
-- Name: mv_specimens_mids; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.mv_specimens_mids AS
 SELECT v_specimens_mids.id,
    v_specimens_mids.main_code,
    v_specimens_mids.category,
    v_specimens_mids.collection_ref,
    v_specimens_mids.expedition_ref,
    v_specimens_mids.gtu_ref,
    v_specimens_mids.taxon_ref,
    v_specimens_mids.litho_ref,
    v_specimens_mids.chrono_ref,
    v_specimens_mids.lithology_ref,
    v_specimens_mids.mineral_ref,
    v_specimens_mids.acquisition_category,
    v_specimens_mids.acquisition_date_mask,
    v_specimens_mids.acquisition_date,
    v_specimens_mids.station_visible,
    v_specimens_mids.ig_ref,
    v_specimens_mids.type,
    v_specimens_mids.type_group,
    v_specimens_mids.type_search,
    v_specimens_mids.sex,
    v_specimens_mids.stage,
    v_specimens_mids.state,
    v_specimens_mids.social_status,
    v_specimens_mids.rock_form,
    v_specimens_mids.specimen_part,
    v_specimens_mids.complete,
    v_specimens_mids.institution_ref,
    v_specimens_mids.building,
    v_specimens_mids.floor,
    v_specimens_mids.room,
    v_specimens_mids."row",
    v_specimens_mids.shelf,
    v_specimens_mids.container,
    v_specimens_mids.sub_container,
    v_specimens_mids.container_type,
    v_specimens_mids.sub_container_type,
    v_specimens_mids.container_storage,
    v_specimens_mids.sub_container_storage,
    v_specimens_mids.surnumerary,
    v_specimens_mids.specimen_status,
    v_specimens_mids.specimen_count_min,
    v_specimens_mids.specimen_count_max,
    v_specimens_mids.object_name,
    v_specimens_mids.object_name_indexed,
    v_specimens_mids.spec_ident_ids,
    v_specimens_mids.spec_coll_ids,
    v_specimens_mids.spec_don_sel_ids,
    v_specimens_mids.collection_type,
    v_specimens_mids.collection_code,
    v_specimens_mids.collection_name,
    v_specimens_mids.collection_is_public,
    v_specimens_mids.collection_parent_ref,
    v_specimens_mids.collection_path,
    v_specimens_mids.expedition_name,
    v_specimens_mids.expedition_name_indexed,
    v_specimens_mids.gtu_code,
    v_specimens_mids.gtu_from_date_mask,
    v_specimens_mids.gtu_from_date,
    v_specimens_mids.gtu_to_date_mask,
    v_specimens_mids.gtu_to_date,
    v_specimens_mids.gtu_tag_values_indexed,
    v_specimens_mids.gtu_country_tag_value,
    v_specimens_mids.gtu_country_tag_indexed,
    v_specimens_mids.gtu_province_tag_value,
    v_specimens_mids.gtu_province_tag_indexed,
    v_specimens_mids.gtu_others_tag_value,
    v_specimens_mids.gtu_others_tag_indexed,
    v_specimens_mids.gtu_elevation,
    v_specimens_mids.gtu_elevation_accuracy,
    v_specimens_mids.taxon_name,
    v_specimens_mids.taxon_name_indexed,
    v_specimens_mids.taxon_level_ref,
    v_specimens_mids.taxon_level_name,
    v_specimens_mids.taxon_status,
    v_specimens_mids.taxon_path,
    v_specimens_mids.taxon_parent_ref,
    v_specimens_mids.taxon_extinct,
    v_specimens_mids.litho_name,
    v_specimens_mids.family,
    v_specimens_mids.litho_name_indexed,
    v_specimens_mids.litho_level_ref,
    v_specimens_mids.litho_level_name,
    v_specimens_mids.litho_status,
    v_specimens_mids.litho_local,
    v_specimens_mids.litho_color,
    v_specimens_mids.litho_path,
    v_specimens_mids.litho_parent_ref,
    v_specimens_mids.chrono_name,
    v_specimens_mids.chrono_name_indexed,
    v_specimens_mids.chrono_level_ref,
    v_specimens_mids.chrono_level_name,
    v_specimens_mids.chrono_status,
    v_specimens_mids.chrono_local,
    v_specimens_mids.chrono_color,
    v_specimens_mids.chrono_path,
    v_specimens_mids.chrono_parent_ref,
    v_specimens_mids.lithology_name,
    v_specimens_mids.lithology_name_indexed,
    v_specimens_mids.lithology_level_ref,
    v_specimens_mids.lithology_level_name,
    v_specimens_mids.lithology_status,
    v_specimens_mids.lithology_local,
    v_specimens_mids.lithology_color,
    v_specimens_mids.lithology_path,
    v_specimens_mids.lithology_parent_ref,
    v_specimens_mids.mineral_name,
    v_specimens_mids.mineral_name_indexed,
    v_specimens_mids.mineral_level_ref,
    v_specimens_mids.mineral_level_name,
    v_specimens_mids.mineral_status,
    v_specimens_mids.mineral_local,
    v_specimens_mids.mineral_color,
    v_specimens_mids.mineral_path,
    v_specimens_mids.mineral_parent_ref,
    v_specimens_mids.ig_num,
    v_specimens_mids.ig_num_indexed,
    v_specimens_mids.ig_date_mask,
    v_specimens_mids.ig_date,
    v_specimens_mids.col,
    v_specimens_mids.gtu_location,
    v_specimens_mids.specimen_creation_date,
    v_specimens_mids.import_ref,
    v_specimens_mids.main_code_indexed,
    v_specimens_mids.specimen_count_males_min,
    v_specimens_mids.specimen_count_males_max,
    v_specimens_mids.specimen_count_females_min,
    v_specimens_mids.specimen_count_females_max,
    v_specimens_mids.specimen_count_juveniles_min,
    v_specimens_mids.specimen_count_juveniles_max,
    v_specimens_mids.nagoya,
    v_specimens_mids.uuid,
    v_specimens_mids.mids_level
   FROM darwin2.v_specimens_mids
  WITH NO DATA;


ALTER TABLE darwin2.mv_specimens_mids OWNER TO darwin2;

--
-- TOC entry 337 (class 1259 OID 19493)
-- Name: my_saved_searches; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.my_saved_searches (
    id integer NOT NULL,
    user_ref integer NOT NULL,
    name character varying DEFAULT 'default'::character varying NOT NULL,
    search_criterias character varying NOT NULL,
    favorite boolean DEFAULT false NOT NULL,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    visible_fields_in_result character varying NOT NULL,
    is_only_id boolean DEFAULT false NOT NULL,
    subject character varying DEFAULT 'specimen'::character varying NOT NULL,
    query_where character varying,
    query_parameters character varying
);


ALTER TABLE darwin2.my_saved_searches OWNER TO darwin2;

--
-- TOC entry 7197 (class 0 OID 0)
-- Dependencies: 337
-- Name: TABLE my_saved_searches; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.my_saved_searches IS 'Stores user''s saved searches but also (by default) the last search done';


--
-- TOC entry 7198 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN my_saved_searches.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.user_ref IS 'Reference of user having saved a search';


--
-- TOC entry 7199 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN my_saved_searches.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.name IS 'Name given by user to his/her saved search';


--
-- TOC entry 7200 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN my_saved_searches.search_criterias; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.search_criterias IS 'String field containing the serialization of search criterias';


--
-- TOC entry 7201 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN my_saved_searches.favorite; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.favorite IS 'Flag telling if saved search concerned is one of the favorites or not';


--
-- TOC entry 7202 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN my_saved_searches.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.modification_date_time IS 'Last modification or entry date and time';


--
-- TOC entry 7203 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN my_saved_searches.visible_fields_in_result; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.visible_fields_in_result IS 'Array of fields that were set visible in the result table at the time the search was saved';


--
-- TOC entry 7204 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN my_saved_searches.is_only_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.is_only_id IS 'Tell if the search only contains saved specimen (ids) or it is a normal saved search';


--
-- TOC entry 338 (class 1259 OID 19504)
-- Name: my_saved_searches_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.my_saved_searches_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.my_saved_searches_id_seq OWNER TO darwin2;

--
-- TOC entry 7205 (class 0 OID 0)
-- Dependencies: 338
-- Name: my_saved_searches_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.my_saved_searches_id_seq OWNED BY darwin2.my_saved_searches.id;


--
-- TOC entry 339 (class 1259 OID 19506)
-- Name: my_widgets; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.my_widgets (
    id integer NOT NULL,
    user_ref integer NOT NULL,
    category character varying DEFAULT 'board_widget'::character varying NOT NULL,
    group_name character varying NOT NULL,
    order_by smallint DEFAULT 1 NOT NULL,
    col_num smallint DEFAULT 1 NOT NULL,
    mandatory boolean DEFAULT false NOT NULL,
    visible boolean DEFAULT true NOT NULL,
    opened boolean DEFAULT true NOT NULL,
    color character varying DEFAULT '#5BAABD'::character varying NOT NULL,
    is_available boolean DEFAULT false NOT NULL,
    icon_ref integer,
    title_perso character varying(32),
    collections character varying DEFAULT ','::character varying NOT NULL,
    all_public boolean DEFAULT false NOT NULL
);


ALTER TABLE darwin2.my_widgets OWNER TO darwin2;

--
-- TOC entry 7206 (class 0 OID 0)
-- Dependencies: 339
-- Name: TABLE my_widgets; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.my_widgets IS 'Stores user''s preferences for customizable page elements - widgets mainly';


--
-- TOC entry 7207 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.user_ref IS 'Reference of user concerned - id field of users table';


--
-- TOC entry 7208 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.category IS 'Customizable page element category: board widget, encoding widget,...';


--
-- TOC entry 7209 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.group_name IS 'Customizable page element name';


--
-- TOC entry 7210 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.order_by IS 'Absolute order by between page element name';


--
-- TOC entry 7211 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.col_num; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.col_num IS 'Column number - tells in which column the page element concerned is';


--
-- TOC entry 7212 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.mandatory; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.mandatory IS 'Flag telling if the page element can be closed or not';


--
-- TOC entry 7213 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.visible; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.visible IS 'Flag telling if the page element is on the board or in the widget chooser';


--
-- TOC entry 7214 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.opened; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.opened IS 'Flag telling if the page element is opened by default or not';


--
-- TOC entry 7215 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.color; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.color IS 'Color given to page element by user';


--
-- TOC entry 7216 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.is_available; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.is_available IS 'Flag telling if the widget can be used or not';


--
-- TOC entry 7217 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.icon_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.icon_ref IS 'Reference of multimedia icon to be used before page element title';


--
-- TOC entry 7218 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.title_perso; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.title_perso IS 'Page element title given by user';


--
-- TOC entry 7219 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.collections; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.collections IS 'list of collections which user_ref has rights to see';


--
-- TOC entry 7220 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN my_widgets.all_public; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.all_public IS 'Set to determine if the widget available for a registered user by default or not';


--
-- TOC entry 340 (class 1259 OID 19522)
-- Name: my_widgets_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.my_widgets_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.my_widgets_id_seq OWNER TO darwin2;

--
-- TOC entry 7221 (class 0 OID 0)
-- Dependencies: 340
-- Name: my_widgets_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.my_widgets_id_seq OWNED BY darwin2.my_widgets.id;


--
-- TOC entry 341 (class 1259 OID 19524)
-- Name: my_widgets_rmca; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.my_widgets_rmca (
    id integer,
    user_ref integer,
    category character varying,
    group_name character varying,
    order_by smallint,
    col_num smallint,
    mandatory boolean,
    visible boolean,
    opened boolean,
    color character varying,
    is_available boolean,
    icon_ref integer,
    title_perso character varying(32),
    collections character varying,
    all_public boolean
);


ALTER TABLE darwin2.my_widgets_rmca OWNER TO darwin2;

--
-- TOC entry 344 (class 1259 OID 19559)
-- Name: template_people_users_addr_common; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_people_users_addr_common (
    po_box character varying,
    extended_address character varying,
    locality character varying NOT NULL,
    region character varying,
    zip_code character varying,
    country character varying NOT NULL
);


ALTER TABLE darwin2.template_people_users_addr_common OWNER TO darwin2;

--
-- TOC entry 7222 (class 0 OID 0)
-- Dependencies: 344
-- Name: TABLE template_people_users_addr_common; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_people_users_addr_common IS 'Template table used to construct addresses tables for people/users';


--
-- TOC entry 7223 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN template_people_users_addr_common.po_box; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.po_box IS 'PO Box';


--
-- TOC entry 7224 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN template_people_users_addr_common.extended_address; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.extended_address IS 'Address extension: State, Special post zip code characters,...';


--
-- TOC entry 7225 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN template_people_users_addr_common.locality; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.locality IS 'Locality';


--
-- TOC entry 7226 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN template_people_users_addr_common.region; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.region IS 'Region';


--
-- TOC entry 7227 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN template_people_users_addr_common.zip_code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.zip_code IS 'zip code';


--
-- TOC entry 7228 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN template_people_users_addr_common.country; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.country IS 'Country';


--
-- TOC entry 345 (class 1259 OID 19565)
-- Name: template_people_users_comm_common; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_people_users_comm_common (
    person_user_ref integer NOT NULL,
    entry character varying NOT NULL
);


ALTER TABLE darwin2.template_people_users_comm_common OWNER TO darwin2;

--
-- TOC entry 7229 (class 0 OID 0)
-- Dependencies: 345
-- Name: TABLE template_people_users_comm_common; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_people_users_comm_common IS 'Template table used to construct people communication tables (tel and e-mail)';


--
-- TOC entry 7230 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN template_people_users_comm_common.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_comm_common.person_user_ref IS 'Reference of person/user - id field of people/users table';


--
-- TOC entry 7231 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN template_people_users_comm_common.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_comm_common.entry IS 'Communication entry';


--
-- TOC entry 346 (class 1259 OID 19571)
-- Name: people_addresses; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people_addresses (
    id integer NOT NULL,
    tag character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_people_users_comm_common, darwin2.template_people_users_addr_common);


ALTER TABLE darwin2.people_addresses OWNER TO darwin2;

--
-- TOC entry 7232 (class 0 OID 0)
-- Dependencies: 346
-- Name: TABLE people_addresses; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people_addresses IS 'People addresses';


--
-- TOC entry 7233 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.person_user_ref IS 'Reference of the person concerned - id field of people table';


--
-- TOC entry 7234 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.entry IS 'Street address';


--
-- TOC entry 7235 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.po_box; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.po_box IS 'PO Box';


--
-- TOC entry 7236 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.extended_address; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.extended_address IS 'Address extension: State, zip code suffix,...';


--
-- TOC entry 7237 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.locality; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.locality IS 'Locality';


--
-- TOC entry 7238 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.region; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.region IS 'Region';


--
-- TOC entry 7239 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.zip_code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.zip_code IS 'Zip code';


--
-- TOC entry 7240 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.country; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.country IS 'Country';


--
-- TOC entry 7241 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.id IS 'Unique identifier of a person address';


--
-- TOC entry 7242 (class 0 OID 0)
-- Dependencies: 346
-- Name: COLUMN people_addresses.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.tag IS 'List of descriptive tags: home, work,...';


--
-- TOC entry 347 (class 1259 OID 19578)
-- Name: people_addresses_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_addresses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_addresses_id_seq OWNER TO darwin2;

--
-- TOC entry 7243 (class 0 OID 0)
-- Dependencies: 347
-- Name: people_addresses_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.people_addresses_id_seq OWNED BY darwin2.people_addresses.id;


--
-- TOC entry 348 (class 1259 OID 19580)
-- Name: people_align_debug; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people_align_debug (
    filename character varying,
    unitid character varying,
    people_role character varying,
    people_name character varying,
    people_fk integer,
    specimen_fk integer,
    id integer NOT NULL,
    specimen_fks integer[]
);


ALTER TABLE darwin2.people_align_debug OWNER TO darwin2;

--
-- TOC entry 349 (class 1259 OID 19586)
-- Name: people_align_debug_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_align_debug_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_align_debug_id_seq OWNER TO darwin2;

--
-- TOC entry 7244 (class 0 OID 0)
-- Dependencies: 349
-- Name: people_align_debug_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.people_align_debug_id_seq OWNED BY darwin2.people_align_debug.id;


--
-- TOC entry 350 (class 1259 OID 19588)
-- Name: people_comm; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people_comm (
    id integer NOT NULL,
    comm_type character varying DEFAULT 'phone/fax'::character varying NOT NULL,
    tag character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_people_users_comm_common);


ALTER TABLE darwin2.people_comm OWNER TO darwin2;

--
-- TOC entry 7245 (class 0 OID 0)
-- Dependencies: 350
-- Name: TABLE people_comm; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people_comm IS 'People phones and e-mails';


--
-- TOC entry 7246 (class 0 OID 0)
-- Dependencies: 350
-- Name: COLUMN people_comm.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.person_user_ref IS 'Reference of person - id field of people table';


--
-- TOC entry 7247 (class 0 OID 0)
-- Dependencies: 350
-- Name: COLUMN people_comm.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.entry IS 'Communication entry';


--
-- TOC entry 7248 (class 0 OID 0)
-- Dependencies: 350
-- Name: COLUMN people_comm.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.id IS 'Unique identifier of a person communication mean entry';


--
-- TOC entry 7249 (class 0 OID 0)
-- Dependencies: 350
-- Name: COLUMN people_comm.comm_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.comm_type IS 'Type of communication table concerned: address, phone or e-mail';


--
-- TOC entry 7250 (class 0 OID 0)
-- Dependencies: 350
-- Name: COLUMN people_comm.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.tag IS 'List of descriptive tags separated by , : internet, tel, fax, pager, public, private,...';


--
-- TOC entry 351 (class 1259 OID 19596)
-- Name: people_comm_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_comm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_comm_id_seq OWNER TO darwin2;

--
-- TOC entry 7251 (class 0 OID 0)
-- Dependencies: 351
-- Name: people_comm_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.people_comm_id_seq OWNED BY darwin2.people_comm.id;


--
-- TOC entry 352 (class 1259 OID 19598)
-- Name: people_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_id_seq OWNER TO darwin2;

--
-- TOC entry 7252 (class 0 OID 0)
-- Dependencies: 352
-- Name: people_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.people_id_seq OWNED BY darwin2.people.id;


--
-- TOC entry 353 (class 1259 OID 19600)
-- Name: people_languages; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people_languages (
    id integer NOT NULL,
    language_country character varying DEFAULT 'en'::character varying NOT NULL,
    mother boolean DEFAULT true NOT NULL,
    preferred_language boolean DEFAULT false NOT NULL,
    people_ref integer NOT NULL
);


ALTER TABLE darwin2.people_languages OWNER TO darwin2;

--
-- TOC entry 7253 (class 0 OID 0)
-- Dependencies: 353
-- Name: TABLE people_languages; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people_languages IS 'Languages spoken by a given person';


--
-- TOC entry 7254 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN people_languages.language_country; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_languages.language_country IS 'Reference of Language - language_country field of languages_countries table';


--
-- TOC entry 7255 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN people_languages.mother; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_languages.mother IS 'Flag telling if its mother language or not';


--
-- TOC entry 7256 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN people_languages.preferred_language; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_languages.preferred_language IS 'Flag telling which language is preferred in communications';


--
-- TOC entry 7257 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN people_languages.people_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_languages.people_ref IS 'Reference of person - id field of people table';


--
-- TOC entry 354 (class 1259 OID 19609)
-- Name: people_languages_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_languages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_languages_id_seq OWNER TO darwin2;

--
-- TOC entry 7258 (class 0 OID 0)
-- Dependencies: 354
-- Name: people_languages_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.people_languages_id_seq OWNED BY darwin2.people_languages.id;


--
-- TOC entry 355 (class 1259 OID 19611)
-- Name: people_relationships; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people_relationships (
    id integer NOT NULL,
    person_user_role character varying,
    relationship_type character varying DEFAULT 'belongs to'::character varying NOT NULL,
    person_1_ref integer NOT NULL,
    person_2_ref integer NOT NULL,
    path character varying,
    activity_date_from_mask integer DEFAULT 0 NOT NULL,
    activity_date_from date DEFAULT '0001-01-01'::date NOT NULL,
    activity_date_to_mask integer DEFAULT 0 NOT NULL,
    activity_date_to date DEFAULT '2038-12-31'::date NOT NULL
);


ALTER TABLE darwin2.people_relationships OWNER TO darwin2;

--
-- TOC entry 7259 (class 0 OID 0)
-- Dependencies: 355
-- Name: TABLE people_relationships; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people_relationships IS 'Relationships between people - mainly between physical person and moral person: relationship of dependancy';


--
-- TOC entry 7260 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN people_relationships.person_user_role; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.person_user_role IS 'Person role in the organization referenced';


--
-- TOC entry 7261 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN people_relationships.relationship_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.relationship_type IS 'Type of relationship between two persons: belongs to, is department of, is section of, works for,...';


--
-- TOC entry 7262 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN people_relationships.person_1_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.person_1_ref IS 'Reference of person to be puted in relationship with an other - id field of people table';


--
-- TOC entry 7263 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN people_relationships.person_2_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.person_2_ref IS 'Reference of person puted the person puted in relationship with is dependant of - id field of people table';


--
-- TOC entry 7264 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN people_relationships.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.path IS 'Hierarchical path of the organization structure';


--
-- TOC entry 7265 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN people_relationships.activity_date_from_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.activity_date_from_mask IS 'person activity period or person activity period in the organization referenced date from mask';


--
-- TOC entry 7266 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN people_relationships.activity_date_from; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.activity_date_from IS 'person activity period or person activity period in the organization referenced date from';


--
-- TOC entry 7267 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN people_relationships.activity_date_to_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.activity_date_to_mask IS 'person activity period or person activity period in the organization referenced date to mask';


--
-- TOC entry 7268 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN people_relationships.activity_date_to; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.activity_date_to IS 'person activity period or person activity period in the organization referenced date to';


--
-- TOC entry 356 (class 1259 OID 19622)
-- Name: people_relationships_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_relationships_id_seq OWNER TO darwin2;

--
-- TOC entry 7269 (class 0 OID 0)
-- Dependencies: 356
-- Name: people_relationships_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.people_relationships_id_seq OWNED BY darwin2.people_relationships.id;


--
-- TOC entry 357 (class 1259 OID 19624)
-- Name: possible_upper_levels; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.possible_upper_levels (
    level_ref integer NOT NULL,
    level_upper_ref integer
);


ALTER TABLE darwin2.possible_upper_levels OWNER TO darwin2;

--
-- TOC entry 7270 (class 0 OID 0)
-- Dependencies: 357
-- Name: TABLE possible_upper_levels; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.possible_upper_levels IS 'For each level, list all the availble parent levels';


--
-- TOC entry 7271 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN possible_upper_levels.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.possible_upper_levels.level_ref IS 'Reference of current level';


--
-- TOC entry 7272 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN possible_upper_levels.level_upper_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.possible_upper_levels.level_upper_ref IS 'Reference of authorized parent level';


--
-- TOC entry 358 (class 1259 OID 19627)
-- Name: preferences; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.preferences (
    id integer NOT NULL,
    user_ref integer NOT NULL,
    pref_key character varying NOT NULL,
    pref_value character varying NOT NULL
);


ALTER TABLE darwin2.preferences OWNER TO darwin2;

--
-- TOC entry 7273 (class 0 OID 0)
-- Dependencies: 358
-- Name: TABLE preferences; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.preferences IS 'Table to handle users preferences';


--
-- TOC entry 7274 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN preferences.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.preferences.user_ref IS 'The referenced user id';


--
-- TOC entry 7275 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN preferences.pref_key; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.preferences.pref_key IS 'The classification key of the preference. eg: color';


--
-- TOC entry 7276 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN preferences.pref_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.preferences.pref_value IS 'The value of the preference for this user eg: red';


--
-- TOC entry 359 (class 1259 OID 19633)
-- Name: preferences_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.preferences_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.preferences_id_seq OWNER TO darwin2;

--
-- TOC entry 7277 (class 0 OID 0)
-- Dependencies: 359
-- Name: preferences_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.preferences_id_seq OWNED BY darwin2.preferences.id;


--
-- TOC entry 360 (class 1259 OID 19635)
-- Name: properties; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.properties (
    id integer NOT NULL,
    property_type character varying NOT NULL,
    applies_to character varying DEFAULT ''::character varying NOT NULL,
    applies_to_indexed character varying NOT NULL,
    date_from_mask integer DEFAULT 0 NOT NULL,
    date_from timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone NOT NULL,
    date_to_mask integer DEFAULT 0 NOT NULL,
    date_to timestamp without time zone DEFAULT '2038-12-31 00:00:00'::timestamp without time zone NOT NULL,
    is_quantitative boolean DEFAULT false NOT NULL,
    property_unit character varying DEFAULT ''::character varying NOT NULL,
    method character varying,
    method_indexed character varying NOT NULL,
    lower_value character varying NOT NULL,
    lower_value_unified double precision,
    upper_value character varying NOT NULL,
    upper_value_unified double precision,
    property_accuracy character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.properties OWNER TO darwin2;

--
-- TOC entry 7278 (class 0 OID 0)
-- Dependencies: 360
-- Name: TABLE properties; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.properties IS 'All properties or all measurements describing an object in darwin are stored in this table';


--
-- TOC entry 7279 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.referenced_relation IS 'Identifier-Name of the table a property is defined for';


--
-- TOC entry 7280 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.record_id IS 'Identifier of record a property is defined for';


--
-- TOC entry 7281 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.property_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.property_type IS 'Type-Category of property - Latitude, Longitude, Ph, Height, Weight, Color, Temperature, Wind direction,...';


--
-- TOC entry 7282 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.applies_to; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.applies_to IS 'Depending on the use of the type, this can further specify the actual part measured. For example, a measurement of temperature may be a surface, air or sub-surface measurement.';


--
-- TOC entry 7283 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.applies_to_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.applies_to_indexed IS 'Indexed form of Sub type of property - if subtype is null, takes a generic replacement value';


--
-- TOC entry 7284 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.date_from_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.date_from_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 7285 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.date_from; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.date_from IS 'For a range of measurements, give the measurement start - if null, takes a generic replacement value';


--
-- TOC entry 7286 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.date_to_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.date_to_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 7287 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.date_to; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.date_to IS 'For a range of measurements, give the measurement stop date/time - if null, takes a generic replacement value';


--
-- TOC entry 7288 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.property_unit; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.property_unit IS 'Unit used for property value introduced';


--
-- TOC entry 7289 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.method; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.method IS 'Method used to collect property value';


--
-- TOC entry 7290 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.method_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.method_indexed IS 'Indexed version of property_method field - if null, takes a generic replacement value';


--
-- TOC entry 7291 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.lower_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.lower_value IS 'Lower value of Single Value';


--
-- TOC entry 7292 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.lower_value_unified; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.lower_value_unified IS 'unified version of the value for comparison with other units';


--
-- TOC entry 7293 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN properties.property_accuracy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.property_accuracy IS 'Accuracy of the values';


--
-- TOC entry 361 (class 1259 OID 19649)
-- Name: properties_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.properties_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.properties_id_seq OWNER TO darwin2;

--
-- TOC entry 7294 (class 0 OID 0)
-- Dependencies: 361
-- Name: properties_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.properties_id_seq OWNED BY darwin2.properties.id;


--
-- TOC entry 362 (class 1259 OID 19651)
-- Name: specimen_collecting_methods; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimen_collecting_methods (
    id integer NOT NULL,
    specimen_ref integer NOT NULL,
    collecting_method_ref integer NOT NULL
);


ALTER TABLE darwin2.specimen_collecting_methods OWNER TO darwin2;

--
-- TOC entry 7295 (class 0 OID 0)
-- Dependencies: 362
-- Name: TABLE specimen_collecting_methods; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.specimen_collecting_methods IS 'Association of collecting methods with specimens';


--
-- TOC entry 7296 (class 0 OID 0)
-- Dependencies: 362
-- Name: COLUMN specimen_collecting_methods.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_methods.id IS 'Unique identifier of an association';


--
-- TOC entry 7297 (class 0 OID 0)
-- Dependencies: 362
-- Name: COLUMN specimen_collecting_methods.specimen_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_methods.specimen_ref IS 'Identifier of a specimen - comes from specimens table (id field)';


--
-- TOC entry 7298 (class 0 OID 0)
-- Dependencies: 362
-- Name: COLUMN specimen_collecting_methods.collecting_method_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_methods.collecting_method_ref IS 'Identifier of a collecting method - comes from collecting_methods table (id field)';


--
-- TOC entry 363 (class 1259 OID 19654)
-- Name: specimen_collecting_methods_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimen_collecting_methods_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimen_collecting_methods_id_seq OWNER TO darwin2;

--
-- TOC entry 7299 (class 0 OID 0)
-- Dependencies: 363
-- Name: specimen_collecting_methods_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.specimen_collecting_methods_id_seq OWNED BY darwin2.specimen_collecting_methods.id;


--
-- TOC entry 364 (class 1259 OID 19656)
-- Name: specimen_collecting_tools; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimen_collecting_tools (
    id integer NOT NULL,
    specimen_ref integer NOT NULL,
    collecting_tool_ref integer NOT NULL
);


ALTER TABLE darwin2.specimen_collecting_tools OWNER TO darwin2;

--
-- TOC entry 7300 (class 0 OID 0)
-- Dependencies: 364
-- Name: TABLE specimen_collecting_tools; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.specimen_collecting_tools IS 'Association of collecting tools with specimens';


--
-- TOC entry 7301 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN specimen_collecting_tools.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_tools.id IS 'Unique identifier of an association';


--
-- TOC entry 7302 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN specimen_collecting_tools.specimen_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_tools.specimen_ref IS 'Identifier of a specimen - comes from specimens table (id field)';


--
-- TOC entry 7303 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN specimen_collecting_tools.collecting_tool_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_tools.collecting_tool_ref IS 'Identifier of a collecting tool - comes from collecting_tools table (id field)';


--
-- TOC entry 365 (class 1259 OID 19659)
-- Name: specimen_collecting_tools_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimen_collecting_tools_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimen_collecting_tools_id_seq OWNER TO darwin2;

--
-- TOC entry 7304 (class 0 OID 0)
-- Dependencies: 365
-- Name: specimen_collecting_tools_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.specimen_collecting_tools_id_seq OWNED BY darwin2.specimen_collecting_tools.id;


--
-- TOC entry 367 (class 1259 OID 19700)
-- Name: specimens_detect_wrong_countries; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimens_detect_wrong_countries (
    id integer NOT NULL,
    gtu_country_tag_indexed character varying[],
    geom public.geometry
);


ALTER TABLE darwin2.specimens_detect_wrong_countries OWNER TO darwin2;

--
-- TOC entry 368 (class 1259 OID 19706)
-- Name: specimens_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimens_id_seq OWNER TO darwin2;

--
-- TOC entry 7305 (class 0 OID 0)
-- Dependencies: 368
-- Name: specimens_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.specimens_id_seq OWNED BY darwin2.specimens.id;


--
-- TOC entry 369 (class 1259 OID 19708)
-- Name: specimens_relationships; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimens_relationships (
    id integer NOT NULL,
    specimen_ref integer,
    relationship_type character varying DEFAULT 'host'::character varying,
    unit_type character varying DEFAULT 'specimens'::character varying,
    specimen_related_ref integer,
    taxon_ref integer,
    mineral_ref integer,
    institution_ref integer,
    source_name text,
    source_id text,
    quantity numeric(16,2),
    unit character varying DEFAULT '%'::character varying
);


ALTER TABLE darwin2.specimens_relationships OWNER TO darwin2;

--
-- TOC entry 7306 (class 0 OID 0)
-- Dependencies: 369
-- Name: TABLE specimens_relationships; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.specimens_relationships IS 'List all the objects/specimens related the current specimen';


--
-- TOC entry 7307 (class 0 OID 0)
-- Dependencies: 369
-- Name: COLUMN specimens_relationships.specimen_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.specimen_ref IS 'Reference of specimen concerned - id field of specimens table';


--
-- TOC entry 7308 (class 0 OID 0)
-- Dependencies: 369
-- Name: COLUMN specimens_relationships.relationship_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.relationship_type IS 'Type of relationship: host, part of, related to, ...';


--
-- TOC entry 7309 (class 0 OID 0)
-- Dependencies: 369
-- Name: COLUMN specimens_relationships.unit_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.unit_type IS 'Type of the related unit : spec, taxo or mineralo';


--
-- TOC entry 7310 (class 0 OID 0)
-- Dependencies: 369
-- Name: COLUMN specimens_relationships.taxon_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.taxon_ref IS 'Reference of the related specimen';


--
-- TOC entry 7311 (class 0 OID 0)
-- Dependencies: 369
-- Name: COLUMN specimens_relationships.mineral_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.mineral_ref IS 'Reference of related mineral';


--
-- TOC entry 7312 (class 0 OID 0)
-- Dependencies: 369
-- Name: COLUMN specimens_relationships.institution_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.institution_ref IS 'External Specimen related institution';


--
-- TOC entry 7313 (class 0 OID 0)
-- Dependencies: 369
-- Name: COLUMN specimens_relationships.source_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.source_name IS 'External Specimen related  source DB';


--
-- TOC entry 7314 (class 0 OID 0)
-- Dependencies: 369
-- Name: COLUMN specimens_relationships.source_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.source_id IS 'External Specimen related id in the source';


--
-- TOC entry 7315 (class 0 OID 0)
-- Dependencies: 369
-- Name: COLUMN specimens_relationships.quantity; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.quantity IS 'Quantity of accompanying mineral';


--
-- TOC entry 370 (class 1259 OID 19717)
-- Name: specimens_relationships_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimens_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimens_relationships_id_seq OWNER TO darwin2;

--
-- TOC entry 7316 (class 0 OID 0)
-- Dependencies: 370
-- Name: specimens_relationships_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.specimens_relationships_id_seq OWNED BY darwin2.specimens_relationships.id;


--
-- TOC entry 374 (class 1259 OID 19745)
-- Name: taxonomy_synonymy_status; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.taxonomy_synonymy_status AS
 SELECT a.group_id,
    a.specimen_ids,
    a.status,
    a.count_by_status,
    ( SELECT count(*) AS count
           FROM darwin2.classification_synonymies
          WHERE (a.group_id = classification_synonymies.group_id)) AS count_all
   FROM ( SELECT a_1.group_id,
            array_agg(a_1.record_id) AS specimen_ids,
            taxonomy.status,
            count(a_1.id) AS count_by_status
           FROM (darwin2.classification_synonymies a_1
             JOIN darwin2.taxonomy ON ((a_1.record_id = taxonomy.id)))
          GROUP BY a_1.group_id, taxonomy.status) a
  GROUP BY a.group_id, a.status, a.count_by_status, a.specimen_ids
  ORDER BY a.group_id;


ALTER TABLE darwin2.taxonomy_synonymy_status OWNER TO darwin2;

--
-- TOC entry 517 (class 1259 OID 1415689)
-- Name: specimens_storage_parts_view; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.specimens_storage_parts_view AS
 SELECT specimens.id,
    specimens.uuid,
    specimens.collection_ref,
    specimens.expedition_ref,
    specimens.gtu_ref,
    specimens.taxon_ref,
    specimens.litho_ref,
    specimens.chrono_ref,
    specimens.lithology_ref,
    specimens.mineral_ref,
    specimens.acquisition_category,
    specimens.acquisition_date_mask,
    specimens.acquisition_date,
    specimens.station_visible,
    specimens.ig_ref,
    specimens.type,
    specimens.type_group,
    specimens.type_search,
    specimens.sex,
    specimens.stage,
    specimens.state,
    specimens.social_status,
    specimens.rock_form,
    specimens.specimen_count_min,
    specimens.specimen_count_max,
    specimens.spec_ident_ids,
    specimens.spec_coll_ids,
    specimens.spec_don_sel_ids,
    specimens.collection_type,
    specimens.collection_code,
    specimens.collection_name,
    specimens.collection_is_public,
    specimens.collection_parent_ref,
    specimens.collection_path,
    specimens.expedition_name,
    specimens.expedition_name_indexed,
    specimens.gtu_code,
    specimens.gtu_from_date_mask,
    specimens.gtu_from_date,
    specimens.gtu_to_date_mask,
    specimens.gtu_to_date,
    specimens.gtu_tag_values_indexed,
    specimens.gtu_country_tag_value,
    specimens.gtu_country_tag_indexed,
    specimens.gtu_province_tag_value,
    specimens.gtu_province_tag_indexed,
    specimens.gtu_others_tag_value,
    specimens.gtu_others_tag_indexed,
    specimens.gtu_elevation,
    specimens.gtu_elevation_accuracy,
    specimens.gtu_location,
    specimens.taxon_name,
    specimens.taxon_name_indexed,
    specimens.taxon_level_ref,
    specimens.taxon_level_name,
    specimens.taxon_status,
    specimens.taxon_path,
    specimens.taxon_parent_ref,
    specimens.taxon_extinct,
    specimens.litho_name,
    specimens.litho_name_indexed,
    specimens.litho_level_ref,
    specimens.litho_level_name,
    specimens.litho_status,
    specimens.litho_local,
    specimens.litho_color,
    specimens.litho_path,
    specimens.litho_parent_ref,
    specimens.chrono_name,
    specimens.chrono_name_indexed,
    specimens.chrono_level_ref,
    specimens.chrono_level_name,
    specimens.chrono_status,
    specimens.chrono_local,
    specimens.chrono_color,
    specimens.chrono_path,
    specimens.chrono_parent_ref,
    specimens.lithology_name,
    specimens.lithology_name_indexed,
    specimens.lithology_level_ref,
    specimens.lithology_level_name,
    specimens.lithology_status,
    specimens.lithology_local,
    specimens.lithology_color,
    specimens.lithology_path,
    specimens.lithology_parent_ref,
    specimens.mineral_name,
    specimens.mineral_name_indexed,
    specimens.mineral_level_ref,
    specimens.mineral_level_name,
    specimens.mineral_status,
    specimens.mineral_local,
    specimens.mineral_color,
    specimens.mineral_path,
    specimens.mineral_parent_ref,
    specimens.ig_num,
    specimens.ig_num_indexed,
    specimens.ig_date_mask,
    specimens.ig_date,
    specimens.specimen_count_males_min,
    specimens.specimen_count_males_max,
    specimens.specimen_count_females_min,
    specimens.specimen_count_females_max,
    specimens.specimen_count_juveniles_max,
    specimens.specimen_count_juveniles_min,
    specimens.main_code_indexed,
    specimens.specimen_creation_date,
    (((specimens.specimen_creation_date)::character varying)::text || (specimens.main_code_indexed)::text) AS specimen_creation_date_tech,
    p.category,
    p.specimen_ref,
    p.specimen_part,
    p.institution_ref,
    p.building,
    p.floor,
    p.room,
    p."row",
    p.col,
    p.shelf,
    p.container,
    p.sub_container,
    p.container_type,
    p.sub_container_type,
    p.container_storage,
    p.sub_container_storage,
    p.surnumerary,
    p.object_name,
    p.object_name_indexed,
    p.specimen_status,
    p.complete,
    taxonomy_synonymy_status.group_id AS synonymy_group_id,
    taxonomy_synonymy_status.status AS synonymy_status,
    taxonomy_synonymy_status.count_by_status AS count_by_synonymy_status,
    taxonomy_synonymy_status.count_all AS synonymy_count_all_in_group,
    specimens.valid_label,
    specimens.label_created_on,
    specimens.label_created_by,
    specimens.gtu_iso3166,
    specimens.gtu_iso3166_subdivision,
    specimens.nagoya,
    t.cites,
    specimens.import_ref,
    i.determination_status,
    specimens.collection_name_full_path
   FROM ((((darwin2.specimens
     LEFT JOIN darwin2.storage_parts p ON ((specimens.id = p.specimen_ref)))
     LEFT JOIN ( SELECT DISTINCT unnest(taxonomy_synonymy_status_1.specimen_ids) AS join_id,
            NULL::integer AS group_id,
            taxonomy_synonymy_status_1.status,
            taxonomy_synonymy_status_1.count_by_status,
            taxonomy_synonymy_status_1.count_all
           FROM darwin2.taxonomy_synonymy_status taxonomy_synonymy_status_1) taxonomy_synonymy_status ON ((specimens.taxon_ref = taxonomy_synonymy_status.join_id)))
     LEFT JOIN darwin2.taxonomy t ON ((t.id = specimens.taxon_ref)))
     LEFT JOIN ( SELECT identifications.record_id,
            string_agg((identifications.determination_status)::text, '; '::text ORDER BY identifications.record_id DESC) AS determination_status
           FROM darwin2.identifications
          WHERE ((identifications.referenced_relation)::text = 'specimens'::text)
          GROUP BY identifications.record_id) i ON ((specimens.id = i.record_id)));


ALTER TABLE darwin2.specimens_storage_parts_view OWNER TO darwin2;

--
-- TOC entry 375 (class 1259 OID 19755)
-- Name: staging_catalogue; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_catalogue (
    id integer NOT NULL,
    import_ref integer NOT NULL,
    name character varying NOT NULL,
    level_ref integer,
    parent_ref integer,
    catalogue_ref integer,
    parent_updated boolean DEFAULT false,
    is_reference_taxonomy boolean,
    source_taxonomy character varying,
    parent_ref_internal integer,
    hierarchical_conflict boolean DEFAULT false,
    name_cluster integer,
    imported boolean DEFAULT false NOT NULL,
    import_exception character varying,
    staging_hierarchy character varying,
    darwin_hierarchy character varying
);


ALTER TABLE darwin2.staging_catalogue OWNER TO darwin2;

--
-- TOC entry 7317 (class 0 OID 0)
-- Dependencies: 375
-- Name: TABLE staging_catalogue; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_catalogue IS 'Stores the catalogues hierarchy to be imported';


--
-- TOC entry 7318 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN staging_catalogue.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.id IS 'Unique identifier of a to be imported catalogue unit entry';


--
-- TOC entry 7319 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN staging_catalogue.import_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.import_ref IS 'Reference of import concerned - from table imports';


--
-- TOC entry 7320 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN staging_catalogue.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.name IS 'Name of unit to be imported/checked';


--
-- TOC entry 7321 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN staging_catalogue.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.level_ref IS 'Level of unit to be imported/checked';


--
-- TOC entry 7322 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN staging_catalogue.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.parent_ref IS 'ID of parent the unit is attached to. Right after the load of xml, it refers recursively to an entry in the same staging_catalogue table. During the import it is replaced by id of the parent from the concerned catalogue table.';


--
-- TOC entry 7323 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN staging_catalogue.catalogue_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.catalogue_ref IS 'ID of unit in concerned catalogue table - set during import process';


--
-- TOC entry 7324 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN staging_catalogue.parent_updated; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.parent_updated IS 'During the catalogue import process, tells if the parent ref has already been updated with one catalogue entry or not';


--
-- TOC entry 376 (class 1259 OID 19764)
-- Name: staging_catalogue_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_catalogue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_catalogue_id_seq OWNER TO darwin2;

--
-- TOC entry 7325 (class 0 OID 0)
-- Dependencies: 376
-- Name: staging_catalogue_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_catalogue_id_seq OWNED BY darwin2.staging_catalogue.id;


--
-- TOC entry 377 (class 1259 OID 19766)
-- Name: staging_collecting_methods; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_collecting_methods (
    id integer NOT NULL,
    staging_ref integer NOT NULL,
    collecting_method_ref integer NOT NULL
);


ALTER TABLE darwin2.staging_collecting_methods OWNER TO darwin2;

--
-- TOC entry 7326 (class 0 OID 0)
-- Dependencies: 377
-- Name: TABLE staging_collecting_methods; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_collecting_methods IS 'Association of collecting methods with Staging';


--
-- TOC entry 7327 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN staging_collecting_methods.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_collecting_methods.id IS 'Unique identifier of an association';


--
-- TOC entry 7328 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN staging_collecting_methods.staging_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_collecting_methods.staging_ref IS 'Identifier of a specimen - comes from staging table (id field)';


--
-- TOC entry 7329 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN staging_collecting_methods.collecting_method_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_collecting_methods.collecting_method_ref IS 'Identifier of a collecting method - comes from collecting_methods table (id field)';


--
-- TOC entry 378 (class 1259 OID 19769)
-- Name: staging_collecting_methods_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_collecting_methods_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_collecting_methods_id_seq OWNER TO darwin2;

--
-- TOC entry 7330 (class 0 OID 0)
-- Dependencies: 378
-- Name: staging_collecting_methods_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_collecting_methods_id_seq OWNED BY darwin2.staging_collecting_methods.id;


--
-- TOC entry 547 (class 1259 OID 1885639)
-- Name: staging_gtu; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_gtu (
    id integer NOT NULL,
    import_ref integer,
    status public.hstore DEFAULT ''::public.hstore NOT NULL,
    date_included boolean DEFAULT false NOT NULL,
    tags_merged boolean DEFAULT false NOT NULL,
    sensitive_information_withheld boolean DEFAULT false NOT NULL,
    gtu_ref integer,
    station_type character varying DEFAULT 'station'::character varying NOT NULL,
    sampling_code character varying NOT NULL,
    sampling_field_number character varying,
    event_cluster_code character varying,
    event_order integer,
    ig_num character varying,
    ig_num_indexed character varying,
    collections character varying[],
    collectors character varying[],
    expeditions character varying[],
    collection_refs integer[],
    collector_refs integer[],
    expedition_refs integer[],
    iso3166 character varying,
    iso3166_subdivision character varying,
    countries character varying[],
    tags character varying[],
    tags_indexed character varying[],
    locality_text character varying,
    locality_text_indexed character varying,
    ecology_text character varying,
    ecology_text_indexed character varying,
    coordinates_format character varying,
    latitude1 character varying,
    longitude1 character varying,
    latitude2 character varying,
    longitude2 character varying,
    gis_type character varying,
    coordinates_wkt character varying,
    coordinates_datum character varying,
    coordinates_proj_ref integer,
    coordinates_original character varying,
    coordinates_accuracy numeric(15,4),
    coordinates_accuracy_text character varying,
    station_baseline_elevation numeric(10,4),
    station_baseline_accuracy numeric(10,4),
    sampling_elevation_start numeric(10,4),
    sampling_elevation_end numeric(10,4),
    sampling_elevation_accuracy numeric(10,4),
    original_elevation_data character varying,
    sampling_depth_start numeric(10,4),
    sampling_depth_end numeric(10,4),
    sampling_depth_accuracy numeric(10,4),
    original_depth_data character varying,
    collecting_date_begin timestamp without time zone,
    collecting_date_begin_mask character varying,
    collecting_date_end timestamp without time zone,
    collecting_date_end_mask character varying,
    collecting_time_begin time without time zone,
    collecting_time_end time without time zone,
    sampling_method character varying,
    sampling_fixation character varying,
    imported boolean DEFAULT false,
    pos_in_file integer,
    import_exception character varying
);


ALTER TABLE darwin2.staging_gtu OWNER TO darwin2;

--
-- TOC entry 7331 (class 0 OID 0)
-- Dependencies: 547
-- Name: COLUMN staging_gtu.coordinates_format; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu.coordinates_format IS 'Possible formats DMS/DD/UTM';


--
-- TOC entry 546 (class 1259 OID 1885637)
-- Name: staging_gtu_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_gtu_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_gtu_id_seq OWNER TO darwin2;

--
-- TOC entry 7333 (class 0 OID 0)
-- Dependencies: 546
-- Name: staging_gtu_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_gtu_id_seq OWNED BY darwin2.staging_gtu.id;


--
-- TOC entry 549 (class 1259 OID 1885673)
-- Name: staging_gtu_tag_groups; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_gtu_tag_groups (
    id integer NOT NULL,
    staging_gtu_ref integer NOT NULL,
    group_name character varying NOT NULL,
    sub_group_name character varying NOT NULL,
    tag_value character varying NOT NULL
);


ALTER TABLE darwin2.staging_gtu_tag_groups OWNER TO darwin2;

--
-- TOC entry 7334 (class 0 OID 0)
-- Dependencies: 549
-- Name: TABLE staging_gtu_tag_groups; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_gtu_tag_groups IS 'List of grouped tags for an imported row (copy of tag group)';


--
-- TOC entry 7335 (class 0 OID 0)
-- Dependencies: 549
-- Name: COLUMN staging_gtu_tag_groups.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.id IS 'Unique identifier of a grouped tag';


--
-- TOC entry 7336 (class 0 OID 0)
-- Dependencies: 549
-- Name: COLUMN staging_gtu_tag_groups.staging_gtu_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.staging_gtu_ref IS 'Ref of an imported line';


--
-- TOC entry 7337 (class 0 OID 0)
-- Dependencies: 549
-- Name: COLUMN staging_gtu_tag_groups.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.group_name IS 'Group name under which the tag is grouped: Administrative area, Topographic structure,...';


--
-- TOC entry 7338 (class 0 OID 0)
-- Dependencies: 549
-- Name: COLUMN staging_gtu_tag_groups.sub_group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.sub_group_name IS 'Sub-Group name under which the tag is grouped: Country, River, Mountain,...';


--
-- TOC entry 7339 (class 0 OID 0)
-- Dependencies: 549
-- Name: COLUMN staging_gtu_tag_groups.tag_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.tag_value IS 'Ensemble of Tags';


--
-- TOC entry 548 (class 1259 OID 1885671)
-- Name: staging_gtu_tag_groups_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_gtu_tag_groups_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_gtu_tag_groups_id_seq OWNER TO darwin2;

--
-- TOC entry 7341 (class 0 OID 0)
-- Dependencies: 548
-- Name: staging_gtu_tag_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_gtu_tag_groups_id_seq OWNED BY darwin2.staging_gtu_tag_groups.id;


--
-- TOC entry 379 (class 1259 OID 19771)
-- Name: staging_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_id_seq OWNER TO darwin2;

--
-- TOC entry 7342 (class 0 OID 0)
-- Dependencies: 379
-- Name: staging_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_id_seq OWNED BY darwin2.staging.id;


--
-- TOC entry 380 (class 1259 OID 19773)
-- Name: staging_info; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_info (
    id integer NOT NULL,
    staging_ref integer NOT NULL,
    referenced_relation character varying NOT NULL
);


ALTER TABLE darwin2.staging_info OWNER TO darwin2;

--
-- TOC entry 7343 (class 0 OID 0)
-- Dependencies: 380
-- Name: TABLE staging_info; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_info IS 'used to make association between catalogue informations and staging eg taxon properties';


--
-- TOC entry 7344 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN staging_info.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_info.id IS 'Unique identifier of a grouped tag';


--
-- TOC entry 7345 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN staging_info.staging_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_info.staging_ref IS 'Ref of a staging record';


--
-- TOC entry 7346 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN staging_info.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_info.referenced_relation IS 'catalogue where associating the info';


--
-- TOC entry 381 (class 1259 OID 19779)
-- Name: staging_info_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_info_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_info_id_seq OWNER TO darwin2;

--
-- TOC entry 7347 (class 0 OID 0)
-- Dependencies: 381
-- Name: staging_info_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_info_id_seq OWNED BY darwin2.staging_info.id;


--
-- TOC entry 382 (class 1259 OID 19781)
-- Name: staging_people; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_people (
    id integer NOT NULL,
    people_type character varying DEFAULT 'author'::character varying NOT NULL,
    people_sub_type character varying DEFAULT ''::character varying NOT NULL,
    order_by integer DEFAULT 1 NOT NULL,
    people_ref integer,
    formated_name character varying,
    import_ref integer
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.staging_people OWNER TO darwin2;

--
-- TOC entry 7348 (class 0 OID 0)
-- Dependencies: 382
-- Name: TABLE staging_people; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_people IS 'List of people of staging units';


--
-- TOC entry 7349 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN staging_people.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.referenced_relation IS 'Identifier-Name of table the units come from';


--
-- TOC entry 7350 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN staging_people.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.record_id IS 'Identifier of record concerned in table concerned';


--
-- TOC entry 7351 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN staging_people.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.id IS 'Unique identifier of record';


--
-- TOC entry 7352 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN staging_people.people_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.people_type IS 'Type of "people" associated to the staging unit: authors, collectors, defined,  ...';


--
-- TOC entry 7353 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN staging_people.people_sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.people_sub_type IS 'Type of "people" associated to the staging unit: Main author, corrector, taking the sense from,...';


--
-- TOC entry 7354 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN staging_people.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.order_by IS 'Integer used to order the persons in a list';


--
-- TOC entry 7355 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN staging_people.people_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.people_ref IS 'Reference of person concerned - id field of people table';


--
-- TOC entry 7356 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN staging_people.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.formated_name IS 'full name of the people';


--
-- TOC entry 383 (class 1259 OID 19790)
-- Name: staging_people_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_people_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_people_id_seq OWNER TO darwin2;

--
-- TOC entry 7357 (class 0 OID 0)
-- Dependencies: 383
-- Name: staging_people_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_people_id_seq OWNED BY darwin2.staging_people.id;


--
-- TOC entry 384 (class 1259 OID 19792)
-- Name: staging_relationship; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_relationship (
    id integer NOT NULL,
    record_id integer NOT NULL,
    referenced_relation character varying NOT NULL,
    relationship_type character varying,
    staging_related_ref integer,
    taxon_ref integer,
    mineral_ref integer,
    institution_ref integer,
    institution_name text,
    source_name text,
    source_id text,
    quantity numeric(16,2),
    unit character varying DEFAULT '%'::character varying,
    unit_type character varying DEFAULT 'specimens'::character varying NOT NULL,
    existing_specimen_ref integer
);


ALTER TABLE darwin2.staging_relationship OWNER TO darwin2;

--
-- TOC entry 7358 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.record_id IS 'id of the orignial record';


--
-- TOC entry 7359 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.referenced_relation IS 'where to find the record_id, referenced_relation is always staging but this field uis mandatory for addRelated php function';


--
-- TOC entry 7360 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.relationship_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.relationship_type IS 'relation type (eg. host, parent, part of)';


--
-- TOC entry 7361 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.staging_related_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.staging_related_ref IS 'the record id associated, this record id must be found in the same import file';


--
-- TOC entry 7362 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.taxon_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.taxon_ref IS 'Reference of the related specimen';


--
-- TOC entry 7363 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.mineral_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.mineral_ref IS 'Reference of related mineral';


--
-- TOC entry 7364 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.institution_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.institution_ref IS 'the institution id associated to this relationship';


--
-- TOC entry 7365 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.institution_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.institution_name IS 'the institution name associated to this relationship, used to add to darwin institution if it dont exist';


--
-- TOC entry 7366 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.source_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.source_name IS 'External Specimen related  source DB';


--
-- TOC entry 7367 (class 0 OID 0)
-- Dependencies: 384
-- Name: COLUMN staging_relationship.source_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.source_id IS 'External Specimen related id in the source';


--
-- TOC entry 385 (class 1259 OID 19800)
-- Name: staging_relationship_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_relationship_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_relationship_id_seq OWNER TO darwin2;

--
-- TOC entry 7368 (class 0 OID 0)
-- Dependencies: 385
-- Name: staging_relationship_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_relationship_id_seq OWNED BY darwin2.staging_relationship.id;


--
-- TOC entry 386 (class 1259 OID 19802)
-- Name: staging_tag_groups; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_tag_groups (
    id integer NOT NULL,
    staging_ref integer NOT NULL,
    group_name character varying NOT NULL,
    sub_group_name character varying NOT NULL,
    tag_value character varying NOT NULL
);


ALTER TABLE darwin2.staging_tag_groups OWNER TO darwin2;

--
-- TOC entry 7369 (class 0 OID 0)
-- Dependencies: 386
-- Name: TABLE staging_tag_groups; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_tag_groups IS 'List of grouped tags for an imported row (copy of tag group)';


--
-- TOC entry 7370 (class 0 OID 0)
-- Dependencies: 386
-- Name: COLUMN staging_tag_groups.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.id IS 'Unique identifier of a grouped tag';


--
-- TOC entry 7371 (class 0 OID 0)
-- Dependencies: 386
-- Name: COLUMN staging_tag_groups.staging_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.staging_ref IS 'Ref of an imported line';


--
-- TOC entry 7372 (class 0 OID 0)
-- Dependencies: 386
-- Name: COLUMN staging_tag_groups.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.group_name IS 'Group name under which the tag is grouped: Administrative area, Topographic structure,...';


--
-- TOC entry 7373 (class 0 OID 0)
-- Dependencies: 386
-- Name: COLUMN staging_tag_groups.sub_group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.sub_group_name IS 'Sub-Group name under which the tag is grouped: Country, River, Mountain,...';


--
-- TOC entry 7374 (class 0 OID 0)
-- Dependencies: 386
-- Name: COLUMN staging_tag_groups.tag_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.tag_value IS 'Ensemble of Tags';


--
-- TOC entry 387 (class 1259 OID 19808)
-- Name: staging_tag_groups_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_tag_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_tag_groups_id_seq OWNER TO darwin2;

--
-- TOC entry 7376 (class 0 OID 0)
-- Dependencies: 387
-- Name: staging_tag_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_tag_groups_id_seq OWNED BY darwin2.staging_tag_groups.id;


--
-- TOC entry 536 (class 1259 OID 1758293)
-- Name: storage_parts_bck_20220513; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.storage_parts_bck_20220513 (
    id integer NOT NULL,
    category character varying DEFAULT 'physical'::character varying NOT NULL,
    specimen_ref integer NOT NULL,
    specimen_part character varying DEFAULT 'specimen'::character varying NOT NULL,
    institution_ref integer,
    building character varying,
    floor character varying,
    room character varying,
    "row" character varying,
    col character varying,
    shelf character varying,
    container character varying,
    sub_container character varying,
    container_type character varying DEFAULT 'container'::character varying NOT NULL,
    sub_container_type character varying DEFAULT 'container'::character varying NOT NULL,
    container_storage character varying DEFAULT 'dry'::character varying NOT NULL,
    sub_container_storage character varying DEFAULT 'dry'::character varying NOT NULL,
    surnumerary boolean DEFAULT false NOT NULL,
    object_name text,
    object_name_indexed text DEFAULT ''::text NOT NULL,
    specimen_status character varying DEFAULT 'good state'::character varying NOT NULL,
    complete boolean DEFAULT true NOT NULL
);


ALTER TABLE darwin2.storage_parts_bck_20220513 OWNER TO darwin2;

--
-- TOC entry 7377 (class 0 OID 0)
-- Dependencies: 536
-- Name: COLUMN storage_parts_bck_20220513.specimen_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.storage_parts_bck_20220513.specimen_status IS 'Specimen status: good state, lost, damaged,...';


--
-- TOC entry 7378 (class 0 OID 0)
-- Dependencies: 536
-- Name: COLUMN storage_parts_bck_20220513.complete; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.storage_parts_bck_20220513.complete IS 'Flag telling if specimen is complete or not';


--
-- TOC entry 537 (class 1259 OID 1758309)
-- Name: storage_parts_bck_20220513_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.storage_parts_bck_20220513_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.storage_parts_bck_20220513_id_seq OWNER TO darwin2;

--
-- TOC entry 7379 (class 0 OID 0)
-- Dependencies: 537
-- Name: storage_parts_bck_20220513_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.storage_parts_bck_20220513_id_seq OWNED BY darwin2.storage_parts_bck_20220513.id;


--
-- TOC entry 535 (class 1259 OID 1758269)
-- Name: storage_parts_fix_ichtyo; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.storage_parts_fix_ichtyo (
    id integer,
    category character varying,
    specimen_ref integer,
    specimen_part character varying,
    institution_ref integer,
    building character varying,
    floor character varying,
    room character varying,
    "row" character varying,
    col character varying,
    shelf character varying,
    container character varying,
    sub_container character varying,
    container_type character varying,
    sub_container_type character varying,
    container_storage character varying,
    sub_container_storage character varying,
    surnumerary boolean,
    object_name text,
    object_name_indexed text,
    specimen_status character varying,
    complete boolean
);


ALTER TABLE darwin2.storage_parts_fix_ichtyo OWNER TO darwin2;

--
-- TOC entry 538 (class 1259 OID 1758379)
-- Name: storage_parts_ichtyo_missing20220517; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.storage_parts_ichtyo_missing20220517 (
    family character varying,
    genus character varying,
    genusupper character varying,
    species character varying,
    room_genus character varying
);


ALTER TABLE darwin2.storage_parts_ichtyo_missing20220517 OWNER TO darwin2;

--
-- TOC entry 388 (class 1259 OID 19810)
-- Name: storage_parts_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.storage_parts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.storage_parts_id_seq OWNER TO darwin2;

--
-- TOC entry 7380 (class 0 OID 0)
-- Dependencies: 388
-- Name: storage_parts_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.storage_parts_id_seq OWNED BY darwin2.storage_parts.id;


--
-- TOC entry 389 (class 1259 OID 19812)
-- Name: t_compare_darwin_digit03_mysql; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.t_compare_darwin_digit03_mysql (
    pid integer NOT NULL,
    phylum character varying,
    class character varying,
    family character varying,
    genus character varying,
    species character varying,
    subspecies character varying,
    status character varying,
    number character varying,
    digitisation character varying,
    url character varying,
    sketchfab_snippet character varying,
    sketchfab_without_snippet character varying,
    contributor character varying,
    pic_path character varying,
    pic_display_order character varying,
    pic_image_file character varying
);


ALTER TABLE darwin2.t_compare_darwin_digit03_mysql OWNER TO darwin2;

--
-- TOC entry 390 (class 1259 OID 19818)
-- Name: t_compare_darwin_digit03_mysql_pid_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.t_compare_darwin_digit03_mysql_pid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.t_compare_darwin_digit03_mysql_pid_seq OWNER TO darwin2;

--
-- TOC entry 7381 (class 0 OID 0)
-- Dependencies: 390
-- Name: t_compare_darwin_digit03_mysql_pid_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.t_compare_darwin_digit03_mysql_pid_seq OWNED BY darwin2.t_compare_darwin_digit03_mysql.pid;


--
-- TOC entry 391 (class 1259 OID 19820)
-- Name: t_darwin_ipt; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.t_darwin_ipt (
    ids text,
    guid text,
    collection_ref integer,
    collection_code character varying,
    collection_name character varying,
    collection_id integer,
    collection_path character varying,
    cataloguenumber text,
    basisofrecord text,
    institutionid text,
    iso_country_institution text,
    bibliographic_citation text,
    license text,
    email text,
    type character varying,
    taxon_path character varying,
    taxon_ref integer,
    taxon_name character varying,
    family character varying,
    iso_country character varying,
    country character varying,
    location text,
    latitude character varying,
    longitude character varying,
    lat_long_accuracy double precision,
    collector_ids integer[],
    collectors text,
    donator_ids integer[],
    donators text,
    identifiers_ids integer[],
    identifiers text,
    gtu_from_date timestamp without time zone,
    gtu_from_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_to_date_mask integer,
    eventdate text,
    country_unnest character varying,
    urls_thumbnails character varying,
    image_category_thumbnails character varying,
    contributor_thumbnails character varying,
    disclaimer_thumbnails character varying,
    license_thumbnails character varying,
    display_order_thumbnails integer,
    urls_image_links character varying,
    image_category_image_links character varying,
    contributor_image_links character varying,
    disclaimer_image_links character varying,
    license_image_links character varying,
    display_order_image_links integer,
    urls_3d_snippets character varying,
    image_category_3d_snippets character varying,
    contributor_3d_snippets character varying,
    disclaimer_3d_snippets character varying,
    license_3d_snippets character varying,
    display_order_3d_snippets integer,
    identification_date text,
    history text,
    gtu_ref integer
);


ALTER TABLE darwin2.t_darwin_ipt OWNER TO darwin2;

--
-- TOC entry 392 (class 1259 OID 19826)
-- Name: tag_groups; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tag_groups (
    id integer NOT NULL,
    gtu_ref integer NOT NULL,
    group_name character varying NOT NULL,
    group_name_indexed character varying NOT NULL,
    sub_group_name character varying NOT NULL,
    sub_group_name_indexed character varying NOT NULL,
    international_name character varying DEFAULT ''::character varying NOT NULL,
    color character varying DEFAULT '#FFFFFF'::character varying NOT NULL,
    tag_value character varying NOT NULL
);


ALTER TABLE darwin2.tag_groups OWNER TO darwin2;

--
-- TOC entry 7382 (class 0 OID 0)
-- Dependencies: 392
-- Name: TABLE tag_groups; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.tag_groups IS 'List of grouped tags';


--
-- TOC entry 7383 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN tag_groups.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.id IS 'Unique identifier of a grouped tag';


--
-- TOC entry 7384 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN tag_groups.gtu_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.gtu_ref IS 'Reference to a Gtu';


--
-- TOC entry 7385 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN tag_groups.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.group_name IS 'Group name under which the tag is grouped: Administrative area, Topographic structure,...';


--
-- TOC entry 7386 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN tag_groups.group_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.group_name_indexed IS 'Indexed form of a group name';


--
-- TOC entry 7387 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN tag_groups.sub_group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.sub_group_name IS 'Sub-Group name under which the tag is grouped: Country, River, Mountain,...';


--
-- TOC entry 7388 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN tag_groups.sub_group_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.sub_group_name_indexed IS 'Indexed form of a sub-group name';


--
-- TOC entry 7389 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN tag_groups.international_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.international_name IS 'The international(english) name of the place / ocean / country';


--
-- TOC entry 7390 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN tag_groups.color; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.color IS 'Color associated to the group concerned';


--
-- TOC entry 7391 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN tag_groups.tag_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.tag_value IS 'Ensemble of Tags';


--
-- TOC entry 393 (class 1259 OID 19834)
-- Name: tag_groups_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.tag_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.tag_groups_id_seq OWNER TO darwin2;

--
-- TOC entry 7392 (class 0 OID 0)
-- Dependencies: 393
-- Name: tag_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.tag_groups_id_seq OWNED BY darwin2.tag_groups.id;


--
-- TOC entry 395 (class 1259 OID 19842)
-- Name: taxonomy_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.taxonomy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.taxonomy_id_seq OWNER TO darwin2;

--
-- TOC entry 7393 (class 0 OID 0)
-- Dependencies: 395
-- Name: taxonomy_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.taxonomy_id_seq OWNED BY darwin2.taxonomy.id;


--
-- TOC entry 396 (class 1259 OID 19844)
-- Name: taxonomy_metadata; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.taxonomy_metadata (
    id integer NOT NULL,
    creation_date date NOT NULL,
    creation_date_mask integer,
    import_ref integer,
    taxonomy_name character varying NOT NULL,
    definition text,
    is_reference_taxonomy boolean NOT NULL,
    source character varying,
    url_website character varying,
    url_webservice character varying
);


ALTER TABLE darwin2.taxonomy_metadata OWNER TO darwin2;

--
-- TOC entry 397 (class 1259 OID 19850)
-- Name: taxonomy_metadata_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.taxonomy_metadata_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.taxonomy_metadata_id_seq OWNER TO darwin2;

--
-- TOC entry 7394 (class 0 OID 0)
-- Dependencies: 397
-- Name: taxonomy_metadata_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.taxonomy_metadata_id_seq OWNED BY darwin2.taxonomy_metadata.id;


--
-- TOC entry 524 (class 1259 OID 1468833)
-- Name: tmp_xylarium_img_links_2022; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tmp_xylarium_img_links_2022 (
    unitid character varying,
    links character varying,
    legend character varying,
    tw_images character varying
);


ALTER TABLE darwin2.tmp_xylarium_img_links_2022 OWNER TO darwin2;

--
-- TOC entry 398 (class 1259 OID 19852)
-- Name: tv_darwin_view_for_csv; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_darwin_view_for_csv (
    id text,
    collection_code character varying,
    code text,
    additional_codes text,
    ig_num character varying,
    taxon_name text,
    author text,
    full_scientific_name text,
    family text,
    type text,
    specimen_count_min integer,
    specimen_count_max integer,
    identifiers text,
    abbreviated_identifiers text,
    identification_year text,
    longitude double precision,
    latitude double precision,
    longitude_text character varying,
    latitude_text character varying,
    gtu_country_tag_value character varying,
    municipality text,
    region_district text,
    exact_site text,
    ecology text,
    gtu_others_tag_value character varying,
    gtu_code character varying,
    gtu_elevation double precision,
    collecting_year_from double precision,
    collecting_month_from double precision,
    collecting_day_from double precision,
    collecting_year_to double precision,
    collecting_month_to double precision,
    collecting_day_to double precision,
    properties_locality text,
    collectors text,
    abbreviated_collectors text,
    expedition_name character varying,
    donators text,
    abbreviated_donators text,
    acquisition_category character varying,
    acquisition_date text,
    sex character varying,
    stage character varying,
    state character varying,
    social_status character varying,
    specimen_part text,
    complete text,
    object_name text,
    specimen_status text,
    container_storage text,
    method text,
    tool text,
    comment text,
    properties_all text,
    specimen_creation_date timestamp without time zone
);


ALTER TABLE darwin2.tv_darwin_view_for_csv OWNER TO darwin2;

--
-- TOC entry 399 (class 1259 OID 19858)
-- Name: tv_rdf_view_2_ichtyo; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_rdf_view_2_ichtyo (
    uuid uuid,
    id integer,
    code_display text,
    full_code_indexed character varying,
    taxon_path character varying,
    taxon_ref integer,
    collection_ref integer,
    collection_name character varying,
    gtu_country_tag_indexed character varying[],
    gtu_country_tag_value character varying,
    localities_indexed character varying[],
    gtu_others_tag_value character varying,
    taxon_name character varying,
    collector_ids integer[],
    collector_name text,
    gtu_from_date timestamp without time zone,
    gtu_from_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_to_date_mask integer,
    coll_type character varying,
    country_unnest character varying,
    urls_thumbnails character varying,
    image_category_thumbnails character varying,
    contributor_thumbnails character varying,
    disclaimer_thumbnails character varying,
    license_thumbnails character varying,
    display_order_thumbnails integer,
    urls_image_links character varying,
    image_category_image_links character varying,
    contributor_image_links character varying,
    disclaimer_image_links character varying,
    license_image_links character varying,
    display_order_image_links integer,
    urls_3d_snippets character varying,
    image_category_3d_snippets character varying,
    contributor_3d_snippets character varying,
    disclaimer_3d_snippets character varying,
    license_3d_snippets character varying,
    display_order_3d_snippets integer,
    latitude double precision,
    longitude double precision,
    identification_date timestamp without time zone,
    identification_date_mask integer,
    history text,
    gtu_ref integer,
    "Country" character varying,
    "Locality" text,
    geom public.geometry
);


ALTER TABLE darwin2.tv_rdf_view_2_ichtyo OWNER TO darwin2;

--
-- TOC entry 400 (class 1259 OID 19864)
-- Name: tv_rdf_view_2_ichtyo_taxo; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_rdf_view_2_ichtyo_taxo (
    uuid uuid,
    id integer,
    code_display text,
    full_code_indexed character varying,
    taxon_path character varying,
    taxon_ref integer,
    collection_ref integer,
    collection_name character varying,
    gtu_country_tag_indexed character varying[],
    gtu_country_tag_value character varying,
    localities_indexed character varying[],
    gtu_others_tag_value character varying,
    taxon_name character varying,
    collector_ids integer[],
    collector_name text,
    gtu_from_date timestamp without time zone,
    gtu_from_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_to_date_mask integer,
    coll_type character varying,
    country_unnest character varying,
    urls_thumbnails character varying,
    image_category_thumbnails character varying,
    contributor_thumbnails character varying,
    disclaimer_thumbnails character varying,
    license_thumbnails character varying,
    display_order_thumbnails integer,
    urls_image_links character varying,
    image_category_image_links character varying,
    contributor_image_links character varying,
    disclaimer_image_links character varying,
    license_image_links character varying,
    display_order_image_links integer,
    urls_3d_snippets character varying,
    image_category_3d_snippets character varying,
    contributor_3d_snippets character varying,
    disclaimer_3d_snippets character varying,
    license_3d_snippets character varying,
    display_order_3d_snippets integer,
    latitude double precision,
    longitude double precision,
    identification_date timestamp without time zone,
    identification_date_mask integer,
    history text,
    gtu_ref integer,
    "Country" character varying,
    "Locality" text,
    geom public.geometry,
    family character varying,
    genus character varying
);


ALTER TABLE darwin2.tv_rdf_view_2_ichtyo_taxo OWNER TO darwin2;

--
-- TOC entry 401 (class 1259 OID 19870)
-- Name: tv_reporting_count_all_specimens_by_collection_year_ig; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_reporting_count_all_specimens_by_collection_year_ig (
    collection_name character varying,
    collection_path character varying,
    collection_ref integer,
    year double precision,
    specimen_creation_date timestamp without time zone,
    nb_records bigint,
    specimen_count_min bigint,
    specimen_count_max bigint,
    ig_ref integer,
    ig_num character varying
);


ALTER TABLE darwin2.tv_reporting_count_all_specimens_by_collection_year_ig OWNER TO darwin2;

--
-- TOC entry 402 (class 1259 OID 19876)
-- Name: tv_reporting_count_all_specimens_type_by_collection_ref_year_ig; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_reporting_count_all_specimens_type_by_collection_ref_year_ig (
    collection_path character varying,
    collection_name character varying,
    collection_ref integer,
    ig_ref integer,
    ig_num character varying,
    year double precision,
    specimen_creation_date timestamp without time zone,
    type text,
    nb_records bigint,
    specimen_count_min bigint,
    specimen_count_max bigint
);


ALTER TABLE darwin2.tv_reporting_count_all_specimens_type_by_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 403 (class 1259 OID 19882)
-- Name: tv_reporting_higher_taxa_geo_per_rank_collection_ref_year_ig; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_reporting_higher_taxa_geo_per_rank_collection_ref_year_ig (
    level_ref integer,
    level_name character varying,
    rank text,
    taxon text,
    year double precision,
    creation_date timestamp without time zone,
    ig_ref integer,
    ig_num character varying,
    collection_path character varying,
    collection_ref integer,
    collection_name character varying,
    countries character varying[],
    min_lon double precision,
    min_lat double precision,
    max_lon double precision,
    max_lat double precision
);


ALTER TABLE darwin2.tv_reporting_higher_taxa_geo_per_rank_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 404 (class 1259 OID 19888)
-- Name: tv_reporting_higher_taxa_per_rank_collection_ref_year_ig; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_reporting_higher_taxa_per_rank_collection_ref_year_ig (
    level_ref integer,
    level_name character varying,
    rank text,
    taxon text,
    year double precision,
    creation_date timestamp without time zone,
    ig_ref integer,
    ig_num character varying,
    collection_path character varying,
    collection_ref integer,
    collection_name character varying
);


ALTER TABLE darwin2.tv_reporting_higher_taxa_per_rank_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 405 (class 1259 OID 19894)
-- Name: tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig (
    taxonomy_id integer,
    collection_path character varying,
    collection_ref integer,
    collection_name character varying,
    ig_ref integer,
    ig_num character varying,
    year double precision,
    creation_date timestamp without time zone,
    level_ref integer,
    level_name character varying,
    nb_records bigint,
    specimen_count_min bigint,
    specimen_count_max bigint
);


ALTER TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 406 (class 1259 OID 19900)
-- Name: tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_igal; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_igal (
    taxonomy_id integer,
    collection_path character varying,
    collection_ref integer,
    collection_name character varying,
    ig_ref integer,
    ig_num character varying,
    year double precision,
    creation_date timestamp without time zone,
    level_ref integer,
    level_name character varying,
    nb_records bigint,
    specimen_count_min bigint,
    specimen_count_max bigint
);


ALTER TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_igal OWNER TO darwin2;

--
-- TOC entry 407 (class 1259 OID 19906)
-- Name: users; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users (
    id integer NOT NULL,
    db_user_type smallint DEFAULT 1 NOT NULL,
    people_id integer,
    created_at timestamp without time zone DEFAULT now(),
    selected_lang character varying DEFAULT 'en'::character varying NOT NULL,
    user_ip character varying
)
INHERITS (darwin2.template_people);


ALTER TABLE darwin2.users OWNER TO darwin2;

--
-- TOC entry 7395 (class 0 OID 0)
-- Dependencies: 407
-- Name: TABLE users; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users IS 'List all application users';


--
-- TOC entry 7396 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.is_physical; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.is_physical IS 'Type of user: physical or moral - true is physical, false is moral';


--
-- TOC entry 7397 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.sub_type IS 'Used for moral users: precise nature - public institution, asbl, sprl, sa,...';


--
-- TOC entry 7398 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.formated_name IS 'Complete user formated name (with honorific mention, prefixes, suffixes,...) - By default composed with family_name and given_name fields, but can be modified by hand';


--
-- TOC entry 7399 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.formated_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.formated_name_indexed IS 'Indexed form of formated_name field';


--
-- TOC entry 7400 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.formated_name_unique; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.formated_name_unique IS 'Indexed form of formated_name field (for unique index use)';


--
-- TOC entry 7401 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.title IS 'Title of a physical user/person like Mr or Mrs or phd,...';


--
-- TOC entry 7402 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.family_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.family_name IS 'Family name for physical users and Organisation name for moral users';


--
-- TOC entry 7403 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.given_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.given_name IS 'User/user''s given name - usually first name';


--
-- TOC entry 7404 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.additional_names; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.additional_names IS 'Any additional names given to user';


--
-- TOC entry 7405 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.birth_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.birth_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 7406 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.birth_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.birth_date IS 'Birth/Creation date composed';


--
-- TOC entry 7407 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.gender; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.gender IS 'For physical users give the gender: M or F';


--
-- TOC entry 7408 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.id IS 'Unique identifier of a user';


--
-- TOC entry 7409 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.db_user_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.db_user_type IS 'Integer is representing a role: 1 for registered user, 2 for encoder, 4 for collection manager, 8 for system admin,...';


--
-- TOC entry 7410 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.people_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.people_id IS 'Reference to a people if this user is also known as a people';


--
-- TOC entry 7411 (class 0 OID 0)
-- Dependencies: 407
-- Name: COLUMN users.selected_lang; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.selected_lang IS 'Lang of the interface for the user en,fr,nl ,....';


--
-- TOC entry 408 (class 1259 OID 19920)
-- Name: users_addresses; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users_addresses (
    id integer NOT NULL,
    person_user_role character varying,
    organization_unit character varying,
    tag character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_people_users_comm_common, darwin2.template_people_users_addr_common);


ALTER TABLE darwin2.users_addresses OWNER TO darwin2;

--
-- TOC entry 7412 (class 0 OID 0)
-- Dependencies: 408
-- Name: TABLE users_addresses; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users_addresses IS 'Users addresses';


--
-- TOC entry 7413 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.person_user_ref IS 'Reference of the user concerned - id field of users table';


--
-- TOC entry 7414 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.entry IS 'Street address';


--
-- TOC entry 7415 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.po_box; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.po_box IS 'PO Box';


--
-- TOC entry 7416 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.extended_address; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.extended_address IS 'Address extension: State, zip code suffix,...';


--
-- TOC entry 7417 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.locality; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.locality IS 'Locality';


--
-- TOC entry 7418 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.region; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.region IS 'Region';


--
-- TOC entry 7419 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.zip_code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.zip_code IS 'Zip code';


--
-- TOC entry 7420 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.country; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.country IS 'Country';


--
-- TOC entry 7421 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.id IS 'Unique identifier of a user address';


--
-- TOC entry 7422 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.person_user_role; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.person_user_role IS 'User role in the organization referenced';


--
-- TOC entry 7423 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.organization_unit; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.organization_unit IS 'When a physical user is in relationship with a moral one, indicates the department or unit the user is related to';


--
-- TOC entry 7424 (class 0 OID 0)
-- Dependencies: 408
-- Name: COLUMN users_addresses.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.tag IS 'List of descriptive tags: home, work,...';


--
-- TOC entry 409 (class 1259 OID 19927)
-- Name: users_addresses_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_addresses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_addresses_id_seq OWNER TO darwin2;

--
-- TOC entry 7425 (class 0 OID 0)
-- Dependencies: 409
-- Name: users_addresses_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.users_addresses_id_seq OWNED BY darwin2.users_addresses.id;


--
-- TOC entry 410 (class 1259 OID 19929)
-- Name: users_comm; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users_comm (
    id integer NOT NULL,
    comm_type character varying DEFAULT 'phone/fax'::character varying NOT NULL,
    tag character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_people_users_comm_common);


ALTER TABLE darwin2.users_comm OWNER TO darwin2;

--
-- TOC entry 7426 (class 0 OID 0)
-- Dependencies: 410
-- Name: TABLE users_comm; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users_comm IS 'Users phones and e-mails';


--
-- TOC entry 7427 (class 0 OID 0)
-- Dependencies: 410
-- Name: COLUMN users_comm.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.person_user_ref IS 'Reference of user - id field of user table';


--
-- TOC entry 7428 (class 0 OID 0)
-- Dependencies: 410
-- Name: COLUMN users_comm.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.entry IS 'Communication entry';


--
-- TOC entry 7429 (class 0 OID 0)
-- Dependencies: 410
-- Name: COLUMN users_comm.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.id IS 'Unique identifier of a users communication mean entry';


--
-- TOC entry 7430 (class 0 OID 0)
-- Dependencies: 410
-- Name: COLUMN users_comm.comm_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.comm_type IS 'Type of communication table concerned: address, phone or e-mail';


--
-- TOC entry 7431 (class 0 OID 0)
-- Dependencies: 410
-- Name: COLUMN users_comm.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.tag IS 'List of descriptive tags: internet, tel, fax, pager, public, private,...';


--
-- TOC entry 411 (class 1259 OID 19937)
-- Name: users_comm_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_comm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_comm_id_seq OWNER TO darwin2;

--
-- TOC entry 7432 (class 0 OID 0)
-- Dependencies: 411
-- Name: users_comm_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.users_comm_id_seq OWNED BY darwin2.users_comm.id;


--
-- TOC entry 412 (class 1259 OID 19939)
-- Name: users_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_id_seq OWNER TO darwin2;

--
-- TOC entry 7433 (class 0 OID 0)
-- Dependencies: 412
-- Name: users_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.users_id_seq OWNED BY darwin2.users.id;


--
-- TOC entry 413 (class 1259 OID 19941)
-- Name: users_login_infos; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users_login_infos (
    id integer NOT NULL,
    user_ref integer NOT NULL,
    login_type character varying DEFAULT 'local'::character varying NOT NULL,
    user_name character varying,
    password character varying,
    login_system character varying,
    renew_hash character varying,
    last_seen timestamp without time zone
);


ALTER TABLE darwin2.users_login_infos OWNER TO darwin2;

--
-- TOC entry 7434 (class 0 OID 0)
-- Dependencies: 413
-- Name: TABLE users_login_infos; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users_login_infos IS 'Contains the login/password informations of DaRWIN 2 users';


--
-- TOC entry 7435 (class 0 OID 0)
-- Dependencies: 413
-- Name: COLUMN users_login_infos.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.user_ref IS 'Identifier of user - id field of users table';


--
-- TOC entry 7436 (class 0 OID 0)
-- Dependencies: 413
-- Name: COLUMN users_login_infos.login_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.login_type IS 'Type of identification system';


--
-- TOC entry 7437 (class 0 OID 0)
-- Dependencies: 413
-- Name: COLUMN users_login_infos.user_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.user_name IS 'For some system (local, ldap, kerberos,...) provides the username (encrypted form)';


--
-- TOC entry 7438 (class 0 OID 0)
-- Dependencies: 413
-- Name: COLUMN users_login_infos.password; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.password IS 'For some system (local, ldap, kerberos,...) provides the password (encrypted form)';


--
-- TOC entry 7439 (class 0 OID 0)
-- Dependencies: 413
-- Name: COLUMN users_login_infos.login_system; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.login_system IS 'For some system (shibbolet, openID,...) provides the user id';


--
-- TOC entry 7440 (class 0 OID 0)
-- Dependencies: 413
-- Name: COLUMN users_login_infos.renew_hash; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.renew_hash IS 'Hashed key defined when asking to renew a password';


--
-- TOC entry 7441 (class 0 OID 0)
-- Dependencies: 413
-- Name: COLUMN users_login_infos.last_seen; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.last_seen IS 'Last time the user has logged in.';


--
-- TOC entry 414 (class 1259 OID 19948)
-- Name: users_login_infos_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_login_infos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_login_infos_id_seq OWNER TO darwin2;

--
-- TOC entry 7442 (class 0 OID 0)
-- Dependencies: 414
-- Name: users_login_infos_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.users_login_infos_id_seq OWNED BY darwin2.users_login_infos.id;


--
-- TOC entry 415 (class 1259 OID 19950)
-- Name: users_tracking; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users_tracking (
    id integer NOT NULL,
    referenced_relation character varying NOT NULL,
    record_id integer NOT NULL,
    user_ref integer NOT NULL,
    action character varying DEFAULT 'insert'::character varying NOT NULL,
    old_value public.hstore,
    new_value public.hstore,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL
);


ALTER TABLE darwin2.users_tracking OWNER TO darwin2;

--
-- TOC entry 7443 (class 0 OID 0)
-- Dependencies: 415
-- Name: TABLE users_tracking; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users_tracking IS 'Tracking of users actions on tables';


--
-- TOC entry 7444 (class 0 OID 0)
-- Dependencies: 415
-- Name: COLUMN users_tracking.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.id IS 'Unique identifier of a table track entry';


--
-- TOC entry 7445 (class 0 OID 0)
-- Dependencies: 415
-- Name: COLUMN users_tracking.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 7446 (class 0 OID 0)
-- Dependencies: 415
-- Name: COLUMN users_tracking.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.record_id IS 'ID of record concerned';


--
-- TOC entry 7447 (class 0 OID 0)
-- Dependencies: 415
-- Name: COLUMN users_tracking.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.user_ref IS 'Reference of user having made an action - id field of users table';


--
-- TOC entry 7448 (class 0 OID 0)
-- Dependencies: 415
-- Name: COLUMN users_tracking.action; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.action IS 'Action done on table record: insert, update, delete';


--
-- TOC entry 7449 (class 0 OID 0)
-- Dependencies: 415
-- Name: COLUMN users_tracking.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.modification_date_time IS 'Track date and time';


--
-- TOC entry 416 (class 1259 OID 19958)
-- Name: users_tracking_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_tracking_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_tracking_id_seq OWNER TO darwin2;

--
-- TOC entry 7450 (class 0 OID 0)
-- Dependencies: 416
-- Name: users_tracking_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.users_tracking_id_seq OWNED BY darwin2.users_tracking.id;


--
-- TOC entry 417 (class 1259 OID 19960)
-- Name: users_tracking_proppb; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users_tracking_proppb (
    id integer,
    referenced_relation character varying,
    record_id integer,
    user_ref integer,
    action character varying,
    old_value public.hstore,
    new_value public.hstore,
    modification_date_time timestamp without time zone
);


ALTER TABLE darwin2.users_tracking_proppb OWNER TO darwin2;

--
-- TOC entry 418 (class 1259 OID 19966)
-- Name: v_collection_statistics; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_collection_statistics AS
 SELECT DISTINCT ((specimens.collection_path)::text || ((specimens.collection_ref)::character varying)::text) AS collection_path,
    'type_count'::text AS counter_category,
    specimens.type AS items,
    count(specimens.id) AS count_items
   FROM darwin2.specimens
  GROUP BY specimens.collection_ref, specimens.type, specimens.collection_path
UNION
 SELECT DISTINCT ((specimens.collection_path)::text || ((specimens.collection_ref)::character varying)::text) AS collection_path,
    'image_count'::text AS counter_category,
    ext_links.category AS items,
    count(ext_links.id) AS count_items
   FROM (darwin2.ext_links
     JOIN darwin2.specimens ON (((ext_links.record_id = specimens.id) AND ((ext_links.referenced_relation)::text = 'specimens'::text))))
  GROUP BY specimens.collection_ref, ext_links.category, specimens.collection_path;


ALTER TABLE darwin2.v_collection_statistics OWNER TO darwin2;

--
-- TOC entry 419 (class 1259 OID 19971)
-- Name: v_comment_loans; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_comment_loans AS
 SELECT properties.id,
    properties.record_id,
    properties.lower_value,
    regexp_matches((properties.lower_value)::text, '($|[^[:alnum:]])(loans?)($|[^[:alnum:]])'::text) AS regexp_matches
   FROM darwin2.properties
  WHERE ((properties.referenced_relation)::text = 'specimens'::text)
UNION
 SELECT properties.id,
    properties.record_id,
    properties.lower_value,
    regexp_matches((properties.lower_value)::text, '($|[^[:alnum:]])(prêts?)($|[^[:alnum:]])'::text) AS regexp_matches
   FROM darwin2.properties
  WHERE ((properties.referenced_relation)::text = 'specimens'::text)
UNION
 SELECT comments.id,
    comments.record_id,
    comments.comment AS lower_value,
    regexp_matches(comments.comment, '($|[^[:alnum:]])(prêts?)($|[^[:alnum:]])'::text) AS regexp_matches
   FROM darwin2.comments
  WHERE ((comments.referenced_relation)::text = 'specimens'::text)
UNION
 SELECT comments.id,
    comments.record_id,
    comments.comment AS lower_value,
    regexp_matches(comments.comment, '($|[^[:alnum:]])(loans?)($|[^[:alnum:]])'::text) AS regexp_matches
   FROM darwin2.comments
  WHERE ((comments.referenced_relation)::text = 'specimens'::text);


ALTER TABLE darwin2.v_comment_loans OWNER TO darwin2;

--
-- TOC entry 542 (class 1259 OID 1881141)
-- Name: v_control_identifications; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_control_identifications AS
 WITH a AS (
         SELECT a_1.linked_ref,
            a_1.specimen_ref AS cluster_ref
           FROM ( SELECT specimens_relationships.specimen_ref AS linked_ref,
                    specimens_relationships.id,
                    specimens_relationships.specimen_ref,
                    specimens_relationships.relationship_type,
                    specimens_relationships.unit_type,
                    specimens_relationships.specimen_related_ref,
                    specimens_relationships.taxon_ref,
                    specimens_relationships.mineral_ref,
                    specimens_relationships.institution_ref,
                    specimens_relationships.source_name,
                    specimens_relationships.source_id,
                    specimens_relationships.quantity,
                    specimens_relationships.unit
                   FROM darwin2.specimens_relationships
                  WHERE ((specimens_relationships.relationship_type)::text = 'other_identification'::text)
                UNION
                 SELECT specimens_relationships.specimen_related_ref AS linked_ref,
                    specimens_relationships.id,
                    specimens_relationships.specimen_ref,
                    specimens_relationships.relationship_type,
                    specimens_relationships.unit_type,
                    specimens_relationships.specimen_related_ref,
                    specimens_relationships.taxon_ref,
                    specimens_relationships.mineral_ref,
                    specimens_relationships.institution_ref,
                    specimens_relationships.source_name,
                    specimens_relationships.source_id,
                    specimens_relationships.quantity,
                    specimens_relationships.unit
                   FROM darwin2.specimens_relationships
                  WHERE ((specimens_relationships.relationship_type)::text = 'other_identification'::text)) a_1
        ), arr_by_cluster AS (
         SELECT a_1.linked_ref AS linked_ref2,
            a_1.cluster_ref AS cluster_ref2
           FROM a a_1
        )
 SELECT a.linked_ref,
    array_agg(DISTINCT arr_by_cluster.cluster_ref2) AS linked_only,
    array_agg(DISTINCT arr_by_cluster.linked_ref2) AS group_all,
    json_object_agg(DISTINCT COALESCE(specimens.valid_label, true), arr_by_cluster.linked_ref2) AS status_labels
   FROM ((a
     LEFT JOIN arr_by_cluster ON ((a.cluster_ref = arr_by_cluster.cluster_ref2)))
     LEFT JOIN darwin2.specimens ON ((arr_by_cluster.linked_ref2 = specimens.id)))
  WHERE (a.linked_ref <> arr_by_cluster.cluster_ref2)
  GROUP BY a.linked_ref;


ALTER TABLE darwin2.v_control_identifications OWNER TO darwin2;

--
-- TOC entry 543 (class 1259 OID 1881146)
-- Name: v_control_identifications_several_true; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_control_identifications_several_true AS
 SELECT v_control_identifications.linked_ref,
    v_control_identifications.linked_only,
    v_control_identifications.group_all,
    v_control_identifications.status_labels,
    json_object_keys(v_control_identifications.status_labels) AS json_object_keys,
    cardinality(array_positions(ARRAY( SELECT json_object_keys(v_control_identifications.status_labels) AS json_object_keys), 'true'::text)) AS cardinality
   FROM darwin2.v_control_identifications
  ORDER BY (array_length(v_control_identifications.group_all, 1)) DESC;


ALTER TABLE darwin2.v_control_identifications_several_true OWNER TO darwin2;

--
-- TOC entry 420 (class 1259 OID 19976)
-- Name: v_rmca_get_lower_by_higher; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_get_lower_by_higher AS
 SELECT parent.id AS parent_id,
    parent.name AS higher_name,
    parent.level_ref AS parent_level_ref,
    rank_parent.level_name AS parent_level_name,
    child.id AS child_id,
    child.name AS lower_name,
    child.level_ref AS child_level_ref,
    rank_child.level_name AS child_level_name,
    (child.level_ref - parent.level_ref) AS diff,
    child.path AS child_path
   FROM (((darwin2.taxonomy parent
     JOIN darwin2.taxonomy child ON ((((child.path)::text ~~ (('%/'::text || (parent.id)::text) || '/%'::text)) OR (parent.id = child.id))))
     JOIN darwin2.catalogue_levels rank_parent ON ((rank_parent.id = parent.level_ref)))
     JOIN darwin2.catalogue_levels rank_child ON ((rank_child.id = child.level_ref)))
  ORDER BY child.path;


ALTER TABLE darwin2.v_rmca_get_lower_by_higher OWNER TO darwin2;

--
-- TOC entry 421 (class 1259 OID 19981)
-- Name: v_rmca_count_specimen_by_higher; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_count_specimen_by_higher AS
 SELECT c.parent_id,
    c.parent_level_name,
    c.parent_level_ref,
    c.higher_name,
    c.child_id,
    c.child_level_name,
    c.child_level_ref,
    c.lower_name,
    a.collection_ref,
    count(a.id) AS count_all,
    (((c.child_path)::text || (c.child_id)::text) || '/'::text) AS full_path,
    ( SELECT count(specimens.id) AS count
           FROM darwin2.specimens
          WHERE (specimens.taxon_ref = c.child_id)) AS count_direct
   FROM ((darwin2.specimens a
     JOIN darwin2.taxonomy b ON ((a.taxon_ref = b.id)))
     JOIN darwin2.v_rmca_get_lower_by_higher c ON (((((b.path)::text || (b.id)::text) || '/'::text) ~~ (((c.child_path)::text || (c.child_id)::text) || '/%'::text))))
  GROUP BY c.parent_id, c.parent_level_name, c.child_level_name, c.higher_name, c.child_id, c.lower_name, a.collection_ref, c.diff, c.parent_level_ref, c.child_level_ref, c.child_path
  ORDER BY c.higher_name, c.diff, c.lower_name;


ALTER TABLE darwin2.v_rmca_count_specimen_by_higher OWNER TO darwin2;

--
-- TOC entry 422 (class 1259 OID 19986)
-- Name: v_count_by_families_genus_species; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_count_by_families_genus_species AS
 SELECT v_rmca_count_specimen_by_higher.child_level_name AS level,
    v_rmca_count_specimen_by_higher.lower_name AS family,
    NULL::character varying AS genus,
    NULL::text AS species_or_lower,
    v_rmca_count_specimen_by_higher.count_all AS count_all_family,
    v_rmca_count_specimen_by_higher.count_direct AS count_direct_family,
    NULL::bigint AS count_all_genus,
    NULL::bigint AS count_direct_genus,
    NULL::text AS count_all_species,
    NULL::text AS count_direct_species,
    v_rmca_count_specimen_by_higher.full_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically((v_rmca_count_specimen_by_higher.full_path)::character varying) AS full_path_alpha,
    v_rmca_count_specimen_by_higher.collection_ref
   FROM darwin2.v_rmca_count_specimen_by_higher
  WHERE ((v_rmca_count_specimen_by_higher.parent_level_ref = 34) AND (v_rmca_count_specimen_by_higher.child_level_ref = 34))
UNION
 SELECT v_rmca_count_specimen_by_higher.child_level_name AS level,
    v_rmca_count_specimen_by_higher.higher_name AS family,
    v_rmca_count_specimen_by_higher.lower_name AS genus,
    NULL::text AS species_or_lower,
    NULL::bigint AS count_all_family,
    NULL::bigint AS count_direct_family,
    v_rmca_count_specimen_by_higher.count_all AS count_all_genus,
    v_rmca_count_specimen_by_higher.count_direct AS count_direct_genus,
    NULL::text AS count_all_species,
    NULL::text AS count_direct_species,
    v_rmca_count_specimen_by_higher.full_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically((v_rmca_count_specimen_by_higher.full_path)::character varying) AS full_path_alpha,
    v_rmca_count_specimen_by_higher.collection_ref
   FROM darwin2.v_rmca_count_specimen_by_higher
  WHERE ((v_rmca_count_specimen_by_higher.parent_level_ref = 34) AND (v_rmca_count_specimen_by_higher.child_level_ref > 34) AND (v_rmca_count_specimen_by_higher.child_level_ref <= 41))
UNION
 SELECT v_rmca_count_specimen_by_higher.child_level_name AS level,
    v_rmca_count_specimen_by_higher.higher_name AS family,
    NULL::character varying AS genus,
    v_rmca_count_specimen_by_higher.lower_name AS species_or_lower,
    NULL::bigint AS count_all_family,
    NULL::bigint AS count_direct_family,
    NULL::bigint AS count_all_genus,
    NULL::bigint AS count_direct_genus,
    (v_rmca_count_specimen_by_higher.count_all)::text AS count_all_species,
    (v_rmca_count_specimen_by_higher.count_direct)::text AS count_direct_species,
    v_rmca_count_specimen_by_higher.full_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically((v_rmca_count_specimen_by_higher.full_path)::character varying) AS full_path_alpha,
    v_rmca_count_specimen_by_higher.collection_ref
   FROM darwin2.v_rmca_count_specimen_by_higher
  WHERE ((v_rmca_count_specimen_by_higher.parent_level_ref = 34) AND (v_rmca_count_specimen_by_higher.child_level_ref > 41));


ALTER TABLE darwin2.v_count_by_families_genus_species OWNER TO darwin2;

--
-- TOC entry 423 (class 1259 OID 19991)
-- Name: v_count_by_families_genus_species_subspecies; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_count_by_families_genus_species_subspecies AS
 SELECT v_rmca_count_specimen_by_higher.child_level_name AS level,
    v_rmca_count_specimen_by_higher.lower_name AS family,
    NULL::character varying AS genus,
    NULL::text AS species_or_lower,
    v_rmca_count_specimen_by_higher.count_all AS count_all_family,
    v_rmca_count_specimen_by_higher.count_direct AS count_direct_family,
    NULL::bigint AS count_all_genus,
    NULL::bigint AS count_direct_genus,
    NULL::text AS count_all_species,
    NULL::text AS count_direct_species,
    NULL::text AS count_all_subspecies,
    NULL::text AS count_direct_subspecies,
    v_rmca_count_specimen_by_higher.full_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically((v_rmca_count_specimen_by_higher.full_path)::character varying) AS full_path_alpha,
    v_rmca_count_specimen_by_higher.collection_ref
   FROM darwin2.v_rmca_count_specimen_by_higher
  WHERE ((v_rmca_count_specimen_by_higher.parent_level_ref = 34) AND (v_rmca_count_specimen_by_higher.child_level_ref = 34))
UNION
 SELECT v_rmca_count_specimen_by_higher.child_level_name AS level,
    v_rmca_count_specimen_by_higher.higher_name AS family,
    v_rmca_count_specimen_by_higher.lower_name AS genus,
    NULL::text AS species_or_lower,
    NULL::bigint AS count_all_family,
    NULL::bigint AS count_direct_family,
    v_rmca_count_specimen_by_higher.count_all AS count_all_genus,
    v_rmca_count_specimen_by_higher.count_direct AS count_direct_genus,
    NULL::text AS count_all_species,
    NULL::text AS count_direct_species,
    NULL::text AS count_all_subspecies,
    NULL::text AS count_direct_subspecies,
    v_rmca_count_specimen_by_higher.full_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically((v_rmca_count_specimen_by_higher.full_path)::character varying) AS full_path_alpha,
    v_rmca_count_specimen_by_higher.collection_ref
   FROM darwin2.v_rmca_count_specimen_by_higher
  WHERE ((v_rmca_count_specimen_by_higher.parent_level_ref = 34) AND (v_rmca_count_specimen_by_higher.child_level_ref > 34) AND (v_rmca_count_specimen_by_higher.child_level_ref <= 41))
UNION
 SELECT v_rmca_count_specimen_by_higher.child_level_name AS level,
    v_rmca_count_specimen_by_higher.higher_name AS family,
    v_rmca_count_specimen_by_higher.lower_name AS genus,
    NULL::text AS species_or_lower,
    NULL::bigint AS count_all_family,
    NULL::bigint AS count_direct_family,
    NULL::bigint AS count_all_genus,
    NULL::bigint AS count_direct_genus,
    (v_rmca_count_specimen_by_higher.count_all)::text AS count_all_species,
    (v_rmca_count_specimen_by_higher.count_direct)::text AS count_direct_species,
    NULL::text AS count_all_subspecies,
    NULL::text AS count_direct_subspecies,
    v_rmca_count_specimen_by_higher.full_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically((v_rmca_count_specimen_by_higher.full_path)::character varying) AS full_path_alpha,
    v_rmca_count_specimen_by_higher.collection_ref
   FROM darwin2.v_rmca_count_specimen_by_higher
  WHERE ((v_rmca_count_specimen_by_higher.parent_level_ref = 34) AND (v_rmca_count_specimen_by_higher.child_level_ref > 41) AND (v_rmca_count_specimen_by_higher.child_level_ref <= 48))
UNION
 SELECT v_rmca_count_specimen_by_higher.child_level_name AS level,
    v_rmca_count_specimen_by_higher.higher_name AS family,
    NULL::character varying AS genus,
    v_rmca_count_specimen_by_higher.lower_name AS species_or_lower,
    NULL::bigint AS count_all_family,
    NULL::bigint AS count_direct_family,
    NULL::bigint AS count_all_genus,
    NULL::bigint AS count_direct_genus,
    NULL::text AS count_all_species,
    NULL::text AS count_direct_species,
    (v_rmca_count_specimen_by_higher.count_all)::text AS count_all_subspecies,
    (v_rmca_count_specimen_by_higher.count_direct)::text AS count_direct_subspecies,
    v_rmca_count_specimen_by_higher.full_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically((v_rmca_count_specimen_by_higher.full_path)::character varying) AS full_path_alpha,
    v_rmca_count_specimen_by_higher.collection_ref
   FROM darwin2.v_rmca_count_specimen_by_higher
  WHERE (v_rmca_count_specimen_by_higher.parent_level_ref > 48);


ALTER TABLE darwin2.v_count_by_families_genus_species_subspecies OWNER TO darwin2;

--
-- TOC entry 424 (class 1259 OID 19996)
-- Name: v_danny_2020_check_collection_date; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_danny_2020_check_collection_date AS
 SELECT a.record_id,
    a.unitid,
    a.acquisitionday,
    a.acquisitionmonth,
    a.acquisitionyear,
    a.collectionstartday,
    a.collectionstartmonth,
    a.collectionstartyear,
    a.collectionendday,
    a.collectionendmonth,
    a.collectionendyear,
    date_part('year'::text, specimens.gtu_from_date) AS from_year,
    date_part('month'::text, specimens.gtu_from_date) AS from_month,
    date_part('day'::text, specimens.gtu_from_date) AS from_day,
    date_part('year'::text, specimens.gtu_to_date) AS to_year,
    date_part('month'::text, specimens.gtu_to_date) AS to_month,
    date_part('day'::text, specimens.gtu_to_date) AS to_day,
    specimens.gtu_from_date_mask,
    specimens.gtu_to_date,
    specimens.gtu_to_date_mask,
    specimens.acquisition_date,
    specimens.acquisition_date_mask,
    specimens.gtu_from_date,
    date_part('year'::text, specimens.acquisition_date) AS dw_acquisitionyear,
    date_part('month'::text, specimens.acquisition_date) AS dw_acquisitionmonth,
    date_part('day'::text, specimens.acquisition_date) AS dw_acquisitionday
   FROM (( SELECT check_dates_danny.unitid,
            check_dates_danny.accessionnumber,
            check_dates_danny.acquisitiontype,
            check_dates_danny.acquiredfrom,
            check_dates_danny.acquisitionday,
            check_dates_danny.acquisitionmonth,
            check_dates_danny.acquisitionyear,
            check_dates_danny.collectedby,
            check_dates_danny.collectionstartday,
            check_dates_danny.collectionstartmonth,
            check_dates_danny.collectionstartyear,
            check_dates_danny.collectionendday,
            check_dates_danny.collectionendmonth,
            check_dates_danny.collectionendyear,
            codes.record_id
           FROM (darwin2.check_dates_danny
             JOIN darwin2.codes ON (((check_dates_danny.unitid)::text = btrim((((codes.code_prefix)::text || (codes.code_prefix_separator)::text) || (codes.code)::text), ((codes.code_suffix_separator)::text || (codes.code_suffix)::text)))))
        UNION
         SELECT check_dates_danny.unitid,
            check_dates_danny.accessionnumber,
            check_dates_danny.acquisitiontype,
            check_dates_danny.acquiredfrom,
            check_dates_danny.acquisitionday,
            check_dates_danny.acquisitionmonth,
            check_dates_danny.acquisitionyear,
            check_dates_danny.collectedby,
            check_dates_danny.collectionstartday,
            check_dates_danny.collectionstartmonth,
            check_dates_danny.collectionstartyear,
            check_dates_danny.collectionendday,
            check_dates_danny.collectionendmonth,
            check_dates_danny.collectionendyear,
            codes.record_id
           FROM (darwin2.check_dates_danny
             JOIN darwin2.codes ON (((check_dates_danny.unitid)::text = (codes.code)::text)))) a
     LEFT JOIN darwin2.specimens ON ((a.record_id = specimens.id)));


ALTER TABLE darwin2.v_danny_2020_check_collection_date OWNER TO darwin2;

--
-- TOC entry 425 (class 1259 OID 20001)
-- Name: v_darwin_ichtyo_history_of_reidentifications; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_ichtyo_history_of_reidentifications AS
 WITH a AS (
         SELECT DISTINCT specimens_1.main_code_indexed AS idx2
           FROM darwin2.specimens specimens_1
          WHERE ((specimens_1.valid_label = false) AND (specimens_1.collection_ref = 6))
        )
 SELECT DISTINCT codes.code,
    specimens.main_code_indexed,
    array_agg(specimens.id ORDER BY identifications.notion_date) AS technical_ids,
    array_agg(specimens.specimen_creation_date ORDER BY identifications.notion_date) AS technical_creation_dates,
    array_agg(((((('Identification: '::text || (identifications.value_defined)::text) || '; by '::text) || b.identifiers) || ' date '::text) || ((identifications.notion_date)::character varying)::text) ORDER BY ((identifications.notion_date || ' is valid'::text) || specimens.valid_label)) AS identifications,
    array_agg(specimens.valid_label ORDER BY identifications.notion_date) AS valid_labels
   FROM ((((darwin2.specimens
     JOIN a ON (((specimens.main_code_indexed)::text = (a.idx2)::text)))
     LEFT JOIN darwin2.identifications ON ((specimens.id = identifications.record_id)))
     LEFT JOIN ( SELECT string_agg((people.formated_name)::text, ','::text ORDER BY catalogue_people.order_by) AS identifiers,
            catalogue_people.record_id
           FROM (darwin2.catalogue_people
             LEFT JOIN darwin2.people ON (((catalogue_people.people_ref = people.id) AND ((catalogue_people.referenced_relation)::text = 'identifications'::text))))
          GROUP BY catalogue_people.record_id) b ON ((identifications.id = b.record_id)))
     LEFT JOIN darwin2.codes ON (((codes.record_id = specimens.id) AND ((codes.code_category)::text = 'main'::text) AND ((codes.referenced_relation)::text = 'specimens'::text))))
  WHERE (((identifications.notion_concerned)::text = 'taxonomy'::text) AND (specimens.collection_ref = 6))
  GROUP BY specimens.main_code_indexed, codes.code;


ALTER TABLE darwin2.v_darwin_ichtyo_history_of_reidentifications OWNER TO darwin2;

--
-- TOC entry 426 (class 1259 OID 20006)
-- Name: v_darwin_ipt; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_ipt AS
 SELECT DISTINCT string_agg(DISTINCT ((specimens.id)::character varying)::text, ','::text) AS ids,
    ((((('http://www.africamuseum.be/collections/browsecollections/naturalsciences/biology/ichtyology/darwin_specimen?id_spec='::text || (COALESCE(codes.code_prefix, ''::character varying))::text) || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text) AS guid,
    specimens.collection_ref,
    collections.code AS collection_code,
    collections.name AS collection_name,
    collections.id AS collection_id,
    collections.path AS collection_path,
    (((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text) AS cataloguenumber,
    'PreservedSpecimen'::text AS basisofrecord,
    'RMCA'::text AS institutionid,
    'BE-RMCA'::text AS iso_country_institution,
    'Please cite the soruce database appropriatly'::text AS bibliographic_citation,
    'placeholder for CC licence'::text AS license,
    'didier.van.den.spiegel@africamuseum.be'::text AS email,
    specimens.type,
    specimens.taxon_path,
    specimens.taxon_ref,
    specimens.taxon_name,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 34) AS family,
    specimens.gtu_iso3166 AS iso_country,
    specimens.gtu_country_tag_value AS country,
    btrim(replace(replace((specimens.gtu_others_tag_value)::text, (specimens.gtu_country_tag_value)::text, ''::text), 'Africa'::text, ''::text), ';'::text) AS location,
    (specimens.gtu_location[1])::character varying AS latitude,
    (specimens.gtu_location[0])::character varying AS longitude,
    gtu.lat_long_accuracy,
    specimens.spec_coll_ids AS collector_ids,
    ( SELECT string_agg((people.formated_name)::text, ', '::text ORDER BY people.id) AS string_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens.spec_coll_ids))) AS collectors,
    specimens.spec_don_sel_ids AS donator_ids,
    ( SELECT string_agg((people.formated_name)::text, ', '::text ORDER BY people.id) AS string_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens.spec_don_sel_ids))) AS donators,
    specimens.spec_ident_ids AS identifiers_ids,
    ( SELECT string_agg((people.formated_name)::text, ', '::text ORDER BY people.id) AS string_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens.spec_ident_ids))) AS identifiers,
    specimens.gtu_from_date,
    specimens.gtu_from_date_mask,
    specimens.gtu_to_date,
    specimens.gtu_to_date_mask,
    replace(replace((NULLIF(darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask), 'xxxx-xx-xx'::text) || COALESCE(('-'::text || NULLIF(darwin2.fct_mask_date(specimens.gtu_to_date, specimens.gtu_to_date_mask), 'xxxx-xx-xx'::text)), ''::text)), 'xxxx'::text, ''::text), '-xx'::text, ''::text) AS eventdate,
    unnest(
        CASE
            WHEN (specimens.gtu_country_tag_indexed IS NOT NULL) THEN specimens.gtu_country_tag_indexed
            ELSE NULL::character varying[]
        END) AS country_unnest,
    ext_links_thumbnails.url AS urls_thumbnails,
    ext_links_thumbnails.category AS image_category_thumbnails,
    ext_links_thumbnails.contributor AS contributor_thumbnails,
    ext_links_thumbnails.disclaimer AS disclaimer_thumbnails,
    ext_links_thumbnails.license AS license_thumbnails,
    ext_links_thumbnails.display_order AS display_order_thumbnails,
    ext_links_image_links.url AS urls_image_links,
    ext_links_image_links.category AS image_category_image_links,
    ext_links_image_links.contributor AS contributor_image_links,
    ext_links_image_links.disclaimer AS disclaimer_image_links,
    ext_links_image_links.license AS license_image_links,
    ext_links_image_links.display_order AS display_order_image_links,
    ext_links_3d_snippets.url AS urls_3d_snippets,
    ext_links_3d_snippets.category AS image_category_3d_snippets,
    ext_links_3d_snippets.contributor AS contributor_3d_snippets,
    ext_links_3d_snippets.disclaimer AS disclaimer_3d_snippets,
    ext_links_3d_snippets.license AS license_3d_snippets,
    ext_links_3d_snippets.display_order AS display_order_3d_snippets,
    replace(replace((NULLIF(darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask), 'xxxx-xx-xx'::text) || COALESCE(('-'::text || NULLIF(darwin2.fct_mask_date(specimens.gtu_to_date, specimens.gtu_to_date_mask), 'xxxx-xx-xx'::text)), ''::text)), 'xxxx'::text, ''::text), '-xx'::text, ''::text) AS identification_date,
    (COALESCE((darwin2.fct_mask_date(identifications.notion_date, identifications.notion_date_mask) || ': '::text), ''::text) || (specimens.taxon_name)::text) AS history,
    specimens.gtu_ref
   FROM ((((((((darwin2.specimens
     LEFT JOIN darwin2.collections ON ((specimens.collection_ref = collections.id)))
     LEFT JOIN darwin2.codes ON ((((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text) AND (specimens.id = codes.record_id))))
     LEFT JOIN darwin2.ext_links ext_links_thumbnails ON (((specimens.id = ext_links_thumbnails.record_id) AND ((ext_links_thumbnails.referenced_relation)::text = 'specimens'::text) AND ((ext_links_thumbnails.category)::text = 'thumbnail'::text))))
     LEFT JOIN darwin2.ext_links ext_links_image_links ON (((specimens.id = ext_links_image_links.record_id) AND ((ext_links_image_links.referenced_relation)::text = 'specimens'::text) AND ((ext_links_image_links.category)::text = 'image_link'::text))))
     LEFT JOIN darwin2.ext_links ext_links_3d_snippets ON (((specimens.id = ext_links_3d_snippets.record_id) AND ((ext_links_3d_snippets.referenced_relation)::text = 'specimens'::text) AND ((ext_links_3d_snippets.category)::text = 'html_3d_snippet'::text))))
     LEFT JOIN darwin2.identifications ON ((((identifications.referenced_relation)::text = 'specimens'::text) AND (specimens.id = identifications.record_id) AND ((identifications.notion_concerned)::text = 'taxonomy'::text))))
     LEFT JOIN darwin2.tags ON ((specimens.gtu_ref = tags.gtu_ref)))
     LEFT JOIN darwin2.gtu ON ((specimens.gtu_ref = gtu.id)))
  GROUP BY ((((('http://www.africamuseum.be/collections/browsecollections/naturalsciences/biology/ichtyology/darwin_specimen?id_spec='::text || (COALESCE(codes.code_prefix, ''::character varying))::text) || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text), collections.id, collections.path, collections.name, collections.code, (((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text), specimens.taxon_path, specimens.taxon_ref, specimens.collection_ref, specimens.gtu_country_tag_indexed, specimens.gtu_country_tag_value, specimens.gtu_iso3166, (specimens.gtu_location[0])::character varying, (specimens.gtu_location[1])::character varying, specimens.spec_ident_ids, specimens.gtu_others_tag_indexed, specimens.gtu_others_tag_value, specimens.taxon_name, ext_links_thumbnails.url, ext_links_thumbnails.category, ext_links_thumbnails.contributor, ext_links_thumbnails.disclaimer, ext_links_thumbnails.license, ext_links_thumbnails.display_order, ext_links_image_links.url, ext_links_image_links.category, ext_links_image_links.contributor, ext_links_image_links.disclaimer, ext_links_image_links.license, ext_links_image_links.display_order, ext_links_3d_snippets.url, ext_links_3d_snippets.category, ext_links_3d_snippets.contributor, ext_links_3d_snippets.disclaimer, ext_links_3d_snippets.license, ext_links_3d_snippets.display_order, identifications.notion_date, identifications.notion_date_mask, specimens.gtu_ref, specimens.gtu_from_date, specimens.gtu_from_date_mask, specimens.gtu_to_date, specimens.gtu_to_date_mask, specimens.type, specimens.spec_coll_ids, specimens.spec_don_sel_ids, codes.full_code_indexed, gtu.lat_long_accuracy;


ALTER TABLE darwin2.v_darwin_ipt OWNER TO darwin2;

--
-- TOC entry 427 (class 1259 OID 20011)
-- Name: v_darwin_ipt_taxonomy; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_ipt_taxonomy AS
 SELECT taxonomy.id AS darwin_id,
    taxonomy.name AS scientificname,
    catalogue_levels.level_name AS taxonrank,
    catalogue_levels.level_name AS verbatimtaxonrank,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 2) AS kingdom,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 4) AS phylum,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 12) AS class,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 28) AS "order",
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 34) AS family,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 41) AS genus,
    replace((darwin2.fct_rmca_sort_taxon_path_alphabetically_not_indexed(taxonomy.path))::text, '/'::text, '|'::text) AS higherclassification,
    taxonomy.path,
    ((taxonomy.path)::text || ((taxonomy.id)::character varying)::text) AS full_path
   FROM (darwin2.taxonomy
     LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)));


ALTER TABLE darwin2.v_darwin_ipt_taxonomy OWNER TO darwin2;

--
-- TOC entry 428 (class 1259 OID 20016)
-- Name: vernacular_names; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.vernacular_names (
    id integer NOT NULL,
    community character varying NOT NULL,
    community_indexed character varying NOT NULL,
    name character varying NOT NULL,
    name_indexed character varying NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.vernacular_names OWNER TO darwin2;

--
-- TOC entry 7451 (class 0 OID 0)
-- Dependencies: 428
-- Name: TABLE vernacular_names; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.vernacular_names IS 'List of vernacular names for a given unit and a given language community';


--
-- TOC entry 7452 (class 0 OID 0)
-- Dependencies: 428
-- Name: COLUMN vernacular_names.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.vernacular_names.referenced_relation IS 'Reference of the unit table a vernacular name for a language community has to be defined - id field of table_list table';


--
-- TOC entry 7453 (class 0 OID 0)
-- Dependencies: 428
-- Name: COLUMN vernacular_names.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.vernacular_names.record_id IS 'Identifier of record a vernacular name for a language community has to be defined';


--
-- TOC entry 7454 (class 0 OID 0)
-- Dependencies: 428
-- Name: COLUMN vernacular_names.community; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.vernacular_names.community IS 'Language community, a unit translation is available for';


--
-- TOC entry 7455 (class 0 OID 0)
-- Dependencies: 428
-- Name: COLUMN vernacular_names.community_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.vernacular_names.community_indexed IS 'indexed version of the language community';


--
-- TOC entry 7456 (class 0 OID 0)
-- Dependencies: 428
-- Name: COLUMN vernacular_names.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.vernacular_names.name IS 'Vernacular name';


--
-- TOC entry 7457 (class 0 OID 0)
-- Dependencies: 428
-- Name: COLUMN vernacular_names.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.vernacular_names.name_indexed IS 'Indexed form of vernacular name';


--
-- TOC entry 429 (class 1259 OID 20022)
-- Name: v_darwin_ipt_taxonomy_vernacular; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_ipt_taxonomy_vernacular AS
 SELECT taxonomy.id AS darwin_id,
    taxonomy.name AS scientificname,
    catalogue_levels.level_name AS taxonrank,
    catalogue_levels.level_name AS verbatimtaxonrank,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 2) AS kingdom,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 4) AS phylum,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 12) AS class,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 28) AS "order",
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 34) AS family,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 41) AS genus,
    replace((darwin2.fct_rmca_sort_taxon_path_alphabetically_not_indexed(taxonomy.path))::text, '/'::text, '|'::text) AS higherclassification,
    taxonomy.path,
    (((taxonomy.path)::text || '/'::text) || taxonomy.id) AS full_path,
    vernacular_names.community,
    vernacular_names.name
   FROM ((darwin2.taxonomy
     LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)))
     LEFT JOIN darwin2.vernacular_names ON ((((vernacular_names.referenced_relation)::text = 'taxonomy'::text) AND (vernacular_names.record_id = taxonomy.id))));


ALTER TABLE darwin2.v_darwin_ipt_taxonomy_vernacular OWNER TO darwin2;

--
-- TOC entry 430 (class 1259 OID 20027)
-- Name: v_darwin_public; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_public AS
 SELECT DISTINCT array_agg(DISTINCT specimens.id) AS ids,
    specimens.collection_name,
    specimens.code_display,
    array_agg(DISTINCT specimens.taxon_path) AS taxon_paths,
    array_agg(DISTINCT specimens.taxon_ref) AS taxon_ref,
    array_agg(DISTINCT specimens.taxon_name) AS taxon_name,
    array_agg(DISTINCT specimens.history) AS history_identification,
    specimens.gtu_country_tag_value,
    specimens.gtu_others_tag_value,
    specimens.gtu_from_date,
    specimens.gtu_from_date_mask,
    specimens.gtu_to_date,
    specimens.gtu_to_date_mask,
    darwin2.fct_mask_date(specimens.gtu_to_date, specimens.gtu_to_date_mask) AS fct_mask_date,
    darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask) AS date_from_display,
    darwin2.fct_mask_date(specimens.gtu_to_date, specimens.gtu_to_date_mask) AS date_to_display,
    specimens.coll_type,
    string_agg(DISTINCT (specimens.urls_thumbnails)::text, '|'::text) AS urls_thumbnails,
    string_agg(DISTINCT (specimens.image_category_thumbnails)::text, '|'::text) AS image_category_thumbnails,
    string_agg(DISTINCT (specimens.contributor_thumbnails)::text, '|'::text) AS contributor_thumbnails,
    string_agg(DISTINCT (specimens.disclaimer_thumbnails)::text, '|'::text) AS disclaimer_thumbnails,
    string_agg(DISTINCT (specimens.license_thumbnails)::text, '|'::text) AS license_order_thumbnails,
    string_agg(DISTINCT ((specimens.display_order_thumbnails)::character varying)::text, '|'::text) AS display_order_thumbnails,
    string_agg(DISTINCT (specimens.urls_image_links)::text, '|'::text) AS urls_image_links,
    string_agg(DISTINCT (specimens.image_category_image_links)::text, '|'::text) AS image_category_image_links,
    string_agg(DISTINCT (specimens.contributor_image_links)::text, '|'::text) AS contributor_image_links,
    string_agg(DISTINCT (specimens.disclaimer_image_links)::text, '|'::text) AS disclaimer_image_links,
    string_agg(DISTINCT (specimens.license_image_links)::text, '|'::text) AS license_image_links,
    string_agg(DISTINCT ((specimens.display_order_image_links)::character varying)::text, '|'::text) AS display_order_image_links,
    string_agg(DISTINCT (specimens.urls_3d_snippets)::text, '|'::text) AS urls_3d_snippets,
    string_agg(DISTINCT (specimens.image_category_3d_snippets)::text, '|'::text) AS image_category_3d_snippets,
    string_agg(DISTINCT (specimens.contributor_3d_snippets)::text, '|'::text) AS contributor_3d_snippets,
    string_agg(DISTINCT (specimens.disclaimer_3d_snippets)::text, '|'::text) AS disclaimer_3d_snippets,
    string_agg(DISTINCT (specimens.license_3d_snippets)::text, '|'::text) AS license_3d_snippets,
    string_agg(DISTINCT ((specimens.display_order_3d_snippets)::character varying)::text, '|'::text) AS display_order_3d_snippets,
    specimens.longitude,
    specimens.latitude,
    count(*) OVER () AS full_count,
    specimens.collector_ids,
    ( SELECT array_agg(people.formated_name) AS array_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens.collector_ids))) AS collectors,
    specimens.donator_ids,
    ( SELECT array_agg(people.formated_name) AS array_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens.donator_ids))) AS donators,
    array_agg(DISTINCT (('\"'::text || specimens.tag_locality) || '\"'::text)) AS localities,
    specimens.modification_date_time
   FROM ( SELECT specimens_1.id,
            (((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text) AS code_display,
            codes.full_code_indexed,
            specimens_1.taxon_path,
            specimens_1.taxon_ref,
            specimens_1.collection_ref,
            specimens_1.collection_name,
            specimens_1.gtu_country_tag_indexed,
            specimens_1.gtu_country_tag_value,
            specimens_1.gtu_others_tag_indexed AS localities_indexed,
            specimens_1.gtu_others_tag_value,
            specimens_1.taxon_name,
            specimens_1.spec_coll_ids AS collector_ids,
            specimens_1.spec_don_sel_ids AS donator_ids,
            specimens_1.gtu_from_date,
            specimens_1.gtu_from_date_mask,
            specimens_1.gtu_to_date,
            specimens_1.gtu_to_date_mask,
            specimens_1.type AS coll_type,
            unnest(
                CASE
                    WHEN (specimens_1.gtu_country_tag_indexed IS NOT NULL) THEN specimens_1.gtu_country_tag_indexed
                    ELSE NULL::character varying[]
                END) AS country_unnest,
            ext_links_thumbnails.url AS urls_thumbnails,
            ext_links_thumbnails.category AS image_category_thumbnails,
            ext_links_thumbnails.contributor AS contributor_thumbnails,
            ext_links_thumbnails.disclaimer AS disclaimer_thumbnails,
            ext_links_thumbnails.license AS license_thumbnails,
            ext_links_thumbnails.display_order AS display_order_thumbnails,
            ext_links_image_links.url AS urls_image_links,
            ext_links_image_links.category AS image_category_image_links,
            ext_links_image_links.contributor AS contributor_image_links,
            ext_links_image_links.disclaimer AS disclaimer_image_links,
            ext_links_image_links.license AS license_image_links,
            ext_links_image_links.display_order AS display_order_image_links,
            ext_links_3d_snippets.url AS urls_3d_snippets,
            ext_links_3d_snippets.category AS image_category_3d_snippets,
            ext_links_3d_snippets.contributor AS contributor_3d_snippets,
            ext_links_3d_snippets.disclaimer AS disclaimer_3d_snippets,
            ext_links_3d_snippets.license AS license_3d_snippets,
            ext_links_3d_snippets.display_order AS display_order_3d_snippets,
            specimens_1.gtu_location[0] AS latitude,
            specimens_1.gtu_location[1] AS longitude,
            identifications.notion_date AS identification_date,
            identifications.notion_date_mask AS identification_date_mask,
            (COALESCE((darwin2.fct_mask_date(identifications.notion_date, identifications.notion_date_mask) || ': '::text), ''::text) || (specimens_1.taxon_name)::text) AS history,
            specimens_1.gtu_ref,
            tags.group_type,
            tags.sub_group_type,
            tags.tag,
            (((((tags.group_type)::text || '-'::text) || (tags.sub_group_type)::text) || ':'::text) || (tags.tag)::text) AS tag_locality,
            users_tracking.modification_date_time
           FROM (((((((darwin2.specimens specimens_1
             LEFT JOIN darwin2.codes ON ((((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text) AND (specimens_1.id = codes.record_id))))
             LEFT JOIN darwin2.ext_links ext_links_thumbnails ON (((specimens_1.id = ext_links_thumbnails.record_id) AND ((ext_links_thumbnails.referenced_relation)::text = 'specimens'::text) AND ((ext_links_thumbnails.category)::text = 'thumbnail'::text))))
             LEFT JOIN darwin2.ext_links ext_links_image_links ON (((specimens_1.id = ext_links_image_links.record_id) AND ((ext_links_image_links.referenced_relation)::text = 'specimens'::text) AND ((ext_links_image_links.category)::text = 'image_link'::text))))
             LEFT JOIN darwin2.ext_links ext_links_3d_snippets ON (((specimens_1.id = ext_links_3d_snippets.record_id) AND ((ext_links_3d_snippets.referenced_relation)::text = 'specimens'::text) AND ((ext_links_3d_snippets.category)::text = 'html_3d_snippet'::text))))
             LEFT JOIN darwin2.identifications ON ((((identifications.referenced_relation)::text = 'specimens'::text) AND (specimens_1.id = identifications.record_id) AND ((identifications.notion_concerned)::text = 'taxonomy'::text))))
             LEFT JOIN darwin2.tags ON ((specimens_1.gtu_ref = tags.gtu_ref)))
             LEFT JOIN ( SELECT users_tracking_1.modification_date_time,
                    users_tracking_1.record_id,
                    users_tracking_1.referenced_relation
                   FROM darwin2.users_tracking users_tracking_1
                  ORDER BY users_tracking_1.id DESC
                 LIMIT 1) users_tracking ON (((specimens_1.id = users_tracking.record_id) AND ((users_tracking.referenced_relation)::text = 'specimens'::text))))
          ORDER BY tags.group_ref) specimens
  GROUP BY specimens.code_display, specimens.collection_name, specimens.gtu_country_tag_value, specimens.gtu_others_tag_value, specimens.gtu_from_date, specimens.gtu_from_date_mask, specimens.gtu_to_date, specimens.gtu_to_date_mask, specimens.coll_type, specimens.longitude, specimens.latitude, specimens.collector_ids, specimens.donator_ids, specimens.modification_date_time;


ALTER TABLE darwin2.v_darwin_public OWNER TO darwin2;

--
-- TOC entry 431 (class 1259 OID 20032)
-- Name: v_darwin_public_gis; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_public_gis AS
 SELECT DISTINCT v_darwin_public.ids,
    v_darwin_public.collection_name,
    v_darwin_public.code_display,
    v_darwin_public.taxon_paths,
    v_darwin_public.taxon_ref,
    v_darwin_public.taxon_name,
    v_darwin_public.history_identification,
    v_darwin_public.gtu_country_tag_value,
    v_darwin_public.gtu_others_tag_value,
    v_darwin_public.gtu_from_date,
    v_darwin_public.gtu_from_date_mask,
    v_darwin_public.gtu_to_date,
    v_darwin_public.gtu_to_date_mask,
    v_darwin_public.fct_mask_date,
    v_darwin_public.date_from_display,
    v_darwin_public.date_to_display,
    v_darwin_public.coll_type,
    v_darwin_public.urls_thumbnails,
    v_darwin_public.image_category_thumbnails,
    v_darwin_public.contributor_thumbnails,
    v_darwin_public.disclaimer_thumbnails,
    v_darwin_public.license_order_thumbnails,
    v_darwin_public.display_order_thumbnails,
    v_darwin_public.urls_image_links,
    v_darwin_public.image_category_image_links,
    v_darwin_public.contributor_image_links,
    v_darwin_public.disclaimer_image_links,
    v_darwin_public.license_image_links,
    v_darwin_public.display_order_image_links,
    v_darwin_public.urls_3d_snippets,
    v_darwin_public.image_category_3d_snippets,
    v_darwin_public.contributor_3d_snippets,
    v_darwin_public.disclaimer_3d_snippets,
    v_darwin_public.license_3d_snippets,
    v_darwin_public.display_order_3d_snippets,
    v_darwin_public.longitude,
    v_darwin_public.latitude,
    v_darwin_public.full_count,
    v_darwin_public.collector_ids,
    v_darwin_public.collectors,
    v_darwin_public.donator_ids,
    v_darwin_public.donators,
    v_darwin_public.localities,
    v_darwin_public.modification_date_time,
    public.st_makepoint(v_darwin_public.longitude, v_darwin_public.latitude) AS geom
   FROM darwin2.v_darwin_public;


ALTER TABLE darwin2.v_darwin_public_gis OWNER TO darwin2;

--
-- TOC entry 432 (class 1259 OID 20037)
-- Name: v_darwin_view_for_csv; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_view_for_csv AS
SELECT
    NULL::text AS id,
    NULL::character varying AS collection_code,
    NULL::text AS code,
    NULL::text AS additional_codes,
    NULL::character varying AS ig_num,
    NULL::text AS taxon_name,
    NULL::text AS author,
    NULL::text AS full_scientific_name,
    NULL::text AS family,
    NULL::text AS type,
    NULL::integer AS specimen_count_min,
    NULL::integer AS specimen_count_max,
    NULL::text AS identifiers,
    NULL::text AS abbreviated_identifiers,
    NULL::text AS identification_year,
    NULL::double precision AS longitude,
    NULL::double precision AS latitude,
    NULL::character varying AS longitude_text,
    NULL::character varying AS latitude_text,
    NULL::character varying AS gtu_country_tag_value,
    NULL::text AS municipality,
    NULL::text AS region_district,
    NULL::text AS exact_site,
    NULL::text AS ecology,
    NULL::character varying AS gtu_others_tag_value,
    NULL::character varying AS gtu_code,
    NULL::double precision AS gtu_elevation,
    NULL::double precision AS collecting_year_from,
    NULL::double precision AS collecting_month_from,
    NULL::double precision AS collecting_day_from,
    NULL::double precision AS collecting_year_to,
    NULL::double precision AS collecting_month_to,
    NULL::double precision AS collecting_day_to,
    NULL::text AS properties_locality,
    NULL::text AS collectors,
    NULL::text AS abbreviated_collectors,
    NULL::character varying AS expedition_name,
    NULL::text AS donators,
    NULL::text AS abbreviated_donators,
    NULL::character varying AS acquisition_category,
    NULL::text AS acquisition_date,
    NULL::character varying AS sex,
    NULL::character varying AS stage,
    NULL::character varying AS state,
    NULL::character varying AS social_status,
    NULL::text AS specimen_part,
    NULL::text AS complete,
    NULL::text AS object_name,
    NULL::text AS specimen_status,
    NULL::text AS container_storage,
    NULL::text AS method,
    NULL::text AS tool,
    NULL::text AS comment,
    NULL::text AS properties_all,
    NULL::timestamp without time zone AS specimen_creation_date;


ALTER TABLE darwin2.v_darwin_view_for_csv OWNER TO darwin2;

--
-- TOC entry 433 (class 1259 OID 20042)
-- Name: v_detect_duplicates; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_detect_duplicates AS
 WITH a AS (
         SELECT specimens.id,
            specimens.collection_name,
            specimens.collection_path,
            specimens.collection_ref,
            specimens.taxon_name,
            ((((specimens.collection_path)::text || '/'::text) || specimens.collection_ref) || '/'::text) AS collection_full_path,
            storage_parts.specimen_part,
            (((specimens.collection_path)::text || ((specimens.collection_ref)::character varying)::text) || '/'::text),
            specimens.import_ref
           FROM ((darwin2.specimens
             LEFT JOIN darwin2.identifications ON (((specimens.id = identifications.record_id) AND ((identifications.referenced_relation)::text = 'specimens'::text))))
             LEFT JOIN darwin2.storage_parts ON ((specimens.id = storage_parts.specimen_ref)))
        ), b AS (
         SELECT a.id AS spec_id,
            a.collection_name,
            a.collection_ref,
            codes.code,
            codes.full_code_indexed,
            a.taxon_name,
            a.specimen_part,
            a.import_ref,
            a.collection_full_path
           FROM (a
             JOIN darwin2.codes ON ((((codes.referenced_relation)::text = 'specimens'::text) AND (codes.record_id = a.id) AND ((codes.code_category)::text = 'main'::text))))
        )
 SELECT b.collection_ref,
    b.collection_name,
    b.code,
    b.full_code_indexed,
    count(b.spec_id) AS cpt_spec_ids,
    array_agg(DISTINCT b.taxon_name) AS cpt_taxa,
    count(DISTINCT b.taxon_name) AS cpt_taxon,
    array_agg(b.specimen_part) AS arr_parts,
    array_agg(b.import_ref) AS imports,
    b.collection_full_path
   FROM b
  GROUP BY b.collection_ref, b.code, b.full_code_indexed, b.collection_name, b.collection_full_path
 HAVING (count(b.spec_id) > 1);


ALTER TABLE darwin2.v_detect_duplicates OWNER TO darwin2;

--
-- TOC entry 434 (class 1259 OID 20047)
-- Name: vmap0_world_boundaries; Type: TABLE; Schema: darwin2; Owner: postgres
--

CREATE TABLE darwin2.vmap0_world_boundaries (
    gid integer NOT NULL,
    id bigint,
    id2 double precision,
    f_code character varying(80),
    f_code_des character varying(80),
    nam character varying(80),
    na2 character varying(80),
    na2_descri character varying(80),
    na3 character varying(80),
    na3_descri character varying(80),
    tile_id bigint,
    fac_id double precision,
    id21 bigint,
    the_geom public.geometry,
    CONSTRAINT enforce_srid_the_geom CHECK ((public.st_srid(the_geom) = 4326))
);


ALTER TABLE darwin2.vmap0_world_boundaries OWNER TO postgres;

--
-- TOC entry 435 (class 1259 OID 20054)
-- Name: v_diagnose_country_from_coord; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_diagnose_country_from_coord AS
 SELECT specimens.id,
    specimens.gtu_location,
    vmap0_world_boundaries.na2_descri,
    specimens.gtu_country_tag_indexed
   FROM (darwin2.specimens
     LEFT JOIN darwin2.vmap0_world_boundaries ON (public.st_within(public.st_setsrid(public.st_makepoint(specimens.gtu_location[0], specimens.gtu_location[1]), 4326), public.st_setsrid(vmap0_world_boundaries.the_geom, 4326))))
  WHERE ((specimens.gtu_location)::public.geometry IS NOT NULL);


ALTER TABLE darwin2.v_diagnose_country_from_coord OWNER TO darwin2;

--
-- TOC entry 436 (class 1259 OID 20059)
-- Name: vmap0_world_boundaries_enveloppe; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.vmap0_world_boundaries_enveloppe (
    gid integer,
    id bigint,
    id2 double precision,
    f_code character varying(80),
    f_code_des character varying(80),
    nam character varying(80),
    na2 character varying(80),
    na2_descri character varying(80),
    na3 character varying(80),
    na3_descri character varying(80),
    tile_id bigint,
    fac_id double precision,
    id21 bigint,
    the_geom public.geometry,
    bounding_box public.geometry
);


ALTER TABLE darwin2.vmap0_world_boundaries_enveloppe OWNER TO darwin2;

--
-- TOC entry 437 (class 1259 OID 20065)
-- Name: v_diagnose_fast_country_outlier_tmp; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_diagnose_fast_country_outlier_tmp AS
 SELECT specimens.id,
    vmap0_world_boundaries_enveloppe.na2_descri,
    vmap0_world_boundaries_enveloppe.bounding_box,
    (specimens.gtu_country_tag_indexed)::character varying AS gtu_country_tag_indexed,
    specimens.collection_ref
   FROM (darwin2.specimens
     LEFT JOIN darwin2.vmap0_world_boundaries_enveloppe ON ((public.st_within(public.st_setsrid(public.st_makepoint(specimens.gtu_location[0], specimens.gtu_location[1]), 4326), vmap0_world_boundaries_enveloppe.bounding_box) OR (vmap0_world_boundaries_enveloppe.na2_descri IS NULL))))
  WHERE (((vmap0_world_boundaries_enveloppe.na2_descri)::text <> 'Fiji'::text) AND ((vmap0_world_boundaries_enveloppe.na2_descri)::text <> 'Kiribati'::text) AND ((vmap0_world_boundaries_enveloppe.na2_descri)::text <> 'New Zealand'::text) AND ((vmap0_world_boundaries_enveloppe.na2_descri)::text <> 'United States'::text));


ALTER TABLE darwin2.v_diagnose_fast_country_outlier_tmp OWNER TO darwin2;

--
-- TOC entry 438 (class 1259 OID 20070)
-- Name: v_diagnose_fast_country_outlier; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_diagnose_fast_country_outlier AS
 SELECT specimens.id,
    a.na2_descri,
    a.bounding_box,
    (specimens.gtu_country_tag_indexed)::character varying AS gtu_country_tag_indexed,
    specimens.collection_ref
   FROM (darwin2.specimens
     LEFT JOIN ( SELECT v_diagnose_fast_country_outlier_tmp.id,
            v_diagnose_fast_country_outlier_tmp.na2_descri,
            v_diagnose_fast_country_outlier_tmp.bounding_box,
            v_diagnose_fast_country_outlier_tmp.gtu_country_tag_indexed,
            v_diagnose_fast_country_outlier_tmp.collection_ref
           FROM darwin2.v_diagnose_fast_country_outlier_tmp) a ON ((specimens.id = a.id)))
  WHERE (specimens.gtu_location IS NOT NULL);


ALTER TABLE darwin2.v_diagnose_fast_country_outlier OWNER TO darwin2;

--
-- TOC entry 439 (class 1259 OID 20075)
-- Name: v_elephants_ivory_emmanuel; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_elephants_ivory_emmanuel AS
 SELECT a.comments,
    (((codes.code_prefix)::text || '_'::text) || (codes.code)::text) AS specimen_code,
    specimens.taxon_name AS taxon,
    specimens.acquisition_date,
    specimens.gtu_from_date AS collection_date,
    specimens.gtu_country_tag_value,
    specimens.gtu_province_tag_value,
    specimens.gtu_others_tag_value,
    specimens.sex,
    specimens.stage,
    specimens.ig_num,
    specimens.gtu_location[1] AS lat,
    specimens.gtu_location[0] AS long
   FROM ((( SELECT string_agg(comments.comment, ';'::text) AS comments,
            specimens_1.id,
            specimens_1.taxon_name
           FROM ((darwin2.specimens specimens_1
             LEFT JOIN darwin2.comments ON (((specimens_1.id = comments.record_id) AND ((comments.referenced_relation)::text = 'specimens'::text))))
             LEFT JOIN darwin2.codes codes_1 ON (((specimens_1.id = codes_1.record_id) AND ((codes_1.referenced_relation)::text = 'specimens'::text) AND ((codes_1.code_category)::text = 'main'::text))))
          WHERE ((((specimens_1.taxon_path)::text || ((specimens_1.taxon_ref)::character varying)::text) || '/'::text) ~~ '%/16616/%'::text)
          GROUP BY specimens_1.id, specimens_1.taxon_name) a
     LEFT JOIN darwin2.specimens ON ((a.id = specimens.id)))
     LEFT JOIN darwin2.codes ON (((specimens.id = codes.record_id) AND ((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text))))
  WHERE ((lower(a.comments) ~~ '%slag%'::text) OR (lower(a.comments) ~~ '%defense%'::text));


ALTER TABLE darwin2.v_elephants_ivory_emmanuel OWNER TO darwin2;

--
-- TOC entry 440 (class 1259 OID 20080)
-- Name: v_erik_verheyen_mammals_in_alcohol_2020; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_erik_verheyen_mammals_in_alcohol_2020 AS
 SELECT DISTINCT b.name AS taxon_group,
    specimens.taxon_name,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 34) AS family,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 41) AS genus,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 48) AS species,
    storage_parts.container_type,
    lower(btrim(split_part((specimens.gtu_country_tag_value)::text, ';'::text, 1))) AS country,
    string_agg(DISTINCT replace((specimens.gtu_others_tag_value)::text, (specimens.gtu_country_tag_value)::text, ''::text), '; '::text) AS loc_list,
    min(NULLIF(specimens.gtu_from_date, '0001-01-01 00:00:00'::timestamp without time zone)) AS date_min,
    GREATEST(max(((NULLIF(specimens.gtu_from_date, '0001-01-01 00:00:00'::timestamp without time zone))::character varying)::text), max(((NULLIF(specimens.gtu_to_date, '2038-12-31 00:00:00'::timestamp without time zone))::character varying)::text)) AS date_max,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min
   FROM (darwin2.specimens
     JOIN darwin2.storage_parts ON ((specimens.id = storage_parts.specimen_ref))),
    ( SELECT (taxonomy.id)::character varying AS id_char,
            taxonomy.name
           FROM darwin2.taxonomy
          WHERE (((taxonomy.name_indexed)::text ~~ '%afrosoricida%'::text) OR ((taxonomy.name_indexed)::text ~~ 'artiodactyla%'::text) OR ((taxonomy.name_indexed)::text ~~ 'carnivora%'::text) OR ((taxonomy.name_indexed)::text ~~ 'chiroptera%'::text) OR ((taxonomy.name_indexed)::text ~~ 'erinaceomorpha%'::text) OR ((taxonomy.name_indexed)::text ~~ 'hyracoid%'::text) OR ((taxonomy.name_indexed)::text ~~ 'lagomorpha%'::text) OR ((taxonomy.name_indexed)::text ~~ 'macroscelidae%'::text) OR ((taxonomy.name_indexed)::text ~~ 'perissodactyla%'::text) OR ((taxonomy.name_indexed)::text ~~ 'pholidota%'::text) OR ((taxonomy.name_indexed)::text ~~ 'pinnid%'::text) OR ((taxonomy.name_indexed)::text ~~ 'primates%'::text) OR ((taxonomy.name_indexed)::text ~~ 'proboscidea%'::text) OR ((taxonomy.name_indexed)::text ~~ 'rodent%'::text) OR ((taxonomy.name_indexed)::text ~~ 'sirenia%'::text) OR ((taxonomy.name_indexed)::text ~~ 'soricida%'::text) OR ((taxonomy.name_indexed)::text ~~ 'talpa%'::text) OR ((taxonomy.name_indexed)::text ~~ 'tubulid%'::text))) b
  WHERE ((((((specimens.taxon_path)::text || '/'::text) || ((specimens.taxon_ref)::character varying)::text) || '/'::text) ~~ (('%/'::text || (b.id_char)::text) || '/%'::text)) AND ((storage_parts.container_type)::text = 'storage_alcohol'::text))
  GROUP BY (lower(btrim(split_part((specimens.gtu_country_tag_value)::text, ';'::text, 1)))), b.name, (darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 34)), (darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 41)), (darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 48)), storage_parts.container_type, specimens.taxon_name
  ORDER BY specimens.taxon_name, b.name, (lower(btrim(split_part((specimens.gtu_country_tag_value)::text, ';'::text, 1)))), storage_parts.container_type;


ALTER TABLE darwin2.v_erik_verheyen_mammals_in_alcohol_2020 OWNER TO darwin2;

--
-- TOC entry 441 (class 1259 OID 20085)
-- Name: v_erik_verheyen_mammals_in_alcohol_2020_detail_rodent_chiro; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_erik_verheyen_mammals_in_alcohol_2020_detail_rodent_chiro AS
 SELECT DISTINCT v_erik_verheyen_mammals_in_alcohol_2020.taxon_group,
    v_erik_verheyen_mammals_in_alcohol_2020.family,
    v_erik_verheyen_mammals_in_alcohol_2020.genus,
    v_erik_verheyen_mammals_in_alcohol_2020.species,
    v_erik_verheyen_mammals_in_alcohol_2020.container_type,
    v_erik_verheyen_mammals_in_alcohol_2020.country,
    array_agg(v_erik_verheyen_mammals_in_alcohol_2020.loc_list) AS loc_list,
    min(v_erik_verheyen_mammals_in_alcohol_2020.date_min) AS date_min,
    max(v_erik_verheyen_mammals_in_alcohol_2020.date_max) AS date_max,
    sum(v_erik_verheyen_mammals_in_alcohol_2020.nb_records) AS nb_records,
    sum(v_erik_verheyen_mammals_in_alcohol_2020.specimen_count_min) AS specimen_count_min
   FROM darwin2.v_erik_verheyen_mammals_in_alcohol_2020
  WHERE (((v_erik_verheyen_mammals_in_alcohol_2020.taxon_group)::text ~~ 'Chiro%'::text) OR ((v_erik_verheyen_mammals_in_alcohol_2020.taxon_group)::text ~~ 'Rodent%'::text))
  GROUP BY v_erik_verheyen_mammals_in_alcohol_2020.taxon_group, v_erik_verheyen_mammals_in_alcohol_2020.country, v_erik_verheyen_mammals_in_alcohol_2020.container_type, v_erik_verheyen_mammals_in_alcohol_2020.family, v_erik_verheyen_mammals_in_alcohol_2020.genus, v_erik_verheyen_mammals_in_alcohol_2020.species
  ORDER BY v_erik_verheyen_mammals_in_alcohol_2020.taxon_group, v_erik_verheyen_mammals_in_alcohol_2020.country, v_erik_verheyen_mammals_in_alcohol_2020.family, v_erik_verheyen_mammals_in_alcohol_2020.genus, v_erik_verheyen_mammals_in_alcohol_2020.species;


ALTER TABLE darwin2.v_erik_verheyen_mammals_in_alcohol_2020_detail_rodent_chiro OWNER TO darwin2;

--
-- TOC entry 442 (class 1259 OID 20090)
-- Name: v_erik_verheyen_mammals_in_alcohol_2020_generic; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_erik_verheyen_mammals_in_alcohol_2020_generic AS
 SELECT DISTINCT v_erik_verheyen_mammals_in_alcohol_2020.taxon_group,
    v_erik_verheyen_mammals_in_alcohol_2020.container_type,
    v_erik_verheyen_mammals_in_alcohol_2020.country,
    array_agg(DISTINCT v_erik_verheyen_mammals_in_alcohol_2020.loc_list) AS array_agg,
    min(v_erik_verheyen_mammals_in_alcohol_2020.date_min) AS min,
    max(v_erik_verheyen_mammals_in_alcohol_2020.date_max) AS max,
    sum(v_erik_verheyen_mammals_in_alcohol_2020.nb_records) AS nb_records,
    sum(v_erik_verheyen_mammals_in_alcohol_2020.specimen_count_min) AS specimen_count_min
   FROM darwin2.v_erik_verheyen_mammals_in_alcohol_2020
  GROUP BY v_erik_verheyen_mammals_in_alcohol_2020.taxon_group, v_erik_verheyen_mammals_in_alcohol_2020.country, v_erik_verheyen_mammals_in_alcohol_2020.container_type
  ORDER BY v_erik_verheyen_mammals_in_alcohol_2020.taxon_group, v_erik_verheyen_mammals_in_alcohol_2020.country;


ALTER TABLE darwin2.v_erik_verheyen_mammals_in_alcohol_2020_generic OWNER TO darwin2;

--
-- TOC entry 443 (class 1259 OID 20094)
-- Name: v_fix_property_shift; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_fix_property_shift AS
 SELECT public.akeys((users_tracking_proppb.new_value OPERATOR(public.-) users_tracking_proppb.old_value)) AS key_1,
    public.akeys((users_tracking_proppb.old_value OPERATOR(public.-) users_tracking_proppb.new_value)) AS key_2,
    (users_tracking_proppb.new_value OPERATOR(public.-) users_tracking_proppb.old_value) AS new_val,
    (users_tracking_proppb.old_value OPERATOR(public.-) users_tracking_proppb.new_value) AS old_val,
    users_tracking_proppb.id,
    users_tracking_proppb.referenced_relation,
    users_tracking_proppb.record_id,
    users_tracking_proppb.user_ref,
    users_tracking_proppb.action,
    users_tracking_proppb.old_value,
    users_tracking_proppb.new_value,
    users_tracking_proppb.modification_date_time
   FROM darwin2.users_tracking_proppb
  WHERE ((array_length(public.akeys((users_tracking_proppb.new_value OPERATOR(public.-) users_tracking_proppb.old_value)), 1) = 1) AND (array_length(public.akeys((users_tracking_proppb.old_value OPERATOR(public.-) users_tracking_proppb.new_value)), 1) = 1) AND ((public.akeys((users_tracking_proppb.new_value OPERATOR(public.-) users_tracking_proppb.old_value)))[1] = 'record_id'::text) AND ((public.akeys((users_tracking_proppb.old_value OPERATOR(public.-) users_tracking_proppb.new_value)))[1] = 'record_id'::text));


ALTER TABLE darwin2.v_fix_property_shift OWNER TO darwin2;

--
-- TOC entry 518 (class 1259 OID 1416253)
-- Name: v_gbif_snails_kin_tine; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.v_gbif_snails_kin_tine AS
 SELECT fct_rmca_dynamic_saved_search_gbif.id,
    fct_rmca_dynamic_saved_search_gbif.uuid,
    fct_rmca_dynamic_saved_search_gbif.guid,
    fct_rmca_dynamic_saved_search_gbif.collection_ref,
    fct_rmca_dynamic_saved_search_gbif.collection_code,
    fct_rmca_dynamic_saved_search_gbif.collection_name,
    fct_rmca_dynamic_saved_search_gbif.collection_id,
    fct_rmca_dynamic_saved_search_gbif.collection_path,
    fct_rmca_dynamic_saved_search_gbif.cataloguenumber,
    fct_rmca_dynamic_saved_search_gbif.auxcode,
    fct_rmca_dynamic_saved_search_gbif.basisofrecord,
    fct_rmca_dynamic_saved_search_gbif.institutionid,
    fct_rmca_dynamic_saved_search_gbif.iso_country_institution,
    fct_rmca_dynamic_saved_search_gbif.bibliographic_citation,
    fct_rmca_dynamic_saved_search_gbif.licence,
    fct_rmca_dynamic_saved_search_gbif.email,
    fct_rmca_dynamic_saved_search_gbif.type,
    fct_rmca_dynamic_saved_search_gbif.taxon_path,
    fct_rmca_dynamic_saved_search_gbif.taxon_ref,
    fct_rmca_dynamic_saved_search_gbif.taxon_name,
    fct_rmca_dynamic_saved_search_gbif.family,
    fct_rmca_dynamic_saved_search_gbif.iso_country,
    fct_rmca_dynamic_saved_search_gbif.country,
    fct_rmca_dynamic_saved_search_gbif.location,
    fct_rmca_dynamic_saved_search_gbif.latitude,
    fct_rmca_dynamic_saved_search_gbif.longitude,
    fct_rmca_dynamic_saved_search_gbif.lat_long_accuracy,
    fct_rmca_dynamic_saved_search_gbif.collector_ids,
    fct_rmca_dynamic_saved_search_gbif.collectors,
    fct_rmca_dynamic_saved_search_gbif.donator_ids,
    fct_rmca_dynamic_saved_search_gbif.donators,
    fct_rmca_dynamic_saved_search_gbif.identifiers_ids,
    fct_rmca_dynamic_saved_search_gbif.identifiers,
    fct_rmca_dynamic_saved_search_gbif.gtu_from_date,
    fct_rmca_dynamic_saved_search_gbif.gtu_to_date,
    fct_rmca_dynamic_saved_search_gbif.eventdate,
    fct_rmca_dynamic_saved_search_gbif.country_unnest,
    fct_rmca_dynamic_saved_search_gbif.urls_thumbnails,
    fct_rmca_dynamic_saved_search_gbif.image_category_thumbnails,
    fct_rmca_dynamic_saved_search_gbif.contributor_thumbnails,
    fct_rmca_dynamic_saved_search_gbif.disclaimer_thumbnails,
    fct_rmca_dynamic_saved_search_gbif.license_thumbnails,
    fct_rmca_dynamic_saved_search_gbif.display_order_thumbnails,
    fct_rmca_dynamic_saved_search_gbif.urls_image_links,
    fct_rmca_dynamic_saved_search_gbif.image_category_image_links,
    fct_rmca_dynamic_saved_search_gbif.contributor_image_links,
    fct_rmca_dynamic_saved_search_gbif.disclaimer_image_links,
    fct_rmca_dynamic_saved_search_gbif.license_image_links,
    fct_rmca_dynamic_saved_search_gbif.display_order_image_links,
    fct_rmca_dynamic_saved_search_gbif.urls_3d_snippets,
    fct_rmca_dynamic_saved_search_gbif.image_category_3d_snippets,
    fct_rmca_dynamic_saved_search_gbif.contributor_3d_snippets,
    fct_rmca_dynamic_saved_search_gbif.disclaimer_3d_snippets,
    fct_rmca_dynamic_saved_search_gbif.license_3d_snippets,
    fct_rmca_dynamic_saved_search_gbif.display_order_3d_snippets,
    fct_rmca_dynamic_saved_search_gbif.identification_date,
    fct_rmca_dynamic_saved_search_gbif.history,
    fct_rmca_dynamic_saved_search_gbif.gtu_ref,
    fct_rmca_dynamic_saved_search_gbif.specimen_count_min,
    fct_rmca_dynamic_saved_search_gbif.specimen_count_males_min,
    fct_rmca_dynamic_saved_search_gbif.specimen_count_females_min,
    fct_rmca_dynamic_saved_search_gbif.specimen_count_juveniles_min
   FROM darwin2.fct_rmca_dynamic_saved_search_gbif(1445, 1) fct_rmca_dynamic_saved_search_gbif(id, uuid, guid, collection_ref, collection_code, collection_name, collection_id, collection_path, cataloguenumber, auxcode, basisofrecord, institutionid, iso_country_institution, bibliographic_citation, licence, email, type, taxon_path, taxon_ref, taxon_name, family, iso_country, country, location, latitude, longitude, lat_long_accuracy, collector_ids, collectors, donator_ids, donators, identifiers_ids, identifiers, gtu_from_date, gtu_to_date, eventdate, country_unnest, urls_thumbnails, image_category_thumbnails, contributor_thumbnails, disclaimer_thumbnails, license_thumbnails, display_order_thumbnails, urls_image_links, image_category_image_links, contributor_image_links, disclaimer_image_links, license_image_links, display_order_image_links, urls_3d_snippets, image_category_3d_snippets, contributor_3d_snippets, disclaimer_3d_snippets, license_3d_snippets, display_order_3d_snippets, identification_date, history, gtu_ref, specimen_count_min, specimen_count_males_min, specimen_count_females_min, specimen_count_juveniles_min)
  WITH NO DATA;


ALTER TABLE darwin2.v_gbif_snails_kin_tine OWNER TO darwin2;

--
-- TOC entry 444 (class 1259 OID 20099)
-- Name: v_get_catalogue_numbers_by_collection; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_get_catalogue_numbers_by_collection AS
 WITH a AS (
         SELECT (((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text) AS code,
            codes.record_id
           FROM darwin2.codes
          WHERE (((codes.code_category)::text = 'main'::text) AND ((codes.referenced_relation)::text = 'specimens'::text))
        )
 SELECT a.code,
    a.record_id,
    specimens.collection_name,
    specimens.taxon_name,
    (((specimens.collection_path)::text || ((specimens.collection_ref)::character varying)::text) || '/'::text) AS full_collection_path
   FROM (a
     JOIN darwin2.specimens ON ((a.record_id = specimens.id)));


ALTER TABLE darwin2.v_get_catalogue_numbers_by_collection OWNER TO darwin2;

--
-- TOC entry 445 (class 1259 OID 20104)
-- Name: v_get_catalogue_numbers_by_collection_taxonomy_with_parent; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_get_catalogue_numbers_by_collection_taxonomy_with_parent AS
 WITH a AS (
         SELECT (((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text) AS code,
            codes.record_id
           FROM darwin2.codes
          WHERE (((codes.code_category)::text = 'main'::text) AND ((codes.referenced_relation)::text = 'specimens'::text))
        )
 SELECT a.code,
    a.record_id,
    specimens.collection_name,
    specimens.taxon_name,
    (((specimens.collection_path)::text || ((specimens.collection_ref)::character varying)::text) || '/'::text) AS full_collection_path,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 34) AS family,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 28) AS order_taxon
   FROM (a
     JOIN darwin2.specimens ON ((a.record_id = specimens.id)));


ALTER TABLE darwin2.v_get_catalogue_numbers_by_collection_taxonomy_with_parent OWNER TO darwin2;

--
-- TOC entry 446 (class 1259 OID 20109)
-- Name: v_ichtyology_series_fast; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_ichtyology_series_fast AS
 WITH a AS (
         SELECT codes.referenced_relation,
            codes.record_id,
            codes.id,
            codes.code_category,
            codes.code_prefix,
            codes.code_prefix_separator,
            codes.code,
            codes.code_suffix,
            codes.code_suffix_separator,
            codes.full_code_indexed,
            codes.code_date,
            codes.code_date_mask,
            codes.code_num,
            codes.code_num_bigint
           FROM (darwin2.codes
             JOIN darwin2.specimens ON ((codes.record_id = specimens.id)))
          WHERE ((specimens.collection_ref = 6) AND ((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text))
        ), b AS (
         SELECT regexp_matches((a.code)::text, '(.+P\.)(\d+)-(\d+)'::text) AS split,
            a.referenced_relation,
            a.record_id,
            a.id,
            a.code_category,
            a.code_prefix,
            a.code_prefix_separator,
            a.code,
            a.code_suffix,
            a.code_suffix_separator,
            a.full_code_indexed,
            a.code_date,
            a.code_date_mask,
            a.code_num,
            a.code_num_bigint
           FROM a
          WHERE ((a.code)::text ~ '\d{4}\.\d{3}\.P.+-.+'::text)
          ORDER BY a.code
        ), c AS (
         SELECT regexp_matches((a.code)::text, '(.+P\.)(\d+)'::text) AS split,
            a.referenced_relation,
            a.record_id,
            a.id,
            a.code_category,
            a.code_prefix,
            a.code_prefix_separator,
            a.code,
            a.code_suffix,
            a.code_suffix_separator,
            a.full_code_indexed,
            a.code_date,
            a.code_date_mask,
            a.code_num,
            a.code_num_bigint
           FROM a
          WHERE (((a.code)::text ~ '\d{4}\.\d{3}\.P.+'::text) AND ((a.code)::text !~~ '%-%'::text))
        ), d AS (
         SELECT regexp_matches((codes.code)::text, '\d+'::text) AS split,
            codes.referenced_relation,
            codes.record_id,
            codes.id,
            codes.code_category,
            codes.code_prefix,
            codes.code_prefix_separator,
            codes.code,
            codes.code_suffix,
            codes.code_suffix_separator,
            codes.full_code_indexed,
            codes.code_date,
            codes.code_date_mask,
            codes.code_num,
            codes.code_num_bigint
           FROM (darwin2.codes
             JOIN darwin2.specimens ON ((codes.record_id = specimens.id)))
          WHERE ((specimens.collection_ref = 6) AND ((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text) AND ((codes.code)::text ~~ 'P%'::text) AND ((codes.code)::text !~~ '%-%'::text))
        ), e AS (
         SELECT regexp_matches((codes.code)::text, '(\d+)-(\d+)'::text) AS split,
            codes.referenced_relation,
            codes.record_id,
            codes.id,
            codes.code_category,
            codes.code_prefix,
            codes.code_prefix_separator,
            codes.code,
            codes.code_suffix,
            codes.code_suffix_separator,
            codes.full_code_indexed,
            codes.code_date,
            codes.code_date_mask,
            codes.code_num,
            codes.code_num_bigint
           FROM (darwin2.codes
             JOIN darwin2.specimens ON ((codes.record_id = specimens.id)))
          WHERE ((specimens.collection_ref = 6) AND ((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text) AND ((codes.code)::text ~~ 'P%'::text) AND ((codes.code)::text ~~ '%-%'::text))
        )
 SELECT b.split[1] AS prefix,
    darwin2.fct_rmca_develop_range((b.split[2])::integer, (b.split[3])::integer) AS range,
    b.split,
    b.referenced_relation,
    b.record_id,
    b.id,
    b.code_category,
    b.code_prefix,
    b.code_prefix_separator,
    b.code,
    b.code_suffix,
    b.code_suffix_separator,
    b.full_code_indexed,
    b.code_date,
    b.code_date_mask,
    b.code_num,
    b.code_num_bigint
   FROM b
UNION
 SELECT c.split[1] AS prefix,
    ARRAY[(c.split[2])::integer] AS range,
    c.split,
    c.referenced_relation,
    c.record_id,
    c.id,
    c.code_category,
    c.code_prefix,
    c.code_prefix_separator,
    c.code,
    c.code_suffix,
    c.code_suffix_separator,
    c.full_code_indexed,
    c.code_date,
    c.code_date_mask,
    c.code_num,
    c.code_num_bigint
   FROM c
UNION
 SELECT d.code AS prefix,
    ARRAY[(d.split[1])::integer] AS range,
    d.split,
    d.referenced_relation,
    d.record_id,
    d.id,
    d.code_category,
    d.code_prefix,
    d.code_prefix_separator,
    d.code,
    d.code_suffix,
    d.code_suffix_separator,
    d.full_code_indexed,
    d.code_date,
    d.code_date_mask,
    d.code_num,
    d.code_num_bigint
   FROM d
UNION
 SELECT ('P.'::text || e.split[1]) AS prefix,
    darwin2.fct_rmca_develop_range((e.split[1])::integer, (e.split[2])::integer) AS range,
    e.split,
    e.referenced_relation,
    e.record_id,
    e.id,
    e.code_category,
    e.code_prefix,
    e.code_prefix_separator,
    e.code,
    e.code_suffix,
    e.code_suffix_separator,
    e.full_code_indexed,
    e.code_date,
    e.code_date_mask,
    e.code_num,
    e.code_num_bigint
   FROM e;


ALTER TABLE darwin2.v_ichtyology_series_fast OWNER TO darwin2;

--
-- TOC entry 447 (class 1259 OID 20114)
-- Name: v_imports_filename_encoded; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_imports_filename_encoded AS
 SELECT imports.id,
    imports.user_ref,
    imports.format,
    imports.collection_ref,
    imports.filename,
    imports.state,
    imports.created_at,
    imports.updated_at,
    imports.initial_count,
    imports.is_finished,
    imports.errors_in_import,
    imports.template_version,
    imports.exclude_invalid_entries,
    imports.specimen_taxonomy_ref,
    imports.taxonomy_name,
    imports.creation_date,
    imports.creation_date_mask,
    imports.definition_taxonomy,
    imports.is_reference_taxonomy,
    imports.source_taxonomy,
    imports.url_website_taxonomy,
    imports.url_webservice_taxonomy,
    imports.working,
    imports.mime_type,
    imports.taxonomy_kingdom,
    imports.history_taxonomy,
    imports.merge_gtu,
    ('uploaded_'::text || encode(public.digest(((imports.filename)::text || ((imports.created_at)::character varying)::text), 'sha1'::text), 'hex'::text)) AS filename_encoded
   FROM darwin2.imports
  ORDER BY imports.id DESC;


ALTER TABLE darwin2.v_imports_filename_encoded OWNER TO darwin2;

--
-- TOC entry 448 (class 1259 OID 20119)
-- Name: v_loan_detail_role_person; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_loan_detail_role_person AS
 SELECT catalogue_people.referenced_relation,
    catalogue_people.record_id,
    catalogue_people.id,
    catalogue_people.people_type,
    catalogue_people.people_sub_type,
    catalogue_people.order_by,
    catalogue_people.people_ref,
    (((((catalogue_people.people_sub_type)::integer)::bit(8) & '10000000'::"bit"))::integer)::boolean AS other,
    (((((catalogue_people.people_sub_type)::integer)::bit(8) & '01000000'::"bit"))::integer)::boolean AS transporter,
    (((((catalogue_people.people_sub_type)::integer)::bit(8) & '00100000'::"bit"))::integer)::boolean AS attendant,
    (((((catalogue_people.people_sub_type)::integer)::bit(8) & '00010000'::"bit"))::integer)::boolean AS preparator,
    (((((catalogue_people.people_sub_type)::integer)::bit(8) & '00001000'::"bit"))::integer)::boolean AS checker,
    (((((catalogue_people.people_sub_type)::integer)::bit(8) & '00000100'::"bit"))::integer)::boolean AS contact,
    (((((catalogue_people.people_sub_type)::integer)::bit(8) & '00000010'::"bit"))::integer)::boolean AS role_responsible
   FROM darwin2.catalogue_people
  WHERE ((catalogue_people.referenced_relation)::text = 'loans'::text);


ALTER TABLE darwin2.v_loan_detail_role_person OWNER TO darwin2;

--
-- TOC entry 449 (class 1259 OID 20124)
-- Name: v_loan_details_for_pentaho; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_loan_details_for_pentaho AS
SELECT
    NULL::integer AS id,
    NULL::integer AS loan_ref,
    NULL::integer AS ig_ref,
    NULL::date AS from_date,
    NULL::date AS to_date,
    NULL::integer AS specimen_ref,
    NULL::character varying AS details,
    NULL::character varying AS taxon_name,
    NULL::character varying AS code,
    NULL::character varying[] AS array_agg,
    NULL::text AS detail_loan,
    NULL::character varying AS type,
    NULL::character varying AS category,
    NULL::character varying AS specimen_part,
    NULL::character varying AS specimen_status,
    NULL::text AS loan_remarks,
    NULL::integer AS loan_id,
    NULL::character varying AS loan_name,
    NULL::integer AS collection_ref;


ALTER TABLE darwin2.v_loan_details_for_pentaho OWNER TO darwin2;

--
-- TOC entry 450 (class 1259 OID 20128)
-- Name: v_loans_for_pentaho; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_loans_for_pentaho AS
 SELECT a.id,
    a.name,
    a.description,
    a.search_indexed,
    a.from_date,
    a.to_date,
    a.extended_to_date,
    ( SELECT properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'Loan at your request'::text))
         LIMIT 1) AS loan_at_your_request,
    ( SELECT properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'in_exchange'::text))
         LIMIT 1) AS in_exchange
   FROM darwin2.loans a;


ALTER TABLE darwin2.v_loans_for_pentaho OWNER TO darwin2;

--
-- TOC entry 451 (class 1259 OID 20133)
-- Name: v_loans_pentaho_contact_person; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_loans_pentaho_contact_person AS
 SELECT string_agg(((
        CASE
            WHEN (p.formated_name IS NULL) THEN ' '::text
            ELSE replace((p.formated_name)::text, ','::text, ''::text)
        END || ', '::text) || (
        CASE
            WHEN (e.entry IS NULL) THEN ' '::character varying
            ELSE e.entry
        END)::text), '; '::text) AS people_group,
    r.people_type,
    r.record_id
   FROM ((darwin2.v_loan_detail_role_person r
     LEFT JOIN darwin2.people_comm e ON ((e.person_user_ref = r.people_ref)))
     LEFT JOIN darwin2.people p ON ((p.id = r.people_ref)))
  WHERE (((r.referenced_relation)::text = 'loans'::text) AND ((r.people_type)::text = 'sender'::text) AND (((e.comm_type)::text = 'e-mail'::text) OR (e.comm_type IS NULL)) AND (r.contact = true))
  GROUP BY r.people_type, r.record_id;


ALTER TABLE darwin2.v_loans_pentaho_contact_person OWNER TO darwin2;

--
-- TOC entry 452 (class 1259 OID 20138)
-- Name: v_loans_pentaho_general; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_loans_pentaho_general AS
 SELECT DISTINCT a.id,
    a.name,
    a.description,
    a.search_indexed,
    a.from_date,
    a.to_date,
    a.extended_to_date,
    COALESCE(( SELECT properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'loan_at_your_request'::text))
         LIMIT 1), 'no'::character varying) AS loan_at_your_request,
    COALESCE(( SELECT properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'gift'::text))
         LIMIT 1), 'no'::character varying) AS gift,
    COALESCE(( SELECT properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'in_exchange'::text))
         LIMIT 1), 'no'::character varying) AS in_exchange,
    COALESCE(( SELECT properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'loan_for_identification_our_request'::text))
         LIMIT 1), 'no'::character varying) AS loan_for_identification_our_request,
    COALESCE(( SELECT properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'return_of_material_sent_for_id'::text))
         LIMIT 1), 'no'::character varying) AS return_of_material_sent_for_id,
    COALESCE(( SELECT properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'return_of_borrowed_material'::text))
         LIMIT 1), 'no'::character varying) AS return_of_borrowed_material,
    COALESCE(( SELECT
                CASE lower((properties.property_type)::text)
                    WHEN 'sent_by_surface'::text THEN 'Sent by surface'::text
                    WHEN 'sent_by_airmail'::text THEN 'Sent by airmail'::text
                    ELSE NULL::text
                END AS "case"
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((lower((properties.property_type)::text) = 'sent_by_surface'::text) OR (lower((properties.property_type)::text) = 'sent_by_airmail'::text)))
         LIMIT 1), (''::character varying)::text) AS shipping_type,
    transporter.formated_name AS transporter,
    to_char(i.modification_date_time, 'YYYY-MM-DD'::text) AS registration_date,
    ((j.insurance_value || ' '::text) || (j.insurance_currency)::text) AS insurance,
    COALESCE(( SELECT properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'packages_count'::text))
         LIMIT 1), '1'::character varying) AS packages_count,
    COALESCE(( SELECT (((properties.lower_value)::text || ' '::text) || (properties.property_unit)::text)
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'loans'::text) AND (properties.record_id = a.id) AND ((properties.property_type)::text = 'weight'::text))
         LIMIT 1), ''::text) AS weight,
        CASE
            WHEN (a.non_cites IS TRUE) THEN 'yes'::text
            ELSE 'no'::text
        END AS non_cites
   FROM (((((((((darwin2.loans a
     LEFT JOIN darwin2.collection_maintenance b ON (((a.id = b.record_id) AND ((b.referenced_relation)::text = 'loans'::text) AND (((b.action_observation)::text = 'sent_by_surface'::text) OR ((b.action_observation)::text = 'sent_by_airmail'::text)))))
     LEFT JOIN darwin2.catalogue_people c ON (((a.id = c.record_id) AND ((c.referenced_relation)::text = 'loans'::text) AND ((c.people_type)::text = 'receiver'::text))))
     LEFT JOIN darwin2.people d ON ((d.id = c.people_ref)))
     LEFT JOIN darwin2.catalogue_people e ON (((a.id = e.record_id) AND ((e.referenced_relation)::text = 'loans'::text) AND ((e.people_type)::text = 'sender'::text))))
     LEFT JOIN darwin2.people f ON ((f.id = e.people_ref)))
     LEFT JOIN darwin2.catalogue_people g ON (((a.id = g.record_id) AND ((g.referenced_relation)::text = 'loans'::text) AND ((g.people_type)::text = 'receiver'::text) AND ((((((g.people_sub_type)::integer)::bit(8) & '01000000'::"bit"))::integer)::boolean = true))))
     LEFT JOIN darwin2.people transporter ON ((g.people_ref = transporter.id)))
     LEFT JOIN darwin2.loan_status i ON (((a.id = i.loan_ref) AND ((i.status)::text = 'new'::text))))
     LEFT JOIN darwin2.insurances j ON (((a.id = j.record_id) AND ((j.referenced_relation)::text = 'loans'::text))))
  WHERE (i.modification_date_time = ( SELECT min(loan_status.modification_date_time) AS min
           FROM darwin2.loan_status
          WHERE ((loan_status.loan_ref = i.loan_ref) AND ((loan_status.status)::text = 'new'::text))));


ALTER TABLE darwin2.v_loans_pentaho_general OWNER TO darwin2;

--
-- TOC entry 453 (class 1259 OID 20143)
-- Name: v_loans_pentaho_receivers; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_loans_pentaho_receivers AS
SELECT
    NULL::integer AS id,
    NULL::character varying AS name,
    NULL::character varying AS description,
    NULL::text AS search_indexed,
    NULL::date AS from_date,
    NULL::date AS to_date,
    NULL::date AS extended_to_date,
    NULL::text AS receiver_id,
    NULL::text AS receiver,
    NULL::text AS institution_receiver,
    NULL::text AS address_institution,
    NULL::character varying AS country_institution,
    NULL::integer AS sender_id,
    NULL::character varying AS sender,
    NULL::text AS receiver_email,
    NULL::text AS receiver_tel,
    NULL::text AS contact_sender_role,
    NULL::character varying AS collection_manager,
    NULL::character varying AS collection_manager_title,
    NULL::character varying AS collection_manager_mail;


ALTER TABLE darwin2.v_loans_pentaho_receivers OWNER TO darwin2;

--
-- TOC entry 527 (class 1259 OID 1745971)
-- Name: v_mbisa_correspondence_dw_number_eod_mukweze_2022; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_mbisa_correspondence_dw_number_eod_mukweze_2022 AS
 WITH a AS (
         SELECT specimens.id,
            codes.code
           FROM (darwin2.specimens
             JOIN darwin2.codes ON (((specimens.id = codes.record_id) AND ((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text))))
          WHERE (((specimens.ig_num)::text = '2018.032'::text) OR ((specimens.ig_num)::text = '2019.012'::text))
        ), b AS (
         SELECT a.id,
            a.code,
            properties.lower_value,
            regexp_replace((properties.lower_value)::text, '[^0-9\-\,\;\&]'::text, ''::text, 'g'::text) AS nb_only
           FROM (darwin2.properties
             JOIN a ON (((properties.record_id = a.id) AND ((properties.referenced_relation)::text = 'specimens'::text))))
          WHERE ((properties.property_type)::text = 'EOD'::text)
        ), c AS (
         SELECT b.id AS id_technique,
            b.code,
            ('MC '::text || (unnest(darwin2.fct_rmca_regex_numeric_interval_to_array((unnest(string_to_array(unnest(string_to_array(b.nb_only, '&'::text)), ','::text)))::character varying)))::text) AS code_terrain_mukweze,
            b.lower_value AS code_terrain_darwin
           FROM b
        )
 SELECT c.id_technique,
    c.code,
    c.code_terrain_mukweze,
    c.code_terrain_darwin
   FROM c
  ORDER BY c.code_terrain_mukweze;


ALTER TABLE darwin2.v_mbisa_correspondence_dw_number_eod_mukweze_2022 OWNER TO darwin2;

--
-- TOC entry 520 (class 1259 OID 1417419)
-- Name: v_rdf_view; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rdf_view AS
 SELECT DISTINCT specimens.uuid,
    specimens.code_display AS "SpecimenID",
    ('http://darwinweb.africamuseum.be/darwin/rdf/'::text || specimens.code_display) AS "RefUri",
    ('http://darwinweb.africamuseum.be/'::text || specimens.code_display) AS "ObjectUri",
    btrim(((specimens.code_display || ' '::text) || array_to_string(array_agg(DISTINCT specimens.taxon_name), ', '::text))) AS "Title",
    btrim(((specimens.code_display || ' '::text) || array_to_string(array_agg(DISTINCT specimens.taxon_name), ', '::text))) AS "TitleDescription",
    btrim(array_to_string(( SELECT array_agg(people.formated_name) AS array_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens.collector_ids))), ', '::text)) AS collector,
    (NULLIF(darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask), 'xxxx-xx-xx'::text) || COALESCE(('-'::text || NULLIF(darwin2.fct_mask_date(specimens.gtu_to_date, specimens.gtu_to_date_mask), 'xxxx-xx-xx'::text)))) AS "CollectionDate",
    ('http://darwinweb.africamuseum.be/'::text || specimens.code_display) AS "ObjectURI",
    specimens.modification_date_time AS modified,
    'specimens'::text AS "BaseOfRecord",
    'RMCA'::text AS "InstitutionCode",
    specimens.collection_name AS "CollectionName",
    specimens.code_display AS "CatalogNumber",
    darwin2.getspecificparentforlevel('taxonomy'::character varying, (array_agg(DISTINCT specimens.taxon_path))[1], 'family'::character varying) AS "Family",
    darwin2.getspecificparentforlevel('taxonomy'::character varying, (array_agg(DISTINCT specimens.taxon_path))[1], 'genus'::character varying) AS "Genus",
    darwin2.getspecificparentforlevel('taxonomy'::character varying, (array_agg(DISTINCT specimens.taxon_path))[1], '"species"'::character varying) AS "SpecificEpithet",
    specimens.taxon_name AS "ScientificName",
    NULL::character varying AS "HigherGeography",
    specimens.gtu_country_tag_value AS "Country",
    btrim(replace(replace((specimens.gtu_others_tag_value)::text, (specimens.gtu_country_tag_value)::text, ''::text), ';'::text, ''::text)) AS "Locality",
    specimens.urls_thumbnails AS "Image"
   FROM ( SELECT specimens_stable_ids.uuid,
            specimens_1.id,
            (((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text) AS code_display,
            codes.full_code_indexed,
            specimens_1.taxon_path,
            specimens_1.taxon_ref,
            specimens_1.collection_ref,
            specimens_1.collection_name,
            specimens_1.gtu_country_tag_indexed,
            specimens_1.gtu_country_tag_value,
            specimens_1.gtu_others_tag_indexed AS localities_indexed,
            specimens_1.gtu_others_tag_value,
            specimens_1.taxon_name,
            specimens_1.spec_coll_ids AS collector_ids,
            specimens_1.spec_don_sel_ids AS donator_ids,
            specimens_1.gtu_from_date,
            specimens_1.gtu_from_date_mask,
            specimens_1.gtu_to_date,
            specimens_1.gtu_to_date_mask,
            specimens_1.type AS coll_type,
            unnest(
                CASE
                    WHEN (specimens_1.gtu_country_tag_indexed IS NOT NULL) THEN specimens_1.gtu_country_tag_indexed
                    ELSE NULL::character varying[]
                END) AS country_unnest,
            ext_links_thumbnails.url AS urls_thumbnails,
            ext_links_thumbnails.category AS image_category_thumbnails,
            ext_links_thumbnails.contributor AS contributor_thumbnails,
            ext_links_thumbnails.disclaimer AS disclaimer_thumbnails,
            ext_links_thumbnails.license AS license_thumbnails,
            ext_links_thumbnails.display_order AS display_order_thumbnails,
            ext_links_image_links.url AS urls_image_links,
            ext_links_image_links.category AS image_category_image_links,
            ext_links_image_links.contributor AS contributor_image_links,
            ext_links_image_links.disclaimer AS disclaimer_image_links,
            ext_links_image_links.license AS license_image_links,
            ext_links_image_links.display_order AS display_order_image_links,
            ext_links_3d_snippets.url AS urls_3d_snippets,
            ext_links_3d_snippets.category AS image_category_3d_snippets,
            ext_links_3d_snippets.contributor AS contributor_3d_snippets,
            ext_links_3d_snippets.disclaimer AS disclaimer_3d_snippets,
            ext_links_3d_snippets.license AS license_3d_snippets,
            ext_links_3d_snippets.display_order AS display_order_3d_snippets,
            specimens_1.gtu_location[0] AS latitude,
            specimens_1.gtu_location[1] AS longitude,
            identifications.notion_date AS identification_date,
            identifications.notion_date_mask AS identification_date_mask,
            (COALESCE((darwin2.fct_mask_date(identifications.notion_date, identifications.notion_date_mask) || ': '::text), ''::text) || (specimens_1.taxon_name)::text) AS history,
            specimens_1.gtu_ref,
            tags.group_type,
            tags.sub_group_type,
            tags.tag,
            (((((tags.group_type)::text || '-'::text) || (tags.sub_group_type)::text) || ':'::text) || (tags.tag)::text) AS tag_locality,
            users_tracking.modification_date_time
           FROM ((((((((darwin2.specimens specimens_1
             JOIN darwin2.specimens_stable_ids ON ((specimens_1.id = specimens_stable_ids.specimen_ref)))
             LEFT JOIN darwin2.codes ON ((((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text) AND (specimens_1.id = codes.record_id))))
             LEFT JOIN darwin2.ext_links ext_links_thumbnails ON (((specimens_1.id = ext_links_thumbnails.record_id) AND ((ext_links_thumbnails.referenced_relation)::text = 'specimens'::text) AND ((ext_links_thumbnails.category)::text = 'thumbnail'::text))))
             LEFT JOIN darwin2.ext_links ext_links_image_links ON (((specimens_1.id = ext_links_image_links.record_id) AND ((ext_links_image_links.referenced_relation)::text = 'specimens'::text) AND ((ext_links_image_links.category)::text = 'image_link'::text))))
             LEFT JOIN darwin2.ext_links ext_links_3d_snippets ON (((specimens_1.id = ext_links_3d_snippets.record_id) AND ((ext_links_3d_snippets.referenced_relation)::text = 'specimens'::text) AND ((ext_links_3d_snippets.category)::text = 'html_3d_snippet'::text))))
             LEFT JOIN darwin2.identifications ON ((((identifications.referenced_relation)::text = 'specimens'::text) AND (specimens_1.id = identifications.record_id) AND ((identifications.notion_concerned)::text = 'taxonomy'::text))))
             LEFT JOIN darwin2.tags ON ((specimens_1.gtu_ref = tags.gtu_ref)))
             LEFT JOIN ( SELECT users_tracking_1.modification_date_time,
                    users_tracking_1.record_id,
                    users_tracking_1.referenced_relation
                   FROM darwin2.users_tracking users_tracking_1
                  ORDER BY users_tracking_1.id DESC
                 LIMIT 1) users_tracking ON (((specimens_1.id = users_tracking.record_id) AND ((users_tracking.referenced_relation)::text = 'specimens'::text))))
          ORDER BY tags.group_ref) specimens
  GROUP BY specimens.uuid, specimens.code_display, specimens.collection_name, specimens.gtu_country_tag_value, specimens.gtu_others_tag_value, specimens.gtu_from_date, specimens.gtu_from_date_mask, specimens.gtu_to_date, specimens.gtu_to_date_mask, specimens.coll_type, specimens.longitude, specimens.latitude, specimens.collector_ids, specimens.donator_ids, specimens.modification_date_time, specimens.urls_thumbnails, specimens.taxon_name;


ALTER TABLE darwin2.v_rdf_view OWNER TO darwin2;

--
-- TOC entry 454 (class 1259 OID 20147)
-- Name: v_report_group_taxon_full_path_per_insertion_year; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_report_group_taxon_full_path_per_insertion_year AS
 SELECT DISTINCT unnest(darwin2.fct_remove_array_elem(string_to_array((((specimens.taxon_path)::text || ((specimens.taxon_ref)::character varying)::text) || '/'::text), '/'::text), '{""}'::text[])) AS taxon_id,
    COALESCE(date_part('year'::text, b.modification_date_time), (2010)::double precision) AS year,
    array_agg(DISTINCT b.record_id) AS spec_ids
   FROM (darwin2.specimens
     LEFT JOIN ( SELECT users_tracking.record_id,
            users_tracking.modification_date_time
           FROM darwin2.users_tracking
          WHERE (((users_tracking.referenced_relation)::text = 'specimens'::text) AND ((users_tracking.action)::text = 'insert'::text))) b ON ((specimens.id = b.record_id)))
  GROUP BY specimens.taxon_path, specimens.taxon_ref, COALESCE(date_part('year'::text, b.modification_date_time), (2010)::double precision);


ALTER TABLE darwin2.v_report_group_taxon_full_path_per_insertion_year OWNER TO darwin2;

--
-- TOC entry 455 (class 1259 OID 20152)
-- Name: v_report_group_taxon_full_path_per_insertion_year_all; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_report_group_taxon_full_path_per_insertion_year_all AS
 SELECT DISTINCT a.min_year,
    specimens.collection_name,
    specimens.taxon_level_name,
    specimens.taxon_level_ref,
    count(DISTINCT specimens.taxon_ref) AS count_taxa
   FROM (( SELECT v_report_group_taxon_full_path_per_insertion_year.taxon_id,
            (array_agg(v_report_group_taxon_full_path_per_insertion_year.year ORDER BY v_report_group_taxon_full_path_per_insertion_year.year))[1] AS min_year,
            unnest(v_report_group_taxon_full_path_per_insertion_year.spec_ids) AS spec_id
           FROM darwin2.v_report_group_taxon_full_path_per_insertion_year
          GROUP BY v_report_group_taxon_full_path_per_insertion_year.taxon_id, v_report_group_taxon_full_path_per_insertion_year.spec_ids) a
     LEFT JOIN darwin2.specimens ON ((a.spec_id = specimens.id)))
  GROUP BY a.min_year, specimens.collection_name, specimens.taxon_level_name, specimens.taxon_level_ref
  ORDER BY a.min_year, specimens.collection_name, specimens.taxon_level_ref;


ALTER TABLE darwin2.v_report_group_taxon_full_path_per_insertion_year_all OWNER TO darwin2;

--
-- TOC entry 456 (class 1259 OID 20157)
-- Name: v_report_yearly_encoding_statistics_specimens; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_report_yearly_encoding_statistics_specimens AS
 SELECT DISTINCT collections.name,
    date_part('year'::text, users_tracking.modification_date_time) AS year,
    count(DISTINCT users_tracking.record_id) AS specimen_count
   FROM ((darwin2.collections
     LEFT JOIN darwin2.specimens ON ((collections.id = specimens.collection_ref)))
     LEFT JOIN darwin2.users_tracking ON (((specimens.id = users_tracking.record_id) AND ((users_tracking.referenced_relation)::text = 'specimens'::text) AND ((users_tracking.action)::text = 'insert'::text))))
  GROUP BY collections.name, (date_part('year'::text, users_tracking.modification_date_time))
  ORDER BY (date_part('year'::text, users_tracking.modification_date_time)), collections.name;


ALTER TABLE darwin2.v_report_yearly_encoding_statistics_specimens OWNER TO darwin2;

--
-- TOC entry 457 (class 1259 OID 20162)
-- Name: v_reporting_count_all_specimens; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens AS
 SELECT count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM darwin2.specimens;


ALTER TABLE darwin2.v_reporting_count_all_specimens OWNER TO darwin2;

--
-- TOC entry 458 (class 1259 OID 20167)
-- Name: v_reporting_count_all_specimens_by_collection; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_by_collection AS
 SELECT collections.name,
    specimens.collection_ref,
    count(specimens.*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM ((( SELECT DISTINCT max(codes.record_id) AS last_code
           FROM darwin2.codes
          WHERE (((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text))
          GROUP BY codes.full_code_indexed) code_unique
     LEFT JOIN darwin2.specimens ON ((code_unique.last_code = specimens.id)))
     LEFT JOIN darwin2.collections ON ((specimens.collection_ref = collections.id)))
  GROUP BY specimens.collection_ref, collections.name;


ALTER TABLE darwin2.v_reporting_count_all_specimens_by_collection OWNER TO darwin2;

--
-- TOC entry 459 (class 1259 OID 20172)
-- Name: v_reporting_count_all_specimens_by_collection_year_ig; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_by_collection_year_ig AS
 SELECT DISTINCT specimens.collection_name,
    specimens.collection_path,
    specimens.collection_ref,
    date_part('year'::text, specimens.specimen_creation_date) AS year,
    specimens.specimen_creation_date,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max,
    specimens.ig_ref,
    specimens.ig_num
   FROM darwin2.specimens
  GROUP BY specimens.collection_ref, specimens.collection_name, specimens.collection_path, (date_part('year'::text, specimens.specimen_creation_date)), specimens.specimen_creation_date, specimens.ig_ref, specimens.ig_num;


ALTER TABLE darwin2.v_reporting_count_all_specimens_by_collection_year_ig OWNER TO darwin2;

--
-- TOC entry 460 (class 1259 OID 20177)
-- Name: v_reporting_count_all_specimens_type; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_type AS
 SELECT btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|\/+|&)'::text), '\d'::text, ''::text)) AS type,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM (( SELECT DISTINCT max(codes.record_id) AS last_code
           FROM darwin2.codes
          WHERE (((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text))
          GROUP BY codes.full_code_indexed) code_unique
     LEFT JOIN darwin2.specimens ON ((code_unique.last_code = specimens.id)))
  GROUP BY (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|\/+|&)'::text), '\d'::text, ''::text)))
  ORDER BY (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|\/+|&)'::text), '\d'::text, ''::text)));


ALTER TABLE darwin2.v_reporting_count_all_specimens_type OWNER TO darwin2;

--
-- TOC entry 461 (class 1259 OID 20182)
-- Name: v_reporting_count_all_specimens_type_by_collection; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_type_by_collection AS
 SELECT btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|\/+|&)'::text), '\d'::text, ''::text)) AS type,
    collections.id AS collection_id,
    collections.name AS collection_name,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM ((( SELECT DISTINCT max(codes.record_id) AS last_code
           FROM darwin2.codes
          WHERE (((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text))
          GROUP BY codes.full_code_indexed) code_unique
     LEFT JOIN darwin2.specimens ON ((code_unique.last_code = specimens.id)))
     LEFT JOIN darwin2.collections ON ((specimens.collection_ref = collections.id)))
  GROUP BY collections.id, collections.name, (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|\/+|&)'::text), '\d'::text, ''::text)))
  ORDER BY (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|\/+|&)'::text), '\d'::text, ''::text))), collections.name;


ALTER TABLE darwin2.v_reporting_count_all_specimens_type_by_collection OWNER TO darwin2;

--
-- TOC entry 462 (class 1259 OID 20187)
-- Name: v_reporting_count_all_specimens_type_by_collection_ref_year_ig; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_type_by_collection_ref_year_ig AS
 SELECT DISTINCT specimens.collection_path,
    specimens.collection_name,
    specimens.collection_ref,
    specimens.ig_ref,
    specimens.ig_num,
    date_part('year'::text, specimens.specimen_creation_date) AS year,
    specimens.specimen_creation_date,
    btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&|\/|\s)'::text), '\d'::text, ''::text)) AS type,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM darwin2.specimens
  GROUP BY specimens.collection_path, specimens.collection_name, specimens.collection_ref, specimens.ig_ref, specimens.ig_num, specimens.specimen_creation_date, (date_part('year'::text, specimens.specimen_creation_date)), (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&|\/|\s)'::text), '\d'::text, ''::text)))
  ORDER BY (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&|\/|\s)'::text), '\d'::text, ''::text)));


ALTER TABLE darwin2.v_reporting_count_all_specimens_type_by_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 463 (class 1259 OID 20192)
-- Name: v_reporting_higher_taxa_geo_per_rank_collection_ref_year_ig; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_higher_taxa_geo_per_rank_collection_ref_year_ig AS
 SELECT DISTINCT catalogue_levels.id AS level_ref,
    catalogue_levels.level_name,
    a.taxon_array[1] AS rank,
    a.taxon_array[2] AS taxon,
    a.year,
    a.creation_date,
    a.ig_ref,
    a.ig_num,
    a.collection_path,
    a.collection_ref,
    a.collection_name,
    a.countries,
    a.min_lon,
    a.min_lat,
    a.max_lon,
    a.max_lat
   FROM (( SELECT string_to_array(replace(replace(((public.each(darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore(specimens.taxon_path)))::character varying)::text, '('::text, ''::text), ')'::text, ''::text), ','::text) AS taxon_array,
            date_part('year'::text, min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date))) AS year,
            min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date)) AS creation_date,
            specimens.ig_ref,
            specimens.ig_num,
            specimens.collection_path,
            specimens.collection_ref,
            specimens.collection_name,
            array_agg(DISTINCT specimens.gtu_country_tag_value ORDER BY specimens.gtu_country_tag_value) AS countries,
            min(specimens.gtu_location[0]) AS min_lon,
            min(specimens.gtu_location[1]) AS min_lat,
            max(specimens.gtu_location[0]) AS max_lon,
            max(specimens.gtu_location[1]) AS max_lat
           FROM ((darwin2.taxonomy
             JOIN darwin2.specimens ON ((taxonomy.id = specimens.taxon_ref)))
             LEFT JOIN darwin2.catalogue_levels catalogue_levels_1 ON ((taxonomy.level_ref = catalogue_levels_1.id)))
          GROUP BY specimens.taxon_path, specimens.ig_ref, specimens.ig_num, specimens.collection_path, specimens.collection_ref, specimens.collection_name) a
     JOIN darwin2.catalogue_levels ON ((a.taxon_array[1] = (catalogue_levels.level_sys_name)::text)))
  WHERE (catalogue_levels.id < 41);


ALTER TABLE darwin2.v_reporting_higher_taxa_geo_per_rank_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 464 (class 1259 OID 20197)
-- Name: v_reporting_higher_taxa_per_rank_collection_ref_year_ig; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_higher_taxa_per_rank_collection_ref_year_ig AS
 SELECT DISTINCT catalogue_levels.id AS level_ref,
    catalogue_levels.level_name,
    a.taxon_array[1] AS rank,
    a.taxon_array[2] AS taxon,
    a.year,
    a.creation_date,
    a.ig_ref,
    a.ig_num,
    a.collection_path,
    a.collection_ref,
    a.collection_name
   FROM (( SELECT string_to_array(replace(replace(((public.each(darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore(specimens.taxon_path)))::character varying)::text, '('::text, ''::text), ')'::text, ''::text), ','::text) AS taxon_array,
            date_part('year'::text, min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date))) AS year,
            min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date)) AS creation_date,
            specimens.ig_ref,
            specimens.ig_num,
            specimens.collection_path,
            specimens.collection_ref,
            specimens.collection_name
           FROM ((darwin2.taxonomy
             JOIN darwin2.specimens ON ((taxonomy.id = specimens.taxon_ref)))
             LEFT JOIN darwin2.catalogue_levels catalogue_levels_1 ON ((taxonomy.level_ref = catalogue_levels_1.id)))
          GROUP BY specimens.taxon_path, specimens.ig_ref, specimens.ig_num, specimens.collection_path, specimens.collection_ref, specimens.collection_name) a
     JOIN darwin2.catalogue_levels ON ((a.taxon_array[1] = (catalogue_levels.level_sys_name)::text)))
  WHERE (catalogue_levels.id < 41);


ALTER TABLE darwin2.v_reporting_higher_taxa_per_rank_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 465 (class 1259 OID 20202)
-- Name: v_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig AS
 SELECT a.taxonomy_id,
    a.collection_path,
    a.collection_ref,
    a.collection_name,
    a.ig_ref,
    a.ig_num,
    a.year,
    a.creation_date,
    a.level_ref,
    a.level_name,
    count(*) AS nb_records,
    sum(a.specimen_count_min) AS specimen_count_min,
    sum(a.specimen_count_max) AS specimen_count_max
   FROM ( SELECT taxonomy.id AS taxonomy_id,
            specimens.collection_path,
            specimens.collection_ref,
            specimens.collection_name,
            taxonomy.id,
            date_part('year'::text, min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date))) AS year,
            min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date)) AS creation_date,
            taxonomy.level_ref,
            catalogue_levels.level_name,
            specimens.ig_ref,
            specimens.ig_num,
            specimens.specimen_count_min,
            specimens.specimen_count_max
           FROM ((darwin2.taxonomy
             JOIN darwin2.specimens ON ((taxonomy.id = specimens.taxon_ref)))
             LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)))
          GROUP BY taxonomy.id, specimens.collection_path, specimens.collection_name, specimens.collection_ref, taxonomy.level_ref, catalogue_levels.level_name, specimens.ig_ref, specimens.ig_num, specimens.specimen_count_min, specimens.specimen_count_max) a
  GROUP BY a.taxonomy_id, a.collection_path, a.collection_name, a.collection_ref, a.year, a.creation_date, a.level_ref, a.level_name, a.ig_ref, a.ig_num, a.specimen_count_min, a.specimen_count_max
  ORDER BY a.year, a.level_name DESC;


ALTER TABLE darwin2.v_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 466 (class 1259 OID 20207)
-- Name: v_reporting_taxa_in_specimen_per_rank_collection_ref_year_igall; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_taxa_in_specimen_per_rank_collection_ref_year_igall AS
 SELECT a.taxonomy_id,
    a.collection_path,
    a.collection_ref,
    a.collection_name,
    a.ig_ref,
    a.ig_num,
    a.year,
    a.creation_date,
    a.level_ref,
    a.level_name,
    count(*) AS nb_records,
    sum(a.specimen_count_min) AS specimen_count_min,
    sum(a.specimen_count_max) AS specimen_count_max
   FROM ( SELECT taxonomy.id AS taxonomy_id,
            specimens.collection_path,
            specimens.collection_ref,
            specimens.collection_name,
            taxonomy.id,
            date_part('year'::text, min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date))) AS year,
            min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date)) AS creation_date,
            taxonomy.level_ref,
            catalogue_levels.level_name,
            specimens.ig_ref,
            specimens.ig_num,
            specimens.specimen_count_min,
            specimens.specimen_count_max
           FROM ((( WITH aa AS (
                         SELECT specimens_1.collection_path,
                            specimens_1.collection_ref,
                            specimens_1.collection_name,
                            specimens_1.specimen_creation_date,
                            specimens_1.ig_ref,
                            specimens_1.ig_num,
                            specimens_1.specimen_count_min,
                            specimens_1.specimen_count_max,
                            regexp_split_to_table((((specimens_1.taxon_path)::text || ((specimens_1.taxon_ref)::character varying)::text) || '/'::text), '/'::text) AS path_elem_2
                           FROM darwin2.specimens specimens_1
                        )
                 SELECT DISTINCT aa.collection_path,
                    aa.collection_ref,
                    aa.collection_name,
                    aa.specimen_creation_date,
                    aa.ig_ref,
                    aa.ig_num,
                    aa.specimen_count_min,
                    aa.specimen_count_max,
                    aa.path_elem_2
                   FROM aa
                  WHERE (aa.path_elem_2 <> ''::text)) specimens
             JOIN darwin2.taxonomy ON (((specimens.path_elem_2)::integer = taxonomy.id)))
             LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)))
          GROUP BY taxonomy.id, specimens.collection_path, specimens.collection_name, specimens.collection_ref, taxonomy.level_ref, catalogue_levels.level_name, specimens.ig_ref, specimens.ig_num, specimens.specimen_count_min, specimens.specimen_count_max) a
  GROUP BY a.taxonomy_id, a.collection_path, a.collection_name, a.collection_ref, a.year, a.creation_date, a.level_ref, a.level_name, a.ig_ref, a.ig_num, a.specimen_count_min, a.specimen_count_max
  ORDER BY a.year, a.level_name DESC;


ALTER TABLE darwin2.v_reporting_taxa_in_specimen_per_rank_collection_ref_year_igall OWNER TO darwin2;

--
-- TOC entry 467 (class 1259 OID 20212)
-- Name: v_reporting_taxonomy_general; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_taxonomy_general AS
 SELECT catalogue_levels.level_name,
    count(*) AS count
   FROM (darwin2.taxonomy
     LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)))
  GROUP BY catalogue_levels.level_name, taxonomy.level_ref
  ORDER BY taxonomy.level_ref;


ALTER TABLE darwin2.v_reporting_taxonomy_general OWNER TO darwin2;

--
-- TOC entry 468 (class 1259 OID 20216)
-- Name: v_reporting_taxonomy_in_specimen; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_taxonomy_in_specimen AS
 SELECT specimens.taxon_level_name,
    count(DISTINCT specimens.taxon_name) AS count
   FROM darwin2.specimens
  GROUP BY specimens.taxon_level_ref, specimens.taxon_level_name
  ORDER BY specimens.taxon_level_ref;


ALTER TABLE darwin2.v_reporting_taxonomy_in_specimen OWNER TO darwin2;

--
-- TOC entry 469 (class 1259 OID 20221)
-- Name: v_rmca_check_taxonomy_in_staging; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_check_taxonomy_in_staging AS
 SELECT DISTINCT codes.code,
    staging.status,
    staging.taxon_name,
    staging.taxon_level_name,
    darwin2.fct_rmca_display_staging_taxon_reorder(staging.taxon_parents) AS imported_taxonomy_in_source,
    replace((darwin2.fct_rmca_display_staging_taxon_comparison(staging.taxon_parents))::text, ('/Eucaryota/Animalia/'::character varying)::text, (''::character varying)::text) AS existing_taxonomy_in_darwin,
    staging.import_ref
   FROM (darwin2.staging
     LEFT JOIN darwin2.codes ON (((staging.id = codes.record_id) AND ((codes.referenced_relation)::text = 'staging'::text) AND ((codes.code_category)::text = 'main'::text))));


ALTER TABLE darwin2.v_rmca_check_taxonomy_in_staging OWNER TO darwin2;

--
-- TOC entry 471 (class 1259 OID 20231)
-- Name: v_rmca_count_vertebrates_drosera_by_number; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_count_vertebrates_drosera_by_number AS
 SELECT a.referenced_relation,
    a.record_id,
    a.id,
    a.code_category,
    a.code_prefix,
    a.code_prefix_separator,
    a.code,
    a.code_suffix,
    a.code_suffix_separator,
    a.full_code_indexed,
    a.code_date,
    a.code_date_mask,
    a.code_num,
    a.upper_count,
    a.lower_count,
    ((a.upper_count - a.lower_count) + 1) AS counter
   FROM ( SELECT codes.referenced_relation,
            codes.record_id,
            codes.id,
            codes.code_category,
            codes.code_prefix,
            codes.code_prefix_separator,
            codes.code,
            codes.code_suffix,
            codes.code_suffix_separator,
            codes.full_code_indexed,
            codes.code_date,
            codes.code_date_mask,
            codes.code_num,
            ((regexp_matches((codes.code)::text, '.(\d+)$'::text))[1])::integer AS upper_count,
            ((regexp_matches((codes.code)::text, '.(\d+)(-|$)'::text))[1])::integer AS lower_count
           FROM darwin2.codes
          WHERE (((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text))) a;


ALTER TABLE darwin2.v_rmca_count_vertebrates_drosera_by_number OWNER TO darwin2;

--
-- TOC entry 7458 (class 0 OID 0)
-- Dependencies: 471
-- Name: VIEW v_rmca_count_vertebrates_drosera_by_number; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON VIEW darwin2.v_rmca_count_vertebrates_drosera_by_number IS 'this view counts the number of specimens present iun a batch when the number has the structure "P.454-459" (old numbering schema of RMCA, befire 1973) or "RMCA_VERT1999.0004.P.4569-4789" (new numbering schema, enabled by Thys van der Audenaerde in 1973). This concerns mainly the icgtyology, but other vetebratrates collections coming from DataPerfect coule also use this feature';


--
-- TOC entry 472 (class 1259 OID 20236)
-- Name: v_rmca_count_ichtyology_by_number_full_restrict_ichtyo; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_count_ichtyology_by_number_full_restrict_ichtyo AS
 SELECT a.referenced_relation,
    a.record_id,
    a.id,
    a.code_category,
    a.code_prefix,
    a.code_prefix_separator,
    a.code,
    a.code_suffix,
    a.code_suffix_separator,
    a.full_code_indexed,
    a.code_date,
    a.code_date_mask AS upper_count,
    b.lower_count,
    b.counter
   FROM (darwin2.codes a
     LEFT JOIN darwin2.v_rmca_count_vertebrates_drosera_by_number b ON ((a.id = b.id)))
  WHERE (((a.referenced_relation)::text = 'specimens'::text) AND ((a.code_category)::text = 'main'::text) AND (a.record_id IN ( SELECT specimens.id
           FROM darwin2.specimens
          WHERE (specimens.collection_ref = 6))));


ALTER TABLE darwin2.v_rmca_count_ichtyology_by_number_full_restrict_ichtyo OWNER TO darwin2;

--
-- TOC entry 7459 (class 0 OID 0)
-- Dependencies: 472
-- Name: VIEW v_rmca_count_ichtyology_by_number_full_restrict_ichtyo; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON VIEW darwin2.v_rmca_count_ichtyology_by_number_full_restrict_ichtyo IS 'Restrict  "v_rmca_count_vertebrates_drosera_by_number" to ichtyology labels';


--
-- TOC entry 473 (class 1259 OID 20241)
-- Name: v_rmca_count_ichtyology_by_number_full_good; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_count_ichtyology_by_number_full_good AS
 SELECT v_rmca_count_ichtyology_by_number_full.referenced_relation,
    v_rmca_count_ichtyology_by_number_full.record_id,
    v_rmca_count_ichtyology_by_number_full.id,
    v_rmca_count_ichtyology_by_number_full.code_category,
    v_rmca_count_ichtyology_by_number_full.code_prefix,
    v_rmca_count_ichtyology_by_number_full.code_prefix_separator,
    v_rmca_count_ichtyology_by_number_full.code,
    v_rmca_count_ichtyology_by_number_full.code_suffix,
    v_rmca_count_ichtyology_by_number_full.code_suffix_separator,
    v_rmca_count_ichtyology_by_number_full.full_code_indexed,
    v_rmca_count_ichtyology_by_number_full.code_date,
    v_rmca_count_ichtyology_by_number_full.upper_count,
    v_rmca_count_ichtyology_by_number_full.lower_count,
    COALESCE(v_rmca_count_ichtyology_by_number_full.counter,
        CASE
            WHEN (((v_rmca_count_ichtyology_by_number_full.code)::text ~~ 'P.%/%'::text) AND (( SELECT (regexp_matches(upper((v_rmca_count_ichtyology_by_number_full.code)::text), '/([A-Z]+)-([A-Z]+)'::text))[1] AS regexp_matches) IS NOT NULL) AND (( SELECT (regexp_matches(upper((v_rmca_count_ichtyology_by_number_full.code)::text), '/([A-Z]+)-([A-Z]+)'::text))[2] AS regexp_matches) IS NOT NULL)) THEN ((( SELECT ascii((regexp_matches(upper((v_rmca_count_ichtyology_by_number_full.code)::text), '/([A-Z]+)-([A-Z]+)'::text))[2]) AS ascii) - ( SELECT ascii((regexp_matches(upper((v_rmca_count_ichtyology_by_number_full.code)::text), '/([A-Z]+)-([A-Z]+)'::text))[1]) AS ascii)) + 1)
            ELSE 1
        END) AS counter
   FROM darwin2.v_rmca_count_ichtyology_by_number_full_restrict_ichtyo v_rmca_count_ichtyology_by_number_full;


ALTER TABLE darwin2.v_rmca_count_ichtyology_by_number_full_good OWNER TO darwin2;

--
-- TOC entry 7460 (class 0 OID 0)
-- Dependencies: 473
-- Name: VIEW v_rmca_count_ichtyology_by_number_full_good; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON VIEW darwin2.v_rmca_count_ichtyology_by_number_full_good IS 'Extends "v_rmca_count_vertebrates_drosera_by_number" to count old labems that have the firm P.147/A-B (3 specimens)';


--
-- TOC entry 474 (class 1259 OID 20246)
-- Name: v_rmca_get_genus_by_families; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_get_genus_by_families AS
 SELECT parent.id AS parent_id,
    parent.name AS family,
    parent.level_ref AS parent_level_ref,
    rank_parent.level_name AS parent_level_name,
    child.id AS child_id,
    child.name AS family_or_genus,
    child.level_ref AS child_level_ref,
    rank_child.level_name AS child_level_name,
    (child.level_ref - parent.level_ref) AS diff,
    child.path AS child_path
   FROM (((darwin2.taxonomy parent
     JOIN darwin2.taxonomy child ON ((((child.path)::text ~~ (('%/'::text || (parent.id)::text) || '/%'::text)) OR (parent.id = child.id))))
     JOIN darwin2.catalogue_levels rank_parent ON ((rank_parent.id = parent.level_ref)))
     JOIN darwin2.catalogue_levels rank_child ON ((rank_child.id = child.level_ref)))
  WHERE ((parent.level_ref = 34) AND (child.level_ref <= 41))
  ORDER BY parent.name, (child.level_ref - parent.level_ref), child.name;


ALTER TABLE darwin2.v_rmca_get_genus_by_families OWNER TO darwin2;

--
-- TOC entry 475 (class 1259 OID 20251)
-- Name: v_rmca_count_specimen_by_families_genus; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_count_specimen_by_families_genus AS
 SELECT c.family,
    c.child_id,
    c.family_or_genus,
    a.collection_ref,
    count(a.id) AS count_all,
    ( SELECT count(specimens.id) AS count
           FROM darwin2.specimens
          WHERE (specimens.taxon_ref = c.child_id)) AS count_direct
   FROM ((darwin2.specimens a
     JOIN darwin2.taxonomy b ON ((a.taxon_ref = b.id)))
     JOIN darwin2.v_rmca_get_genus_by_families c ON (((((b.path)::text || (b.id)::text) || '/'::text) ~~ (((c.child_path)::text || (c.child_id)::text) || '/%'::text))))
  GROUP BY c.family, c.child_id, c.family_or_genus, a.collection_ref, c.diff
  ORDER BY c.family, c.diff, c.family_or_genus;


ALTER TABLE darwin2.v_rmca_count_specimen_by_families_genus OWNER TO darwin2;

--
-- TOC entry 476 (class 1259 OID 20256)
-- Name: v_rmca_export_staging_info; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_export_staging_info AS
 SELECT DISTINCT b.code,
    a.taxon_name,
    a.status,
    a.import_ref,
    c.collection_ref
   FROM ((darwin2.staging a
     JOIN darwin2.codes b ON (((a.id = b.record_id) AND ((b.referenced_relation)::text = 'staging'::text) AND ((b.code_category)::text = 'main'::text))))
     LEFT JOIN darwin2.imports c ON ((a.import_ref = c.collection_ref)));


ALTER TABLE darwin2.v_rmca_export_staging_info OWNER TO darwin2;

--
-- TOC entry 477 (class 1259 OID 20261)
-- Name: v_rmca_get_higher_by_lower; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_get_higher_by_lower AS
 SELECT parent.id AS parent_id,
    parent.name AS higher_name,
    parent.level_ref AS parent_level_ref,
    rank_parent.level_name AS parent_level_name,
    child.id AS child_id,
    child.name AS lower_name,
    child.level_ref AS child_level_ref,
    rank_child.level_name AS child_level_name,
    (child.level_ref - parent.level_ref) AS diff,
    (((parent.path)::text || ((parent.id)::character varying)::text) || '/'::text) AS parent_path
   FROM (((darwin2.taxonomy parent
     JOIN darwin2.taxonomy child ON ((((child.path)::text ~~ (('%/'::text || (parent.id)::text) || '/%'::text)) OR (parent.id = child.id))))
     JOIN darwin2.catalogue_levels rank_parent ON ((rank_parent.id = parent.level_ref)))
     JOIN darwin2.catalogue_levels rank_child ON ((rank_child.id = child.level_ref)))
  ORDER BY child.path;


ALTER TABLE darwin2.v_rmca_get_higher_by_lower OWNER TO darwin2;

--
-- TOC entry 478 (class 1259 OID 20266)
-- Name: v_rmca_gtu_tags_administraive_and_ecology; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_gtu_tags_administraive_and_ecology AS
 SELECT DISTINCT t.gtu_ref,
    ((( SELECT array_agg(t2.tag) AS array_agg
           FROM darwin2.tags t2
          WHERE ((t2.gtu_ref = t.gtu_ref) AND ((t2.group_type)::text = 'administrative'::text))) || ( SELECT array_agg(t2.tag) AS array_agg
           FROM darwin2.tags t2
          WHERE ((t2.gtu_ref = t.gtu_ref) AND ((t2.group_type)::text = 'administrative area'::text)))) || ( SELECT array_agg(t2.tag) AS array_agg
           FROM darwin2.tags t2
          WHERE ((t2.gtu_ref = t.gtu_ref) AND ((t2.group_type)::text = 'area'::text)))) AS administraive_tags,
    ( SELECT array_agg(t2.tag) AS array_agg
           FROM darwin2.tags t2
          WHERE ((t2.gtu_ref = t.gtu_ref) AND ((t2.group_type)::text <> 'administrative'::text) AND ((t2.group_type)::text <> 'administrative area'::text) AND ((t2.group_type)::text <> 'area'::text))) AS non_administrative_tags
   FROM darwin2.tags t;


ALTER TABLE darwin2.v_rmca_gtu_tags_administraive_and_ecology OWNER TO darwin2;

--
-- TOC entry 479 (class 1259 OID 20271)
-- Name: v_rmca_higher_than_familiy_in_collection; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_higher_than_familiy_in_collection AS
 SELECT count(*) AS count,
    a.collection_ref
   FROM (darwin2.specimens a
     JOIN darwin2.taxonomy b ON ((a.taxon_ref = b.id)))
  WHERE (b.level_ref < 34)
  GROUP BY a.collection_ref;


ALTER TABLE darwin2.v_rmca_higher_than_familiy_in_collection OWNER TO darwin2;

--
-- TOC entry 480 (class 1259 OID 20276)
-- Name: v_rmca_ig_to_people; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_ig_to_people AS
 SELECT a.ig_ref,
    a.ig_num,
    a.people_ref,
    a.role,
    a.collection_ref,
    a.collection_name,
    people.formated_name,
    people.formated_name_indexed,
    people.formated_name_unique,
    people.title,
    people.family_name,
    people.given_name
   FROM (( SELECT specimens.ig_ref,
            specimens.ig_num,
            unnest(specimens.spec_coll_ids) AS people_ref,
            'collector'::text AS role,
            specimens.collection_ref,
            specimens.collection_name
           FROM darwin2.specimens
        UNION
         SELECT specimens.ig_ref,
            specimens.ig_num,
            unnest(specimens.spec_ident_ids) AS people_ref,
            'identifier'::text AS role,
            specimens.collection_ref,
            specimens.collection_name
           FROM darwin2.specimens
        UNION
         SELECT specimens.ig_ref,
            specimens.ig_num,
            unnest(specimens.spec_don_sel_ids) AS people_ref,
            'donator_seller'::text AS role,
            specimens.collection_ref,
            specimens.collection_name
           FROM darwin2.specimens) a
     LEFT JOIN darwin2.people ON ((a.people_ref = people.id)));


ALTER TABLE darwin2.v_rmca_ig_to_people OWNER TO darwin2;

--
-- TOC entry 481 (class 1259 OID 20281)
-- Name: v_rmca_ig_to_people_bics_report_2020; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_ig_to_people_bics_report_2020 AS
 SELECT v_rmca_ig_to_people.ig_ref,
    v_rmca_ig_to_people.ig_num,
    v_rmca_ig_to_people.people_ref,
    v_rmca_ig_to_people.role,
    v_rmca_ig_to_people.collection_ref,
    v_rmca_ig_to_people.collection_name,
    v_rmca_ig_to_people.formated_name,
    v_rmca_ig_to_people.formated_name_indexed,
    v_rmca_ig_to_people.formated_name_unique,
    v_rmca_ig_to_people.title,
    v_rmca_ig_to_people.family_name,
    v_rmca_ig_to_people.given_name
   FROM darwin2.v_rmca_ig_to_people
  WHERE ((((v_rmca_ig_to_people.ig_num)::text ~~ '2018%'::text) OR ((v_rmca_ig_to_people.ig_num)::text ~~ '2019%'::text) OR ((v_rmca_ig_to_people.ig_num)::text ~~ '2020%'::text)) AND (v_rmca_ig_to_people.collection_ref = 6) AND (((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%mukweze%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%mambo%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%mayo%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%lemvo%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%manonekene%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%kiwele%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%wilson%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%guimbi%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%bigirama%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%kasongo%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%wamuini%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%kosi%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%abwe%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%kalumba%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%bauchet%'::text) OR ((v_rmca_ig_to_people.formated_name_indexed)::text ~~ '%ibala%'::text)));


ALTER TABLE darwin2.v_rmca_ig_to_people_bics_report_2020 OWNER TO darwin2;

--
-- TOC entry 482 (class 1259 OID 20286)
-- Name: v_rmca_ig_to_people_bics_report_2020_specimens; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_ig_to_people_bics_report_2020_specimens AS
 SELECT DISTINCT specimens.ig_num,
    specimens.ig_ref,
    count(specimens.id) AS count,
    sum(specimens.specimen_count_min) AS phyisical,
    array_agg(DISTINCT a.formated_name) AS people
   FROM (darwin2.v_rmca_ig_to_people_bics_report_2020 a
     LEFT JOIN darwin2.specimens ON ((a.ig_ref = specimens.ig_ref)))
  GROUP BY specimens.ig_num, specimens.ig_ref
  ORDER BY specimens.ig_num;


ALTER TABLE darwin2.v_rmca_ig_to_people_bics_report_2020_specimens OWNER TO darwin2;

--
-- TOC entry 483 (class 1259 OID 20291)
-- Name: v_rmca_path_parent_children_extended_taxonomy_alpha_count_child; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_path_parent_children_extended_taxonomy_alpha_count_child AS
 SELECT b.id AS parent_id,
    ((((b.path)::text || b.id) || '/'::text))::character varying AS parent_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically(((((b.path)::text || b.id) || '/'::text))::character varying) AS parent_alpha_path,
    b.name AS parent_name,
    d.level_name AS parent_level,
    d.level_order AS parent_level_order,
    a.id AS child_id,
    ((((a.path)::text || (a.id)::text) || '/'::text))::character varying AS child_path,
    a.name AS child_name,
    a.level_ref,
    c.level_name AS child_level,
    c.level_order AS child_level_order
   FROM (((darwin2.taxonomy a
     JOIN darwin2.taxonomy b ON (((((((a.path)::text || (a.id)::text) || '/'::text))::character varying)::text ~~ (((((b.path)::text || (b.id)::text) || '/%'::text))::character varying)::text)))
     JOIN darwin2.catalogue_levels c ON ((a.level_ref = c.id)))
     JOIN darwin2.catalogue_levels d ON ((b.level_ref = d.id)));


ALTER TABLE darwin2.v_rmca_path_parent_children_extended_taxonomy_alpha_count_child OWNER TO darwin2;

--
-- TOC entry 484 (class 1259 OID 20296)
-- Name: v_rmca_preferences_with_usernames; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_preferences_with_usernames AS
 SELECT pr.id,
    pr.user_ref,
    u.formated_name,
    pr.pref_key,
    pr.pref_value
   FROM (darwin2.preferences pr
     LEFT JOIN darwin2.users u ON ((pr.user_ref = u.id)));


ALTER TABLE darwin2.v_rmca_preferences_with_usernames OWNER TO darwin2;

--
-- TOC entry 485 (class 1259 OID 20300)
-- Name: v_rmca_report_ig_ichtyo_1_main; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_report_ig_ichtyo_1_main AS
 SELECT DISTINCT igs.id,
    igs.ig_num,
    darwin2.fct_mask_date((igs.ig_date)::timestamp without time zone, igs.ig_date_mask) AS date_donation,
    p.formated_name AS donateur,
    darwin2.fct_remove_null_array_elem((array_agg(DISTINCT p2.formated_name) || array_agg(DISTINCT expeditions.name))) AS collectors_array,
    sum(v_rmca_count_ichtyology_by_number.counter) AS sum,
    specimens.collection_name
   FROM ((((((((darwin2.igs
     LEFT JOIN darwin2.specimens ON ((igs.id = specimens.ig_ref)))
     LEFT JOIN darwin2.v_rmca_count_vertebrates_drosera_by_number v_rmca_count_ichtyology_by_number ON ((specimens.id = v_rmca_count_ichtyology_by_number.record_id)))
     LEFT JOIN darwin2.catalogue_people c ON (((specimens.id = c.record_id) AND ((c.referenced_relation)::text = 'specimens'::text) AND ((c.people_type)::text = 'donator'::text))))
     LEFT JOIN darwin2.people p ON ((c.people_ref = p.id)))
     LEFT JOIN darwin2.catalogue_people c2 ON (((specimens.id = c2.record_id) AND ((c2.referenced_relation)::text = 'specimens'::text) AND ((c2.people_type)::text = 'collector'::text))))
     LEFT JOIN darwin2.people p2 ON ((c2.people_ref = p2.id)))
     LEFT JOIN darwin2.expeditions ON ((specimens.expedition_ref = expeditions.id)))
     LEFT JOIN darwin2.collections ON ((specimens.collection_ref = collections.id)))
  WHERE (specimens.valid_label IS TRUE)
  GROUP BY igs.id, igs.ig_num, igs.ig_date, igs.ig_date_mask, p.formated_name, specimens.collection_name;


ALTER TABLE darwin2.v_rmca_report_ig_ichtyo_1_main OWNER TO darwin2;

--
-- TOC entry 486 (class 1259 OID 20305)
-- Name: v_rmca_report_ig_ichtyo_2_localities; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_report_ig_ichtyo_2_localities AS
SELECT
    NULL::integer AS id,
    NULL::character varying AS country,
    NULL::integer AS id_gtu,
    NULL::text AS locality,
    NULL::text AS coordinates_text,
    NULL::text AS date_min,
    NULL::text AS date_max,
    NULL::text AS collections_numbers,
    NULL::bigint AS sum;


ALTER TABLE darwin2.v_rmca_report_ig_ichtyo_2_localities OWNER TO darwin2;

--
-- TOC entry 487 (class 1259 OID 20309)
-- Name: v_rmca_report_ig_ichtyo_3_taxo; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_report_ig_ichtyo_3_taxo AS
 SELECT DISTINCT igs.id,
    specimens.taxon_name,
    string_agg(DISTINCT (storage_parts.specimen_part)::text, ','::text) AS parts,
    sum(v_rmca_count_ichtyology_by_number.counter) AS counter,
    string_agg(replace((v_rmca_count_ichtyology_by_number.code)::text, ((igs.ig_num)::text || '.'::text), ''::text), ' '::text ORDER BY v_rmca_count_ichtyology_by_number.code) AS codes,
    specimens.valid_label
   FROM (((darwin2.igs
     LEFT JOIN darwin2.specimens ON ((igs.id = specimens.ig_ref)))
     LEFT JOIN darwin2.v_rmca_count_vertebrates_drosera_by_number v_rmca_count_ichtyology_by_number ON ((specimens.id = v_rmca_count_ichtyology_by_number.record_id)))
     LEFT JOIN darwin2.storage_parts ON ((specimens.id = storage_parts.specimen_ref)))
  GROUP BY igs.id, specimens.taxon_name, specimens.valid_label;


ALTER TABLE darwin2.v_rmca_report_ig_ichtyo_3_taxo OWNER TO darwin2;

--
-- TOC entry 488 (class 1259 OID 20314)
-- Name: v_rmca_split_path; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_split_path AS
 SELECT taxonomy.id AS child_name_id,
    taxonomy.path,
    (regexp_matches((taxonomy.path)::text, '([0-9]+)/'::text, 'g'::text))[1] AS regexp_matches
   FROM darwin2.taxonomy;


ALTER TABLE darwin2.v_rmca_split_path OWNER TO darwin2;

--
-- TOC entry 489 (class 1259 OID 20318)
-- Name: v_rmca_split_path_extended; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_split_path_extended AS
 SELECT DISTINCT b.child_name_id,
    c.name,
    c.id,
    c.path,
    c.level_ref,
    d.level_name,
    d.level_order
   FROM ((darwin2.v_rmca_split_path b
     JOIN darwin2.taxonomy c ON ((b.child_name_id = c.id)))
     JOIN darwin2.catalogue_levels d ON ((c.level_ref = d.id)));


ALTER TABLE darwin2.v_rmca_split_path_extended OWNER TO darwin2;

--
-- TOC entry 490 (class 1259 OID 20323)
-- Name: v_rmca_split_path_extended_alpha_path; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_split_path_extended_alpha_path AS
 SELECT DISTINCT b.child_name_id,
    c.name,
    c.id,
    c.path,
    c.level_ref,
    d.level_name,
    d.level_order,
    (((c.path)::text || (c.id)::text) || '/'::text) AS full_path,
    darwin2.fct_rmca_sort_taxon_path_alphabetically(((((c.path)::text || (c.id)::text) || '/'::text))::character varying) AS alpha_path
   FROM ((darwin2.v_rmca_split_path b
     JOIN darwin2.taxonomy c ON ((b.child_name_id = c.id)))
     JOIN darwin2.catalogue_levels d ON ((c.level_ref = d.id)));


ALTER TABLE darwin2.v_rmca_split_path_extended_alpha_path OWNER TO darwin2;

--
-- TOC entry 491 (class 1259 OID 20328)
-- Name: v_rmca_taxo_detect_duplicate_hierarchies; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_taxo_detect_duplicate_hierarchies AS
 SELECT subquery.level_ref,
    catalogue_levels.level_name,
    subquery.canonical_name,
    array_length(subquery.names_list, 1) AS nb_canonical_homonyms,
    subquery.names_list,
    subquery.taxa_ids AS ids
   FROM (( SELECT darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(taxonomy.name) AS fct_rmca_taxonomy_try_to_isolate_from_author,
            count(DISTINCT taxonomy.id) AS canonical_homonyms,
            taxonomy.level_ref,
            array_agg(taxonomy.name) AS names_list,
            array_agg(taxonomy.id) AS taxa_ids,
            darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(taxonomy.name) AS canonical_name
           FROM darwin2.taxonomy
          GROUP BY (darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(taxonomy.name)), taxonomy.level_ref
         HAVING (count(DISTINCT taxonomy.id) > 1)) subquery
     JOIN darwin2.catalogue_levels ON ((subquery.level_ref = catalogue_levels.id)))
  GROUP BY subquery.level_ref, catalogue_levels.level_name, subquery.names_list, subquery.taxa_ids, subquery.canonical_name
  ORDER BY subquery.level_ref, subquery.canonical_name;


ALTER TABLE darwin2.v_rmca_taxo_detect_duplicate_hierarchies OWNER TO darwin2;

--
-- TOC entry 521 (class 1259 OID 1417767)
-- Name: v_sophie_gryseels_2022; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_sophie_gryseels_2022 AS
 SELECT b.name AS taxo_group,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 34) AS family,
    string_agg(DISTINCT (storage_parts.container_type)::text, ','::text) AS container_type,
    specimens.type,
    string_agg(DISTINCT (storage_parts.specimen_part)::text, ','::text) AS part,
    string_agg(DISTINCT (specimens.gtu_country_tag_value)::text, ','::text) AS string_agg,
    min(NULLIF(specimens.gtu_from_date, '0001-01-01 00:00:00'::timestamp without time zone)) AS date_min,
    GREATEST(max(((NULLIF(specimens.gtu_from_date, '0001-01-01 00:00:00'::timestamp without time zone))::character varying)::text), max(((NULLIF(specimens.gtu_to_date, '2038-12-31 00:00:00'::timestamp without time zone))::character varying)::text)) AS date_max,
    count(DISTINCT specimens.id) AS records,
    sum(specimens.specimen_count_min) AS specimens
   FROM (darwin2.specimens
     JOIN darwin2.storage_parts ON ((specimens.id = storage_parts.specimen_ref))),
    ( SELECT (taxonomy.id)::character varying AS id_char,
            taxonomy.name
           FROM darwin2.taxonomy
          WHERE (((taxonomy.name_indexed)::text ~~ '%afrosoricida%'::text) OR ((taxonomy.name_indexed)::text ~~ 'artiodactyla%'::text) OR ((taxonomy.name_indexed)::text ~~ 'carnivora%'::text) OR ((taxonomy.name_indexed)::text ~~ 'chiroptera%'::text) OR ((taxonomy.name_indexed)::text ~~ 'erinaceomorpha%'::text) OR ((taxonomy.name_indexed)::text ~~ 'hyracoid%'::text) OR ((taxonomy.name_indexed)::text ~~ 'lagomorpha%'::text) OR ((taxonomy.name_indexed)::text ~~ 'macroscelidae%'::text) OR ((taxonomy.name_indexed)::text ~~ 'perissodactyla%'::text) OR ((taxonomy.name_indexed)::text ~~ 'pholidota%'::text) OR ((taxonomy.name_indexed)::text ~~ 'pinnid%'::text) OR ((taxonomy.name_indexed)::text ~~ 'primates%'::text) OR ((taxonomy.name_indexed)::text ~~ 'proboscidea%'::text) OR ((taxonomy.name_indexed)::text ~~ 'rodent%'::text) OR ((taxonomy.name_indexed)::text ~~ 'sirenia%'::text) OR ((taxonomy.name_indexed)::text ~~ 'soricida%'::text) OR ((taxonomy.name_indexed)::text ~~ 'talpa%'::text) OR ((taxonomy.name_indexed)::text ~~ 'tubulid%'::text))) b
  WHERE ((((((specimens.taxon_path)::text || '/'::text) || ((specimens.taxon_ref)::character varying)::text) || '/'::text) ~~ (('%/'::text || (b.id_char)::text) || '/%'::text)) AND ((((specimens.collection_path)::text || specimens.collection_ref) || '/'::text) ~~ '%/13/%'::text) AND ((storage_parts.container_type)::text ~~ '%alcohol%'::text))
  GROUP BY b.name, specimens.type, (darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 34));


ALTER TABLE darwin2.v_sophie_gryseels_2022 OWNER TO darwin2;

--
-- TOC entry 492 (class 1259 OID 20333)
-- Name: v_specimens_isolate_taxa_in_path; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_specimens_isolate_taxa_in_path AS
 SELECT specimens.id,
    specimens.taxon_ref,
    unnest(darwin2.fct_remove_null_array_elem(string_to_array(((specimens.taxon_path)::text || ((specimens.taxon_ref)::character varying)::text), '/'::text, ''::text))) AS path_elem,
    specimens.taxon_path,
    specimens.collection_ref,
    specimens.collection_path
   FROM darwin2.specimens;


ALTER TABLE darwin2.v_specimens_isolate_taxa_in_path OWNER TO darwin2;

--
-- TOC entry 493 (class 1259 OID 20338)
-- Name: v_specimens_isolate_taxa_in_path_with_metadata_ref; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_specimens_isolate_taxa_in_path_with_metadata_ref AS
 SELECT v_specimens_isolate_taxa_in_path.id,
    v_specimens_isolate_taxa_in_path.taxon_ref,
    v_specimens_isolate_taxa_in_path.path_elem,
    v_specimens_isolate_taxa_in_path.taxon_path,
    v_specimens_isolate_taxa_in_path.collection_ref,
    v_specimens_isolate_taxa_in_path.collection_path,
    taxonomy.metadata_ref AS taxonomy_metadata_ref
   FROM (darwin2.v_specimens_isolate_taxa_in_path
     LEFT JOIN darwin2.taxonomy ON (((v_specimens_isolate_taxa_in_path.path_elem)::integer = taxonomy.id)));


ALTER TABLE darwin2.v_specimens_isolate_taxa_in_path_with_metadata_ref OWNER TO darwin2;

--
-- TOC entry 494 (class 1259 OID 20342)
-- Name: v_specimens_people_full_text; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_specimens_people_full_text AS
 SELECT specimens.id,
    specimens.collection_ref,
    specimens.collection_name,
    specimens.ig_num,
    specimens.specimen_creation_date,
    specimens.spec_ident_ids,
    array_agg(t_identifier.formated_name) AS identifiers,
    specimens.spec_coll_ids,
    array_agg(t_collector.formated_name) AS collectors,
    specimens.spec_don_sel_ids,
    array_agg(t_donator.formated_name) AS donators
   FROM (((darwin2.specimens
     LEFT JOIN darwin2.people t_identifier ON ((t_identifier.id = ANY (specimens.spec_ident_ids))))
     LEFT JOIN darwin2.people t_collector ON ((t_collector.id = ANY (specimens.spec_coll_ids))))
     LEFT JOIN darwin2.people t_donator ON ((t_donator.id = ANY (specimens.spec_don_sel_ids))))
  GROUP BY specimens.id, specimens.collection_ref, specimens.collection_name, specimens.ig_num, specimens.specimen_creation_date, specimens.spec_ident_ids, specimens.spec_coll_ids, specimens.spec_don_sel_ids;


ALTER TABLE darwin2.v_specimens_people_full_text OWNER TO darwin2;

--
-- TOC entry 495 (class 1259 OID 20347)
-- Name: v_staging_diagnose_rejects; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_staging_diagnose_rejects AS
 SELECT codes.code,
    staging.status,
    staging.id,
    staging.taxon_name,
    staging.taxon_parents,
    staging.import_ref
   FROM (darwin2.staging
     LEFT JOIN darwin2.codes ON (((staging.id = codes.record_id) AND ((codes.referenced_relation)::text = 'staging'::text) AND ((codes.code_category)::text = 'main'::text))));


ALTER TABLE darwin2.v_staging_diagnose_rejects OWNER TO darwin2;

--
-- TOC entry 496 (class 1259 OID 20352)
-- Name: v_t_compare_darwin_digit03_mysql; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_t_compare_darwin_digit03_mysql AS
 SELECT t_compare_darwin_digit03_mysql.pid,
    t_compare_darwin_digit03_mysql.phylum,
    t_compare_darwin_digit03_mysql.class,
    t_compare_darwin_digit03_mysql.family,
    t_compare_darwin_digit03_mysql.genus,
    t_compare_darwin_digit03_mysql.species,
    t_compare_darwin_digit03_mysql.subspecies,
    t_compare_darwin_digit03_mysql.status,
    t_compare_darwin_digit03_mysql.number,
    t_compare_darwin_digit03_mysql.digitisation,
    t_compare_darwin_digit03_mysql.url,
    t_compare_darwin_digit03_mysql.sketchfab_snippet,
    t_compare_darwin_digit03_mysql.sketchfab_without_snippet,
    t_compare_darwin_digit03_mysql.contributor,
    t_compare_darwin_digit03_mysql.pic_path,
    t_compare_darwin_digit03_mysql.pic_display_order,
    t_compare_darwin_digit03_mysql.pic_image_file,
    (regexp_split_to_array((t_compare_darwin_digit03_mysql.species)::text, ' '::text))[array_length(regexp_split_to_array((t_compare_darwin_digit03_mysql.species)::text, ' '::text), 1)] AS sp_corr,
    (regexp_split_to_array((t_compare_darwin_digit03_mysql.subspecies)::text, ' '::text))[array_length(regexp_split_to_array((t_compare_darwin_digit03_mysql.subspecies)::text, ' '::text), 1)] AS ssp_corr,
    btrim((((((t_compare_darwin_digit03_mysql.genus)::text || ' '::text) || btrim(COALESCE((regexp_split_to_array((t_compare_darwin_digit03_mysql.species)::text, ' '::text))[array_length(regexp_split_to_array((t_compare_darwin_digit03_mysql.species)::text, ' '::text), 1)], ''::text))) || ' '::text) || btrim(COALESCE((regexp_split_to_array((t_compare_darwin_digit03_mysql.subspecies)::text, ' '::text))[array_length(regexp_split_to_array((t_compare_darwin_digit03_mysql.subspecies)::text, ' '::text), 1)], ''::text)))) AS full_sc_name
   FROM darwin2.t_compare_darwin_digit03_mysql;


ALTER TABLE darwin2.v_t_compare_darwin_digit03_mysql OWNER TO darwin2;

--
-- TOC entry 497 (class 1259 OID 20357)
-- Name: v_taxonomical_statistics_callard; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_taxonomical_statistics_callard AS
 SELECT DISTINCT specimens.collection_ref,
    specimens.taxon_single_ref,
    taxonomy.name,
    taxonomy.name_indexed,
    taxonomy.level_ref,
    taxonomy.status,
    taxonomy.local_naming,
    taxonomy.color,
    taxonomy.path,
    taxonomy.parent_ref,
    taxonomy.id AS taxon,
    taxonomy.extinct,
    catalogue_levels.id AS level_id,
    catalogue_levels.level_type,
    catalogue_levels.level_name,
    catalogue_levels.level_sys_name,
    catalogue_levels.optional_level,
    catalogue_levels.level_order
   FROM ((( SELECT specimens_1.collection_ref,
            regexp_split_to_table(((((specimens_1.taxon_path)::text || '/'::text) || ((specimens_1.taxon_ref)::character varying)::text) || '/'::text), '/'::text) AS taxon_single_ref
           FROM darwin2.specimens specimens_1) specimens
     LEFT JOIN darwin2.taxonomy ON ((((specimens.taxon_single_ref)::character varying)::text = ((taxonomy.id)::character varying)::text)))
     LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)));


ALTER TABLE darwin2.v_taxonomical_statistics_callard OWNER TO darwin2;

--
-- TOC entry 498 (class 1259 OID 20362)
-- Name: v_taxonomy_split_author_fast; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_taxonomy_split_author_fast AS
SELECT
    NULL::integer AS id,
    NULL::character varying AS name,
    NULL::character varying AS name_indexed,
    NULL::integer AS level_ref,
    NULL::character varying AS status,
    NULL::boolean AS local_naming,
    NULL::character varying AS color,
    NULL::character varying AS path,
    NULL::integer AS parent_ref,
    NULL::boolean AS extinct,
    NULL::boolean AS sensitive_info_withheld,
    NULL::integer AS metadata_ref,
    NULL::timestamp without time zone AS taxonomy_creation_date,
    NULL::text AS name_no_author,
    NULL::text AS author;


ALTER TABLE darwin2.v_taxonomy_split_author_fast OWNER TO darwin2;

--
-- TOC entry 499 (class 1259 OID 20366)
-- Name: x_ray_drosera; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.x_ray_drosera (
    full_path character varying NOT NULL,
    file character varying,
    folder character varying,
    metadata_found character varying,
    object_desc character varying
);


ALTER TABLE darwin2.x_ray_drosera OWNER TO darwin2;

--
-- TOC entry 500 (class 1259 OID 20372)
-- Name: v_x_ray_drosera; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_x_ray_drosera AS
 WITH x_ray_drosera_num AS (
         SELECT x_ray_drosera.full_path,
            x_ray_drosera.file,
            x_ray_drosera.folder,
            x_ray_drosera.metadata_found,
            x_ray_drosera.object_desc,
            regexp_replace(regexp_replace(regexp_replace(regexp_replace(upper((x_ray_drosera.file)::text), '([^[:alnum:]]|^)(A)(\d+)'::text, '\1200\3'::text), '([^[:alnum:]]|^)(B)(\d+)'::text, '\1201\3'::text), '\(.*?\)'::text, '()'::text), 'TAG.+'::text, ''::text, 'g'::text) AS file_num,
            regexp_replace(regexp_replace(regexp_replace(regexp_replace(upper((x_ray_drosera.object_desc)::text), '([^[:alnum:]]|^)(A)(\d+)'::text, '\1200\3'::text), '([^[:alnum:]]|^)(B)(\d+)'::text, '\1201\3'::text), '\(.*?\)'::text, '()'::text, 'g'::text), 'TAG.+'::text, ''::text) AS object_desc_num
           FROM darwin2.x_ray_drosera
        ), to_match_tmp AS (
         SELECT x_ray_drosera_num.full_path,
            x_ray_drosera_num.file,
            x_ray_drosera_num.folder,
            x_ray_drosera_num.metadata_found,
            x_ray_drosera_num.object_desc,
            darwin2.fct_rmca_regexp_matches_one_line((x_ray_drosera_num.file_num)::character varying, '\d+|[a-c]d+'::character varying) AS file_num,
            darwin2.fct_rmca_regexp_matches_one_line((x_ray_drosera_num.object_desc_num)::character varying, '\d+'::character varying) AS object_num
           FROM x_ray_drosera_num
        ), to_match AS (
         SELECT to_match_tmp.full_path,
            to_match_tmp.file,
            to_match_tmp.folder,
            to_match_tmp.metadata_found,
            to_match_tmp.object_desc,
                CASE
                    WHEN ((array_length(to_match_tmp.file_num, 1) >= 3) AND (length((to_match_tmp.file_num[1])::text) = 2)) THEN ((('19'::text || (to_match_tmp.file_num[1])::text))::character varying || to_match_tmp.file_num[2:100])
                    ELSE to_match_tmp.file_num
                END AS file_num,
                CASE
                    WHEN ((array_length(to_match_tmp.object_num, 1) >= 3) AND (length((to_match_tmp.object_num[1])::text) = 2)) THEN ((('19'::text || (to_match_tmp.object_num[1])::text))::character varying || to_match_tmp.object_num[2:100])
                    ELSE to_match_tmp.object_num
                END AS object_num
           FROM to_match_tmp
        ), code_fish AS (
         SELECT codes.referenced_relation,
            codes.record_id,
            codes.id,
            codes.code_category,
            codes.code_prefix,
            codes.code_prefix_separator,
            codes.code,
            codes.code_suffix,
            codes.code_suffix_separator,
            codes.full_code_indexed,
            codes.code_date,
            codes.code_date_mask,
            codes.code_num,
            codes.code_num_bigint,
            specimens.taxon_name AS darwin_taxon_name
           FROM (darwin2.codes
             JOIN darwin2.specimens ON ((codes.record_id = specimens.id)))
          WHERE (((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text) AND (specimens.collection_ref = 6))
        ), code_fish_catch AS (
         SELECT code_fish.referenced_relation,
            code_fish.record_id,
            code_fish.id,
            code_fish.code_category,
            code_fish.code_prefix,
            code_fish.code_prefix_separator,
            code_fish.code,
            code_fish.code_suffix,
            code_fish.code_suffix_separator,
            code_fish.full_code_indexed,
            code_fish.code_date,
            code_fish.code_date_mask,
            code_fish.code_num,
            code_fish.code_num_bigint,
            code_fish.darwin_taxon_name,
            darwin2.fct_rmca_regexp_matches_one_line(code_fish.code, '\d+'::character varying) AS code_num_parts,
            array_length(darwin2.fct_rmca_regexp_matches_one_line(code_fish.code, '\d+'::character varying), 1) AS nb_code_num_parts
           FROM code_fish
        ), catch_from_code1 AS (
         SELECT to_match.full_path,
            to_match.file,
            to_match.folder,
            to_match.metadata_found,
            to_match.object_desc,
            to_match.file_num,
            to_match.object_num,
            code_fish_catch.referenced_relation,
            code_fish_catch.record_id,
            code_fish_catch.id,
            code_fish_catch.code_category,
            code_fish_catch.code_prefix,
            code_fish_catch.code_prefix_separator,
            code_fish_catch.code,
            code_fish_catch.code_suffix,
            code_fish_catch.code_suffix_separator,
            code_fish_catch.full_code_indexed,
            code_fish_catch.code_date,
            code_fish_catch.code_date_mask,
            code_fish_catch.code_num,
            code_fish_catch.code_num_bigint,
            code_fish_catch.darwin_taxon_name,
            code_fish_catch.code_num_parts,
            code_fish_catch.nb_code_num_parts
           FROM to_match,
            code_fish_catch
          WHERE (((code_fish_catch.code_num_parts[1])::integer = (to_match.file_num[1])::integer) AND darwin2.fct_rmca_compare_varchar_array_as_integer(code_fish_catch.code_num_parts, to_match.file_num) AND (array_length(code_fish_catch.code_num_parts, 1) = array_length(to_match.file_num, 1)))
        ), catch_from_code2 AS (
         SELECT to_match.full_path,
            to_match.file,
            to_match.folder,
            to_match.metadata_found,
            to_match.object_desc,
            to_match.file_num,
            to_match.object_num,
            code_fish_catch.referenced_relation,
            code_fish_catch.record_id,
            code_fish_catch.id,
            code_fish_catch.code_category,
            code_fish_catch.code_prefix,
            code_fish_catch.code_prefix_separator,
            code_fish_catch.code,
            code_fish_catch.code_suffix,
            code_fish_catch.code_suffix_separator,
            code_fish_catch.full_code_indexed,
            code_fish_catch.code_date,
            code_fish_catch.code_date_mask,
            code_fish_catch.code_num,
            code_fish_catch.code_num_bigint,
            code_fish_catch.darwin_taxon_name,
            code_fish_catch.code_num_parts,
            code_fish_catch.nb_code_num_parts
           FROM to_match,
            code_fish_catch
          WHERE (((code_fish_catch.code_num_parts[1])::integer = (to_match.object_num[1])::integer) AND darwin2.fct_rmca_compare_varchar_array_as_integer(code_fish_catch.code_num_parts, to_match.object_num) AND (array_length(code_fish_catch.code_num_parts, 1) = array_length(to_match.object_num, 1)))
        ), tmp_match AS (
         SELECT catch_from_code1.full_path,
            catch_from_code1.file,
            catch_from_code1.folder,
            catch_from_code1.metadata_found,
            catch_from_code1.object_desc,
            catch_from_code1.file_num,
            catch_from_code1.object_num,
            catch_from_code1.referenced_relation,
            catch_from_code1.record_id,
            catch_from_code1.id,
            catch_from_code1.code_category,
            catch_from_code1.code_prefix,
            catch_from_code1.code_prefix_separator,
            catch_from_code1.code,
            catch_from_code1.code_suffix,
            catch_from_code1.code_suffix_separator,
            catch_from_code1.full_code_indexed,
            catch_from_code1.code_date,
            catch_from_code1.code_date_mask,
            catch_from_code1.code_num,
            catch_from_code1.code_num_bigint,
            catch_from_code1.darwin_taxon_name,
            catch_from_code1.code_num_parts,
            catch_from_code1.nb_code_num_parts
           FROM catch_from_code1
        UNION
         SELECT catch_from_code2.full_path,
            catch_from_code2.file,
            catch_from_code2.folder,
            catch_from_code2.metadata_found,
            catch_from_code2.object_desc,
            catch_from_code2.file_num,
            catch_from_code2.object_num,
            catch_from_code2.referenced_relation,
            catch_from_code2.record_id,
            catch_from_code2.id,
            catch_from_code2.code_category,
            catch_from_code2.code_prefix,
            catch_from_code2.code_prefix_separator,
            catch_from_code2.code,
            catch_from_code2.code_suffix,
            catch_from_code2.code_suffix_separator,
            catch_from_code2.full_code_indexed,
            catch_from_code2.code_date,
            catch_from_code2.code_date_mask,
            catch_from_code2.code_num,
            catch_from_code2.code_num_bigint,
            catch_from_code2.darwin_taxon_name,
            catch_from_code2.code_num_parts,
            catch_from_code2.nb_code_num_parts
           FROM catch_from_code2
        ), unmatched AS (
         SELECT to_match.full_path,
            to_match.file,
            to_match.folder,
            to_match.metadata_found,
            to_match.object_desc,
            to_match.file_num,
            to_match.object_num
           FROM (to_match
             LEFT JOIN tmp_match ON (((to_match.full_path)::text = (tmp_match.full_path)::text)))
          WHERE (tmp_match.full_path IS NULL)
        )
 SELECT 'MATCHED'::text AS matched,
    tmp_match.full_path,
    tmp_match.file,
    tmp_match.folder,
    tmp_match.metadata_found,
    tmp_match.object_desc,
    tmp_match.file_num,
    tmp_match.object_num,
    tmp_match.referenced_relation,
    tmp_match.record_id,
    tmp_match.id,
    tmp_match.code_category,
    tmp_match.code_prefix,
    tmp_match.code_prefix_separator,
    tmp_match.code,
    tmp_match.code_suffix,
    tmp_match.code_suffix_separator,
    tmp_match.full_code_indexed,
    tmp_match.code_date,
    tmp_match.code_date_mask,
    tmp_match.code_num,
    tmp_match.code_num_bigint,
    tmp_match.darwin_taxon_name,
    tmp_match.code_num_parts,
    tmp_match.nb_code_num_parts
   FROM tmp_match
UNION
 SELECT 'UNMATCHED'::text AS matched,
    unmatched.full_path,
    unmatched.file,
    unmatched.folder,
    unmatched.metadata_found,
    unmatched.object_desc,
    unmatched.file_num,
    unmatched.object_num,
    NULL::character varying AS referenced_relation,
    NULL::integer AS record_id,
    NULL::integer AS id,
    NULL::character varying AS code_category,
    NULL::character varying AS code_prefix,
    NULL::character varying AS code_prefix_separator,
    NULL::character varying AS code,
    NULL::character varying AS code_suffix,
    NULL::character varying AS code_suffix_separator,
    NULL::character varying AS full_code_indexed,
    NULL::timestamp without time zone AS code_date,
    NULL::integer AS code_date_mask,
    NULL::integer AS code_num,
    NULL::bigint AS code_num_bigint,
    NULL::character varying AS darwin_taxon_name,
    NULL::character varying[] AS code_num_parts,
    NULL::integer AS nb_code_num_parts
   FROM unmatched;


ALTER TABLE darwin2.v_x_ray_drosera OWNER TO darwin2;

--
-- TOC entry 525 (class 1259 OID 1468840)
-- Name: v_xylarium_2022_image_link; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_xylarium_2022_image_link AS
 WITH a AS (
         SELECT tmp_xylarium_img_links_2022.unitid,
            string_to_array((tmp_xylarium_img_links_2022.links)::text, ','::text) AS ar_links,
            string_to_array((tmp_xylarium_img_links_2022.legend)::text, ','::text) AS ar_legend,
            string_to_array((tmp_xylarium_img_links_2022.tw_images)::text, ','::text) AS ar_tw_images,
            array_length(string_to_array((tmp_xylarium_img_links_2022.links)::text, ','::text), 1) AS l_ar_links,
            array_length(string_to_array((tmp_xylarium_img_links_2022.legend)::text, ','::text), 1) AS l_legend,
            array_length(string_to_array((tmp_xylarium_img_links_2022.tw_images)::text, ','::text), 1) AS l_tw_images
           FROM darwin2.tmp_xylarium_img_links_2022
        )
 SELECT b.unitid,
    b.links,
    b.legend,
    b.file
   FROM ( SELECT a.unitid,
            unnest(a.ar_links) AS links,
            unnest(a.ar_legend) AS legend,
            unnest(a.ar_tw_images) AS file
           FROM a
          WHERE (a.l_ar_links = a.l_tw_images)) b;


ALTER TABLE darwin2.v_xylarium_2022_image_link OWNER TO darwin2;

--
-- TOC entry 501 (class 1259 OID 20377)
-- Name: vernacular_names_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.vernacular_names_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.vernacular_names_id_seq OWNER TO darwin2;

--
-- TOC entry 7461 (class 0 OID 0)
-- Dependencies: 501
-- Name: vernacular_names_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.vernacular_names_id_seq OWNED BY darwin2.vernacular_names.id;


--
-- TOC entry 502 (class 1259 OID 20379)
-- Name: vmap0_world_boundaries_gid_seq; Type: SEQUENCE; Schema: darwin2; Owner: postgres
--

CREATE SEQUENCE darwin2.vmap0_world_boundaries_gid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.vmap0_world_boundaries_gid_seq OWNER TO postgres;

--
-- TOC entry 7462 (class 0 OID 0)
-- Dependencies: 502
-- Name: vmap0_world_boundaries_gid_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: postgres
--

ALTER SEQUENCE darwin2.vmap0_world_boundaries_gid_seq OWNED BY darwin2.vmap0_world_boundaries.gid;


--
-- TOC entry 541 (class 1259 OID 1871202)
-- Name: anoek_data; Type: TABLE; Schema: drosera_import; Owner: postgres
--

CREATE TABLE drosera_import.anoek_data (
    sample character varying,
    rg character varying,
    family character varying,
    taxa character varying,
    common_name character varying,
    comm_en character varying,
    comm_fr character varying,
    provenance character varying,
    date character varying,
    collector character varying,
    region character varying,
    ecology character varying
);


ALTER TABLE drosera_import.anoek_data OWNER TO postgres;

--
-- TOC entry 540 (class 1259 OID 1870252)
-- Name: anoek_taxo; Type: TABLE; Schema: drosera_import; Owner: postgres
--

CREATE TABLE drosera_import.anoek_taxo (
    name character varying
);


ALTER TABLE drosera_import.anoek_taxo OWNER TO postgres;

--
-- TOC entry 503 (class 1259 OID 20381)
-- Name: loans_content; Type: TABLE; Schema: drosera_import; Owner: darwin2
--

CREATE TABLE drosera_import.loans_content (
    pbram character varying,
    loan_code character varying,
    spec_code character varying,
    spec_code2 character varying,
    storage character varying,
    quantity character varying,
    part_code character varying,
    insurrance character varying,
    insurrance_value character varying,
    pick_up_species_name character varying,
    return_date character varying,
    out_flag_drosera character varying,
    spec_storage_1 character varying,
    spect_storage character varying,
    pbram2 character varying,
    code1 character varying,
    code2 character varying
);


ALTER TABLE drosera_import.loans_content OWNER TO darwin2;

--
-- TOC entry 504 (class 1259 OID 20387)
-- Name: loans_main; Type: TABLE; Schema: drosera_import; Owner: darwin2
--

CREATE TABLE drosera_import.loans_main (
    collection character varying,
    nr_loan character varying,
    date character varying,
    expiration character varying,
    contact1 character varying,
    contact_adresse character varying,
    "out" character varying,
    shipment_or_destroyed character varying,
    code2 character varying,
    curator character varying,
    return_date character varying,
    code_2 character varying,
    code_3 character varying,
    counter_1 character varying,
    counter_2 character varying,
    counter_3 character varying,
    counter_4 character varying,
    counter_5 character varying,
    code_4 character varying
);


ALTER TABLE drosera_import.loans_main OWNER TO darwin2;

--
-- TOC entry 505 (class 1259 OID 20393)
-- Name: mv_loans_content_matched; Type: TABLE; Schema: drosera_import; Owner: darwin2
--

CREATE TABLE drosera_import.mv_loans_content_matched (
    pbram character varying,
    loan_code character varying,
    spec_code character varying,
    spec_code2 character varying,
    storage character varying,
    quantity character varying,
    part_code character varying,
    insurrance character varying,
    insurrance_value character varying,
    pick_up_species_name character varying,
    return_date character varying,
    out_flag_drosera character varying,
    spec_storage_1 character varying,
    spect_storage character varying,
    pbram2 character varying,
    code1 character varying,
    code2 character varying,
    record_id integer
);


ALTER TABLE drosera_import.mv_loans_content_matched OWNER TO darwin2;

--
-- TOC entry 506 (class 1259 OID 20399)
-- Name: stations_danny; Type: TABLE; Schema: drosera_import; Owner: darwin2
--

CREATE TABLE drosera_import.stations_danny (
    datasetname text,
    stationlist text,
    stationnumber text,
    exactsite text,
    countrygiven text,
    elevationgivenbycollector text,
    coordinatesgivenbycollector text,
    elevationinmeters text,
    coordinatestext text,
    coordinatesstatus text,
    coordinatesbycollector text,
    latitudedecimaldegrees text,
    longitudedecimaldegrees text,
    extent_m text,
    continent text,
    country text,
    state_province text,
    region_district text,
    municipality text
);


ALTER TABLE drosera_import.stations_danny OWNER TO darwin2;

--
-- TOC entry 507 (class 1259 OID 20405)
-- Name: v_loan_content_new_number; Type: VIEW; Schema: drosera_import; Owner: darwin2
--

CREATE VIEW drosera_import.v_loan_content_new_number AS
 WITH a AS (
         SELECT regexp_replace(replace(tmp.new_code, '.'::text, '.P.'::text), '(^\d{4})(.+)'::text, '\1.\2'::text) AS padded_number,
            tmp.new_code,
            tmp.pbram,
            tmp.loan_code,
            tmp.spec_code,
            tmp.spec_code2,
            tmp.storage,
            tmp.quantity,
            tmp.part_code,
            tmp.insurrance,
            tmp.insurrance_value,
            tmp.pick_up_species_name,
            tmp.return_date,
            tmp.out_flag_drosera,
            tmp.spec_storage_1,
            tmp.spect_storage,
            tmp.pbram2,
            tmp.code1,
            tmp.code2
           FROM ( SELECT replace(replace((loans_content.spec_code)::text, 'A'::text, '200'::text), 'B'::text, '201'::text) AS new_code,
                    loans_content.pbram,
                    loans_content.loan_code,
                    loans_content.spec_code,
                    loans_content.spec_code2,
                    loans_content.storage,
                    loans_content.quantity,
                    loans_content.part_code,
                    loans_content.insurrance,
                    loans_content.insurrance_value,
                    loans_content.pick_up_species_name,
                    loans_content.return_date,
                    loans_content.out_flag_drosera,
                    loans_content.spec_storage_1,
                    loans_content.spect_storage,
                    loans_content.pbram2,
                    loans_content.code1,
                    loans_content.code2
                   FROM drosera_import.loans_content
                  WHERE (((loans_content.pbram)::text = 'P'::text) AND ((loans_content.spec_code)::text ~ '[A|B|0-9]\d{4}\.\d+'::text) AND (((loans_content.spec_code)::text ~~ 'A%'::text) OR ((loans_content.spec_code)::text ~~ 'B%'::text)))
                UNION
                 SELECT ('19'::text || (loans_content.spec_code)::text) AS new_code,
                    loans_content.pbram,
                    loans_content.loan_code,
                    loans_content.spec_code,
                    loans_content.spec_code2,
                    loans_content.storage,
                    loans_content.quantity,
                    loans_content.part_code,
                    loans_content.insurrance,
                    loans_content.insurrance_value,
                    loans_content.pick_up_species_name,
                    loans_content.return_date,
                    loans_content.out_flag_drosera,
                    loans_content.spec_storage_1,
                    loans_content.spect_storage,
                    loans_content.pbram2,
                    loans_content.code1,
                    loans_content.code2
                   FROM drosera_import.loans_content
                  WHERE (((loans_content.pbram)::text = 'P'::text) AND ((loans_content.spec_code)::text ~ '[A|B|0-9]\d{4}\.\d+'::text) AND ((loans_content.spec_code)::text !~~ 'A%'::text) AND ((loans_content.spec_code)::text !~~ 'B%'::text))) tmp
        )
 SELECT (regexp_matches(a.padded_number, '(.+P\.)(.+)'::text))[1] AS prefix,
    (regexp_matches(a.padded_number, '(.+P\.)(.+)'::text))[2] AS suffix,
    a.padded_number,
    a.new_code,
    a.pbram,
    a.loan_code,
    a.spec_code,
    a.spec_code2,
    a.storage,
    a.quantity,
    a.part_code,
    a.insurrance,
    a.insurrance_value,
    a.pick_up_species_name,
    a.return_date,
    a.out_flag_drosera,
    a.spec_storage_1,
    a.spect_storage,
    a.pbram2,
    a.code1,
    a.code2
   FROM a;


ALTER TABLE drosera_import.v_loan_content_new_number OWNER TO darwin2;

--
-- TOC entry 508 (class 1259 OID 20410)
-- Name: v_loan_to_darwin_people; Type: VIEW; Schema: drosera_import; Owner: darwin2
--

CREATE VIEW drosera_import.v_loan_to_darwin_people AS
 WITH a AS (
         SELECT DISTINCT btrim((regexp_matches(btrim(replace(replace(lower((loans_main.contact1)::text), 'dr.'::text, ''::text), 'prof'::text, ''::text)), '(.+?)((c/o)|$)'::text))[1]) AS btrim,
            loans_main.contact1
           FROM drosera_import.loans_main
          WHERE ((loans_main.collection)::text = 'P'::text)
        ), b AS (
         SELECT people.is_physical,
            people.sub_type,
            people.formated_name,
            people.formated_name_indexed,
            people.formated_name_unique,
            people.title,
            people.family_name,
            people.given_name,
            people.additional_names,
            people.birth_date_mask,
            people.birth_date,
            people.gender,
            people.id,
            people.end_date_mask,
            people.end_date,
            people.activity_date_from_mask,
            people.activity_date_from,
            people.activity_date_to_mask,
            people.activity_date_to,
            people.name_formated_indexed,
            people.import_ref
           FROM darwin2.people
        ), c AS (
         SELECT a.btrim,
            a.contact1,
            b.is_physical,
            b.sub_type,
            b.formated_name,
            b.formated_name_indexed,
            b.formated_name_unique,
            b.title,
            b.family_name,
            b.given_name,
            b.additional_names,
            b.birth_date_mask,
            b.birth_date,
            b.gender,
            b.id,
            b.end_date_mask,
            b.end_date,
            b.activity_date_from_mask,
            b.activity_date_from,
            b.activity_date_to_mask,
            b.activity_date_to,
            b.name_formated_indexed,
            b.import_ref
           FROM (a
             LEFT JOIN b ON (((darwin2.fulltoindex(a.contact1))::text = (darwin2.fulltoindex((lower((b.formated_name)::text))::character varying))::text)))
          WHERE (b.id IS NOT NULL)
        )
 SELECT c.contact1,
    (array_agg(c.id))[1] AS array_agg
   FROM c
  GROUP BY c.contact1;


ALTER TABLE drosera_import.v_loan_to_darwin_people OWNER TO darwin2;

--
-- TOC entry 509 (class 1259 OID 20415)
-- Name: v_matched_new_numbers; Type: VIEW; Schema: drosera_import; Owner: darwin2
--

CREATE VIEW drosera_import.v_matched_new_numbers AS
 SELECT a.prefix,
    b.range,
    b.split,
    b.referenced_relation,
    b.record_id,
    b.id,
    b.code_category,
    b.code_prefix,
    b.code_prefix_separator,
    b.code,
    b.code_suffix,
    b.code_suffix_separator,
    b.full_code_indexed,
    b.code_date,
    b.code_date_mask,
    b.code_num,
    b.code_num_bigint,
    b.prefix AS prefix_loan,
    a.suffix,
    a.padded_number,
    a.new_code,
    a.pbram,
    a.loan_code,
    a.spec_code,
    a.spec_code2,
    a.storage,
    a.quantity,
    a.part_code,
    a.insurrance,
    a.insurrance_value,
    a.pick_up_species_name,
    a.return_date,
    a.out_flag_drosera,
    a.spec_storage_1,
    a.spect_storage,
    a.pbram2,
    a.code1,
    a.code2
   FROM (drosera_import.v_loan_content_new_number a
     LEFT JOIN darwin2.v_ichtyology_series_fast b ON (((a.prefix = b.prefix) AND ((a.suffix)::integer = ANY (b.range)))));


ALTER TABLE drosera_import.v_matched_new_numbers OWNER TO darwin2;

--
-- TOC entry 510 (class 1259 OID 20420)
-- Name: v_matched_old_numbers; Type: VIEW; Schema: drosera_import; Owner: darwin2
--

CREATE VIEW drosera_import.v_matched_old_numbers AS
 WITH a AS (
         SELECT (replace((loans_content.spec_code)::text, '-'::text, ''::text))::integer AS int_code,
            loans_content.pbram,
            loans_content.loan_code,
            loans_content.spec_code,
            loans_content.spec_code2,
            loans_content.storage,
            loans_content.quantity,
            loans_content.part_code,
            loans_content.insurrance,
            loans_content.insurrance_value,
            loans_content.pick_up_species_name,
            loans_content.return_date,
            loans_content.out_flag_drosera,
            loans_content.spec_storage_1,
            loans_content.spect_storage,
            loans_content.pbram2,
            loans_content.code1,
            loans_content.code2
           FROM drosera_import.loans_content
          WHERE (((loans_content.pbram)::text = 'P'::text) AND ((loans_content.spec_code)::text ~~ '-%'::text))
        )
 SELECT a.int_code,
    a.pbram,
    a.loan_code,
    a.spec_code,
    a.spec_code2,
    a.storage,
    a.quantity,
    a.part_code,
    a.insurrance,
    a.insurrance_value,
    a.pick_up_species_name,
    a.return_date,
    a.out_flag_drosera,
    a.spec_storage_1,
    a.spect_storage,
    a.pbram2,
    a.code1,
    a.code2,
    v_ichtyology_series_fast.prefix,
    v_ichtyology_series_fast.range,
    v_ichtyology_series_fast.split,
    v_ichtyology_series_fast.referenced_relation,
    v_ichtyology_series_fast.record_id,
    v_ichtyology_series_fast.id,
    v_ichtyology_series_fast.code_category,
    v_ichtyology_series_fast.code_prefix,
    v_ichtyology_series_fast.code_prefix_separator,
    v_ichtyology_series_fast.code,
    v_ichtyology_series_fast.code_suffix,
    v_ichtyology_series_fast.code_suffix_separator,
    v_ichtyology_series_fast.full_code_indexed,
    v_ichtyology_series_fast.code_date,
    v_ichtyology_series_fast.code_date_mask,
    v_ichtyology_series_fast.code_num,
    v_ichtyology_series_fast.code_num_bigint
   FROM (a
     LEFT JOIN darwin2.v_ichtyology_series_fast ON ((a.int_code = ANY (v_ichtyology_series_fast.range))))
  WHERE ((v_ichtyology_series_fast.code)::text ~~ 'P%'::text);


ALTER TABLE drosera_import.v_matched_old_numbers OWNER TO darwin2;

--
-- TOC entry 511 (class 1259 OID 20425)
-- Name: v_matched_all_numbers; Type: VIEW; Schema: drosera_import; Owner: darwin2
--

CREATE VIEW drosera_import.v_matched_all_numbers AS
 SELECT DISTINCT a.pbram,
    a.loan_code,
    a.spec_code,
    a.spec_code2,
    a.record_id
   FROM ( SELECT v_matched_old_numbers.pbram,
            v_matched_old_numbers.loan_code,
            v_matched_old_numbers.spec_code,
            v_matched_old_numbers.spec_code2,
            v_matched_old_numbers.record_id
           FROM drosera_import.v_matched_old_numbers
        UNION
         SELECT v_matched_new_numbers.pbram,
            v_matched_new_numbers.loan_code,
            v_matched_new_numbers.spec_code,
            v_matched_new_numbers.spec_code2,
            v_matched_new_numbers.record_id
           FROM drosera_import.v_matched_new_numbers) a;


ALTER TABLE drosera_import.v_matched_all_numbers OWNER TO darwin2;

--
-- TOC entry 512 (class 1259 OID 20430)
-- Name: v_loans_content_matched; Type: VIEW; Schema: drosera_import; Owner: darwin2
--

CREATE VIEW drosera_import.v_loans_content_matched AS
 SELECT a.pbram,
    a.loan_code,
    a.spec_code,
    a.spec_code2,
    a.storage,
    a.quantity,
    a.part_code,
    a.insurrance,
    a.insurrance_value,
    a.pick_up_species_name,
    a.return_date,
    a.out_flag_drosera,
    a.spec_storage_1,
    a.spect_storage,
    a.pbram2,
    a.code1,
    a.code2,
    b.record_id
   FROM (drosera_import.loans_content a
     LEFT JOIN drosera_import.v_matched_all_numbers b ON ((((a.pbram)::text = (b.pbram)::text) AND ((a.loan_code)::text = (b.loan_code)::text) AND ((COALESCE(a.spec_code, ''::character varying))::text = (COALESCE(b.spec_code, ''::character varying))::text) AND ((COALESCE(a.spec_code2, ''::character varying))::text = (COALESCE(b.spec_code2, ''::character varying))::text))));


ALTER TABLE drosera_import.v_loans_content_matched OWNER TO darwin2;

--
-- TOC entry 513 (class 1259 OID 20435)
-- Name: mukweze_files; Type: TABLE; Schema: eod; Owner: darwin2
--

CREATE TABLE eod.mukweze_files (
    pk integer NOT NULL,
    file character varying,
    format character varying,
    mime character varying
);


ALTER TABLE eod.mukweze_files OWNER TO darwin2;

--
-- TOC entry 514 (class 1259 OID 20441)
-- Name: mukweze_files_pk_seq; Type: SEQUENCE; Schema: eod; Owner: darwin2
--

CREATE SEQUENCE eod.mukweze_files_pk_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE eod.mukweze_files_pk_seq OWNER TO darwin2;

--
-- TOC entry 7464 (class 0 OID 0)
-- Dependencies: 514
-- Name: mukweze_files_pk_seq; Type: SEQUENCE OWNED BY; Schema: eod; Owner: darwin2
--

ALTER SEQUENCE eod.mukweze_files_pk_seq OWNED BY eod.mukweze_files.pk;


--
-- TOC entry 515 (class 1259 OID 20443)
-- Name: mukweze_multimedia; Type: TABLE; Schema: eod; Owner: darwin2
--

CREATE TABLE eod.mukweze_multimedia (
    tagno character varying,
    fieldno character varying,
    cumlno character varying,
    datecollected character varying,
    daterecorded character varying,
    museumno character varying,
    weblink character varying,
    hyperlink character varying,
    fieldid character varying,
    speciesid character varying,
    typestatus character varying,
    sex character varying,
    standard_length character varying,
    specimentemperature character varying,
    eod character varying,
    spi character varying,
    dna_samples character varying,
    photo character varying,
    specimencomment character varying,
    family character varying,
    author character varying,
    hardware_used character varying,
    software character varying,
    recordist character varying,
    eodcomment character varying,
    specimenlocality character varying,
    bit_depth character varying,
    localityname character varying,
    localitydate character varying,
    latitude character varying,
    longitude character varying,
    elevation character varying,
    localityconductivity character varying,
    localitytemperature character varying,
    localityph character varying,
    localityoxygen character varying,
    country character varying,
    province character varying,
    basin character varying,
    river character varying,
    localitycomment character varying,
    gear character varying,
    timein character varying,
    timeout character varying,
    collectors character varying,
    metadatafilename character varying,
    catch_invetory character varying
);


ALTER TABLE eod.mukweze_multimedia OWNER TO darwin2;

--
-- TOC entry 516 (class 1259 OID 20449)
-- Name: mukweze_specimens; Type: TABLE; Schema: eod; Owner: darwin2
--

CREATE TABLE eod.mukweze_specimens (
    code character varying,
    individual_code character varying,
    scientific_name character varying,
    author character varying,
    valid_identification character varying,
    valid_author character varying,
    family character varying,
    type character varying,
    count_min character varying,
    count_max character varying,
    determinators character varying,
    identification_year character varying,
    country character varying,
    exact_site character varying,
    ecology character varying,
    locality_full character varying,
    coordinates_source character varying,
    latitude_deci character varying,
    longitude_deci character varying,
    latitude_dms character varying,
    longitude_dms character varying,
    elevation character varying,
    collecting_year_from character varying,
    collecting_month_from character varying,
    collecting_day_from character varying,
    properties_locality character varying,
    collectors character varying,
    expedition character varying,
    amount_males character varying,
    amount_females character varying,
    amount_juveniles character varying,
    valid_label character varying,
    comments character varying,
    properties character varying,
    eod character varying
);


ALTER TABLE eod.mukweze_specimens OWNER TO darwin2;

--
-- TOC entry 5485 (class 2604 OID 20455)
-- Name: bibliography id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.bibliography ALTER COLUMN id SET DEFAULT nextval('darwin2.bibliography_id_seq'::regclass);


--
-- TOC entry 5486 (class 2604 OID 20456)
-- Name: catalogue_bibliography id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_bibliography ALTER COLUMN id SET DEFAULT nextval('darwin2.catalogue_bibliography_id_seq'::regclass);


--
-- TOC entry 5483 (class 2604 OID 20457)
-- Name: catalogue_levels id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_levels ALTER COLUMN id SET DEFAULT nextval('darwin2.catalogue_levels_id_seq'::regclass);


--
-- TOC entry 5490 (class 2604 OID 20458)
-- Name: catalogue_people id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_people ALTER COLUMN id SET DEFAULT nextval('darwin2.catalogue_people_id_seq'::regclass);


--
-- TOC entry 5492 (class 2604 OID 20459)
-- Name: catalogue_relationships id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_relationships ALTER COLUMN id SET DEFAULT nextval('darwin2.catalogue_relationships_id_seq'::regclass);


--
-- TOC entry 5494 (class 2604 OID 20460)
-- Name: chronostratigraphy status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 5495 (class 2604 OID 20461)
-- Name: chronostratigraphy local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 5496 (class 2604 OID 20462)
-- Name: chronostratigraphy path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 5497 (class 2604 OID 20463)
-- Name: chronostratigraphy id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy ALTER COLUMN id SET DEFAULT nextval('darwin2.chronostratigraphy_id_seq'::regclass);


--
-- TOC entry 5500 (class 2604 OID 20464)
-- Name: classification_keywords id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.classification_keywords ALTER COLUMN id SET DEFAULT nextval('darwin2.classification_keywords_id_seq'::regclass);


--
-- TOC entry 5503 (class 2604 OID 20465)
-- Name: classification_synonymies id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.classification_synonymies ALTER COLUMN id SET DEFAULT nextval('darwin2.classification_synonymies_id_seq'::regclass);


--
-- TOC entry 5506 (class 2604 OID 20466)
-- Name: classification_synonymies_history id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.classification_synonymies_history ALTER COLUMN id SET DEFAULT nextval('darwin2.classification_synonymies_history_id_seq'::regclass);


--
-- TOC entry 5511 (class 2604 OID 20467)
-- Name: codes id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.codes ALTER COLUMN id SET DEFAULT nextval('darwin2.codes_id_seq'::regclass);


--
-- TOC entry 5512 (class 2604 OID 20468)
-- Name: collecting_methods id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_methods ALTER COLUMN id SET DEFAULT nextval('darwin2.collecting_methods_id_seq'::regclass);


--
-- TOC entry 5514 (class 2604 OID 20469)
-- Name: collecting_tools id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_tools ALTER COLUMN id SET DEFAULT nextval('darwin2.collecting_tools_id_seq'::regclass);


--
-- TOC entry 5519 (class 2604 OID 20470)
-- Name: collection_maintenance id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collection_maintenance ALTER COLUMN id SET DEFAULT nextval('darwin2.collection_maintenance_id_seq'::regclass);


--
-- TOC entry 5530 (class 2604 OID 20471)
-- Name: collections id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections ALTER COLUMN id SET DEFAULT nextval('darwin2.collections_id_seq'::regclass);


--
-- TOC entry 5536 (class 2604 OID 20472)
-- Name: collections_rights id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections_rights ALTER COLUMN id SET DEFAULT nextval('darwin2.collections_rights_id_seq'::regclass);


--
-- TOC entry 5537 (class 2604 OID 20473)
-- Name: comments id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.comments ALTER COLUMN id SET DEFAULT nextval('darwin2.comments_id_seq'::regclass);


--
-- TOC entry 5543 (class 2604 OID 20474)
-- Name: expeditions id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.expeditions ALTER COLUMN id SET DEFAULT nextval('darwin2.expeditions_id_seq'::regclass);


--
-- TOC entry 5544 (class 2604 OID 20475)
-- Name: ext_links id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.ext_links ALTER COLUMN id SET DEFAULT nextval('darwin2.ext_links_id_seq'::regclass);


--
-- TOC entry 5546 (class 2604 OID 20476)
-- Name: flat_dict id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.flat_dict ALTER COLUMN id SET DEFAULT nextval('darwin2.flat_dict_id_seq'::regclass);


--
-- TOC entry 5554 (class 2604 OID 20477)
-- Name: gtu id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.gtu ALTER COLUMN id SET DEFAULT nextval('darwin2.gtu_id_seq'::regclass);


--
-- TOC entry 5564 (class 2604 OID 20478)
-- Name: identifications id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.identifications ALTER COLUMN id SET DEFAULT nextval('darwin2.identifications_id_seq'::regclass);


--
-- TOC entry 5566 (class 2604 OID 20479)
-- Name: identifiers id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.identifiers ALTER COLUMN id SET DEFAULT nextval('darwin2.identifiers_id_seq'::regclass);


--
-- TOC entry 5569 (class 2604 OID 20480)
-- Name: igs id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.igs ALTER COLUMN id SET DEFAULT nextval('darwin2.igs_id_seq'::regclass);


--
-- TOC entry 5575 (class 2604 OID 20481)
-- Name: imports id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.imports ALTER COLUMN id SET DEFAULT nextval('darwin2.imports_id_seq'::regclass);


--
-- TOC entry 5580 (class 2604 OID 20482)
-- Name: informative_workflow id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.informative_workflow ALTER COLUMN id SET DEFAULT nextval('darwin2.informative_workflow_id_seq'::regclass);


--
-- TOC entry 5586 (class 2604 OID 20483)
-- Name: insurances id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.insurances ALTER COLUMN id SET DEFAULT nextval('darwin2.insurances_id_seq'::regclass);


--
-- TOC entry 5588 (class 2604 OID 20484)
-- Name: lithology status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 5589 (class 2604 OID 20485)
-- Name: lithology local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 5590 (class 2604 OID 20486)
-- Name: lithology path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 5591 (class 2604 OID 20487)
-- Name: lithology id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology ALTER COLUMN id SET DEFAULT nextval('darwin2.lithology_id_seq'::regclass);


--
-- TOC entry 5593 (class 2604 OID 20488)
-- Name: lithostratigraphy status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 5594 (class 2604 OID 20489)
-- Name: lithostratigraphy local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 5595 (class 2604 OID 20490)
-- Name: lithostratigraphy path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 5596 (class 2604 OID 20491)
-- Name: lithostratigraphy id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy ALTER COLUMN id SET DEFAULT nextval('darwin2.lithostratigraphy_id_seq'::regclass);


--
-- TOC entry 5599 (class 2604 OID 20492)
-- Name: loan_history id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_history ALTER COLUMN id SET DEFAULT nextval('darwin2.loan_history_id_seq'::regclass);


--
-- TOC entry 5601 (class 2604 OID 20493)
-- Name: loan_items id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items ALTER COLUMN id SET DEFAULT nextval('darwin2.loan_items_id_seq'::regclass);


--
-- TOC entry 5603 (class 2604 OID 20494)
-- Name: loan_rights id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_rights ALTER COLUMN id SET DEFAULT nextval('darwin2.loan_rights_id_seq'::regclass);


--
-- TOC entry 5608 (class 2604 OID 20495)
-- Name: loan_status id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_status ALTER COLUMN id SET DEFAULT nextval('darwin2.loan_status_id_seq'::regclass);


--
-- TOC entry 5611 (class 2604 OID 20496)
-- Name: loans id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loans ALTER COLUMN id SET DEFAULT nextval('darwin2.loans_id_seq'::regclass);


--
-- TOC entry 5613 (class 2604 OID 20497)
-- Name: mineralogy status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 5614 (class 2604 OID 20498)
-- Name: mineralogy local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 5615 (class 2604 OID 20499)
-- Name: mineralogy path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 5616 (class 2604 OID 20500)
-- Name: mineralogy id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy ALTER COLUMN id SET DEFAULT nextval('darwin2.mineralogy_id_seq'::regclass);


--
-- TOC entry 5625 (class 2604 OID 20501)
-- Name: multimedia id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.multimedia ALTER COLUMN id SET DEFAULT nextval('darwin2.multimedia_id_seq'::regclass);


--
-- TOC entry 5626 (class 2604 OID 20502)
-- Name: multimedia_todelete id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.multimedia_todelete ALTER COLUMN id SET DEFAULT nextval('darwin2.multimedia_todelete_id_seq'::regclass);


--
-- TOC entry 5632 (class 2604 OID 20503)
-- Name: my_saved_searches id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_saved_searches ALTER COLUMN id SET DEFAULT nextval('darwin2.my_saved_searches_id_seq'::regclass);


--
-- TOC entry 5643 (class 2604 OID 20504)
-- Name: my_widgets id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_widgets ALTER COLUMN id SET DEFAULT nextval('darwin2.my_widgets_id_seq'::regclass);


--
-- TOC entry 5656 (class 2604 OID 20505)
-- Name: people is_physical; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people ALTER COLUMN is_physical SET DEFAULT true;


--
-- TOC entry 5657 (class 2604 OID 20506)
-- Name: people title; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people ALTER COLUMN title SET DEFAULT ''::character varying;


--
-- TOC entry 5658 (class 2604 OID 20507)
-- Name: people birth_date_mask; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people ALTER COLUMN birth_date_mask SET DEFAULT 0;


--
-- TOC entry 5659 (class 2604 OID 20508)
-- Name: people birth_date; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people ALTER COLUMN birth_date SET DEFAULT '0001-01-01'::date;


--
-- TOC entry 5660 (class 2604 OID 20509)
-- Name: people id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people ALTER COLUMN id SET DEFAULT nextval('darwin2.people_id_seq'::regclass);


--
-- TOC entry 5663 (class 2604 OID 20510)
-- Name: people_addresses id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_addresses ALTER COLUMN id SET DEFAULT nextval('darwin2.people_addresses_id_seq'::regclass);


--
-- TOC entry 5664 (class 2604 OID 20511)
-- Name: people_align_debug id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_align_debug ALTER COLUMN id SET DEFAULT nextval('darwin2.people_align_debug_id_seq'::regclass);


--
-- TOC entry 5667 (class 2604 OID 20512)
-- Name: people_comm id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_comm ALTER COLUMN id SET DEFAULT nextval('darwin2.people_comm_id_seq'::regclass);


--
-- TOC entry 5671 (class 2604 OID 20513)
-- Name: people_languages id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_languages ALTER COLUMN id SET DEFAULT nextval('darwin2.people_languages_id_seq'::regclass);


--
-- TOC entry 5677 (class 2604 OID 20514)
-- Name: people_relationships id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_relationships ALTER COLUMN id SET DEFAULT nextval('darwin2.people_relationships_id_seq'::regclass);


--
-- TOC entry 5678 (class 2604 OID 20515)
-- Name: preferences id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.preferences ALTER COLUMN id SET DEFAULT nextval('darwin2.preferences_id_seq'::regclass);


--
-- TOC entry 5687 (class 2604 OID 20516)
-- Name: properties id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.properties ALTER COLUMN id SET DEFAULT nextval('darwin2.properties_id_seq'::regclass);


--
-- TOC entry 5688 (class 2604 OID 20517)
-- Name: specimen_collecting_methods id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_methods ALTER COLUMN id SET DEFAULT nextval('darwin2.specimen_collecting_methods_id_seq'::regclass);


--
-- TOC entry 5689 (class 2604 OID 20518)
-- Name: specimen_collecting_tools id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_tools ALTER COLUMN id SET DEFAULT nextval('darwin2.specimen_collecting_tools_id_seq'::regclass);


--
-- TOC entry 5721 (class 2604 OID 20519)
-- Name: specimens id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens ALTER COLUMN id SET DEFAULT nextval('darwin2.specimens_id_seq'::regclass);


--
-- TOC entry 5727 (class 2604 OID 20520)
-- Name: specimens_relationships id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships ALTER COLUMN id SET DEFAULT nextval('darwin2.specimens_relationships_id_seq'::regclass);


--
-- TOC entry 5468 (class 2604 OID 20521)
-- Name: staging id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_id_seq'::regclass);


--
-- TOC entry 5744 (class 2604 OID 20522)
-- Name: staging_catalogue id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_catalogue ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_catalogue_id_seq'::regclass);


--
-- TOC entry 5745 (class 2604 OID 20523)
-- Name: staging_collecting_methods id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_collecting_methods_id_seq'::regclass);


--
-- TOC entry 5794 (class 2604 OID 1885642)
-- Name: staging_gtu id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_gtu_id_seq'::regclass);


--
-- TOC entry 5801 (class 2604 OID 1885676)
-- Name: staging_gtu_tag_groups id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu_tag_groups ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_gtu_tag_groups_id_seq'::regclass);


--
-- TOC entry 5746 (class 2604 OID 20524)
-- Name: staging_info id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_info ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_info_id_seq'::regclass);


--
-- TOC entry 5750 (class 2604 OID 20525)
-- Name: staging_people id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_people ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_people_id_seq'::regclass);


--
-- TOC entry 5753 (class 2604 OID 20526)
-- Name: staging_relationship id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_relationship_id_seq'::regclass);


--
-- TOC entry 5754 (class 2604 OID 20527)
-- Name: staging_tag_groups id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_tag_groups ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_tag_groups_id_seq'::regclass);


--
-- TOC entry 5740 (class 2604 OID 20528)
-- Name: storage_parts id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.storage_parts ALTER COLUMN id SET DEFAULT nextval('darwin2.storage_parts_id_seq'::regclass);


--
-- TOC entry 5783 (class 2604 OID 1758311)
-- Name: storage_parts_bck_20220513 id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.storage_parts_bck_20220513 ALTER COLUMN id SET DEFAULT nextval('darwin2.storage_parts_bck_20220513_id_seq'::regclass);


--
-- TOC entry 5755 (class 2604 OID 20529)
-- Name: t_compare_darwin_digit03_mysql pid; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.t_compare_darwin_digit03_mysql ALTER COLUMN pid SET DEFAULT nextval('darwin2.t_compare_darwin_digit03_mysql_pid_seq'::regclass);


--
-- TOC entry 5758 (class 2604 OID 20530)
-- Name: tag_groups id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_groups ALTER COLUMN id SET DEFAULT nextval('darwin2.tag_groups_id_seq'::regclass);


--
-- TOC entry 5476 (class 2604 OID 20531)
-- Name: taxonomy status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 5477 (class 2604 OID 20532)
-- Name: taxonomy local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 5478 (class 2604 OID 20533)
-- Name: taxonomy path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 5479 (class 2604 OID 20534)
-- Name: taxonomy id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy ALTER COLUMN id SET DEFAULT nextval('darwin2.taxonomy_id_seq'::regclass);


--
-- TOC entry 5759 (class 2604 OID 20535)
-- Name: taxonomy_metadata id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy_metadata ALTER COLUMN id SET DEFAULT nextval('darwin2.taxonomy_metadata_id_seq'::regclass);


--
-- TOC entry 5763 (class 2604 OID 20536)
-- Name: users is_physical; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users ALTER COLUMN is_physical SET DEFAULT true;


--
-- TOC entry 5764 (class 2604 OID 20537)
-- Name: users title; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users ALTER COLUMN title SET DEFAULT ''::character varying;


--
-- TOC entry 5765 (class 2604 OID 20538)
-- Name: users birth_date_mask; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users ALTER COLUMN birth_date_mask SET DEFAULT 0;


--
-- TOC entry 5766 (class 2604 OID 20539)
-- Name: users birth_date; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users ALTER COLUMN birth_date SET DEFAULT '0001-01-01'::date;


--
-- TOC entry 5767 (class 2604 OID 20540)
-- Name: users id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users ALTER COLUMN id SET DEFAULT nextval('darwin2.users_id_seq'::regclass);


--
-- TOC entry 5770 (class 2604 OID 20541)
-- Name: users_addresses id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_addresses ALTER COLUMN id SET DEFAULT nextval('darwin2.users_addresses_id_seq'::regclass);


--
-- TOC entry 5773 (class 2604 OID 20542)
-- Name: users_comm id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_comm ALTER COLUMN id SET DEFAULT nextval('darwin2.users_comm_id_seq'::regclass);


--
-- TOC entry 5775 (class 2604 OID 20543)
-- Name: users_login_infos id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_login_infos ALTER COLUMN id SET DEFAULT nextval('darwin2.users_login_infos_id_seq'::regclass);


--
-- TOC entry 5778 (class 2604 OID 20544)
-- Name: users_tracking id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_tracking ALTER COLUMN id SET DEFAULT nextval('darwin2.users_tracking_id_seq'::regclass);


--
-- TOC entry 5779 (class 2604 OID 20545)
-- Name: vernacular_names id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.vernacular_names ALTER COLUMN id SET DEFAULT nextval('darwin2.vernacular_names_id_seq'::regclass);


--
-- TOC entry 5780 (class 2604 OID 20546)
-- Name: vmap0_world_boundaries gid; Type: DEFAULT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.vmap0_world_boundaries ALTER COLUMN gid SET DEFAULT nextval('darwin2.vmap0_world_boundaries_gid_seq'::regclass);


--
-- TOC entry 5782 (class 2604 OID 20547)
-- Name: mukweze_files pk; Type: DEFAULT; Schema: eod; Owner: darwin2
--

ALTER TABLE ONLY eod.mukweze_files ALTER COLUMN pk SET DEFAULT nextval('eod.mukweze_files_pk_seq'::regclass);


--
-- TOC entry 5940 (class 2606 OID 1413142)
-- Name: identifiers identifiers_pkey; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.identifiers
    ADD CONSTRAINT identifiers_pkey PRIMARY KEY (id);


--
-- TOC entry 5825 (class 2606 OID 1413144)
-- Name: bibliography pk_bibliography; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.bibliography
    ADD CONSTRAINT pk_bibliography PRIMARY KEY (id);


--
-- TOC entry 5830 (class 2606 OID 1413146)
-- Name: catalogue_bibliography pk_catalogue_bibliography; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_bibliography
    ADD CONSTRAINT pk_catalogue_bibliography PRIMARY KEY (id);


--
-- TOC entry 5819 (class 2606 OID 1413148)
-- Name: catalogue_levels pk_catalogue_levels; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_levels
    ADD CONSTRAINT pk_catalogue_levels PRIMARY KEY (id);


--
-- TOC entry 5839 (class 2606 OID 1413150)
-- Name: catalogue_people pk_catalogue_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_people
    ADD CONSTRAINT pk_catalogue_people PRIMARY KEY (id);


--
-- TOC entry 5844 (class 2606 OID 1413152)
-- Name: catalogue_relationships pk_catalogue_relationships; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_relationships
    ADD CONSTRAINT pk_catalogue_relationships PRIMARY KEY (id);


--
-- TOC entry 5853 (class 2606 OID 1413154)
-- Name: chronostratigraphy pk_chronostratigraphy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy
    ADD CONSTRAINT pk_chronostratigraphy PRIMARY KEY (id);


--
-- TOC entry 5858 (class 2606 OID 1413156)
-- Name: classification_keywords pk_classification_keywords_id; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.classification_keywords
    ADD CONSTRAINT pk_classification_keywords_id PRIMARY KEY (id);


--
-- TOC entry 5871 (class 2606 OID 1413158)
-- Name: codes pk_codes; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.codes
    ADD CONSTRAINT pk_codes PRIMARY KEY (id);


--
-- TOC entry 5877 (class 2606 OID 1413160)
-- Name: collecting_methods pk_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_methods
    ADD CONSTRAINT pk_collecting_methods PRIMARY KEY (id);


--
-- TOC entry 5883 (class 2606 OID 1413162)
-- Name: collecting_tools pk_collecting_tools; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_tools
    ADD CONSTRAINT pk_collecting_tools PRIMARY KEY (id);


--
-- TOC entry 5890 (class 2606 OID 1413164)
-- Name: collection_maintenance pk_collection_maintenance; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collection_maintenance
    ADD CONSTRAINT pk_collection_maintenance PRIMARY KEY (id);


--
-- TOC entry 5894 (class 2606 OID 1413166)
-- Name: collections pk_collections; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT pk_collections PRIMARY KEY (id);


--
-- TOC entry 5900 (class 2606 OID 1413168)
-- Name: collections_rights pk_collections_right; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections_rights
    ADD CONSTRAINT pk_collections_right PRIMARY KEY (id);


--
-- TOC entry 5908 (class 2606 OID 1413170)
-- Name: comments pk_comments; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.comments
    ADD CONSTRAINT pk_comments PRIMARY KEY (id);


--
-- TOC entry 5915 (class 2606 OID 1413172)
-- Name: expeditions pk_expeditions; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.expeditions
    ADD CONSTRAINT pk_expeditions PRIMARY KEY (id);


--
-- TOC entry 5920 (class 2606 OID 1413174)
-- Name: ext_links pk_ext_links; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.ext_links
    ADD CONSTRAINT pk_ext_links PRIMARY KEY (id);


--
-- TOC entry 6209 (class 2606 OID 1416671)
-- Name: fix_date_kin_feb2022 pk_fix_kin; Type: CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.fix_date_kin_feb2022
    ADD CONSTRAINT pk_fix_kin PRIMARY KEY (num);


--
-- TOC entry 5924 (class 2606 OID 1413176)
-- Name: flat_dict pk_flat_dict; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.flat_dict
    ADD CONSTRAINT pk_flat_dict PRIMARY KEY (id);


--
-- TOC entry 5931 (class 2606 OID 1413178)
-- Name: gtu pk_gtu; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.gtu
    ADD CONSTRAINT pk_gtu PRIMARY KEY (id);


--
-- TOC entry 5936 (class 2606 OID 1413180)
-- Name: identifications pk_identifications; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.identifications
    ADD CONSTRAINT pk_identifications PRIMARY KEY (id);


--
-- TOC entry 5946 (class 2606 OID 1413182)
-- Name: igs pk_igs; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.igs
    ADD CONSTRAINT pk_igs PRIMARY KEY (id);


--
-- TOC entry 5951 (class 2606 OID 1413184)
-- Name: imports pk_import; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.imports
    ADD CONSTRAINT pk_import PRIMARY KEY (id);


--
-- TOC entry 5955 (class 2606 OID 1413186)
-- Name: informative_workflow pk_informative_workflow; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.informative_workflow
    ADD CONSTRAINT pk_informative_workflow PRIMARY KEY (id);


--
-- TOC entry 5960 (class 2606 OID 1413188)
-- Name: insurances pk_insurances; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.insurances
    ADD CONSTRAINT pk_insurances PRIMARY KEY (id);


--
-- TOC entry 5969 (class 2606 OID 1413190)
-- Name: lithology pk_lithology; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology
    ADD CONSTRAINT pk_lithology PRIMARY KEY (id);


--
-- TOC entry 5977 (class 2606 OID 1413192)
-- Name: lithostratigraphy pk_lithostratigraphy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy
    ADD CONSTRAINT pk_lithostratigraphy PRIMARY KEY (id);


--
-- TOC entry 5981 (class 2606 OID 1413194)
-- Name: loan_history pk_loan_history; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_history
    ADD CONSTRAINT pk_loan_history PRIMARY KEY (id);


--
-- TOC entry 5986 (class 2606 OID 1413196)
-- Name: loan_items pk_loan_items; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT pk_loan_items PRIMARY KEY (id);


--
-- TOC entry 5992 (class 2606 OID 1413198)
-- Name: loan_rights pk_loan_rights; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_rights
    ADD CONSTRAINT pk_loan_rights PRIMARY KEY (id);


--
-- TOC entry 6000 (class 2606 OID 1413200)
-- Name: loan_status pk_loan_status; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_status
    ADD CONSTRAINT pk_loan_status PRIMARY KEY (id);


--
-- TOC entry 6002 (class 2606 OID 1413202)
-- Name: loans pk_loans; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loans
    ADD CONSTRAINT pk_loans PRIMARY KEY (id);


--
-- TOC entry 6010 (class 2606 OID 1413204)
-- Name: mineralogy pk_mineralogy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy
    ADD CONSTRAINT pk_mineralogy PRIMARY KEY (id);


--
-- TOC entry 6016 (class 2606 OID 1413206)
-- Name: multimedia pk_multimedia; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.multimedia
    ADD CONSTRAINT pk_multimedia PRIMARY KEY (id);


--
-- TOC entry 6018 (class 2606 OID 1413208)
-- Name: multimedia_todelete pk_multimedia_todelete; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.multimedia_todelete
    ADD CONSTRAINT pk_multimedia_todelete PRIMARY KEY (id);


--
-- TOC entry 6020 (class 2606 OID 1413210)
-- Name: my_saved_searches pk_my_saved_searches; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_saved_searches
    ADD CONSTRAINT pk_my_saved_searches PRIMARY KEY (id);


--
-- TOC entry 6025 (class 2606 OID 1413212)
-- Name: my_widgets pk_my_widgets; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_widgets
    ADD CONSTRAINT pk_my_widgets PRIMARY KEY (id);


--
-- TOC entry 6032 (class 2606 OID 1413214)
-- Name: people pk_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people
    ADD CONSTRAINT pk_people PRIMARY KEY (id);


--
-- TOC entry 6038 (class 2606 OID 1413216)
-- Name: people_addresses pk_people_addresses; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_addresses
    ADD CONSTRAINT pk_people_addresses PRIMARY KEY (id);


--
-- TOC entry 6042 (class 2606 OID 1413218)
-- Name: people_comm pk_people_comm; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_comm
    ADD CONSTRAINT pk_people_comm PRIMARY KEY (id);


--
-- TOC entry 6046 (class 2606 OID 1413220)
-- Name: people_languages pk_people_languages; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_languages
    ADD CONSTRAINT pk_people_languages PRIMARY KEY (id);


--
-- TOC entry 6052 (class 2606 OID 1413222)
-- Name: people_relationships pk_people_relationships; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_relationships
    ADD CONSTRAINT pk_people_relationships PRIMARY KEY (id);


--
-- TOC entry 6057 (class 2606 OID 1413224)
-- Name: preferences pk_preferences; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.preferences
    ADD CONSTRAINT pk_preferences PRIMARY KEY (id);


--
-- TOC entry 6066 (class 2606 OID 1413226)
-- Name: properties pk_properties; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.properties
    ADD CONSTRAINT pk_properties PRIMARY KEY (id);


--
-- TOC entry 5910 (class 2606 OID 1413243)
-- Name: comments pk_rmca_unique_comment_for_insertion; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.comments
    ADD CONSTRAINT pk_rmca_unique_comment_for_insertion UNIQUE (referenced_relation, record_id, notion_concerned, comment);


--
-- TOC entry 6069 (class 2606 OID 1413254)
-- Name: specimen_collecting_methods pk_specimen_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_methods
    ADD CONSTRAINT pk_specimen_collecting_methods PRIMARY KEY (id);


--
-- TOC entry 6074 (class 2606 OID 1413256)
-- Name: specimen_collecting_tools pk_specimen_collecting_tools; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_tools
    ADD CONSTRAINT pk_specimen_collecting_tools PRIMARY KEY (id);


--
-- TOC entry 6127 (class 2606 OID 1413258)
-- Name: storage_parts pk_specimen_paths; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.storage_parts
    ADD CONSTRAINT pk_specimen_paths PRIMARY KEY (id);


--
-- TOC entry 6114 (class 2606 OID 1413260)
-- Name: specimens pk_specimens; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT pk_specimens PRIMARY KEY (id);


--
-- TOC entry 6123 (class 2606 OID 1413262)
-- Name: specimens_relationships pk_specimens_relationships; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT pk_specimens_relationships PRIMARY KEY (id);


--
-- TOC entry 5806 (class 2606 OID 1413264)
-- Name: staging pk_staging; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT pk_staging PRIMARY KEY (id);


--
-- TOC entry 6138 (class 2606 OID 1413266)
-- Name: staging_catalogue pk_staging_catalogue; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_catalogue
    ADD CONSTRAINT pk_staging_catalogue PRIMARY KEY (id);


--
-- TOC entry 6140 (class 2606 OID 1413268)
-- Name: staging_collecting_methods pk_staging_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods
    ADD CONSTRAINT pk_staging_collecting_methods PRIMARY KEY (id);


--
-- TOC entry 6217 (class 2606 OID 1885681)
-- Name: staging_gtu_tag_groups pk_staging_gtu_tag_groups; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu_tag_groups
    ADD CONSTRAINT pk_staging_gtu_tag_groups PRIMARY KEY (id);


--
-- TOC entry 6144 (class 2606 OID 1413270)
-- Name: staging_info pk_staging_info; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_info
    ADD CONSTRAINT pk_staging_info PRIMARY KEY (id);


--
-- TOC entry 6147 (class 2606 OID 1413272)
-- Name: staging_people pk_staging_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_people
    ADD CONSTRAINT pk_staging_people PRIMARY KEY (id);


--
-- TOC entry 6149 (class 2606 OID 1413274)
-- Name: staging_relationship pk_staging_relationship; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT pk_staging_relationship PRIMARY KEY (id);


--
-- TOC entry 6151 (class 2606 OID 1413276)
-- Name: staging_tag_groups pk_staging_tag_groups; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_tag_groups
    ADD CONSTRAINT pk_staging_tag_groups PRIMARY KEY (id);


--
-- TOC entry 5863 (class 2606 OID 1413278)
-- Name: classification_synonymies pk_synonym_id; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.classification_synonymies
    ADD CONSTRAINT pk_synonym_id PRIMARY KEY (id);


--
-- TOC entry 6158 (class 2606 OID 1413280)
-- Name: tag_groups pk_tag_groups; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_groups
    ADD CONSTRAINT pk_tag_groups PRIMARY KEY (id);


--
-- TOC entry 6168 (class 2606 OID 1413282)
-- Name: tags pk_tags_for_replication_rmca; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tags
    ADD CONSTRAINT pk_tags_for_replication_rmca PRIMARY KEY (gtu_ref, group_ref, group_type, sub_group_type, tag, tag_indexed);


--
-- TOC entry 5813 (class 2606 OID 1413284)
-- Name: taxonomy pk_taxonomy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT pk_taxonomy PRIMARY KEY (id);


--
-- TOC entry 6173 (class 2606 OID 1413286)
-- Name: users pk_users; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users
    ADD CONSTRAINT pk_users PRIMARY KEY (id);


--
-- TOC entry 6179 (class 2606 OID 1413288)
-- Name: users_addresses pk_users_addresses; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_addresses
    ADD CONSTRAINT pk_users_addresses PRIMARY KEY (id);


--
-- TOC entry 6183 (class 2606 OID 1413290)
-- Name: users_comm pk_users_comm; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_comm
    ADD CONSTRAINT pk_users_comm PRIMARY KEY (id);


--
-- TOC entry 6185 (class 2606 OID 1413292)
-- Name: users_login_infos pk_users_login_infos; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_login_infos
    ADD CONSTRAINT pk_users_login_infos PRIMARY KEY (id);


--
-- TOC entry 6194 (class 2606 OID 1413294)
-- Name: users_tracking pk_users_tracking_pk; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_tracking
    ADD CONSTRAINT pk_users_tracking_pk PRIMARY KEY (id);


--
-- TOC entry 6199 (class 2606 OID 1413296)
-- Name: vernacular_names pk_vernacular_names; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.vernacular_names
    ADD CONSTRAINT pk_vernacular_names PRIMARY KEY (id);


--
-- TOC entry 6125 (class 2606 OID 1413298)
-- Name: specimens_stable_ids specimens_stable_ids_pkey; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_stable_ids
    ADD CONSTRAINT specimens_stable_ids_pkey PRIMARY KEY (id);


--
-- TOC entry 6117 (class 2606 OID 1413300)
-- Name: specimens_detect_wrong_countries specimens_wrong_countries_pk; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_detect_wrong_countries
    ADD CONSTRAINT specimens_wrong_countries_pk PRIMARY KEY (id);


--
-- TOC entry 6215 (class 2606 OID 1885653)
-- Name: staging_gtu staging_gtu_pkey1; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu
    ADD CONSTRAINT staging_gtu_pkey1 PRIMARY KEY (id);


--
-- TOC entry 6153 (class 2606 OID 1413302)
-- Name: t_compare_darwin_digit03_mysql t_compare_darwin_digit03_mysql_pkey; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.t_compare_darwin_digit03_mysql
    ADD CONSTRAINT t_compare_darwin_digit03_mysql_pkey PRIMARY KEY (pid);


--
-- TOC entry 6170 (class 2606 OID 1413304)
-- Name: taxonomy_metadata taxonomy_metadata_pkey; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy_metadata
    ADD CONSTRAINT taxonomy_metadata_pkey PRIMARY KEY (id);


--
-- TOC entry 5827 (class 2606 OID 1413306)
-- Name: bibliography unq_bibliography; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.bibliography
    ADD CONSTRAINT unq_bibliography UNIQUE (title_indexed, type, year);


--
-- TOC entry 5832 (class 2606 OID 1413308)
-- Name: catalogue_bibliography unq_catalogue_bibliography; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_bibliography
    ADD CONSTRAINT unq_catalogue_bibliography UNIQUE (referenced_relation, record_id, bibliography_ref);


--
-- TOC entry 5821 (class 2606 OID 1413310)
-- Name: catalogue_levels unq_catalogue_levels; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_levels
    ADD CONSTRAINT unq_catalogue_levels UNIQUE (level_type, level_name);


--
-- TOC entry 5841 (class 2606 OID 1413312)
-- Name: catalogue_people unq_catalogue_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_people
    ADD CONSTRAINT unq_catalogue_people UNIQUE (referenced_relation, people_type, people_sub_type, record_id, people_ref);


--
-- TOC entry 5846 (class 2606 OID 1413314)
-- Name: catalogue_relationships unq_catalogue_relationships; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_relationships
    ADD CONSTRAINT unq_catalogue_relationships UNIQUE (referenced_relation, relationship_type, record_id_1, record_id_2);


--
-- TOC entry 5855 (class 2606 OID 1413316)
-- Name: chronostratigraphy unq_chronostratigraphy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy
    ADD CONSTRAINT unq_chronostratigraphy UNIQUE (path, name_indexed, level_ref);


--
-- TOC entry 5873 (class 2606 OID 1413318)
-- Name: codes unq_codes; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.codes
    ADD CONSTRAINT unq_codes UNIQUE (referenced_relation, record_id, full_code_indexed, code_category);


--
-- TOC entry 5879 (class 2606 OID 1413320)
-- Name: collecting_methods unq_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_methods
    ADD CONSTRAINT unq_collecting_methods UNIQUE (method_indexed);


--
-- TOC entry 5885 (class 2606 OID 1413322)
-- Name: collecting_tools unq_collecting_tools; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_tools
    ADD CONSTRAINT unq_collecting_tools UNIQUE (tool_indexed);


--
-- TOC entry 5896 (class 2606 OID 1413324)
-- Name: collections unq_collections; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT unq_collections UNIQUE (institution_ref, path, code);


--
-- TOC entry 5902 (class 2606 OID 1413326)
-- Name: collections_rights unq_collections_rights; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections_rights
    ADD CONSTRAINT unq_collections_rights UNIQUE (collection_ref, user_ref);


--
-- TOC entry 5917 (class 2606 OID 1413328)
-- Name: expeditions unq_expeditions; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.expeditions
    ADD CONSTRAINT unq_expeditions UNIQUE (name_indexed, expedition_from_date, expedition_from_date_mask, expedition_to_date, expedition_to_date_mask);


--
-- TOC entry 5922 (class 2606 OID 1413330)
-- Name: ext_links unq_ext_links; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.ext_links
    ADD CONSTRAINT unq_ext_links UNIQUE (referenced_relation, record_id, url);


--
-- TOC entry 5926 (class 2606 OID 1413332)
-- Name: flat_dict unq_flat_dict; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.flat_dict
    ADD CONSTRAINT unq_flat_dict UNIQUE (dict_value, dict_field, referenced_relation, dict_depend);


--
-- TOC entry 5938 (class 2606 OID 1413334)
-- Name: identifications unq_identifications; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.identifications
    ADD CONSTRAINT unq_identifications UNIQUE (referenced_relation, record_id, notion_concerned, notion_date, value_defined_indexed);


--
-- TOC entry 5948 (class 2606 OID 1413336)
-- Name: igs unq_igs; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.igs
    ADD CONSTRAINT unq_igs UNIQUE (ig_num);


--
-- TOC entry 5962 (class 2606 OID 1413338)
-- Name: insurances unq_insurances; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.insurances
    ADD CONSTRAINT unq_insurances UNIQUE (referenced_relation, record_id, date_from, date_to, insurer_ref);


--
-- TOC entry 5971 (class 2606 OID 1413340)
-- Name: lithology unq_lithology; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology
    ADD CONSTRAINT unq_lithology UNIQUE (path, name_indexed, level_ref);


--
-- TOC entry 5979 (class 2606 OID 1413342)
-- Name: lithostratigraphy unq_lithostratigraphy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy
    ADD CONSTRAINT unq_lithostratigraphy UNIQUE (path, name_indexed, level_ref);


--
-- TOC entry 5988 (class 2606 OID 1413344)
-- Name: loan_items unq_loan_items; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT unq_loan_items UNIQUE (loan_ref, specimen_ref);


--
-- TOC entry 5994 (class 2606 OID 1413346)
-- Name: loan_rights unq_loan_rights; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_rights
    ADD CONSTRAINT unq_loan_rights UNIQUE (loan_ref, user_ref);


--
-- TOC entry 6012 (class 2606 OID 1413348)
-- Name: mineralogy unq_mineralogy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy
    ADD CONSTRAINT unq_mineralogy UNIQUE (path, name_indexed, level_ref, code);


--
-- TOC entry 6022 (class 2606 OID 1413350)
-- Name: my_saved_searches unq_my_saved_searches; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_saved_searches
    ADD CONSTRAINT unq_my_saved_searches UNIQUE (user_ref, name);


--
-- TOC entry 6027 (class 2606 OID 1413352)
-- Name: my_widgets unq_my_widgets; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_widgets
    ADD CONSTRAINT unq_my_widgets UNIQUE (user_ref, category, group_name);


--
-- TOC entry 6034 (class 2606 OID 1413354)
-- Name: people unq_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people
    ADD CONSTRAINT unq_people UNIQUE (is_physical, gender, formated_name_unique, birth_date, birth_date_mask, end_date, end_date_mask);


--
-- TOC entry 6048 (class 2606 OID 1413356)
-- Name: people_languages unq_people_languages; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_languages
    ADD CONSTRAINT unq_people_languages UNIQUE (people_ref, language_country);


--
-- TOC entry 6055 (class 2606 OID 1413358)
-- Name: possible_upper_levels unq_possible_upper_levels; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.possible_upper_levels
    ADD CONSTRAINT unq_possible_upper_levels UNIQUE (level_ref, level_upper_ref);


--
-- TOC entry 6071 (class 2606 OID 1413360)
-- Name: specimen_collecting_methods unq_specimen_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_methods
    ADD CONSTRAINT unq_specimen_collecting_methods UNIQUE (specimen_ref, collecting_method_ref);


--
-- TOC entry 6076 (class 2606 OID 1413362)
-- Name: specimen_collecting_tools unq_specimen_collecting_tools; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_tools
    ADD CONSTRAINT unq_specimen_collecting_tools UNIQUE (specimen_ref, collecting_tool_ref);


--
-- TOC entry 6142 (class 2606 OID 1413364)
-- Name: staging_collecting_methods unq_staging_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods
    ADD CONSTRAINT unq_staging_collecting_methods UNIQUE (staging_ref, collecting_method_ref);


--
-- TOC entry 5865 (class 2606 OID 1413366)
-- Name: classification_synonymies unq_synonym; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.classification_synonymies
    ADD CONSTRAINT unq_synonym UNIQUE (referenced_relation, record_id, group_id);


--
-- TOC entry 6160 (class 2606 OID 1413368)
-- Name: tag_groups unq_tag_groups; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_groups
    ADD CONSTRAINT unq_tag_groups UNIQUE (gtu_ref, group_name_indexed, sub_group_name_indexed);


--
-- TOC entry 5815 (class 2606 OID 1413370)
-- Name: taxonomy unq_taxonomy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT unq_taxonomy UNIQUE (path, name_indexed, level_ref, metadata_ref);


--
-- TOC entry 6175 (class 2606 OID 1413372)
-- Name: users unq_users; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users
    ADD CONSTRAINT unq_users UNIQUE (is_physical, gender, formated_name_unique, birth_date, birth_date_mask);


--
-- TOC entry 6187 (class 2606 OID 1413374)
-- Name: users_login_infos unq_users_login_infos; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_login_infos
    ADD CONSTRAINT unq_users_login_infos UNIQUE (user_ref, login_type);


--
-- TOC entry 6189 (class 2606 OID 1413376)
-- Name: users_login_infos unq_users_login_infos_user_name; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_login_infos
    ADD CONSTRAINT unq_users_login_infos_user_name UNIQUE (user_name, login_type);


--
-- TOC entry 6201 (class 2606 OID 1413378)
-- Name: vernacular_names unq_vernacular_names; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.vernacular_names
    ADD CONSTRAINT unq_vernacular_names UNIQUE (referenced_relation, record_id, community_indexed, name_indexed);


--
-- TOC entry 5942 (class 2606 OID 1413380)
-- Name: identifiers uq_identifiers; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.identifiers
    ADD CONSTRAINT uq_identifiers UNIQUE (referenced_relation, record_id, protocol);


--
-- TOC entry 5817 (class 2606 OID 1413382)
-- Name: taxonomy uq_rcma_one_taxon_per_metadata; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT uq_rcma_one_taxon_per_metadata UNIQUE (metadata_ref, level_ref, name_indexed);


--
-- TOC entry 6203 (class 2606 OID 1413384)
-- Name: vmap0_world_boundaries vmap0_world_boundaries_pkey; Type: CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.vmap0_world_boundaries
    ADD CONSTRAINT vmap0_world_boundaries_pkey PRIMARY KEY (gid);


--
-- TOC entry 6205 (class 2606 OID 1413386)
-- Name: x_ray_drosera x_ray_drosera_pkey; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.x_ray_drosera
    ADD CONSTRAINT x_ray_drosera_pkey PRIMARY KEY (full_path);


--
-- TOC entry 6207 (class 2606 OID 1413388)
-- Name: mukweze_files mukweze_files_pkey; Type: CONSTRAINT; Schema: eod; Owner: darwin2
--

ALTER TABLE ONLY eod.mukweze_files
    ADD CONSTRAINT mukweze_files_pkey PRIMARY KEY (pk);


--
-- TOC entry 6212 (class 1259 OID 1885669)
-- Name: fki_to_gtu; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX fki_to_gtu ON darwin2.staging_gtu USING btree (gtu_ref);


--
-- TOC entry 6213 (class 1259 OID 1885670)
-- Name: fki_to_import; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX fki_to_import ON darwin2.staging_gtu USING btree (import_ref);


--
-- TOC entry 5822 (class 1259 OID 1413389)
-- Name: idx_bibliography_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_bibliography_type ON darwin2.bibliography USING btree (type);


--
-- TOC entry 5828 (class 1259 OID 1413390)
-- Name: idx_catalogue_bibliography_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_bibliography_referenced_record ON darwin2.catalogue_bibliography USING btree (referenced_relation, record_id);


--
-- TOC entry 5833 (class 1259 OID 1413391)
-- Name: idx_catalogue_people_people_order_by; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_people_order_by ON darwin2.catalogue_people USING btree (order_by);


--
-- TOC entry 5834 (class 1259 OID 1413392)
-- Name: idx_catalogue_people_people_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_people_ref ON darwin2.catalogue_people USING btree (people_ref);


--
-- TOC entry 5835 (class 1259 OID 1413393)
-- Name: idx_catalogue_people_people_sub_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_people_sub_type ON darwin2.catalogue_people USING btree (people_sub_type);


--
-- TOC entry 5836 (class 1259 OID 1413394)
-- Name: idx_catalogue_people_people_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_people_type ON darwin2.catalogue_people USING btree (people_type);


--
-- TOC entry 5837 (class 1259 OID 1413395)
-- Name: idx_catalogue_people_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_referenced_record ON darwin2.catalogue_people USING btree (referenced_relation, record_id);


--
-- TOC entry 5842 (class 1259 OID 1413396)
-- Name: idx_catalogue_relationships_relations; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_relationships_relations ON darwin2.catalogue_relationships USING btree (referenced_relation, record_id_1, relationship_type);


--
-- TOC entry 5847 (class 1259 OID 1413397)
-- Name: idx_chronostratigraphy_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_chronostratigraphy_level_ref ON darwin2.chronostratigraphy USING btree (level_ref);


--
-- TOC entry 5848 (class 1259 OID 1413398)
-- Name: idx_chronostratigraphy_lower_bound; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_chronostratigraphy_lower_bound ON darwin2.chronostratigraphy USING btree (COALESCE(lower_bound, ('-4600'::integer)::numeric));


--
-- TOC entry 5849 (class 1259 OID 1413399)
-- Name: idx_chronostratigraphy_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_chronostratigraphy_parent_ref ON darwin2.chronostratigraphy USING btree (parent_ref);


--
-- TOC entry 5850 (class 1259 OID 1413400)
-- Name: idx_chronostratigraphy_upper_bound; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_chronostratigraphy_upper_bound ON darwin2.chronostratigraphy USING btree (COALESCE(upper_bound, (1)::numeric));


--
-- TOC entry 5856 (class 1259 OID 1413401)
-- Name: idx_classification_keywords_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_classification_keywords_referenced_record ON darwin2.classification_keywords USING btree (referenced_relation, record_id);


--
-- TOC entry 5859 (class 1259 OID 1413402)
-- Name: idx_classification_synonymies_grouping; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_classification_synonymies_grouping ON darwin2.classification_synonymies USING btree (group_id, is_basionym);


--
-- TOC entry 5860 (class 1259 OID 1413403)
-- Name: idx_classification_synonymies_order_by; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_classification_synonymies_order_by ON darwin2.classification_synonymies USING btree (group_name, order_by);


--
-- TOC entry 5861 (class 1259 OID 1413404)
-- Name: idx_classification_synonymies_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_classification_synonymies_referenced_record ON darwin2.classification_synonymies USING btree (referenced_relation, record_id, group_id);


--
-- TOC entry 5866 (class 1259 OID 1413405)
-- Name: idx_codes_code_num; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_codes_code_num ON darwin2.codes USING btree (code_num) WHERE (NOT (code_num IS NULL));


--
-- TOC entry 5867 (class 1259 OID 1413406)
-- Name: idx_codes_full_code_indexed_btree; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_codes_full_code_indexed_btree ON darwin2.codes USING btree (full_code_indexed);


--
-- TOC entry 5868 (class 1259 OID 1413407)
-- Name: idx_codes_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_codes_referenced_record ON darwin2.codes USING btree (referenced_relation, record_id);


--
-- TOC entry 5874 (class 1259 OID 1413408)
-- Name: idx_collecting_methods_method_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collecting_methods_method_indexed ON darwin2.collecting_methods USING btree (method_indexed);


--
-- TOC entry 5880 (class 1259 OID 1413409)
-- Name: idx_collecting_tools_tool_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collecting_tools_tool_indexed ON darwin2.collecting_tools USING btree (tool_indexed);


--
-- TOC entry 5886 (class 1259 OID 1413410)
-- Name: idx_collection_maintenance_action; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collection_maintenance_action ON darwin2.collection_maintenance USING btree (action_observation);


--
-- TOC entry 5887 (class 1259 OID 1413411)
-- Name: idx_collection_maintenance_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collection_maintenance_referenced_record ON darwin2.collection_maintenance USING btree (referenced_relation, record_id);


--
-- TOC entry 5888 (class 1259 OID 1413412)
-- Name: idx_collection_maintenance_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collection_maintenance_user_ref ON darwin2.collection_maintenance USING btree (people_ref);


--
-- TOC entry 5891 (class 1259 OID 1413413)
-- Name: idx_collections_main_manager_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collections_main_manager_ref ON darwin2.collections USING btree (main_manager_ref);


--
-- TOC entry 5892 (class 1259 OID 1413414)
-- Name: idx_collections_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collections_parent_ref ON darwin2.collections USING btree (parent_ref);


--
-- TOC entry 5897 (class 1259 OID 1413415)
-- Name: idx_collections_rights_db_user_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collections_rights_db_user_type ON darwin2.collections_rights USING btree (db_user_type);


--
-- TOC entry 5898 (class 1259 OID 1413416)
-- Name: idx_collections_rights_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collections_rights_user_ref ON darwin2.collections_rights USING btree (user_ref);


--
-- TOC entry 5903 (class 1259 OID 1413417)
-- Name: idx_comments_notion_concerned; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_comments_notion_concerned ON darwin2.comments USING btree (notion_concerned);


--
-- TOC entry 5904 (class 1259 OID 1413418)
-- Name: idx_comments_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_comments_referenced_record ON darwin2.comments USING btree (referenced_relation, record_id);


--
-- TOC entry 6077 (class 1259 OID 1413419)
-- Name: idx_darwin_flat_gtu_code; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_darwin_flat_gtu_code ON darwin2.specimens USING gin (gtu_code public.gin_trgm_ops);


--
-- TOC entry 5911 (class 1259 OID 1413420)
-- Name: idx_expeditions_expedition_from_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_expeditions_expedition_from_date ON darwin2.expeditions USING btree (expedition_from_date, expedition_from_date_mask);


--
-- TOC entry 5912 (class 1259 OID 1413421)
-- Name: idx_expeditions_expedition_to_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_expeditions_expedition_to_date ON darwin2.expeditions USING btree (expedition_to_date, expedition_to_date_mask);


--
-- TOC entry 5918 (class 1259 OID 1413422)
-- Name: idx_ext_links_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_ext_links_referenced_record ON darwin2.ext_links USING btree (referenced_relation, record_id);


--
-- TOC entry 5927 (class 1259 OID 1413423)
-- Name: idx_gin_gtu_tags_values; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_gtu_tags_values ON darwin2.gtu USING gin (tag_values_indexed);


--
-- TOC entry 6013 (class 1259 OID 1413424)
-- Name: idx_gin_multimedia_search_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_multimedia_search_indexed ON darwin2.multimedia USING gin (search_indexed public.gin_trgm_ops);


--
-- TOC entry 6078 (class 1259 OID 1413425)
-- Name: idx_gin_specimens_gtu_country_tag_indexed_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_gtu_country_tag_indexed_indexed ON darwin2.specimens USING gin (gtu_country_tag_indexed);


--
-- TOC entry 6079 (class 1259 OID 1413426)
-- Name: idx_gin_specimens_gtu_tag_values_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_gtu_tag_values_indexed ON darwin2.specimens USING gin (gtu_tag_values_indexed);


--
-- TOC entry 6080 (class 1259 OID 1413427)
-- Name: idx_gin_specimens_spec_coll_ids; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_spec_coll_ids ON darwin2.specimens USING gin (spec_coll_ids);


--
-- TOC entry 6081 (class 1259 OID 1413428)
-- Name: idx_gin_specimens_spec_don_sel_ids; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_spec_don_sel_ids ON darwin2.specimens USING gin (spec_don_sel_ids);


--
-- TOC entry 6082 (class 1259 OID 1413429)
-- Name: idx_gin_specimens_spec_ident_ids; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_spec_ident_ids ON darwin2.specimens USING gin (spec_ident_ids);


--
-- TOC entry 5823 (class 1259 OID 1413430)
-- Name: idx_gin_trgm_bibliography_title; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_bibliography_title ON darwin2.bibliography USING gist (title_indexed public.gist_trgm_ops);


--
-- TOC entry 5851 (class 1259 OID 1413431)
-- Name: idx_gin_trgm_chronostratigraphy_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_chronostratigraphy_naming ON darwin2.chronostratigraphy USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 5905 (class 1259 OID 1413432)
-- Name: idx_gin_trgm_comments_comment; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_comments_comment ON darwin2.comments USING gin (comment public.gin_trgm_ops);


--
-- TOC entry 5906 (class 1259 OID 1413433)
-- Name: idx_gin_trgm_comments_comment_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_comments_comment_indexed ON darwin2.comments USING gin (comment_indexed public.gin_trgm_ops);


--
-- TOC entry 5913 (class 1259 OID 1413434)
-- Name: idx_gin_trgm_expeditions_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_expeditions_name ON darwin2.expeditions USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 5963 (class 1259 OID 1413435)
-- Name: idx_gin_trgm_lithology_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_lithology_name_indexed ON darwin2.lithology USING btree (name_indexed);


--
-- TOC entry 5964 (class 1259 OID 1413436)
-- Name: idx_gin_trgm_lithology_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_lithology_naming ON darwin2.lithology USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 5972 (class 1259 OID 1413437)
-- Name: idx_gin_trgm_lithostratigraphy_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_lithostratigraphy_naming ON darwin2.lithostratigraphy USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 6003 (class 1259 OID 1413438)
-- Name: idx_gin_trgm_mineralogy_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_mineralogy_naming ON darwin2.mineralogy USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 6028 (class 1259 OID 1413439)
-- Name: idx_gin_trgm_people_formated_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_people_formated_name ON darwin2.people USING gin (formated_name_indexed public.gin_trgm_ops);


--
-- TOC entry 6083 (class 1259 OID 1413440)
-- Name: idx_gin_trgm_specimens_expedition_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_specimens_expedition_name_indexed ON darwin2.specimens USING gin (expedition_name_indexed public.gin_trgm_ops);


--
-- TOC entry 6084 (class 1259 OID 1413441)
-- Name: idx_gin_trgm_specimens_ig_num; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_specimens_ig_num ON darwin2.specimens USING gin (ig_num_indexed public.gin_trgm_ops);


--
-- TOC entry 6085 (class 1259 OID 1413442)
-- Name: idx_gin_trgm_specimens_taxon_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_specimens_taxon_name_indexed ON darwin2.specimens USING gin (taxon_name_indexed public.gin_trgm_ops);


--
-- TOC entry 6086 (class 1259 OID 1413443)
-- Name: idx_gin_trgm_specimens_taxon_path; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_specimens_taxon_path ON darwin2.specimens USING gin (taxon_path public.gin_trgm_ops);


--
-- TOC entry 5807 (class 1259 OID 1413444)
-- Name: idx_gin_trgm_taxonomy_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_taxonomy_name_indexed ON darwin2.taxonomy USING btree (name_indexed text_pattern_ops);


--
-- TOC entry 5808 (class 1259 OID 1413445)
-- Name: idx_gin_trgm_taxonomy_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_taxonomy_naming ON darwin2.taxonomy USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 6171 (class 1259 OID 1413446)
-- Name: idx_gin_trgm_users_formated_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_users_formated_name ON darwin2.users USING gin (formated_name_indexed public.gin_trgm_ops);


--
-- TOC entry 6087 (class 1259 OID 1413447)
-- Name: idx_gist_specimens_gtu_location; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gist_specimens_gtu_location ON darwin2.specimens USING gist (gtu_location);


--
-- TOC entry 5928 (class 1259 OID 1413448)
-- Name: idx_gtu_code; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gtu_code ON darwin2.gtu USING btree (code);


--
-- TOC entry 5929 (class 1259 OID 1413449)
-- Name: idx_gtu_location; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gtu_location ON darwin2.gtu USING gist (location);


--
-- TOC entry 5932 (class 1259 OID 1413450)
-- Name: idx_identifications_determination_status; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_identifications_determination_status ON darwin2.identifications USING btree (determination_status) WHERE ((determination_status)::text <> ''::text);


--
-- TOC entry 5933 (class 1259 OID 1413451)
-- Name: idx_identifications_notion_concerned; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_identifications_notion_concerned ON darwin2.identifications USING btree (notion_concerned);


--
-- TOC entry 5934 (class 1259 OID 1413452)
-- Name: idx_identifications_order_by; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_identifications_order_by ON darwin2.identifications USING btree (order_by);


--
-- TOC entry 5943 (class 1259 OID 1413453)
-- Name: idx_igs_ig_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_igs_ig_date ON darwin2.igs USING btree (ig_date, ig_date_mask);


--
-- TOC entry 5944 (class 1259 OID 1413454)
-- Name: idx_igs_ig_num_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_igs_ig_num_indexed ON darwin2.igs USING btree (ig_num_indexed text_pattern_ops);


--
-- TOC entry 5949 (class 1259 OID 1413455)
-- Name: idx_imports_collection_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_imports_collection_ref ON darwin2.imports USING btree (collection_ref);


--
-- TOC entry 5952 (class 1259 OID 1413456)
-- Name: idx_informative_workflow_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_informative_workflow_referenced_record ON darwin2.informative_workflow USING btree (referenced_relation, record_id);


--
-- TOC entry 5953 (class 1259 OID 1413457)
-- Name: idx_informative_workflow_user_status; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_informative_workflow_user_status ON darwin2.informative_workflow USING btree (user_ref, status);


--
-- TOC entry 5956 (class 1259 OID 1413458)
-- Name: idx_insurances_contact_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_insurances_contact_ref ON darwin2.insurances USING btree (contact_ref);


--
-- TOC entry 5957 (class 1259 OID 1413459)
-- Name: idx_insurances_insurance_currency; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_insurances_insurance_currency ON darwin2.insurances USING btree (insurance_currency);


--
-- TOC entry 5958 (class 1259 OID 1413460)
-- Name: idx_insurances_insurer_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_insurances_insurer_ref ON darwin2.insurances USING btree (insurer_ref);


--
-- TOC entry 5965 (class 1259 OID 1413461)
-- Name: idx_lithology_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithology_level_ref ON darwin2.lithology USING btree (level_ref);


--
-- TOC entry 5966 (class 1259 OID 1413462)
-- Name: idx_lithology_name_order_by_txt_op; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithology_name_order_by_txt_op ON darwin2.lithology USING btree (name_indexed text_pattern_ops);


--
-- TOC entry 5967 (class 1259 OID 1413463)
-- Name: idx_lithology_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithology_parent_ref ON darwin2.lithology USING btree (parent_ref);


--
-- TOC entry 5973 (class 1259 OID 1413464)
-- Name: idx_lithostratigraphy_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithostratigraphy_level_ref ON darwin2.lithostratigraphy USING btree (level_ref);


--
-- TOC entry 5974 (class 1259 OID 1413465)
-- Name: idx_lithostratigraphy_name_order_by_txt_op; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithostratigraphy_name_order_by_txt_op ON darwin2.lithostratigraphy USING btree (name_indexed text_pattern_ops);


--
-- TOC entry 5975 (class 1259 OID 1413466)
-- Name: idx_lithostratigraphy_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithostratigraphy_parent_ref ON darwin2.lithostratigraphy USING btree (parent_ref);


--
-- TOC entry 5982 (class 1259 OID 1413467)
-- Name: idx_loan_items_ig_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_items_ig_ref ON darwin2.loan_items USING btree (ig_ref);


--
-- TOC entry 5983 (class 1259 OID 1413468)
-- Name: idx_loan_items_loan_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_items_loan_ref ON darwin2.loan_items USING btree (loan_ref);


--
-- TOC entry 5984 (class 1259 OID 1413469)
-- Name: idx_loan_items_part_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_items_part_ref ON darwin2.loan_items USING btree (specimen_ref);


--
-- TOC entry 5989 (class 1259 OID 1413470)
-- Name: idx_loan_rights_ig_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_rights_ig_ref ON darwin2.loan_rights USING btree (loan_ref);


--
-- TOC entry 5990 (class 1259 OID 1413471)
-- Name: idx_loan_rights_part_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_rights_part_ref ON darwin2.loan_rights USING btree (user_ref);


--
-- TOC entry 5995 (class 1259 OID 1413472)
-- Name: idx_loan_status_loan_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_status_loan_ref ON darwin2.loan_status USING btree (loan_ref);


--
-- TOC entry 5996 (class 1259 OID 1413473)
-- Name: idx_loan_status_loan_ref_is_last; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_status_loan_ref_is_last ON darwin2.loan_status USING btree (loan_ref, is_last);


--
-- TOC entry 5997 (class 1259 OID 1413474)
-- Name: idx_loan_status_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_status_user_ref ON darwin2.loan_status USING btree (user_ref);


--
-- TOC entry 5875 (class 1259 OID 1413475)
-- Name: idx_method_trgm; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_method_trgm ON darwin2.collecting_methods USING gin (method public.gin_trgm_ops);


--
-- TOC entry 6004 (class 1259 OID 1413476)
-- Name: idx_mineralogy_code; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_code ON darwin2.mineralogy USING btree (upper((code)::text));


--
-- TOC entry 6005 (class 1259 OID 1413477)
-- Name: idx_mineralogy_cristal_system; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_cristal_system ON darwin2.mineralogy USING btree (cristal_system) WHERE ((cristal_system)::text <> ''::text);


--
-- TOC entry 6006 (class 1259 OID 1413478)
-- Name: idx_mineralogy_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_level_ref ON darwin2.mineralogy USING btree (level_ref);


--
-- TOC entry 6007 (class 1259 OID 1413479)
-- Name: idx_mineralogy_name_order_by_txt_op; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_name_order_by_txt_op ON darwin2.mineralogy USING btree (name_indexed text_pattern_ops);


--
-- TOC entry 6008 (class 1259 OID 1413480)
-- Name: idx_mineralogy_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_parent_ref ON darwin2.mineralogy USING btree (parent_ref);


--
-- TOC entry 6014 (class 1259 OID 1413481)
-- Name: idx_multimedia_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_multimedia_referenced_record ON darwin2.multimedia USING btree (referenced_relation, record_id);


--
-- TOC entry 6023 (class 1259 OID 1413482)
-- Name: idx_my_widgets_user_category; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_my_widgets_user_category ON darwin2.my_widgets USING btree (user_ref, category, group_name);


--
-- TOC entry 6035 (class 1259 OID 1413483)
-- Name: idx_people_addresses_country; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_addresses_country ON darwin2.people_addresses USING btree (country);


--
-- TOC entry 6036 (class 1259 OID 1413484)
-- Name: idx_people_addresses_person_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_addresses_person_user_ref ON darwin2.people_addresses USING btree (person_user_ref);


--
-- TOC entry 6039 (class 1259 OID 1413485)
-- Name: idx_people_comm_comm_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_comm_comm_type ON darwin2.people_comm USING btree (comm_type);


--
-- TOC entry 6040 (class 1259 OID 1413486)
-- Name: idx_people_comm_person_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_comm_person_user_ref ON darwin2.people_comm USING btree (person_user_ref);


--
-- TOC entry 6029 (class 1259 OID 1413487)
-- Name: idx_people_family_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_family_name ON darwin2.people USING btree (family_name);


--
-- TOC entry 6043 (class 1259 OID 1413488)
-- Name: idx_people_languages_language_country; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_languages_language_country ON darwin2.people_languages USING btree (language_country);


--
-- TOC entry 6044 (class 1259 OID 1413489)
-- Name: idx_people_languages_people_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_languages_people_ref ON darwin2.people_languages USING btree (people_ref);


--
-- TOC entry 6049 (class 1259 OID 1413490)
-- Name: idx_people_relationships_person_1_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_relationships_person_1_ref ON darwin2.people_relationships USING btree (person_1_ref);


--
-- TOC entry 6050 (class 1259 OID 1413491)
-- Name: idx_people_relationships_person_2_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_relationships_person_2_ref ON darwin2.people_relationships USING btree (person_2_ref);


--
-- TOC entry 6030 (class 1259 OID 1413492)
-- Name: idx_people_sub_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_sub_type ON darwin2.people USING btree (sub_type) WHERE (NOT (sub_type IS NULL));


--
-- TOC entry 6053 (class 1259 OID 1413493)
-- Name: idx_possible_upper_levels_level_upper_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_possible_upper_levels_level_upper_ref ON darwin2.possible_upper_levels USING btree (level_upper_ref);


--
-- TOC entry 6058 (class 1259 OID 1413494)
-- Name: idx_properties_property_lower_value; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_lower_value ON darwin2.properties USING btree (lower_value);


--
-- TOC entry 6059 (class 1259 OID 1413495)
-- Name: idx_properties_property_lower_value_unified; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_lower_value_unified ON darwin2.properties USING btree (lower_value_unified);


--
-- TOC entry 6060 (class 1259 OID 1413496)
-- Name: idx_properties_property_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_type ON darwin2.properties USING btree (property_type);


--
-- TOC entry 6061 (class 1259 OID 1413497)
-- Name: idx_properties_property_unit; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_unit ON darwin2.properties USING btree (property_unit);


--
-- TOC entry 6062 (class 1259 OID 1413498)
-- Name: idx_properties_property_upper_value; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_upper_value ON darwin2.properties USING btree (upper_value);


--
-- TOC entry 6063 (class 1259 OID 1413499)
-- Name: idx_properties_property_upper_value_unified; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_upper_value_unified ON darwin2.properties USING btree (upper_value_unified);


--
-- TOC entry 6064 (class 1259 OID 1413500)
-- Name: idx_properties_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_referenced_record ON darwin2.properties USING btree (referenced_relation, record_id);


--
-- TOC entry 5869 (class 1259 OID 1413501)
-- Name: idx_rmca_codes; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_rmca_codes ON darwin2.codes USING btree (code);


--
-- TOC entry 6067 (class 1259 OID 1413502)
-- Name: idx_specimen_collecting_methods_method_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimen_collecting_methods_method_ref ON darwin2.specimen_collecting_methods USING btree (collecting_method_ref);


--
-- TOC entry 6072 (class 1259 OID 1413503)
-- Name: idx_specimen_collecting_tools_tool_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimen_collecting_tools_tool_ref ON darwin2.specimen_collecting_tools USING btree (collecting_tool_ref);


--
-- TOC entry 6088 (class 1259 OID 1413504)
-- Name: idx_specimens_chrono_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_chrono_ref ON darwin2.specimens USING btree (chrono_ref) WHERE (chrono_ref <> 0);


--
-- TOC entry 6089 (class 1259 OID 1413505)
-- Name: idx_specimens_collection_is_public; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_collection_is_public ON darwin2.specimens USING btree (collection_is_public);


--
-- TOC entry 6090 (class 1259 OID 1413506)
-- Name: idx_specimens_collection_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_collection_name ON darwin2.specimens USING btree (collection_name);


--
-- TOC entry 6091 (class 1259 OID 1413507)
-- Name: idx_specimens_expedition_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_expedition_ref ON darwin2.specimens USING btree (expedition_ref) WHERE (expedition_ref <> 0);


--
-- TOC entry 6092 (class 1259 OID 1413508)
-- Name: idx_specimens_gtu_from_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_from_date ON darwin2.specimens USING btree (gtu_from_date);


--
-- TOC entry 6093 (class 1259 OID 1413509)
-- Name: idx_specimens_gtu_from_date_mask; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_from_date_mask ON darwin2.specimens USING btree (gtu_from_date_mask);


--
-- TOC entry 6094 (class 1259 OID 1415824)
-- Name: idx_specimens_gtu_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_ref ON darwin2.specimens USING btree (gtu_ref) WHERE (gtu_ref <> 0);


--
-- TOC entry 6095 (class 1259 OID 1413511)
-- Name: idx_specimens_gtu_to_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_to_date ON darwin2.specimens USING btree (gtu_to_date);


--
-- TOC entry 6096 (class 1259 OID 1413512)
-- Name: idx_specimens_gtu_to_date_mask; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_to_date_mask ON darwin2.specimens USING btree (gtu_to_date_mask);


--
-- TOC entry 6097 (class 1259 OID 1413513)
-- Name: idx_specimens_ig_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_ig_ref ON darwin2.specimens USING btree (ig_ref);


--
-- TOC entry 6098 (class 1259 OID 1413514)
-- Name: idx_specimens_litho_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_litho_ref ON darwin2.specimens USING btree (litho_ref) WHERE (litho_ref <> 0);


--
-- TOC entry 6099 (class 1259 OID 1413515)
-- Name: idx_specimens_lithology_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_lithology_ref ON darwin2.specimens USING btree (lithology_ref) WHERE (lithology_ref <> 0);


--
-- TOC entry 6100 (class 1259 OID 1415823)
-- Name: idx_specimens_main_code_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_main_code_indexed ON darwin2.specimens USING btree (main_code_indexed);


--
-- TOC entry 6101 (class 1259 OID 1413516)
-- Name: idx_specimens_mineral_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_mineral_ref ON darwin2.specimens USING btree (mineral_ref) WHERE (mineral_ref <> 0);


--
-- TOC entry 6118 (class 1259 OID 1413517)
-- Name: idx_specimens_relationships_mineral_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_relationships_mineral_ref ON darwin2.specimens_relationships USING btree (mineral_ref);


--
-- TOC entry 6119 (class 1259 OID 1413518)
-- Name: idx_specimens_relationships_specimen_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_relationships_specimen_ref ON darwin2.specimens_relationships USING btree (specimen_ref);


--
-- TOC entry 6120 (class 1259 OID 1413519)
-- Name: idx_specimens_relationships_specimen_related_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_relationships_specimen_related_ref ON darwin2.specimens_relationships USING btree (specimen_related_ref);


--
-- TOC entry 6121 (class 1259 OID 1413520)
-- Name: idx_specimens_relationships_taxon_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_relationships_taxon_ref ON darwin2.specimens_relationships USING btree (taxon_ref);


--
-- TOC entry 6102 (class 1259 OID 1413521)
-- Name: idx_specimens_rock_form; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_rock_form ON darwin2.specimens USING btree (rock_form);


--
-- TOC entry 6103 (class 1259 OID 1413522)
-- Name: idx_specimens_room; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_room ON darwin2.specimens USING btree (room) WHERE (NOT (room IS NULL));


--
-- TOC entry 6104 (class 1259 OID 1413523)
-- Name: idx_specimens_sex; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_sex ON darwin2.specimens USING btree (sex) WHERE ((sex)::text <> ALL (ARRAY[('undefined'::character varying)::text, ('unknown'::character varying)::text]));


--
-- TOC entry 6105 (class 1259 OID 1413524)
-- Name: idx_specimens_shelf; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_shelf ON darwin2.specimens USING btree (shelf) WHERE (NOT (shelf IS NULL));


--
-- TOC entry 6106 (class 1259 OID 1413525)
-- Name: idx_specimens_social_status; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_social_status ON darwin2.specimens USING btree (social_status) WHERE ((social_status)::text <> 'not applicable'::text);


--
-- TOC entry 6107 (class 1259 OID 1413526)
-- Name: idx_specimens_stage; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_stage ON darwin2.specimens USING btree (stage) WHERE ((stage)::text <> ALL (ARRAY[('undefined'::character varying)::text, ('unknown'::character varying)::text]));


--
-- TOC entry 6108 (class 1259 OID 1413527)
-- Name: idx_specimens_state; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_state ON darwin2.specimens USING btree (state) WHERE ((state)::text <> 'not applicable'::text);


--
-- TOC entry 6109 (class 1259 OID 1413528)
-- Name: idx_specimens_station_visible; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_station_visible ON darwin2.specimens USING btree (station_visible);


--
-- TOC entry 6110 (class 1259 OID 1413529)
-- Name: idx_specimens_taxon_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_taxon_name_indexed ON darwin2.specimens USING btree (taxon_name_indexed);


--
-- TOC entry 6111 (class 1259 OID 1413530)
-- Name: idx_specimens_taxon_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_taxon_ref ON darwin2.specimens USING btree (taxon_ref) WHERE (taxon_ref <> 0);


--
-- TOC entry 6112 (class 1259 OID 1413531)
-- Name: idx_specimens_type_search; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_type_search ON darwin2.specimens USING btree (type_search) WHERE ((type_search)::text <> 'specimen'::text);


--
-- TOC entry 6133 (class 1259 OID 1413533)
-- Name: idx_staging_catalogue_catalogue_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_catalogue_catalogue_ref ON darwin2.staging_catalogue USING btree (import_ref, parent_ref) WHERE (catalogue_ref IS NOT NULL);


--
-- TOC entry 6134 (class 1259 OID 1413534)
-- Name: idx_staging_catalogue_filter; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_catalogue_filter ON darwin2.staging_catalogue USING btree (import_ref, name, level_ref);


--
-- TOC entry 6135 (class 1259 OID 1413535)
-- Name: idx_staging_catalogue_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_catalogue_parent_ref ON darwin2.staging_catalogue USING btree (parent_ref) WHERE (parent_ref IS NOT NULL);


--
-- TOC entry 6136 (class 1259 OID 1413536)
-- Name: idx_staging_catalogue_parent_updated; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_catalogue_parent_updated ON darwin2.staging_catalogue USING btree (parent_updated);


--
-- TOC entry 5804 (class 1259 OID 1413537)
-- Name: idx_staging_import_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_import_ref ON darwin2.staging USING btree (import_ref);


--
-- TOC entry 6145 (class 1259 OID 1413538)
-- Name: idx_staging_people_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_people_record ON darwin2.staging_people USING btree (record_id, referenced_relation);


--
-- TOC entry 6154 (class 1259 OID 1413539)
-- Name: idx_tag_groups_group_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tag_groups_group_name_indexed ON darwin2.tag_groups USING btree (group_name_indexed);


--
-- TOC entry 6155 (class 1259 OID 1413540)
-- Name: idx_tag_groups_group_name_indexed_txt_op; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tag_groups_group_name_indexed_txt_op ON darwin2.tag_groups USING btree (group_name_indexed text_pattern_ops);


--
-- TOC entry 6156 (class 1259 OID 1413541)
-- Name: idx_tag_groups_sub_group_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tag_groups_sub_group_name ON darwin2.tag_groups USING btree (sub_group_name);


--
-- TOC entry 6161 (class 1259 OID 1413542)
-- Name: idx_tags_group_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_group_ref ON darwin2.tags USING btree (group_ref);


--
-- TOC entry 6162 (class 1259 OID 1413543)
-- Name: idx_tags_group_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_group_type ON darwin2.tags USING btree (group_type);


--
-- TOC entry 6163 (class 1259 OID 1413544)
-- Name: idx_tags_gtu_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_gtu_ref ON darwin2.tags USING btree (gtu_ref);


--
-- TOC entry 6164 (class 1259 OID 1413545)
-- Name: idx_tags_sub_group_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_sub_group_type ON darwin2.tags USING btree (sub_group_type);


--
-- TOC entry 6165 (class 1259 OID 1413546)
-- Name: idx_tags_tag_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_tag_indexed ON darwin2.tags USING btree (tag_indexed);


--
-- TOC entry 6166 (class 1259 OID 1413547)
-- Name: idx_tags_trgm; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_trgm ON darwin2.tags USING gin (tag public.gin_trgm_ops);


--
-- TOC entry 5809 (class 1259 OID 1413548)
-- Name: idx_taxonomy_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_taxonomy_level_ref ON darwin2.taxonomy USING btree (level_ref);


--
-- TOC entry 5810 (class 1259 OID 1413549)
-- Name: idx_taxonomy_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_taxonomy_parent_ref ON darwin2.taxonomy USING btree (parent_ref);


--
-- TOC entry 5811 (class 1259 OID 1413550)
-- Name: idx_taxonomy_path; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_taxonomy_path ON darwin2.taxonomy USING btree (path text_pattern_ops);


--
-- TOC entry 5881 (class 1259 OID 1413551)
-- Name: idx_tool_trgm; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tool_trgm ON darwin2.collecting_tools USING gin (tool public.gin_trgm_ops);


--
-- TOC entry 6176 (class 1259 OID 1413552)
-- Name: idx_users_addresses_country; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_addresses_country ON darwin2.users_addresses USING btree (country);


--
-- TOC entry 6177 (class 1259 OID 1413553)
-- Name: idx_users_addresses_person_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_addresses_person_user_ref ON darwin2.users_addresses USING btree (person_user_ref);


--
-- TOC entry 6180 (class 1259 OID 1413554)
-- Name: idx_users_comm_comm_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_comm_comm_type ON darwin2.users_comm USING btree (comm_type);


--
-- TOC entry 6181 (class 1259 OID 1413555)
-- Name: idx_users_comm_person_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_comm_person_user_ref ON darwin2.users_comm USING btree (person_user_ref);


--
-- TOC entry 6190 (class 1259 OID 1413556)
-- Name: idx_users_tracking_action; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_tracking_action ON darwin2.users_tracking USING btree (action);


--
-- TOC entry 6191 (class 1259 OID 1413557)
-- Name: idx_users_tracking_modification_date_time; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_tracking_modification_date_time ON darwin2.users_tracking USING btree (modification_date_time DESC);


--
-- TOC entry 6192 (class 1259 OID 1413558)
-- Name: idx_users_tracking_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_tracking_user_ref ON darwin2.users_tracking USING btree (user_ref);


--
-- TOC entry 6195 (class 1259 OID 1413559)
-- Name: idx_vernacular_names_community_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_vernacular_names_community_indexed ON darwin2.vernacular_names USING btree (community_indexed);


--
-- TOC entry 6196 (class 1259 OID 1413560)
-- Name: idx_vernacular_names_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_vernacular_names_name_indexed ON darwin2.vernacular_names USING btree (name_indexed);


--
-- TOC entry 6197 (class 1259 OID 1413561)
-- Name: idx_vernacular_names_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_vernacular_names_referenced_record ON darwin2.vernacular_names USING btree (referenced_relation, record_id);


--
-- TOC entry 5998 (class 1259 OID 1413562)
-- Name: loan_status_loan_ref_user_ref_status_idx; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE UNIQUE INDEX loan_status_loan_ref_user_ref_status_idx ON darwin2.loan_status USING btree (loan_ref, user_ref, status) WHERE (((status)::text = 'new'::text) OR ((status)::text = 'rejected'::text));


--
-- TOC entry 7465 (class 0 OID 0)
-- Dependencies: 5998
-- Name: INDEX loan_status_loan_ref_user_ref_status_idx; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON INDEX darwin2.loan_status_loan_ref_user_ref_status_idx IS 'added by rmca (ftheeten and jmherpers 2017 11 29)
';


--
-- TOC entry 6115 (class 1259 OID 1413563)
-- Name: specimens_detect_wrong_countrie_gix; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX specimens_detect_wrong_countrie_gix ON darwin2.specimens_detect_wrong_countries USING gist (geom);


--
-- TOC entry 6128 (class 1259 OID 1413564)
-- Name: storage_institution_idex; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX storage_institution_idex ON darwin2.storage_parts USING btree (institution_ref);


--
-- TOC entry 6129 (class 1259 OID 1413565)
-- Name: storage_object_idx; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX storage_object_idx ON darwin2.storage_parts USING btree (object_name);


--
-- TOC entry 6210 (class 1259 OID 1758312)
-- Name: storage_parts_bck_20220513_id_idx; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX storage_parts_bck_20220513_id_idx ON darwin2.storage_parts_bck_20220513 USING btree (id);


--
-- TOC entry 6211 (class 1259 OID 1758313)
-- Name: storage_parts_bck_20220513_specimen_ref_idx; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX storage_parts_bck_20220513_specimen_ref_idx ON darwin2.storage_parts_bck_20220513 USING btree (specimen_ref);


--
-- TOC entry 6130 (class 1259 OID 1413566)
-- Name: storage_parts_id_idx; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX storage_parts_id_idx ON darwin2.storage_parts USING btree (id);


--
-- TOC entry 6131 (class 1259 OID 1413567)
-- Name: storage_parts_specimen_ref_idx; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX storage_parts_specimen_ref_idx ON darwin2.storage_parts USING btree (specimen_ref);


--
-- TOC entry 6132 (class 1259 OID 1413568)
-- Name: storage_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX storage_type ON darwin2.storage_parts USING btree (specimen_status);


--
-- TOC entry 6669 (class 2618 OID 20040)
-- Name: v_darwin_view_for_csv _RETURN; Type: RULE; Schema: darwin2; Owner: darwin2
--

CREATE OR REPLACE VIEW darwin2.v_darwin_view_for_csv AS
 SELECT string_agg(DISTINCT ((a.id)::character varying)::text, '; '::text ORDER BY ((a.id)::character varying)::text DESC) AS id,
    a.collection_code,
    a.code,
    a.additional_codes,
    a.ig_num,
    string_agg(DISTINCT (a.taxon_name)::text, '; '::text) AS taxon_name,
    string_agg(DISTINCT (a.author)::text, '; '::text) AS author,
    string_agg(DISTINCT (a.full_scientific_name)::text, '; '::text) AS full_scientific_name,
    string_agg(DISTINCT (a.family)::text, '; '::text) AS family,
    string_agg(DISTINCT (a.type)::text, '; '::text) AS type,
    a.specimen_count_min,
    a.specimen_count_max,
    string_agg(DISTINCT a.identifiers, '; '::text) AS identifiers,
    string_agg(DISTINCT a.abbreviated_identifiers, '; '::text) AS abbreviated_identifiers,
    string_agg(DISTINCT ((a.identification_year)::character varying)::text, '; '::text) AS identification_year,
    a.longitude_deci AS longitude,
    a.latitude_deci AS latitude,
    a.longitude_text,
    a.latitude_text,
    a.gtu_country_tag_value,
    a.municipality,
    a.region_district,
    a.exact_site,
    a.ecology,
    a.gtu_others_tag_value,
    a.gtu_code,
    a.gtu_elevation,
    a.collecting_year_from,
    a.collecting_month_from,
    a.collecting_day_from,
    a.collecting_year_to,
    a.collecting_month_to,
    a.collecting_day_to,
    string_agg(DISTINCT a.properties_locality, '; '::text) AS properties_locality,
    string_agg(DISTINCT a.collectors, '; '::text) AS collectors,
    string_agg(DISTINCT a.abbreviated_collectors, '; '::text) AS abbreviated_collectors,
    a.expedition_name,
    string_agg(DISTINCT a.donators, '; '::text) AS donators,
    string_agg(DISTINCT a.abbreviated_donators, '; '::text) AS abbreviated_donators,
    a.acquisition_category,
    a.acquisition_date,
    a.sex,
    a.stage,
    a.state,
    a.social_status,
    a.specimen_part,
    a.complete,
    a.object_name,
    a.specimen_status,
    a.container_storage,
    string_agg((a.method)::text, '; '::text) AS method,
    string_agg((a.tool)::text, '; '::text) AS tool,
    string_agg(DISTINCT a.comment, '; '::text) AS comment,
    string_agg(DISTINCT a.properties_all, '; '::text) AS properties_all,
    a.specimen_creation_date
   FROM ( SELECT s.id,
            s.collection_code,
            (((((COALESCE(c.code_prefix, ''::character varying))::text || (COALESCE(c.code_prefix_separator, ''::character varying))::text) || (COALESCE(c.code, ''::character varying))::text) || (COALESCE(c.code_suffix, ''::character varying))::text) || (COALESCE(c.code_suffix_separator, ''::character varying))::text) AS code,
            string_agg(DISTINCT (c2.code)::text, ', '::text) AS additional_codes,
            s.ig_num,
            s.taxon_name AS full_scientific_name,
            (darwin2.fct_rmca_taxonomy_split_name_author(s.taxon_name, s.taxon_level_ref))[1] AS taxon_name,
            (darwin2.fct_rmca_taxonomy_split_name_author(s.taxon_name, s.taxon_level_ref))[2] AS author,
            darwin2.fct_rmca_sort_taxon_get_parent_level_text(s.taxon_ref, 34) AS family,
            s.type,
            s.specimen_count_min,
            s.specimen_count_max,
            array_to_string(array_agg(DISTINCT ident.formated_name), '; '::text) AS identifiers,
                CASE
                    WHEN (ident.given_name IS NULL) THEN (ident.family_name)::text
                    ELSE ((btrim((ident.family_name)::text) || ' '::text) || btrim((darwin2.fct_rmca_abbreviate_names(ident.given_name))::text))
                END AS abbreviated_identifiers,
            date_part('year'::text, i.notion_date) AS identification_year,
            s.gtu_country_tag_value,
            array_to_string(array_agg(DISTINCT municipality.tag), '; '::text) AS municipality,
            array_to_string(array_agg(DISTINCT region_district.tag), '; '::text) AS region_district,
            array_to_string(array_agg(DISTINCT exact_site.tag), '; '::text) AS exact_site,
            array_to_string(array_agg(DISTINCT ecology.tag), '; '::text) AS ecology,
            s.gtu_others_tag_value,
            s.gtu_code,
            s.gtu_location[0] AS latitude_deci,
            s.gtu_location[1] AS longitude_deci,
            darwin2.rmca_dms_to_text(gtu.coordinates_source, gtu.latitude_dms_degree, gtu.latitude_dms_minutes, gtu.latitude_dms_seconds, gtu.latitude_dms_direction, gtu.latitude, 'lat'::character varying) AS latitude_text,
            darwin2.rmca_dms_to_text(gtu.coordinates_source, gtu.longitude_dms_degree, gtu.longitude_dms_minutes, gtu.longitude_dms_seconds, gtu.longitude_dms_direction, gtu.longitude, 'lon'::character varying) AS longitude_text,
            s.gtu_elevation,
                CASE
                    WHEN (s.gtu_from_date_mask >= 32) THEN date_part('year'::text, s.gtu_from_date)
                    ELSE NULL::double precision
                END AS collecting_year_from,
                CASE
                    WHEN (s.gtu_from_date_mask >= 48) THEN date_part('month'::text, s.gtu_from_date)
                    ELSE NULL::double precision
                END AS collecting_month_from,
                CASE
                    WHEN (s.gtu_from_date_mask >= 56) THEN date_part('day'::text, s.gtu_from_date)
                    ELSE NULL::double precision
                END AS collecting_day_from,
                CASE
                    WHEN (s.gtu_to_date_mask >= 32) THEN date_part('year'::text, s.gtu_to_date)
                    ELSE NULL::double precision
                END AS collecting_year_to,
                CASE
                    WHEN (s.gtu_to_date_mask >= 48) THEN date_part('month'::text, s.gtu_to_date)
                    ELSE NULL::double precision
                END AS collecting_month_to,
                CASE
                    WHEN (s.gtu_to_date_mask >= 56) THEN date_part('day'::text, s.gtu_to_date)
                    ELSE NULL::double precision
                END AS collecting_day_to,
            array_to_string(array_agg(DISTINCT (((locp.property_type)::text || ': '::text) || (locp.lower_value)::text)), '; '::text) AS properties_locality,
            array_to_string(array_agg(DISTINCT recol.formated_name), '; '::text) AS collectors,
                CASE
                    WHEN (recol.given_name IS NULL) THEN (recol.family_name)::text
                    ELSE ((btrim((recol.family_name)::text) || ' '::text) || btrim((darwin2.fct_rmca_abbreviate_names(recol.given_name))::text))
                END AS abbreviated_collectors,
            s.expedition_name,
            array_to_string(array_agg(DISTINCT donator.formated_name), '; '::text) AS donators,
                CASE
                    WHEN (donator.given_name IS NULL) THEN (donator.family_name)::text
                    ELSE ((btrim((donator.family_name)::text) || ' '::text) || btrim((darwin2.fct_rmca_abbreviate_names(donator.given_name))::text))
                END AS abbreviated_donators,
            s.acquisition_category,
            darwin2.fct_mask_date((s.acquisition_date)::timestamp without time zone, s.acquisition_date_mask) AS acquisition_date,
            s.sex,
            s.stage,
            s.state,
            s.social_status,
            string_agg(DISTINCT (sp.specimen_part)::text, ';'::text ORDER BY (sp.specimen_part)::text) AS specimen_part,
            string_agg(DISTINCT ((sp.complete)::character varying)::text, ';'::text ORDER BY ((sp.complete)::character varying)::text) AS complete,
            string_agg(DISTINCT sp.object_name, ';'::text ORDER BY sp.object_name) AS object_name,
            col_meth.method,
            col_tool.tool,
            string_agg(DISTINCT (sp.specimen_status)::text, ';'::text ORDER BY (sp.specimen_status)::text) AS specimen_status,
            string_agg(DISTINCT (sp.container_storage)::text, ';'::text ORDER BY (sp.container_storage)::text) AS container_storage,
            array_to_string(array_agg(DISTINCT (((comm.notion_concerned)::text || ': '::text) || comm.comment)), '| '::text) AS comment,
            array_to_string(array_agg(DISTINCT (((((p.property_type)::text || (': '::character varying)::text) || (p.lower_value)::text) || COALESCE((('-'::character varying)::text || (p.upper_value)::text), ''::text)) || COALESCE(((' '::character varying)::text || (p.property_unit)::text), ''::text))), '| '::text) AS properties_all,
            s.specimen_creation_date
           FROM (((((((((((((((((((((((((darwin2.specimens s
             LEFT JOIN darwin2.codes c ON (((s.id = c.record_id) AND ((c.referenced_relation)::text = 'specimens'::text) AND ((c.code_category)::text = 'main'::text))))
             LEFT JOIN darwin2.storage_parts sp ON ((s.id = sp.specimen_ref)))
             LEFT JOIN darwin2.codes c2 ON (((s.id = c2.record_id) AND ((c2.referenced_relation)::text = 'specimens'::text) AND ((c2.code_category)::text <> 'main'::text))))
             LEFT JOIN darwin2.identifications i ON ((((i.referenced_relation)::text = 'specimens'::text) AND (s.id = i.record_id))))
             LEFT JOIN darwin2.catalogue_people cp1 ON ((((cp1.referenced_relation)::text = 'identifications'::text) AND (i.id = cp1.record_id))))
             LEFT JOIN darwin2.people ident ON ((cp1.people_ref = ident.id)))
             LEFT JOIN darwin2.tags municipality ON (((s.gtu_ref = municipality.gtu_ref) AND (lower((municipality.sub_group_type)::text) ~~ '%municipality%'::text))))
             LEFT JOIN darwin2.tags region_district ON (((s.gtu_ref = region_district.gtu_ref) AND (lower((region_district.sub_group_type)::text) ~~ '%region or district%'::text))))
             LEFT JOIN darwin2.tags exact_site ON (((s.gtu_ref = exact_site.gtu_ref) AND (lower((exact_site.sub_group_type)::text) ~~ '%exact_site%'::text))))
             LEFT JOIN darwin2.tags ecology ON (((s.gtu_ref = ecology.gtu_ref) AND (lower((ecology.sub_group_type)::text) ~~ '%ecology%'::text))))
             LEFT JOIN darwin2.gtu ON ((s.gtu_ref = gtu.id)))
             LEFT JOIN darwin2.properties locp ON ((((locp.referenced_relation)::text = 'gtu'::text) AND (gtu.id = locp.record_id))))
             LEFT JOIN darwin2.catalogue_people cp2 ON ((((cp2.referenced_relation)::text = 'specimens'::text) AND ((cp2.people_type)::text = 'collector'::text) AND (s.id = cp2.record_id))))
             LEFT JOIN darwin2.people recol ON ((cp2.people_ref = recol.id)))
             LEFT JOIN darwin2.catalogue_people cp3 ON ((((cp3.referenced_relation)::text = 'specimens'::text) AND ((cp3.people_type)::text = 'donator'::text) AND (s.id = cp3.record_id))))
             LEFT JOIN darwin2.people donator ON ((cp3.people_ref = donator.id)))
             LEFT JOIN darwin2.properties males ON ((((males.referenced_relation)::text = 'specimens'::text) AND ((males.property_type)::text = 'N males'::text) AND (s.id = males.record_id))))
             LEFT JOIN darwin2.properties females ON ((((females.referenced_relation)::text = 'specimens'::text) AND ((females.property_type)::text = 'N females'::text) AND (s.id = females.record_id))))
             LEFT JOIN darwin2.properties juveniles ON ((((juveniles.referenced_relation)::text = 'specimens'::text) AND ((juveniles.property_type)::text = 'N juveniles'::text) AND (s.id = juveniles.record_id))))
             LEFT JOIN darwin2.comments comm ON ((((comm.referenced_relation)::text = 'specimens'::text) AND (s.id = comm.record_id))))
             LEFT JOIN darwin2.properties p ON ((((p.referenced_relation)::text = 'specimens'::text) AND (s.id = p.record_id))))
             LEFT JOIN darwin2.specimen_collecting_methods s_col_meth ON ((s.id = s_col_meth.specimen_ref)))
             LEFT JOIN darwin2.collecting_methods col_meth ON ((s_col_meth.collecting_method_ref = col_meth.id)))
             LEFT JOIN darwin2.specimen_collecting_tools s_col_tool ON ((s.id = s_col_tool.specimen_ref)))
             LEFT JOIN darwin2.collecting_tools col_tool ON ((s_col_tool.collecting_tool_ref = col_tool.id)))
          GROUP BY s.id, c.code_prefix, c.code_prefix_separator, c.code, c.code_suffix, c.code_suffix_separator, i.id, col_tool.tool, col_meth.method, ident.given_name, ident.family_name, recol.given_name, recol.family_name, donator.given_name, donator.family_name, gtu.coordinates_source, gtu.latitude_dms_degree, gtu.latitude_dms_minutes, gtu.latitude_dms_seconds, gtu.latitude_dms_direction, gtu.latitude, gtu.longitude_dms_degree, gtu.longitude_dms_minutes, gtu.longitude_dms_seconds, gtu.longitude_dms_direction, gtu.longitude) a
  GROUP BY a.collection_code, a.code, a.additional_codes, a.ig_num, a.specimen_count_min, a.specimen_count_max, a.gtu_country_tag_value, a.municipality, a.region_district, a.exact_site, a.ecology, a.gtu_others_tag_value, a.gtu_code, a.gtu_elevation, a.collecting_year_from, a.collecting_month_from, a.collecting_day_from, a.collecting_year_to, a.collecting_month_to, a.collecting_day_to, a.expedition_name, a.specimen_creation_date, a.acquisition_category, a.acquisition_date, a.sex, a.stage, a.state, a.social_status, a.specimen_part, a.complete, a.object_name, a.specimen_status, a.container_storage, a.longitude_deci, a.latitude_deci, a.latitude_text, a.longitude_text
  ORDER BY a.code;


--
-- TOC entry 6684 (class 2618 OID 20127)
-- Name: v_loan_details_for_pentaho _RETURN; Type: RULE; Schema: darwin2; Owner: darwin2
--

CREATE OR REPLACE VIEW darwin2.v_loan_details_for_pentaho AS
 SELECT a.id,
    a.loan_ref,
    a.ig_ref,
    a.from_date,
    a.to_date,
    a.specimen_ref,
    a.details,
    b.taxon_name,
    c.code,
    array_agg(d.lower_value) AS array_agg,
    regexp_replace(regexp_replace(((((COALESCE(((a.details)::text || chr(10))) || (a.specimen_count)::text) || chr(10)) || (a.specimen_part)::text) || chr(10)), '^\s+'::text, ''::text), '\s+$'::text, ''::text) AS detail_loan,
    b.type,
    f.category,
    f.specimen_part,
    f.specimen_status,
    btrim(((((COALESCE(f.category, ''::character varying))::text || COALESCE((', '::text || NULLIF(replace((f.specimen_part)::text, 'specimen'::text, ''::text), ''::text)), ''::text)) || COALESCE((', '::text || NULLIF((f.specimen_status)::text, ''::text)), ''::text)) || COALESCE((', '::text || NULLIF(replace((b.type)::text, 'specimen'::text, ''::text), ''::text)), ''::text))) AS loan_remarks,
    e.id AS loan_id,
    e.name AS loan_name,
    b.collection_ref
   FROM (((((darwin2.loan_items a
     JOIN darwin2.specimens b ON ((a.specimen_ref = b.id)))
     JOIN darwin2.codes c ON (((b.id = c.record_id) AND ((c.referenced_relation)::text = 'specimens'::text) AND ((c.code_category)::text = 'main'::text))))
     LEFT JOIN darwin2.properties d ON (((b.id = d.record_id) AND ((d.referenced_relation)::text = 'specimens'::text))))
     JOIN darwin2.loans e ON ((a.loan_ref = e.id)))
     LEFT JOIN darwin2.storage_parts f ON ((b.id = f.specimen_ref)))
  GROUP BY a.id, a.loan_ref, a.ig_ref, a.from_date, a.to_date, a.specimen_ref, a.details, b.taxon_name, c.code, b.type, f.category, f.specimen_part, f.specimen_status, e.id, b.collection_ref, b.specimen_count_males_min, b.specimen_count_females_min, b.specimen_count_juveniles_min, b.specimen_count_min;


--
-- TOC entry 6688 (class 2618 OID 20146)
-- Name: v_loans_pentaho_receivers _RETURN; Type: RULE; Schema: darwin2; Owner: darwin2
--

CREATE OR REPLACE VIEW darwin2.v_loans_pentaho_receivers AS
 SELECT a.id,
    a.name,
    a.description,
    a.search_indexed,
    a.from_date,
    a.to_date,
    a.extended_to_date,
    string_agg(((c.id)::character varying)::text, ', '::text ORDER BY c.id) AS receiver_id,
    string_agg((c.formated_name)::text, ', '::text ORDER BY c.id) AS receiver,
        CASE
            WHEN (COALESCE(btrim((a.institution_receiver)::text), ''::text) = ''::text) THEN ((btrim(string_agg(COALESCE((g.formated_name)::text, (h.entry)::text), ', '::text ORDER BY c.id)))::character varying)::text
            ELSE
            CASE "position"((a.institution_receiver)::text, '§§§'::text)
                WHEN 0 THEN (a.institution_receiver)::text
                ELSE "substring"((a.institution_receiver)::text, 1, ("position"((a.institution_receiver)::text, '§§§'::text) - 1))
            END
        END AS institution_receiver,
        CASE
            WHEN (COALESCE(btrim((a.address_receiver)::text), ''::text) = ''::text) THEN btrim(btrim(NULLIF(string_agg(btrim((((((COALESCE((NULLIF((h.entry)::text, ''::text) || ', '::text), ''::text) || COALESCE((NULLIF((h.extended_address)::text, ''::text) || ', '::text), ''::text)) || COALESCE((NULLIF((h.locality)::text, ''::text) || ', '::text), ''::text)) || COALESCE((NULLIF((h.po_box)::text, ''::text) || ', '::text), ''::text)) || COALESCE((NULLIF((h.region)::text, ''::text) || ', '::text), ''::text)) || COALESCE((NULLIF((h.zip_code)::text, ''::text) || ', '::text), ''::text))), ', '::text ORDER BY c.id), ', '::text), ','::text))
            ELSE btrim(btrim(NULLIF(string_agg(btrim(((COALESCE((NULLIF((a.address_receiver)::text, ''::text) || ', '::text), ''::text) || COALESCE((NULLIF((a.zip_receiver)::text, ''::text) || ', '::text), ''::text)) || COALESCE((NULLIF((a.city_receiver)::text, ''::text) || ', '::text), ''::text))), ', '::text ORDER BY c.id), ', '::text), ','::text))
        END AS address_institution,
        CASE
            WHEN (COALESCE(btrim((a.country_receiver)::text), ''::text) = ''::text) THEN (btrim(NULLIF(string_agg(COALESCE(NULLIF((h.country)::text, ''::text), ''::text), ', '::text ORDER BY c.id), ', '::text), ','::text))::character varying
            ELSE a.country_receiver
        END AS country_institution,
    e.id AS sender_id,
    e.formated_name AS sender,
    string_agg((i.entry)::text, ', '::text) AS receiver_email,
    string_agg((j.entry)::text, ', '::text) AS receiver_tel,
    string_agg((f2.person_user_role)::text, ', '::text) AS contact_sender_role,
    a.collection_manager,
    a.collection_manager_title,
    a.collection_manager_mail
   FROM (((((((((((darwin2.loans a
     LEFT JOIN darwin2.catalogue_people b ON (((a.id = b.record_id) AND ((b.referenced_relation)::text = 'loans'::text) AND ((b.people_type)::text = 'receiver'::text) AND (b.order_by = ( SELECT min(cp.order_by) AS min
           FROM darwin2.catalogue_people cp
          WHERE ((cp.record_id = b.record_id) AND ((cp.referenced_relation)::text = 'loans'::text) AND ((cp.people_type)::text = 'receiver'::text) AND ((((cp.people_sub_type)::integer & 2) = 2) OR (((cp.people_sub_type)::integer & 4) = 4))))))))
     LEFT JOIN darwin2.people c ON ((c.id = b.people_ref)))
     LEFT JOIN darwin2.catalogue_people d ON (((a.id = d.record_id) AND ((d.referenced_relation)::text = 'loans'::text) AND ((d.people_type)::text = 'sender'::text))))
     LEFT JOIN darwin2.people e ON ((e.id = d.people_ref)))
     LEFT JOIN darwin2.people_relationships f ON (((((f.relationship_type)::text = 'works for'::text) OR ((f.relationship_type)::text = 'belongs to'::text)) AND (c.id = f.person_2_ref))))
     LEFT JOIN darwin2.v_loan_detail_role_person f1 ON ((((f1.referenced_relation)::text = 'loans'::text) AND ((f1.people_type)::text = 'sender'::text) AND (f1.record_id = a.id) AND (f1.contact = true) AND (f1.people_ref = d.people_ref))))
     LEFT JOIN darwin2.people_relationships f2 ON (((((f2.relationship_type)::text = 'works for'::text) OR ((f2.relationship_type)::text = 'belongs to'::text)) AND (f2.person_2_ref = f1.people_ref))))
     LEFT JOIN darwin2.people g ON ((f.person_1_ref = g.id)))
     LEFT JOIN darwin2.people_addresses h ON ((COALESCE(g.id, c.id) = h.person_user_ref)))
     LEFT JOIN darwin2.people_comm i ON (((i.person_user_ref = b.people_ref) AND ((i.comm_type)::text = 'e-mail'::text))))
     LEFT JOIN darwin2.people_comm j ON (((j.person_user_ref = b.people_ref) AND ((j.comm_type)::text = 'phone/fax'::text))))
  GROUP BY a.id, e.id, b.people_sub_type;


--
-- TOC entry 6721 (class 2618 OID 20308)
-- Name: v_rmca_report_ig_ichtyo_2_localities _RETURN; Type: RULE; Schema: darwin2; Owner: darwin2
--

CREATE OR REPLACE VIEW darwin2.v_rmca_report_ig_ichtyo_2_localities AS
 SELECT igs.id,
    specimens.gtu_country_tag_value AS country,
    gtu.id AS id_gtu,
    btrim(regexp_replace(replace(array_to_string(tags.tags, (', '::character varying)::text), (specimens.gtu_country_tag_value)::text, (''::character varying)::text), ('^,'::character varying)::text, (''::character varying)::text)) AS locality,
        CASE
            WHEN (upper((gtu.coordinates_source)::text) = ('DD'::character varying)::text) THEN COALESCE(((((((abs(round((gtu.latitude)::numeric, 5)))::character varying)::text || (
            CASE
                WHEN (gtu.latitude < (0)::double precision) THEN 'S'::character varying
                ELSE 'N'::character varying
            END)::text) || (' '::character varying)::text) || ((abs(round((gtu.longitude)::numeric, 5)))::character varying)::text) || (
            CASE
                WHEN (gtu.longitude < (0)::double precision) THEN 'W'::character varying
                ELSE 'E'::character varying
            END)::text), (''::character varying)::text)
            WHEN (upper((gtu.coordinates_source)::text) = ('DMS'::character varying)::text) THEN (((((((COALESCE((((gtu.latitude_dms_degree)::character varying)::text || ('°'::character varying)::text), (''::character varying)::text) || COALESCE(((((gtu.latitude_dms_minutes)::numeric)::character varying)::text || (''''::character varying)::text), (''::character varying)::text)) || COALESCE(((((gtu.latitude_dms_seconds)::numeric)::character varying)::text || ('"'::character varying)::text), (''::character varying)::text)) || (
            CASE
                WHEN (gtu.latitude_dms_direction >= 1) THEN 'N'::character varying
                WHEN (gtu.latitude_dms_direction <= '-1'::integer) THEN 'S'::character varying
                ELSE ''::character varying
            END)::text) || COALESCE((((', '::character varying)::text || ((gtu.longitude_dms_degree)::character varying)::text) || ('°'::character varying)::text), (''::character varying)::text)) || COALESCE(((((gtu.longitude_dms_minutes)::numeric)::character varying)::text || (''''::character varying)::text), (''::character varying)::text)) || COALESCE(((((gtu.longitude_dms_seconds)::numeric)::character varying)::text || ('"'::character varying)::text), (''::character varying)::text)) || (
            CASE
                WHEN (gtu.longitude_dms_direction >= 1) THEN 'E'::character varying
                WHEN (gtu.longitude_dms_direction <= '-1'::integer) THEN '>'::character varying
                ELSE ''::character varying
            END)::text)
            WHEN (upper((gtu.coordinates_source)::text) = ('UTM'::character varying)::text) THEN COALESCE(((((((', '::character varying)::text || ((gtu.latitude_utm)::character varying)::text) || (' '::character varying)::text) || ((gtu.longitude_utm)::character varying)::text) || (' '::character varying)::text) || (gtu.utm_zone)::text), (''::character varying)::text)
            ELSE (((((((COALESCE((((gtu.latitude_dms_degree)::character varying)::text || ('°'::character varying)::text), (''::character varying)::text) || COALESCE(((((gtu.latitude_dms_minutes)::numeric)::character varying)::text || (''''::character varying)::text), (''::character varying)::text)) || COALESCE(((((gtu.latitude_dms_seconds)::numeric)::character varying)::text || ('"'::character varying)::text), (''::character varying)::text)) || (
            CASE
                WHEN (gtu.latitude_dms_direction >= 1) THEN 'N'::character varying
                WHEN (gtu.latitude_dms_direction <= '-1'::integer) THEN 'S'::character varying
                ELSE ''::character varying
            END)::text) || COALESCE((((', '::character varying)::text || ((gtu.longitude_dms_degree)::character varying)::text) || ('°'::character varying)::text), (''::character varying)::text)) || COALESCE(((((gtu.longitude_dms_minutes)::numeric)::character varying)::text || (''''::character varying)::text), (''::character varying)::text)) || COALESCE(((((gtu.longitude_dms_seconds)::numeric)::character varying)::text || ('"'::character varying)::text), (''::character varying)::text)) || (
            CASE
                WHEN (gtu.longitude_dms_direction >= 1) THEN 'E'::character varying
                WHEN (gtu.longitude_dms_direction <= '-1'::integer) THEN '>'::character varying
                ELSE ''::character varying
            END)::text)
        END AS coordinates_text,
    min(darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask)) AS date_min,
    NULLIF(max(darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask)), min(darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask))) AS date_max,
    string_agg(replace((v_rmca_count_ichtyology_by_number.code)::text, ((igs.ig_num)::text || ('.'::character varying)::text), (''::character varying)::text), (' '::character varying)::text ORDER BY v_rmca_count_ichtyology_by_number.code) AS collections_numbers,
    sum(v_rmca_count_ichtyology_by_number.counter) AS sum
   FROM ((((darwin2.igs
     LEFT JOIN darwin2.specimens ON ((igs.id = specimens.ig_ref)))
     LEFT JOIN darwin2.v_rmca_count_vertebrates_drosera_by_number v_rmca_count_ichtyology_by_number ON ((specimens.id = v_rmca_count_ichtyology_by_number.record_id)))
     LEFT JOIN darwin2.gtu ON ((specimens.gtu_ref = gtu.id)))
     LEFT JOIN ( SELECT array_agg(tags_1.tag ORDER BY tags_1.group_ref) AS tags,
            array_agg(tags_1.group_type ORDER BY tags_1.group_ref) AS group_types,
            tags_1.gtu_ref
           FROM darwin2.tags tags_1
          GROUP BY tags_1.gtu_ref) tags ON ((gtu.id = tags.gtu_ref)))
  GROUP BY igs.id, specimens.gtu_country_tag_value, gtu.id, tags.tags, tags.group_types
  ORDER BY specimens.gtu_country_tag_value, tags.tags, tags.group_types;


--
-- TOC entry 6733 (class 2618 OID 20365)
-- Name: v_taxonomy_split_author_fast _RETURN; Type: RULE; Schema: darwin2; Owner: darwin2
--

CREATE OR REPLACE VIEW darwin2.v_taxonomy_split_author_fast AS
 WITH a AS (
         SELECT regexp_matches((taxonomy.name)::text, '^[A-Z].+?\s(\(.+?|[A-Z].+?|d''.+?|de\s.+?|van\s.+?)$'::text) AS split_t,
            taxonomy.name,
            taxonomy.name_indexed,
            taxonomy.level_ref,
            taxonomy.status,
            taxonomy.local_naming,
            taxonomy.color,
            taxonomy.path,
            taxonomy.parent_ref,
            taxonomy.id,
            taxonomy.extinct,
            taxonomy.sensitive_info_withheld,
            taxonomy.is_reference_taxonomy,
            taxonomy.metadata_ref,
            taxonomy.taxonomy_creation_date,
            taxonomy.import_ref,
            taxonomy.cites
           FROM darwin2.taxonomy
        ), b AS (
         SELECT a.split_t,
            a.name,
            a.name_indexed,
            a.level_ref,
            a.status,
            a.local_naming,
            a.color,
            a.path,
            a.parent_ref,
            a.id,
            a.extinct,
            a.sensitive_info_withheld,
            a.is_reference_taxonomy,
            a.metadata_ref,
            a.taxonomy_creation_date,
            a.import_ref,
            a.cites
           FROM a
        UNION
         SELECT array_agg(''::character varying) AS array_agg,
            taxonomy.name,
            taxonomy.name_indexed,
            taxonomy.level_ref,
            taxonomy.status,
            taxonomy.local_naming,
            taxonomy.color,
            taxonomy.path,
            taxonomy.parent_ref,
            taxonomy.id,
            taxonomy.extinct,
            taxonomy.sensitive_info_withheld,
            taxonomy.is_reference_taxonomy,
            taxonomy.metadata_ref,
            taxonomy.taxonomy_creation_date,
            taxonomy.import_ref,
            taxonomy.cites
           FROM (darwin2.taxonomy
             LEFT JOIN a ON ((taxonomy.id = a.id)))
          WHERE (a.id IS NULL)
          GROUP BY taxonomy.id
        )
 SELECT b.id,
    b.name,
    b.name_indexed,
    b.level_ref,
    b.status,
    b.local_naming,
    b.color,
    b.path,
    b.parent_ref,
    b.extinct,
    b.sensitive_info_withheld,
    b.metadata_ref,
    b.taxonomy_creation_date,
    btrim(replace((b.name)::text, b.split_t[1], ''::text)) AS name_no_author,
    btrim(b.split_t[1]) AS author
   FROM b;


--
-- TOC entry 6361 (class 2620 OID 1413574)
-- Name: collections fct_chk_peopleismoral_collections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_chk_peopleismoral_collections AFTER INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_peopleismoral();


--
-- TOC entry 6346 (class 2620 OID 1413575)
-- Name: codes fct_cpy_trg_del_dict_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_codes AFTER DELETE OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6356 (class 2620 OID 1413576)
-- Name: collection_maintenance fct_cpy_trg_del_dict_collection_maintenance; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_collection_maintenance AFTER DELETE OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6390 (class 2620 OID 1413577)
-- Name: identifications fct_cpy_trg_del_dict_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_identifications AFTER DELETE OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6397 (class 2620 OID 1413578)
-- Name: identifiers fct_cpy_trg_del_dict_identifiers; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_identifiers AFTER DELETE OR UPDATE ON darwin2.identifiers FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6408 (class 2620 OID 1413579)
-- Name: insurances fct_cpy_trg_del_dict_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_insurances AFTER DELETE OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6428 (class 2620 OID 1413580)
-- Name: loan_status fct_cpy_trg_del_dict_loan_status; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_loan_status AFTER DELETE OR UPDATE ON darwin2.loan_status FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6438 (class 2620 OID 1413581)
-- Name: mineralogy fct_cpy_trg_del_dict_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_mineralogy AFTER DELETE OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6451 (class 2620 OID 1413582)
-- Name: people fct_cpy_trg_del_dict_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_people AFTER DELETE OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6431 (class 2620 OID 1413583)
-- Name: loans fct_cpy_trg_del_dict_people_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_people_addresses AFTER DELETE OR UPDATE ON darwin2.loans FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6457 (class 2620 OID 1413584)
-- Name: people_addresses fct_cpy_trg_del_dict_people_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_people_addresses AFTER DELETE OR UPDATE ON darwin2.people_addresses FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6463 (class 2620 OID 1413585)
-- Name: properties fct_cpy_trg_del_dict_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_properties AFTER DELETE OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6471 (class 2620 OID 1413586)
-- Name: specimens fct_cpy_trg_del_dict_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_specimens AFTER DELETE OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6485 (class 2620 OID 1413587)
-- Name: specimens_relationships fct_cpy_trg_del_dict_specimens_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_specimens_relationships AFTER DELETE OR UPDATE ON darwin2.specimens_relationships FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6490 (class 2620 OID 1413588)
-- Name: storage_parts fct_cpy_trg_del_dict_storage_parts; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_storage_parts AFTER DELETE OR UPDATE ON darwin2.storage_parts FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6499 (class 2620 OID 1413589)
-- Name: tag_groups fct_cpy_trg_del_dict_tag_groups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_tag_groups AFTER DELETE OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6508 (class 2620 OID 1413590)
-- Name: users fct_cpy_trg_del_dict_users; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_users AFTER DELETE OR UPDATE ON darwin2.users FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6513 (class 2620 OID 1413591)
-- Name: users_addresses fct_cpy_trg_del_dict_users_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_users_addresses AFTER DELETE OR UPDATE ON darwin2.users_addresses FOR EACH ROW EXECUTE FUNCTION darwin2.trg_del_dict();


--
-- TOC entry 6350 (class 2620 OID 1413592)
-- Name: codes fct_cpy_trg_ins_update_dict_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_codes AFTER INSERT OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6357 (class 2620 OID 1413593)
-- Name: collection_maintenance fct_cpy_trg_ins_update_dict_collection_maintenance; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_collection_maintenance AFTER INSERT OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6391 (class 2620 OID 1413594)
-- Name: identifications fct_cpy_trg_ins_update_dict_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_identifications AFTER INSERT OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6398 (class 2620 OID 1413595)
-- Name: identifiers fct_cpy_trg_ins_update_dict_identifiers; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_identifiers AFTER INSERT OR UPDATE ON darwin2.identifiers FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6409 (class 2620 OID 1413596)
-- Name: insurances fct_cpy_trg_ins_update_dict_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_insurances AFTER INSERT OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6429 (class 2620 OID 1413597)
-- Name: loan_status fct_cpy_trg_ins_update_dict_loan_status; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_loan_status AFTER INSERT OR UPDATE ON darwin2.loan_status FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6439 (class 2620 OID 1413598)
-- Name: mineralogy fct_cpy_trg_ins_update_dict_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_mineralogy AFTER INSERT OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6452 (class 2620 OID 1413599)
-- Name: people fct_cpy_trg_ins_update_dict_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_people AFTER INSERT OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6432 (class 2620 OID 1413600)
-- Name: loans fct_cpy_trg_ins_update_dict_people_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_people_addresses AFTER INSERT OR UPDATE ON darwin2.loans FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6458 (class 2620 OID 1413601)
-- Name: people_addresses fct_cpy_trg_ins_update_dict_people_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_people_addresses AFTER INSERT OR UPDATE ON darwin2.people_addresses FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6464 (class 2620 OID 1413602)
-- Name: properties fct_cpy_trg_ins_update_dict_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_properties AFTER INSERT OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6472 (class 2620 OID 1413603)
-- Name: specimens fct_cpy_trg_ins_update_dict_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_specimens AFTER INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6486 (class 2620 OID 1413604)
-- Name: specimens_relationships fct_cpy_trg_ins_update_dict_specimens_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_specimens_relationships AFTER INSERT OR UPDATE ON darwin2.specimens_relationships FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6491 (class 2620 OID 1413605)
-- Name: storage_parts fct_cpy_trg_ins_update_dict_storage_parts; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_storage_parts AFTER INSERT OR UPDATE ON darwin2.storage_parts FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6500 (class 2620 OID 1413606)
-- Name: tag_groups fct_cpy_trg_ins_update_dict_tag_groups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_tag_groups AFTER INSERT OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6509 (class 2620 OID 1413607)
-- Name: users fct_cpy_trg_ins_update_dict_users; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_users AFTER INSERT OR UPDATE ON darwin2.users FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6514 (class 2620 OID 1413608)
-- Name: users_addresses fct_cpy_trg_ins_update_dict_users_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_users_addresses AFTER INSERT OR UPDATE ON darwin2.users_addresses FOR EACH ROW EXECUTE FUNCTION darwin2.trg_ins_update_dict();


--
-- TOC entry 6433 (class 2620 OID 1413609)
-- Name: loans fct_rmca_cpy_trg_ins_update_people_instit; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_rmca_cpy_trg_ins_update_people_instit AFTER UPDATE ON darwin2.loans FOR EACH ROW EXECUTE FUNCTION darwin2.trg_rmca_ins_update_people_and_address();


--
-- TOC entry 6482 (class 2620 OID 1868048)
-- Name: specimens fct_trg_rmca_collection_full_path_in_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_trg_rmca_collection_full_path_in_specimens BEFORE INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.fct_rmca_collection_full_path_in_specimens();


--
-- TOC entry 6473 (class 2620 OID 1413610)
-- Name: specimens fct_trg_rmca_create_uuid; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_trg_rmca_create_uuid AFTER INSERT ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.trg_rmca_create_uuid();


--
-- TOC entry 6403 (class 2620 OID 1413611)
-- Name: imports fct_trg_rmca_del_import_related; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_trg_rmca_del_import_related BEFORE DELETE OR UPDATE ON darwin2.imports FOR EACH ROW EXECUTE FUNCTION darwin2.trg_rmca_del_import_related();


--
-- TOC entry 6404 (class 2620 OID 1413612)
-- Name: imports fct_trg_rmca_import_taxonomy_history; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_trg_rmca_import_taxonomy_history BEFORE INSERT OR UPDATE ON darwin2.imports FOR EACH ROW EXECUTE FUNCTION darwin2.trg_rmca_import_taxonomy_history();


--
-- TOC entry 6434 (class 2620 OID 1413613)
-- Name: loans trg_add_status_history; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_add_status_history AFTER INSERT ON darwin2.loans FOR EACH ROW EXECUTE FUNCTION darwin2.fct_auto_insert_status_history();


--
-- TOC entry 6494 (class 2620 OID 1413614)
-- Name: staging_catalogue trg_catalogue_import_keywords_update; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_catalogue_import_keywords_update AFTER INSERT OR DELETE OR UPDATE ON darwin2.staging_catalogue FOR EACH ROW EXECUTE FUNCTION darwin2.fct_catalogue_import_keywords_update();


--
-- TOC entry 6372 (class 2620 OID 1413615)
-- Name: collections_rights trg_chk_canupdatecollectionsrights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_canupdatecollectionsrights BEFORE UPDATE ON darwin2.collections_rights FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_canupdatecollectionsrights();


--
-- TOC entry 6405 (class 2620 OID 1413616)
-- Name: informative_workflow trg_chk_is_last_informative_workflow; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_is_last_informative_workflow BEFORE INSERT ON darwin2.informative_workflow FOR EACH ROW EXECUTE FUNCTION darwin2.fct_remove_last_flag();


--
-- TOC entry 6430 (class 2620 OID 1413617)
-- Name: loan_status trg_chk_is_last_loan_status; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_is_last_loan_status BEFORE INSERT ON darwin2.loan_status FOR EACH ROW EXECUTE FUNCTION darwin2.fct_remove_last_flag_loan();


--
-- TOC entry 6362 (class 2620 OID 1413618)
-- Name: collections trg_chk_parentcollinstitution; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_parentcollinstitution BEFORE INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_parentcollinstitution();


--
-- TOC entry 6332 (class 2620 OID 1413619)
-- Name: chronostratigraphy trg_chk_possible_upper_level_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_chronostratigraphy AFTER INSERT OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 6413 (class 2620 OID 1413620)
-- Name: lithology trg_chk_possible_upper_level_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_lithology AFTER INSERT OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 6420 (class 2620 OID 1413621)
-- Name: lithostratigraphy trg_chk_possible_upper_level_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_lithostratigraphy AFTER INSERT OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 6440 (class 2620 OID 1413622)
-- Name: mineralogy trg_chk_possible_upper_level_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_mineralogy AFTER INSERT OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 6314 (class 2620 OID 1413623)
-- Name: taxonomy trg_chk_possible_upper_level_taxonomy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_taxonomy AFTER INSERT OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 6347 (class 2620 OID 1413624)
-- Name: codes trg_chk_ref_record_catalogue_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_catalogue_codes AFTER INSERT OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6327 (class 2620 OID 1413625)
-- Name: catalogue_people trg_chk_ref_record_catalogue_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_catalogue_people AFTER INSERT OR UPDATE ON darwin2.catalogue_people FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6341 (class 2620 OID 1413626)
-- Name: classification_synonymies trg_chk_ref_record_classification_synonymies; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_classification_synonymies AFTER INSERT OR UPDATE ON darwin2.classification_synonymies FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6358 (class 2620 OID 1413627)
-- Name: collection_maintenance trg_chk_ref_record_collection_maintenance; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_collection_maintenance AFTER INSERT OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6376 (class 2620 OID 1413628)
-- Name: comments trg_chk_ref_record_comments; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_comments AFTER INSERT OR UPDATE ON darwin2.comments FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6383 (class 2620 OID 1413629)
-- Name: ext_links trg_chk_ref_record_ext_links; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_ext_links AFTER INSERT OR UPDATE ON darwin2.ext_links FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6392 (class 2620 OID 1413630)
-- Name: identifications trg_chk_ref_record_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_identifications AFTER INSERT OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6406 (class 2620 OID 1413631)
-- Name: informative_workflow trg_chk_ref_record_informative_workflow; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_informative_workflow AFTER INSERT OR UPDATE ON darwin2.informative_workflow FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6410 (class 2620 OID 1413632)
-- Name: insurances trg_chk_ref_record_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_insurances AFTER INSERT OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6465 (class 2620 OID 1413633)
-- Name: properties trg_chk_ref_record_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_properties AFTER INSERT OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6329 (class 2620 OID 1413634)
-- Name: catalogue_relationships trg_chk_ref_record_relationship_catalogue_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_relationship_catalogue_relationships AFTER INSERT OR UPDATE ON darwin2.catalogue_relationships FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecordrelationship();


--
-- TOC entry 6326 (class 2620 OID 1413635)
-- Name: template_table_record_ref trg_chk_ref_record_template_table_record_ref; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_template_table_record_ref AFTER INSERT OR UPDATE ON darwin2.template_table_record_ref FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6515 (class 2620 OID 1413636)
-- Name: vernacular_names trg_chk_ref_record_vernacular_names; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_vernacular_names AFTER INSERT OR UPDATE ON darwin2.vernacular_names FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_referencedrecord();


--
-- TOC entry 6474 (class 2620 OID 1413637)
-- Name: specimens trg_chk_specimencollectionallowed; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_specimencollectionallowed BEFORE INSERT OR DELETE OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_specimencollectionallowed();


--
-- TOC entry 6475 (class 2620 OID 1413638)
-- Name: specimens trg_chk_specimens_not_loaned; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_specimens_not_loaned BEFORE DELETE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.chk_specimens_not_loaned();


--
-- TOC entry 6333 (class 2620 OID 1413639)
-- Name: chronostratigraphy trg_chk_upper_level_for_childrens_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_chronostratigraphy AFTER UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 6414 (class 2620 OID 1413640)
-- Name: lithology trg_chk_upper_level_for_childrens_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_lithology AFTER UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 6421 (class 2620 OID 1413641)
-- Name: lithostratigraphy trg_chk_upper_level_for_childrens_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_lithostratigraphy AFTER UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 6441 (class 2620 OID 1413642)
-- Name: mineralogy trg_chk_upper_level_for_childrens_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_mineralogy AFTER UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 6315 (class 2620 OID 1413643)
-- Name: taxonomy trg_chk_upper_level_for_childrens_taxonomy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_taxonomy AFTER UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 6393 (class 2620 OID 1413644)
-- Name: identifications trg_clr_identifiers_in_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_identifiers_in_flat BEFORE DELETE ON darwin2.identifications FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_identifiers_in_flat();


--
-- TOC entry 6323 (class 2620 OID 1413645)
-- Name: bibliography trg_clr_referencerecord_bibliography; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_bibliography AFTER DELETE OR UPDATE ON darwin2.bibliography FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6334 (class 2620 OID 1413646)
-- Name: chronostratigraphy trg_clr_referencerecord_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_chronostratigraphy AFTER DELETE OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6363 (class 2620 OID 1413647)
-- Name: collections trg_clr_referencerecord_collections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_collections AFTER DELETE OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6379 (class 2620 OID 1413648)
-- Name: expeditions trg_clr_referencerecord_expeditions; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_expeditions AFTER DELETE OR UPDATE ON darwin2.expeditions FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6386 (class 2620 OID 1413649)
-- Name: gtu trg_clr_referencerecord_gtu; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_gtu AFTER DELETE OR UPDATE ON darwin2.gtu FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6394 (class 2620 OID 1413650)
-- Name: identifications trg_clr_referencerecord_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_identifications AFTER DELETE OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6399 (class 2620 OID 1413651)
-- Name: igs trg_clr_referencerecord_igs; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_igs AFTER DELETE OR UPDATE ON darwin2.igs FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6411 (class 2620 OID 1413652)
-- Name: insurances trg_clr_referencerecord_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_insurances AFTER DELETE OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6415 (class 2620 OID 1413653)
-- Name: lithology trg_clr_referencerecord_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_lithology AFTER DELETE OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6422 (class 2620 OID 1413654)
-- Name: lithostratigraphy trg_clr_referencerecord_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_lithostratigraphy AFTER DELETE OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6427 (class 2620 OID 1413655)
-- Name: loan_items trg_clr_referencerecord_loan_items; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_loan_items AFTER DELETE OR UPDATE ON darwin2.loan_items FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6435 (class 2620 OID 1413656)
-- Name: loans trg_clr_referencerecord_loans; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_loans AFTER DELETE OR UPDATE ON darwin2.loans FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6442 (class 2620 OID 1413657)
-- Name: mineralogy trg_clr_referencerecord_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_mineralogy AFTER DELETE OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6447 (class 2620 OID 1413658)
-- Name: multimedia trg_clr_referencerecord_multimedia; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_multimedia AFTER DELETE OR UPDATE ON darwin2.multimedia FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6359 (class 2620 OID 1413659)
-- Name: collection_maintenance trg_clr_referencerecord_mysavedsearches; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_mysavedsearches AFTER DELETE OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6453 (class 2620 OID 1413660)
-- Name: people trg_clr_referencerecord_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_people AFTER DELETE OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6476 (class 2620 OID 1413661)
-- Name: specimens trg_clr_referencerecord_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_specimens AFTER DELETE OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6487 (class 2620 OID 1413662)
-- Name: specimens_relationships trg_clr_referencerecord_specimens_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_specimens_relationships AFTER DELETE OR UPDATE ON darwin2.specimens_relationships FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6312 (class 2620 OID 1413663)
-- Name: staging trg_clr_referencerecord_staging; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_staging AFTER DELETE OR UPDATE ON darwin2.staging FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6496 (class 2620 OID 1413664)
-- Name: staging_info trg_clr_referencerecord_staging_info; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_staging_info AFTER DELETE OR UPDATE ON darwin2.staging_info FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6319 (class 2620 OID 1413665)
-- Name: taxonomy trg_clr_referencerecord_taxa; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_taxa AFTER DELETE OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6510 (class 2620 OID 1413666)
-- Name: users trg_clr_referencerecord_users; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_users AFTER DELETE OR UPDATE ON darwin2.users FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6516 (class 2620 OID 1413667)
-- Name: vernacular_names trg_clr_referencerecord_vernacularnames; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_vernacularnames AFTER DELETE OR UPDATE ON darwin2.vernacular_names FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clear_referencedrecord();


--
-- TOC entry 6478 (class 2620 OID 1413668)
-- Name: specimens trg_clr_specialstatus_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_specialstatus_specimens BEFORE INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.fct_clr_specialstatus();


--
-- TOC entry 6448 (class 2620 OID 1413669)
-- Name: multimedia trg_cpy_deleted_file; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_deleted_file AFTER DELETE ON darwin2.multimedia FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_deleted_file();


--
-- TOC entry 6454 (class 2620 OID 1413670)
-- Name: people trg_cpy_formattedname; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_formattedname BEFORE INSERT OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_formattedname();


--
-- TOC entry 6511 (class 2620 OID 1413671)
-- Name: users trg_cpy_formattedname; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_formattedname BEFORE INSERT OR UPDATE ON darwin2.users FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_formattedname();


--
-- TOC entry 6324 (class 2620 OID 1413672)
-- Name: bibliography trg_cpy_fulltoindex_bibliography; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_bibliography BEFORE INSERT OR UPDATE ON darwin2.bibliography FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6335 (class 2620 OID 1413673)
-- Name: chronostratigraphy trg_cpy_fulltoindex_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_chronostratigraphy BEFORE INSERT OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6339 (class 2620 OID 1413674)
-- Name: classification_keywords trg_cpy_fulltoindex_classification_keywords; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_classification_keywords BEFORE INSERT OR UPDATE ON darwin2.classification_keywords FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6348 (class 2620 OID 1413675)
-- Name: codes trg_cpy_fulltoindex_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_codes BEFORE INSERT OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6352 (class 2620 OID 1413676)
-- Name: collecting_methods trg_cpy_fulltoindex_collecting_methods; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_collecting_methods BEFORE INSERT OR UPDATE ON darwin2.collecting_methods FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6354 (class 2620 OID 1413677)
-- Name: collecting_tools trg_cpy_fulltoindex_collecting_tools; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_collecting_tools BEFORE INSERT OR UPDATE ON darwin2.collecting_tools FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6364 (class 2620 OID 1413678)
-- Name: collections trg_cpy_fulltoindex_collection; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_collection BEFORE INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6377 (class 2620 OID 1413679)
-- Name: comments trg_cpy_fulltoindex_comments; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_comments BEFORE INSERT OR UPDATE ON darwin2.comments FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6380 (class 2620 OID 1413680)
-- Name: expeditions trg_cpy_fulltoindex_expeditions; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_expeditions BEFORE INSERT OR UPDATE ON darwin2.expeditions FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6384 (class 2620 OID 1413681)
-- Name: ext_links trg_cpy_fulltoindex_ext_links; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_ext_links BEFORE INSERT OR UPDATE ON darwin2.ext_links FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6395 (class 2620 OID 1413682)
-- Name: identifications trg_cpy_fulltoindex_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_identifications BEFORE INSERT OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6400 (class 2620 OID 1413683)
-- Name: igs trg_cpy_fulltoindex_igs; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_igs BEFORE INSERT OR UPDATE ON darwin2.igs FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6416 (class 2620 OID 1413684)
-- Name: lithology trg_cpy_fulltoindex_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_lithology BEFORE INSERT OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6423 (class 2620 OID 1413685)
-- Name: lithostratigraphy trg_cpy_fulltoindex_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_lithostratigraphy BEFORE INSERT OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6436 (class 2620 OID 1413686)
-- Name: loans trg_cpy_fulltoindex_loans; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_loans BEFORE INSERT OR UPDATE ON darwin2.loans FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6443 (class 2620 OID 1413687)
-- Name: mineralogy trg_cpy_fulltoindex_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_mineralogy BEFORE INSERT OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6449 (class 2620 OID 1413688)
-- Name: multimedia trg_cpy_fulltoindex_multimedia; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_multimedia BEFORE INSERT OR UPDATE ON darwin2.multimedia FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6466 (class 2620 OID 1413689)
-- Name: properties trg_cpy_fulltoindex_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_properties BEFORE INSERT OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6479 (class 2620 OID 1413690)
-- Name: specimens trg_cpy_fulltoindex_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_specimens BEFORE INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6492 (class 2620 OID 1413691)
-- Name: storage_parts trg_cpy_fulltoindex_storage_parts; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_storage_parts BEFORE INSERT OR UPDATE ON darwin2.storage_parts FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6501 (class 2620 OID 1413692)
-- Name: tag_groups trg_cpy_fulltoindex_taggroups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_taggroups BEFORE INSERT OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6316 (class 2620 OID 1413693)
-- Name: taxonomy trg_cpy_fulltoindex_taxa; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_taxa BEFORE INSERT OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6517 (class 2620 OID 1413694)
-- Name: vernacular_names trg_cpy_fulltoindex_vernacularnames; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_vernacularnames BEFORE INSERT OR UPDATE ON darwin2.vernacular_names FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 6502 (class 2620 OID 1413695)
-- Name: tag_groups trg_cpy_gtutags_taggroups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_gtutags_taggroups AFTER INSERT OR DELETE OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_gtutags();


--
-- TOC entry 6480 (class 2620 OID 1413696)
-- Name: specimens trg_cpy_ig_to_loan_items; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_ig_to_loan_items AFTER UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_ig_to_loan_items();


--
-- TOC entry 6387 (class 2620 OID 1413697)
-- Name: gtu trg_cpy_location; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_location BEFORE INSERT OR UPDATE ON darwin2.gtu FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_location();


--
-- TOC entry 6336 (class 2620 OID 1413698)
-- Name: chronostratigraphy trg_cpy_path_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_chronostratigraphy BEFORE INSERT OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 6365 (class 2620 OID 1413699)
-- Name: collections trg_cpy_path_collections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_collections BEFORE INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_path();


--
-- TOC entry 6417 (class 2620 OID 1413700)
-- Name: lithology trg_cpy_path_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_lithology BEFORE INSERT OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 6424 (class 2620 OID 1413701)
-- Name: lithostratigraphy trg_cpy_path_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_lithostratigraphy BEFORE INSERT OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 6444 (class 2620 OID 1413702)
-- Name: mineralogy trg_cpy_path_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_mineralogy BEFORE INSERT OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 6461 (class 2620 OID 1413703)
-- Name: people_relationships trg_cpy_path_peoplerelationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_peoplerelationships BEFORE INSERT OR UPDATE ON darwin2.people_relationships FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_path();


--
-- TOC entry 6320 (class 2620 OID 1413704)
-- Name: taxonomy trg_cpy_path_taxonomy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_taxonomy BEFORE INSERT OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 6467 (class 2620 OID 1413705)
-- Name: properties trg_cpy_unified_values; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_unified_values BEFORE INSERT OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_unified_values();


--
-- TOC entry 6366 (class 2620 OID 1413706)
-- Name: collections trg_cpy_updatecollectionrights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updatecollectionrights AFTER INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_updatecollectionrights();


--
-- TOC entry 6367 (class 2620 OID 1413707)
-- Name: collections trg_cpy_updatecollinstitutioncascade; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updatecollinstitutioncascade AFTER UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_updatecollinstitutioncascade();


--
-- TOC entry 6373 (class 2620 OID 1413708)
-- Name: collections_rights trg_cpy_updatemywidgetscollrights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updatemywidgetscollrights AFTER DELETE OR UPDATE ON darwin2.collections_rights FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_updatemywidgetscoll();


--
-- TOC entry 6374 (class 2620 OID 1413709)
-- Name: collections_rights trg_cpy_updateuserrights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updateuserrights AFTER INSERT OR DELETE OR UPDATE ON darwin2.collections_rights FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_updateuserrights();


--
-- TOC entry 6368 (class 2620 OID 1413710)
-- Name: collections trg_cpy_updateuserrightscollections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updateuserrightscollections AFTER INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_cpy_updateuserrights();


--
-- TOC entry 6342 (class 2620 OID 1413711)
-- Name: classification_synonymies trg_fct_reinit_sequences_synonyms; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_reinit_sequences_synonyms AFTER INSERT OR UPDATE ON darwin2.classification_synonymies FOR EACH ROW EXECUTE FUNCTION darwin2.fct_reinit_sequences_synonyms();


--
-- TOC entry 6321 (class 2620 OID 1413712)
-- Name: taxonomy trg_fct_rmca_chk_is_already_reference_taxo; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_chk_is_already_reference_taxo BEFORE INSERT OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_rmca_chk_is_already_reference_taxo();


--
-- TOC entry 6505 (class 2620 OID 1413713)
-- Name: taxonomy_metadata trg_fct_rmca_chk_only_one_reference_taxo; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_chk_only_one_reference_taxo BEFORE INSERT OR UPDATE ON darwin2.taxonomy_metadata FOR EACH ROW EXECUTE FUNCTION darwin2.fct_rmca_chk_uniqueness_reference_taxo();


--
-- TOC entry 6495 (class 2620 OID 1413714)
-- Name: staging_catalogue trg_fct_rmca_keep_staging_catalogue_parent; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_keep_staging_catalogue_parent BEFORE INSERT OR UPDATE ON darwin2.staging_catalogue FOR EACH ROW EXECUTE FUNCTION darwin2.fct_rmca_keep_staging_catalogue_parent();


--
-- TOC entry 6322 (class 2620 OID 1413715)
-- Name: taxonomy trg_fct_rmca_update_child_of_taxon_protected; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_update_child_of_taxon_protected BEFORE UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_rmca_update_child_of_taxon_protected();


--
-- TOC entry 6506 (class 2620 OID 1413716)
-- Name: taxonomy_metadata trg_fct_rmca_update_reference_taxo; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_update_reference_taxo AFTER UPDATE ON darwin2.taxonomy_metadata FOR EACH ROW EXECUTE FUNCTION darwin2.fct_rmca_update_reference_taxo();


--
-- TOC entry 6351 (class 2620 OID 1413717)
-- Name: codes trg_insert_auto_code; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_insert_auto_code AFTER INSERT OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE FUNCTION darwin2.check_auto_increment_code_in_spec();


--
-- TOC entry 6481 (class 2620 OID 1413718)
-- Name: specimens trg_insert_auto_code_del_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_insert_auto_code_del_specimens BEFORE DELETE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.check_auto_increment_code_in_spec_on_specimen();


--
-- TOC entry 6437 (class 2620 OID 1413719)
-- Name: loans trg_insert_auto_code_loan; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_insert_auto_code_loan BEFORE INSERT ON darwin2.loans FOR EACH ROW EXECUTE FUNCTION darwin2.check_auto_increment_code_in_loan();


--
-- TOC entry 6330 (class 2620 OID 1413720)
-- Name: catalogue_relationships trg_nbr_in_relation; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_nbr_in_relation BEFORE INSERT OR UPDATE ON darwin2.catalogue_relationships FOR EACH ROW EXECUTE FUNCTION darwin2.fct_nbr_in_relation();


--
-- TOC entry 6343 (class 2620 OID 1413721)
-- Name: classification_synonymies trg_nbr_in_synonym; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_nbr_in_synonym AFTER INSERT OR UPDATE ON darwin2.classification_synonymies FOR EACH ROW EXECUTE FUNCTION darwin2.fct_nbr_in_synonym();


--
-- TOC entry 6407 (class 2620 OID 1413722)
-- Name: informative_workflow trg_reset_last_flag_informative_workflow; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_reset_last_flag_informative_workflow AFTER DELETE ON darwin2.informative_workflow FOR EACH ROW EXECUTE FUNCTION darwin2.fct_informative_reset_last_flag();


--
-- TOC entry 6455 (class 2620 OID 1413723)
-- Name: people trg_rmca_check_people_before_delete; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_check_people_before_delete BEFORE DELETE ON darwin2.people FOR EACH ROW EXECUTE FUNCTION darwin2.fct_rmca_check_people_before_delete();


--
-- TOC entry 6477 (class 2620 OID 1413724)
-- Name: specimens trg_rmca_delete_specimen_storage_enable; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_delete_specimen_storage_enable BEFORE DELETE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.trg_rmca_delete_specimen_storage();


--
-- TOC entry 6489 (class 2620 OID 1413725)
-- Name: specimens_stable_ids trg_rmca_log_specimens_stable_ids; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_log_specimens_stable_ids BEFORE INSERT OR UPDATE ON darwin2.specimens_stable_ids FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trg_rmca_log_specimens_stable_ids();


--
-- TOC entry 6493 (class 2620 OID 1413726)
-- Name: storage_parts trg_rmca_trk_log_table_storage_parts; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_trk_log_table_storage_parts AFTER INSERT OR DELETE OR UPDATE ON darwin2.storage_parts FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6507 (class 2620 OID 1413727)
-- Name: taxonomy_metadata trg_rmca_trk_log_table_taxonomy_metadata; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_trk_log_table_taxonomy_metadata AFTER INSERT OR DELETE OR UPDATE ON darwin2.taxonomy_metadata FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6369 (class 2620 OID 1413728)
-- Name: collections trg_rmca_update_parent_code; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_update_parent_code AFTER INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.rmca_update_parent_code();


--
-- TOC entry 6325 (class 2620 OID 1413729)
-- Name: bibliography trg_trk_log_table_bibliography; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_bibliography AFTER INSERT OR DELETE OR UPDATE ON darwin2.bibliography FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6331 (class 2620 OID 1413730)
-- Name: catalogue_relationships trg_trk_log_table_catalogue_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_catalogue_relationships AFTER INSERT OR DELETE OR UPDATE ON darwin2.catalogue_relationships FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6337 (class 2620 OID 1413731)
-- Name: chronostratigraphy trg_trk_log_table_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_chronostratigraphy AFTER INSERT OR DELETE OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6340 (class 2620 OID 1413732)
-- Name: classification_keywords trg_trk_log_table_classification_keywords; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_classification_keywords AFTER INSERT OR DELETE OR UPDATE ON darwin2.classification_keywords FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6344 (class 2620 OID 1413733)
-- Name: classification_synonymies trg_trk_log_table_classification_synonymies; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_classification_synonymies AFTER INSERT OR DELETE OR UPDATE ON darwin2.classification_synonymies FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6345 (class 2620 OID 1413734)
-- Name: classification_synonymies trg_trk_log_table_classification_synonymies_history; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_classification_synonymies_history AFTER DELETE OR UPDATE ON darwin2.classification_synonymies FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_old_synonyms();


--
-- TOC entry 6349 (class 2620 OID 1413735)
-- Name: codes trg_trk_log_table_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_codes AFTER INSERT OR DELETE OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6353 (class 2620 OID 1413736)
-- Name: collecting_methods trg_trk_log_table_collecting_methods; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collecting_methods AFTER INSERT OR DELETE OR UPDATE ON darwin2.collecting_methods FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6355 (class 2620 OID 1413737)
-- Name: collecting_tools trg_trk_log_table_collecting_tools; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collecting_tools AFTER INSERT OR DELETE OR UPDATE ON darwin2.collecting_tools FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6360 (class 2620 OID 1413738)
-- Name: collection_maintenance trg_trk_log_table_collection_maintenance; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collection_maintenance AFTER INSERT OR DELETE OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6370 (class 2620 OID 1413739)
-- Name: collections trg_trk_log_table_collections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collections AFTER INSERT OR DELETE OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6375 (class 2620 OID 1413740)
-- Name: collections_rights trg_trk_log_table_collections_rights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collections_rights AFTER INSERT OR DELETE OR UPDATE ON darwin2.collections_rights FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6378 (class 2620 OID 1413741)
-- Name: comments trg_trk_log_table_comments; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_comments AFTER INSERT OR DELETE OR UPDATE ON darwin2.comments FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6381 (class 2620 OID 1413742)
-- Name: expeditions trg_trk_log_table_expeditions; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_expeditions AFTER INSERT OR DELETE OR UPDATE ON darwin2.expeditions FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6385 (class 2620 OID 1413743)
-- Name: ext_links trg_trk_log_table_ext_links; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_ext_links AFTER INSERT OR DELETE OR UPDATE ON darwin2.ext_links FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6388 (class 2620 OID 1413744)
-- Name: gtu trg_trk_log_table_gtu; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_gtu AFTER INSERT OR DELETE OR UPDATE ON darwin2.gtu FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6396 (class 2620 OID 1413745)
-- Name: identifications trg_trk_log_table_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_identifications AFTER INSERT OR DELETE OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6401 (class 2620 OID 1413746)
-- Name: igs trg_trk_log_table_igs; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_igs AFTER INSERT OR DELETE OR UPDATE ON darwin2.igs FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6412 (class 2620 OID 1413747)
-- Name: insurances trg_trk_log_table_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_insurances AFTER INSERT OR DELETE OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6418 (class 2620 OID 1413748)
-- Name: lithology trg_trk_log_table_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_lithology AFTER INSERT OR DELETE OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6425 (class 2620 OID 1413749)
-- Name: lithostratigraphy trg_trk_log_table_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_lithostratigraphy AFTER INSERT OR DELETE OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6445 (class 2620 OID 1413750)
-- Name: mineralogy trg_trk_log_table_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_mineralogy AFTER INSERT OR DELETE OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6450 (class 2620 OID 1413751)
-- Name: multimedia trg_trk_log_table_multimedia; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_multimedia AFTER INSERT OR DELETE OR UPDATE ON darwin2.multimedia FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6456 (class 2620 OID 1413752)
-- Name: people trg_trk_log_table_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_people AFTER INSERT OR DELETE OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6459 (class 2620 OID 1413753)
-- Name: people_addresses trg_trk_log_table_people_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_people_addresses AFTER INSERT OR DELETE OR UPDATE ON darwin2.people_addresses FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6460 (class 2620 OID 1413754)
-- Name: people_comm trg_trk_log_table_people_comm; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_people_comm AFTER INSERT OR DELETE OR UPDATE ON darwin2.people_comm FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6462 (class 2620 OID 1413755)
-- Name: people_relationships trg_trk_log_table_people_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_people_relationships AFTER INSERT OR DELETE OR UPDATE ON darwin2.people_relationships FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6468 (class 2620 OID 1413756)
-- Name: properties trg_trk_log_table_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_properties AFTER INSERT OR DELETE OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6469 (class 2620 OID 1413757)
-- Name: specimen_collecting_methods trg_trk_log_table_specimen_collecting_methods; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_specimen_collecting_methods AFTER INSERT OR DELETE OR UPDATE ON darwin2.specimen_collecting_methods FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6470 (class 2620 OID 1413758)
-- Name: specimen_collecting_tools trg_trk_log_table_specimen_collecting_tools; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_specimen_collecting_tools AFTER INSERT OR DELETE OR UPDATE ON darwin2.specimen_collecting_tools FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6483 (class 2620 OID 1413759)
-- Name: specimens trg_trk_log_table_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_specimens AFTER INSERT OR DELETE OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6488 (class 2620 OID 1413760)
-- Name: specimens_relationships trg_trk_log_table_specimens_relationship; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_specimens_relationship AFTER INSERT OR DELETE OR UPDATE ON darwin2.specimens_relationships FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6503 (class 2620 OID 1413761)
-- Name: tag_groups trg_trk_log_table_tag_groups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_tag_groups AFTER INSERT OR DELETE OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6317 (class 2620 OID 1413762)
-- Name: taxonomy trg_trk_log_table_taxonomy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_taxonomy AFTER INSERT OR DELETE OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6518 (class 2620 OID 1413763)
-- Name: vernacular_names trg_trk_log_table_vernacular_names; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_vernacular_names AFTER INSERT OR DELETE OR UPDATE ON darwin2.vernacular_names FOR EACH ROW EXECUTE FUNCTION darwin2.fct_trk_log_table();


--
-- TOC entry 6512 (class 2620 OID 1413764)
-- Name: users trg_unpromotion_remove_cols; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_unpromotion_remove_cols AFTER UPDATE ON darwin2.users FOR EACH ROW EXECUTE FUNCTION darwin2.fct_unpromotion_impact_prefs();


--
-- TOC entry 6313 (class 2620 OID 1413765)
-- Name: staging trg_upd_fields_staging; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_upd_fields_staging AFTER UPDATE ON darwin2.staging FOR EACH ROW EXECUTE FUNCTION darwin2.fct_upd_staging_fields();


--
-- TOC entry 6498 (class 2620 OID 1413766)
-- Name: staging_relationship trg_upd_institution_staging_relationship; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_upd_institution_staging_relationship AFTER UPDATE ON darwin2.staging_relationship FOR EACH ROW EXECUTE FUNCTION darwin2.fct_upd_institution_staging_relationship();


--
-- TOC entry 6328 (class 2620 OID 1413767)
-- Name: catalogue_people trg_upd_people_in_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_upd_people_in_flat AFTER INSERT OR DELETE OR UPDATE ON darwin2.catalogue_people FOR EACH ROW EXECUTE FUNCTION darwin2.fct_upd_people_in_flat();


--
-- TOC entry 6497 (class 2620 OID 1413768)
-- Name: staging_people trg_upd_people_ref_staging_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_upd_people_ref_staging_people AFTER UPDATE ON darwin2.staging_people FOR EACH ROW EXECUTE FUNCTION darwin2.fct_upd_people_staging_fields();


--
-- TOC entry 6338 (class 2620 OID 1413769)
-- Name: chronostratigraphy trg_update_chronostratigraphy_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_chronostratigraphy_darwin_flat AFTER UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6371 (class 2620 OID 1413770)
-- Name: collections trg_update_collections_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_collections_darwin_flat AFTER UPDATE ON darwin2.collections FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6382 (class 2620 OID 1413771)
-- Name: expeditions trg_update_expeditions_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_expeditions_darwin_flat AFTER UPDATE ON darwin2.expeditions FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6389 (class 2620 OID 1413772)
-- Name: gtu trg_update_gtu_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_gtu_darwin_flat AFTER UPDATE ON darwin2.gtu FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6402 (class 2620 OID 1413773)
-- Name: igs trg_update_igs_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_igs_darwin_flat AFTER UPDATE ON darwin2.igs FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6419 (class 2620 OID 1413774)
-- Name: lithology trg_update_lithology_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_lithology_darwin_flat AFTER UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6426 (class 2620 OID 1413775)
-- Name: lithostratigraphy trg_update_lithostratigraphy_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_lithostratigraphy_darwin_flat AFTER UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6446 (class 2620 OID 1413776)
-- Name: mineralogy trg_update_mineralogy_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_mineralogy_darwin_flat AFTER UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6484 (class 2620 OID 1413777)
-- Name: specimens trg_update_specimens_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_specimens_darwin_flat BEFORE INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimen_flat();


--
-- TOC entry 6504 (class 2620 OID 1413778)
-- Name: tag_groups trg_update_tag_groups_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_tag_groups_darwin_flat AFTER INSERT OR DELETE OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6318 (class 2620 OID 1413779)
-- Name: taxonomy trg_update_taxonomy_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_taxonomy_darwin_flat AFTER UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE FUNCTION darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 6228 (class 2606 OID 1413780)
-- Name: catalogue_bibliography fk_bibliography; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_bibliography
    ADD CONSTRAINT fk_bibliography FOREIGN KEY (bibliography_ref) REFERENCES darwin2.bibliography(id) ON DELETE CASCADE;


--
-- TOC entry 6230 (class 2606 OID 1413785)
-- Name: chronostratigraphy fk_chronostratigraphy_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy
    ADD CONSTRAINT fk_chronostratigraphy_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 6231 (class 2606 OID 1413790)
-- Name: chronostratigraphy fk_chronostratigraphy_parent_ref_chronostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy
    ADD CONSTRAINT fk_chronostratigraphy_parent_ref_chronostratigraphy FOREIGN KEY (parent_ref) REFERENCES darwin2.chronostratigraphy(id) ON DELETE CASCADE;


--
-- TOC entry 6232 (class 2606 OID 1413795)
-- Name: collection_maintenance fk_collection_maintenance_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collection_maintenance
    ADD CONSTRAINT fk_collection_maintenance_users FOREIGN KEY (people_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 6233 (class 2606 OID 1413800)
-- Name: collections fk_collections_collections; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT fk_collections_collections FOREIGN KEY (parent_ref) REFERENCES darwin2.collections(id) ON DELETE CASCADE;


--
-- TOC entry 6234 (class 2606 OID 1413805)
-- Name: collections fk_collections_institutions; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT fk_collections_institutions FOREIGN KEY (institution_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 6237 (class 2606 OID 1413810)
-- Name: collections_rights fk_collections_rights_collections; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections_rights
    ADD CONSTRAINT fk_collections_rights_collections FOREIGN KEY (collection_ref) REFERENCES darwin2.collections(id) ON DELETE CASCADE;


--
-- TOC entry 6238 (class 2606 OID 1413815)
-- Name: collections_rights fk_collections_rights_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections_rights
    ADD CONSTRAINT fk_collections_rights_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6235 (class 2606 OID 1413820)
-- Name: collections fk_collections_staff; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT fk_collections_staff FOREIGN KEY (staff_ref) REFERENCES darwin2.users(id) ON DELETE SET NULL;


--
-- TOC entry 6236 (class 2606 OID 1413825)
-- Name: collections fk_collections_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT fk_collections_users FOREIGN KEY (main_manager_ref) REFERENCES darwin2.users(id);


--
-- TOC entry 6239 (class 2606 OID 1413830)
-- Name: imports fk_imports_collections; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.imports
    ADD CONSTRAINT fk_imports_collections FOREIGN KEY (collection_ref) REFERENCES darwin2.collections(id) ON DELETE CASCADE;


--
-- TOC entry 6240 (class 2606 OID 1413835)
-- Name: imports fk_imports_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.imports
    ADD CONSTRAINT fk_imports_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6241 (class 2606 OID 1413840)
-- Name: informative_workflow fk_informative_workflow_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.informative_workflow
    ADD CONSTRAINT fk_informative_workflow_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6242 (class 2606 OID 1413845)
-- Name: insurances fk_insurances_contact; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.insurances
    ADD CONSTRAINT fk_insurances_contact FOREIGN KEY (contact_ref) REFERENCES darwin2.people(id) ON DELETE SET NULL;


--
-- TOC entry 6243 (class 2606 OID 1413850)
-- Name: insurances fk_insurances_people; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.insurances
    ADD CONSTRAINT fk_insurances_people FOREIGN KEY (insurer_ref) REFERENCES darwin2.people(id) ON DELETE SET NULL;


--
-- TOC entry 6244 (class 2606 OID 1413855)
-- Name: lithology fk_lithology_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology
    ADD CONSTRAINT fk_lithology_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 6245 (class 2606 OID 1413860)
-- Name: lithology fk_lithology_parent_ref_lithology; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology
    ADD CONSTRAINT fk_lithology_parent_ref_lithology FOREIGN KEY (parent_ref) REFERENCES darwin2.lithology(id) ON DELETE CASCADE;


--
-- TOC entry 6246 (class 2606 OID 1413865)
-- Name: lithostratigraphy fk_lithostratigraphy_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy
    ADD CONSTRAINT fk_lithostratigraphy_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 6247 (class 2606 OID 1413870)
-- Name: lithostratigraphy fk_lithostratigraphy_parent_ref_lithostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy
    ADD CONSTRAINT fk_lithostratigraphy_parent_ref_lithostratigraphy FOREIGN KEY (parent_ref) REFERENCES darwin2.lithostratigraphy(id) ON DELETE CASCADE;


--
-- TOC entry 6248 (class 2606 OID 1413875)
-- Name: loan_history fk_loan_history_loan_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_history
    ADD CONSTRAINT fk_loan_history_loan_ref FOREIGN KEY (loan_ref) REFERENCES darwin2.loans(id) ON DELETE CASCADE;


--
-- TOC entry 6249 (class 2606 OID 1413880)
-- Name: loan_items fk_loan_items_ig; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT fk_loan_items_ig FOREIGN KEY (ig_ref) REFERENCES darwin2.igs(id);


--
-- TOC entry 6250 (class 2606 OID 1413885)
-- Name: loan_items fk_loan_items_loan_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT fk_loan_items_loan_ref FOREIGN KEY (loan_ref) REFERENCES darwin2.loans(id);


--
-- TOC entry 6251 (class 2606 OID 1413890)
-- Name: loan_items fk_loan_items_specimen_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT fk_loan_items_specimen_ref FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id) ON DELETE SET NULL;


--
-- TOC entry 6252 (class 2606 OID 1413895)
-- Name: loan_rights fk_loan_rights_loan_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_rights
    ADD CONSTRAINT fk_loan_rights_loan_ref FOREIGN KEY (loan_ref) REFERENCES darwin2.loans(id) ON DELETE CASCADE;


--
-- TOC entry 6253 (class 2606 OID 1413900)
-- Name: loan_rights fk_loan_rights_user_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_rights
    ADD CONSTRAINT fk_loan_rights_user_ref FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6254 (class 2606 OID 1413905)
-- Name: loan_status fk_loan_status_loan_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_status
    ADD CONSTRAINT fk_loan_status_loan_ref FOREIGN KEY (loan_ref) REFERENCES darwin2.loans(id) ON DELETE CASCADE;


--
-- TOC entry 6255 (class 2606 OID 1413910)
-- Name: loan_status fk_loan_status_user_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_status
    ADD CONSTRAINT fk_loan_status_user_ref FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6256 (class 2606 OID 1413915)
-- Name: loans fk_loans_collections; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loans
    ADD CONSTRAINT fk_loans_collections FOREIGN KEY (collection_ref) REFERENCES darwin2.collections(id);


--
-- TOC entry 6257 (class 2606 OID 1413920)
-- Name: mineralogy fk_mineralogy_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy
    ADD CONSTRAINT fk_mineralogy_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 6258 (class 2606 OID 1413925)
-- Name: mineralogy fk_mineralogy_parent_ref_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy
    ADD CONSTRAINT fk_mineralogy_parent_ref_mineralogy FOREIGN KEY (parent_ref) REFERENCES darwin2.mineralogy(id) ON DELETE CASCADE;


--
-- TOC entry 6259 (class 2606 OID 1413930)
-- Name: my_saved_searches fk_my_saved_searches_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_saved_searches
    ADD CONSTRAINT fk_my_saved_searches_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6260 (class 2606 OID 1413935)
-- Name: my_widgets fk_my_widgets_multimedia; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_widgets
    ADD CONSTRAINT fk_my_widgets_multimedia FOREIGN KEY (icon_ref) REFERENCES darwin2.multimedia(id);


--
-- TOC entry 6261 (class 2606 OID 1413940)
-- Name: my_widgets fk_my_widgets_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_widgets
    ADD CONSTRAINT fk_my_widgets_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6289 (class 2606 OID 1413945)
-- Name: storage_parts fk_part_specimens; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.storage_parts
    ADD CONSTRAINT fk_part_specimens FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id);


--
-- TOC entry 6262 (class 2606 OID 1413950)
-- Name: people_addresses fk_people_addresses_people; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_addresses
    ADD CONSTRAINT fk_people_addresses_people FOREIGN KEY (person_user_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 6263 (class 2606 OID 1413955)
-- Name: people_comm fk_people_comm_people; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_comm
    ADD CONSTRAINT fk_people_comm_people FOREIGN KEY (person_user_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 6264 (class 2606 OID 1413960)
-- Name: people_languages fk_people_languages_people; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_languages
    ADD CONSTRAINT fk_people_languages_people FOREIGN KEY (people_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 6229 (class 2606 OID 1413965)
-- Name: catalogue_people fk_people_list_person; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_people
    ADD CONSTRAINT fk_people_list_person FOREIGN KEY (people_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 6265 (class 2606 OID 1413970)
-- Name: people_relationships fk_people_relationships_people_01; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_relationships
    ADD CONSTRAINT fk_people_relationships_people_01 FOREIGN KEY (person_1_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 6266 (class 2606 OID 1413975)
-- Name: people_relationships fk_people_relationships_people_02; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_relationships
    ADD CONSTRAINT fk_people_relationships_people_02 FOREIGN KEY (person_2_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 6267 (class 2606 OID 1413980)
-- Name: possible_upper_levels fk_possible_upper_levels_catalogue_levels_01; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.possible_upper_levels
    ADD CONSTRAINT fk_possible_upper_levels_catalogue_levels_01 FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id) ON DELETE CASCADE;


--
-- TOC entry 6268 (class 2606 OID 1413985)
-- Name: possible_upper_levels fk_possible_upper_levels_catalogue_levels_02; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.possible_upper_levels
    ADD CONSTRAINT fk_possible_upper_levels_catalogue_levels_02 FOREIGN KEY (level_upper_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 6296 (class 2606 OID 1413990)
-- Name: staging_relationship fk_record_id; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT fk_record_id FOREIGN KEY (record_id) REFERENCES darwin2.staging(id) ON DELETE CASCADE;


--
-- TOC entry 6270 (class 2606 OID 1413995)
-- Name: specimen_collecting_methods fk_specimen_collecting_methods_method; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_methods
    ADD CONSTRAINT fk_specimen_collecting_methods_method FOREIGN KEY (collecting_method_ref) REFERENCES darwin2.collecting_methods(id) ON DELETE CASCADE;


--
-- TOC entry 6271 (class 2606 OID 1414000)
-- Name: specimen_collecting_methods fk_specimen_collecting_methods_specimen; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_methods
    ADD CONSTRAINT fk_specimen_collecting_methods_specimen FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id) ON DELETE CASCADE;


--
-- TOC entry 6272 (class 2606 OID 1414005)
-- Name: specimen_collecting_tools fk_specimen_collecting_tools_specimen; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_tools
    ADD CONSTRAINT fk_specimen_collecting_tools_specimen FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id) ON DELETE CASCADE;


--
-- TOC entry 6273 (class 2606 OID 1414010)
-- Name: specimen_collecting_tools fk_specimen_collecting_tools_tool; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_tools
    ADD CONSTRAINT fk_specimen_collecting_tools_tool FOREIGN KEY (collecting_tool_ref) REFERENCES darwin2.collecting_tools(id) ON DELETE CASCADE;


--
-- TOC entry 6274 (class 2606 OID 1414015)
-- Name: specimens fk_specimens_chronostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_chronostratigraphy FOREIGN KEY (chrono_ref) REFERENCES darwin2.chronostratigraphy(id);


--
-- TOC entry 6275 (class 2606 OID 1414020)
-- Name: specimens fk_specimens_collections; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_collections FOREIGN KEY (collection_ref) REFERENCES darwin2.collections(id);


--
-- TOC entry 6276 (class 2606 OID 1414025)
-- Name: specimens fk_specimens_expeditions; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_expeditions FOREIGN KEY (expedition_ref) REFERENCES darwin2.expeditions(id);


--
-- TOC entry 6277 (class 2606 OID 1414030)
-- Name: specimens fk_specimens_gtu; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_gtu FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id);


--
-- TOC entry 6278 (class 2606 OID 1414035)
-- Name: specimens fk_specimens_igs; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_igs FOREIGN KEY (ig_ref) REFERENCES darwin2.igs(id);


--
-- TOC entry 6279 (class 2606 OID 1414040)
-- Name: specimens fk_specimens_lithology; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_lithology FOREIGN KEY (lithology_ref) REFERENCES darwin2.lithology(id);


--
-- TOC entry 6280 (class 2606 OID 1414045)
-- Name: specimens fk_specimens_lithostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_lithostratigraphy FOREIGN KEY (litho_ref) REFERENCES darwin2.lithostratigraphy(id);


--
-- TOC entry 6281 (class 2606 OID 1414050)
-- Name: specimens fk_specimens_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_mineralogy FOREIGN KEY (mineral_ref) REFERENCES darwin2.mineralogy(id);


--
-- TOC entry 6283 (class 2606 OID 1414055)
-- Name: specimens_relationships fk_specimens_relationships_institution; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_institution FOREIGN KEY (institution_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 6297 (class 2606 OID 1414060)
-- Name: staging_relationship fk_specimens_relationships_institution; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT fk_specimens_relationships_institution FOREIGN KEY (institution_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 6284 (class 2606 OID 1414065)
-- Name: specimens_relationships fk_specimens_relationships_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_mineralogy FOREIGN KEY (mineral_ref) REFERENCES darwin2.mineralogy(id);


--
-- TOC entry 6298 (class 2606 OID 1414070)
-- Name: staging_relationship fk_specimens_relationships_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT fk_specimens_relationships_mineralogy FOREIGN KEY (mineral_ref) REFERENCES darwin2.mineralogy(id);


--
-- TOC entry 6285 (class 2606 OID 1414075)
-- Name: specimens_relationships fk_specimens_relationships_specimens; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_specimens FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id) ON DELETE CASCADE;


--
-- TOC entry 6286 (class 2606 OID 1414080)
-- Name: specimens_relationships fk_specimens_relationships_specimens_related; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_specimens_related FOREIGN KEY (specimen_related_ref) REFERENCES darwin2.specimens(id) ON DELETE CASCADE;


--
-- TOC entry 6287 (class 2606 OID 1414085)
-- Name: specimens_relationships fk_specimens_relationships_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_taxonomy FOREIGN KEY (taxon_ref) REFERENCES darwin2.taxonomy(id);


--
-- TOC entry 6299 (class 2606 OID 1414090)
-- Name: staging_relationship fk_specimens_relationships_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT fk_specimens_relationships_taxonomy FOREIGN KEY (taxon_ref) REFERENCES darwin2.taxonomy(id);


--
-- TOC entry 6288 (class 2606 OID 1414095)
-- Name: specimens_stable_ids fk_specimens_stable_ids_specimens; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_stable_ids
    ADD CONSTRAINT fk_specimens_stable_ids_specimens FOREIGN KEY (specimen_fk) REFERENCES darwin2.specimens(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- TOC entry 6282 (class 2606 OID 1414100)
-- Name: specimens fk_specimens_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_taxonomy FOREIGN KEY (taxon_ref) REFERENCES darwin2.taxonomy(id);


--
-- TOC entry 6218 (class 2606 OID 1414105)
-- Name: staging fk_staging_chronostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_chronostratigraphy FOREIGN KEY (chrono_ref) REFERENCES darwin2.chronostratigraphy(id) ON DELETE SET NULL;


--
-- TOC entry 6292 (class 2606 OID 1414110)
-- Name: staging_collecting_methods fk_staging_collecting_methods_method; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods
    ADD CONSTRAINT fk_staging_collecting_methods_method FOREIGN KEY (collecting_method_ref) REFERENCES darwin2.collecting_methods(id) ON DELETE CASCADE;


--
-- TOC entry 6293 (class 2606 OID 1414115)
-- Name: staging_collecting_methods fk_staging_collecting_methods_staging; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods
    ADD CONSTRAINT fk_staging_collecting_methods_staging FOREIGN KEY (staging_ref) REFERENCES darwin2.staging(id) ON DELETE CASCADE;


--
-- TOC entry 6219 (class 2606 OID 1414120)
-- Name: staging fk_staging_gtu; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_gtu FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id) ON DELETE SET NULL;


--
-- TOC entry 6220 (class 2606 OID 1414125)
-- Name: staging fk_staging_import; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_import FOREIGN KEY (import_ref) REFERENCES darwin2.imports(id) ON DELETE CASCADE;


--
-- TOC entry 6221 (class 2606 OID 1414130)
-- Name: staging fk_staging_lithology; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_lithology FOREIGN KEY (lithology_ref) REFERENCES darwin2.lithology(id) ON DELETE SET NULL;


--
-- TOC entry 6222 (class 2606 OID 1414135)
-- Name: staging fk_staging_lithostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_lithostratigraphy FOREIGN KEY (litho_ref) REFERENCES darwin2.lithostratigraphy(id) ON DELETE SET NULL;


--
-- TOC entry 6223 (class 2606 OID 1414140)
-- Name: staging fk_staging_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_mineralogy FOREIGN KEY (mineral_ref) REFERENCES darwin2.mineralogy(id) ON DELETE SET NULL;


--
-- TOC entry 6295 (class 2606 OID 1414145)
-- Name: staging_people fk_staging_people_list_person; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_people
    ADD CONSTRAINT fk_staging_people_list_person FOREIGN KEY (people_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 6294 (class 2606 OID 1414150)
-- Name: staging_info fk_staging_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_info
    ADD CONSTRAINT fk_staging_ref FOREIGN KEY (staging_ref) REFERENCES darwin2.staging(id) ON DELETE CASCADE;


--
-- TOC entry 6300 (class 2606 OID 1414155)
-- Name: staging_tag_groups fk_staging_tag_groups; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_tag_groups
    ADD CONSTRAINT fk_staging_tag_groups FOREIGN KEY (staging_ref) REFERENCES darwin2.staging(id) ON DELETE CASCADE;


--
-- TOC entry 6224 (class 2606 OID 1414160)
-- Name: staging fk_staging_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_taxonomy FOREIGN KEY (taxon_ref) REFERENCES darwin2.taxonomy(id) ON DELETE SET NULL;


--
-- TOC entry 6290 (class 2606 OID 1414165)
-- Name: staging_catalogue fk_stg_catalogue_import_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_catalogue
    ADD CONSTRAINT fk_stg_catalogue_import_ref FOREIGN KEY (import_ref) REFERENCES darwin2.imports(id) ON DELETE CASCADE;


--
-- TOC entry 6291 (class 2606 OID 1414170)
-- Name: staging_catalogue fk_stg_catalogue_level_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_catalogue
    ADD CONSTRAINT fk_stg_catalogue_level_ref FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 6301 (class 2606 OID 1414175)
-- Name: tag_groups fk_tag_groups_gtu; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_groups
    ADD CONSTRAINT fk_tag_groups_gtu FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id) ON DELETE CASCADE;


--
-- TOC entry 6302 (class 2606 OID 1414180)
-- Name: tags fk_tags_gtu; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tags
    ADD CONSTRAINT fk_tags_gtu FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id) ON DELETE CASCADE;


--
-- TOC entry 6303 (class 2606 OID 1414185)
-- Name: tags fk_tags_tag_groups; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tags
    ADD CONSTRAINT fk_tags_tag_groups FOREIGN KEY (group_ref) REFERENCES darwin2.tag_groups(id) ON DELETE CASCADE;


--
-- TOC entry 6225 (class 2606 OID 1414190)
-- Name: taxonomy fk_taxonomy_level_ref_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT fk_taxonomy_level_ref_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 6226 (class 2606 OID 1414195)
-- Name: taxonomy fk_taxonomy_metadata; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT fk_taxonomy_metadata FOREIGN KEY (metadata_ref) REFERENCES darwin2.taxonomy_metadata(id);


--
-- TOC entry 6227 (class 2606 OID 1414200)
-- Name: taxonomy fk_taxonomy_parent_ref_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT fk_taxonomy_parent_ref_taxonomy FOREIGN KEY (parent_ref) REFERENCES darwin2.taxonomy(id) ON DELETE CASCADE;


--
-- TOC entry 6309 (class 2606 OID 1885654)
-- Name: staging_gtu fk_to_gtu; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu
    ADD CONSTRAINT fk_to_gtu FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id);


--
-- TOC entry 6310 (class 2606 OID 1885659)
-- Name: staging_gtu fk_to_import; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu
    ADD CONSTRAINT fk_to_import FOREIGN KEY (import_ref) REFERENCES darwin2.imports(id);


--
-- TOC entry 6304 (class 2606 OID 1414205)
-- Name: users fk_user_people_id; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users
    ADD CONSTRAINT fk_user_people_id FOREIGN KEY (people_id) REFERENCES darwin2.people(id) ON DELETE SET NULL;


--
-- TOC entry 6305 (class 2606 OID 1414210)
-- Name: users_addresses fk_users_addresses_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_addresses
    ADD CONSTRAINT fk_users_addresses_users FOREIGN KEY (person_user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6306 (class 2606 OID 1414215)
-- Name: users_comm fk_users_comm_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_comm
    ADD CONSTRAINT fk_users_comm_users FOREIGN KEY (person_user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6307 (class 2606 OID 1414220)
-- Name: users_login_infos fk_users_login_infos_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_login_infos
    ADD CONSTRAINT fk_users_login_infos_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6269 (class 2606 OID 1414225)
-- Name: preferences fk_users_preferences; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.preferences
    ADD CONSTRAINT fk_users_preferences FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 6308 (class 2606 OID 1414230)
-- Name: users_tracking fk_users_tracking_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_tracking
    ADD CONSTRAINT fk_users_tracking_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id);


--
-- TOC entry 6311 (class 2606 OID 1885664)
-- Name: staging_gtu staging_gtu_import_ref_fkey; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu
    ADD CONSTRAINT staging_gtu_import_ref_fkey FOREIGN KEY (import_ref) REFERENCES darwin2.imports(id);


--
-- TOC entry 6772 (class 0 OID 0)
-- Dependencies: 716
-- Name: FUNCTION check_auto_increment_code_in_spec(); Type: ACL; Schema: darwin2; Owner: postgres
--

GRANT ALL ON FUNCTION darwin2.check_auto_increment_code_in_spec() TO darwin2;


--
-- TOC entry 6773 (class 0 OID 0)
-- Dependencies: 808
-- Name: FUNCTION fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean); Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT ALL ON FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean) TO postgres;


--
-- TOC entry 6798 (class 0 OID 0)
-- Dependencies: 790
-- Name: FUNCTION fct_rmca_refresh_public_view(); Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT ALL ON FUNCTION darwin2.fct_rmca_refresh_public_view() TO postgres;


--
-- TOC entry 6799 (class 0 OID 0)
-- Dependencies: 1632
-- Name: FUNCTION rmca_dmscheck_syntax(coord_dms character varying); Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT ALL ON FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) TO postgres;


--
-- TOC entry 6800 (class 0 OID 0)
-- Dependencies: 1707
-- Name: FUNCTION rmca_import_gtu_in_darwin_fast(p_import_ref integer); Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT ALL ON FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) TO postgres;


--
-- TOC entry 6801 (class 0 OID 0)
-- Dependencies: 1637
-- Name: FUNCTION rowcount_all(schema_name text); Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT ALL ON FUNCTION darwin2.rowcount_all(schema_name text) TO postgres;


--
-- TOC entry 6950 (class 0 OID 0)
-- Dependencies: 519
-- Name: TABLE fix_date_kin_feb2022; Type: ACL; Schema: darwin2; Owner: postgres
--

GRANT ALL ON TABLE darwin2.fix_date_kin_feb2022 TO darwin2;


--
-- TOC entry 6982 (class 0 OID 0)
-- Dependencies: 306
-- Name: TABLE identifiers; Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT SELECT ON TABLE darwin2.identifiers TO postgres;


--
-- TOC entry 7155 (class 0 OID 0)
-- Dependencies: 470
-- Name: TABLE v_rmca_collections_path_as_text; Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT SELECT ON TABLE darwin2.v_rmca_collections_path_as_text TO postgres;


--
-- TOC entry 7332 (class 0 OID 0)
-- Dependencies: 547
-- Name: TABLE staging_gtu; Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT SELECT ON TABLE darwin2.staging_gtu TO postgres;


--
-- TOC entry 7340 (class 0 OID 0)
-- Dependencies: 549
-- Name: TABLE staging_gtu_tag_groups; Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT SELECT ON TABLE darwin2.staging_gtu_tag_groups TO postgres;


--
-- TOC entry 7375 (class 0 OID 0)
-- Dependencies: 386
-- Name: TABLE staging_tag_groups; Type: ACL; Schema: darwin2; Owner: darwin2
--

GRANT SELECT ON TABLE darwin2.staging_tag_groups TO postgres;


--
-- TOC entry 7463 (class 0 OID 0)
-- Dependencies: 540
-- Name: TABLE anoek_taxo; Type: ACL; Schema: drosera_import; Owner: postgres
--

GRANT ALL ON TABLE drosera_import.anoek_taxo TO darwin2;


-- Completed on 2022-09-09 19:06:52

--
-- PostgreSQL database dump complete
--

