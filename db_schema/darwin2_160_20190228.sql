--
-- PostgreSQL database dump
--

-- Dumped from database version 9.5.14
-- Dumped by pg_dump version 11.1

-- Started on 2019-02-28 19:49:48

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- TOC entry 15 (class 2615 OID 4814661)
-- Name: darwin2; Type: SCHEMA; Schema: -; Owner: darwin2
--

CREATE SCHEMA darwin2;


ALTER SCHEMA darwin2 OWNER TO darwin2;

--
-- TOC entry 7 (class 3079 OID 4814662)
-- Name: file_fdw; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS file_fdw WITH SCHEMA public;


--
-- TOC entry 5794 (class 0 OID 0)
-- Dependencies: 7
-- Name: EXTENSION file_fdw; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION file_fdw IS 'foreign-data wrapper for flat file access';


--
-- TOC entry 6 (class 3079 OID 4814666)
-- Name: fuzzystrmatch; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS fuzzystrmatch WITH SCHEMA public;


--
-- TOC entry 5795 (class 0 OID 0)
-- Dependencies: 6
-- Name: EXTENSION fuzzystrmatch; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION fuzzystrmatch IS 'determine similarities and distance between strings';


--
-- TOC entry 5 (class 3079 OID 4814677)
-- Name: hstore; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA public;


--
-- TOC entry 5796 (class 0 OID 0)
-- Dependencies: 5
-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION hstore IS 'data type for storing sets of (key, value) pairs';


--
-- TOC entry 4 (class 3079 OID 4814800)
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- TOC entry 5797 (class 0 OID 0)
-- Dependencies: 4
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'text similarity measurement and index searching based on trigrams';


--
-- TOC entry 3 (class 3079 OID 4814851)
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;


--
-- TOC entry 5798 (class 0 OID 0)
-- Dependencies: 3
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- TOC entry 2 (class 3079 OID 4814888)
-- Name: postgis; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA public;


--
-- TOC entry 5799 (class 0 OID 0)
-- Dependencies: 2
-- Name: EXTENSION postgis; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION postgis IS 'PostGIS geometry, geography, and raster spatial types and functions';


--
-- TOC entry 8 (class 3079 OID 4816254)
-- Name: tablefunc; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS tablefunc WITH SCHEMA darwin2;


--
-- TOC entry 5800 (class 0 OID 0)
-- Dependencies: 8
-- Name: EXTENSION tablefunc; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION tablefunc IS 'functions that manipulate whole tables, including crosstab';


--
-- TOC entry 2386 (class 1247 OID 4816276)
-- Name: coverages; Type: TYPE; Schema: darwin2; Owner: darwin2
--

CREATE TYPE darwin2.coverages AS ENUM (
    'temporal',
    'spatial'
);


ALTER TYPE darwin2.coverages OWNER TO darwin2;

--
-- TOC entry 2389 (class 1247 OID 4816283)
-- Name: encoders_stats_collections; Type: TYPE; Schema: darwin2; Owner: postgres
--

CREATE TYPE darwin2.encoders_stats_collections AS (
	encoder text,
	collection_path text,
	new_items bigint,
	updated_items bigint,
	new_types bigint,
	updated_types bigint,
	new_species bigint
);


ALTER TYPE darwin2.encoders_stats_collections OWNER TO postgres;

--
-- TOC entry 2392 (class 1247 OID 4816284)
-- Name: full_text_language; Type: DOMAIN; Schema: darwin2; Owner: darwin2
--

CREATE DOMAIN darwin2.full_text_language AS character varying NOT NULL DEFAULT 'simple'::character varying
	CONSTRAINT full_text_language_chk CHECK (((VALUE)::text = ANY (ARRAY[('danish'::character varying)::text, ('dutch'::character varying)::text, ('english'::character varying)::text, ('finnish'::character varying)::text, ('french'::character varying)::text, ('german'::character varying)::text, ('hungarian'::character varying)::text, ('italian'::character varying)::text, ('norwegian'::character varying)::text, ('portuguese'::character varying)::text, ('romanian'::character varying)::text, ('russian'::character varying)::text, ('spanish'::character varying)::text, ('swedish'::character varying)::text, ('turkish'::character varying)::text, ('simple'::character varying)::text])));


ALTER DOMAIN darwin2.full_text_language OWNER TO darwin2;

--
-- TOC entry 2394 (class 1247 OID 4816288)
-- Name: rmca_taxon_report; Type: TYPE; Schema: darwin2; Owner: darwin2
--

CREATE TYPE darwin2.rmca_taxon_report AS (
	domain character varying,
	kingdom character varying,
	super_phylum character varying,
	phylum character varying,
	sub_phylum character varying,
	infra_phylum character varying,
	super_cohort_botany character varying,
	cohort_botany character varying,
	sub_cohort_botany character varying,
	infra_cohort_botany character varying,
	super_class character varying,
	class character varying,
	sub_class character varying,
	infra_class character varying,
	super_division character varying,
	division character varying,
	sub_division character varying,
	infra_division character varying,
	super_legion character varying,
	legion character varying,
	sub_legion character varying,
	infra_legion character varying,
	super_cohort_zoology character varying,
	cohort_zoology character varying,
	sub_cohort_zoology character varying,
	infra_cohort_zoology character varying,
	super_order character varying,
	"order" character varying,
	sub_order character varying,
	infra_order character varying,
	section_zoology character varying,
	sub_section_zoology character varying,
	super_family character varying,
	family character varying,
	sub_family character varying,
	infra_family character varying,
	super_tribe character varying,
	tribe character varying,
	sub_tribe character varying,
	infra_tribe character varying,
	genus character varying,
	sub_genus character varying,
	section_botany character varying,
	sub_section_botany character varying,
	serie character varying,
	sub_serie character varying,
	super_species character varying,
	species character varying,
	sub_species character varying,
	variety character varying,
	sub_variety character varying,
	form character varying,
	sub_form character varying,
	abberans character varying
);


ALTER TYPE darwin2.rmca_taxon_report OWNER TO darwin2;

--
-- TOC entry 2397 (class 1247 OID 4816291)
-- Name: stats_collections; Type: TYPE; Schema: darwin2; Owner: postgres
--

CREATE TYPE darwin2.stats_collections AS (
	collection character varying,
	new_items bigint,
	updated_items bigint,
	new_types bigint,
	updated_types bigint,
	new_species bigint
);


ALTER TYPE darwin2.stats_collections OWNER TO postgres;

--
-- TOC entry 2400 (class 1247 OID 4816294)
-- Name: taxo_collections; Type: TYPE; Schema: darwin2; Owner: darwin2
--

CREATE TYPE darwin2.taxo_collections AS (
	family character varying,
	family_cnt bigint,
	genus character varying,
	genus_cnt bigint,
	species character varying,
	species_cnt bigint
);


ALTER TYPE darwin2.taxo_collections OWNER TO darwin2;

--
-- TOC entry 2403 (class 1247 OID 4816297)
-- Name: taxo_collections_no_fam; Type: TYPE; Schema: darwin2; Owner: darwin2
--

CREATE TYPE darwin2.taxo_collections_no_fam AS (
	count bigint
);


ALTER TYPE darwin2.taxo_collections_no_fam OWNER TO darwin2;

--
-- TOC entry 2406 (class 1247 OID 4816300)
-- Name: taxo_collections_total; Type: TYPE; Schema: darwin2; Owner: darwin2
--

CREATE TYPE darwin2.taxo_collections_total AS (
	count bigint
);


ALTER TYPE darwin2.taxo_collections_total OWNER TO darwin2;

--
-- TOC entry 2409 (class 1247 OID 4816301)
-- Name: box3d_extent; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.box3d_extent;


ALTER TYPE public.box3d_extent OWNER TO postgres;

--
-- TOC entry 2410 (class 1247 OID 4816302)
-- Name: chip; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.chip;


ALTER TYPE public.chip OWNER TO postgres;

--
-- TOC entry 1706 (class 1255 OID 4816303)
-- Name: check_auto_increment_code_in_spec(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.check_auto_increment_code_in_spec() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  col collections%ROWTYPE;
  number BIGINT ;
BEGIN
  IF TG_OP != 'DELETE' THEN
    IF NEW.referenced_relation = 'specimens' THEN
      SELECT c.* INTO col FROM collections c INNER JOIN specimens s ON s.collection_ref=c.id WHERE s.id=NEW.record_id;
      IF FOUND THEN
        IF NEW.code_category = 'main' THEN
          IF isnumeric(NEW.code) AND strpos(NEW.code, 'E') = 0 THEN
            number := NEW.code::bigint;
            IF number > col.code_last_value THEN
              UPDATE collections set code_last_value = number WHERE id=col.id ;
            END IF;
          ELSE
            UPDATE collections
            SET code_last_value = (SELECT max(code_num)
                                   FROM codes inner join specimens
                                     ON codes.referenced_relation = 'specimens'
                                     AND codes.record_id = specimens.id
                                   WHERE codes.code_category = 'main'
                                     AND specimens.collection_ref = col.id
                                     AND codes.code_num IS NOT NULL
                                  )
            WHERE id = col.id
              AND EXISTS (SELECT 1
                          FROM codes inner join specimens
                            ON codes.referenced_relation = 'specimens'
                            AND codes.record_id = specimens.id
                          WHERE codes.code_category = 'main'
                            AND specimens.collection_ref = col.id
                            AND codes.code_num IS NOT NULL
                          LIMIT 1
                         );
            IF NOT FOUND THEN
              UPDATE collections
              SET code_last_value = DEFAULT
              WHERE id=col.id;
            END IF;
          END IF;
        ELSEIF TG_OP = 'UPDATE' THEN
          IF OLD.code_category = 'main' THEN
            IF isnumeric(OLD.code) AND strpos(OLD.code, 'E') = 0 THEN
              number := OLD.code::bigint;
              IF number = col.code_last_value THEN
                UPDATE collections
                SET code_last_value = (SELECT max(code_num)
                                       FROM codes inner join specimens
                                         ON codes.referenced_relation = 'specimens'
                                         AND codes.record_id = specimens.id
                                       WHERE codes.code_category = 'main'
                                         AND specimens.collection_ref = col.id
                                         AND codes.code_num IS NOT NULL
                                      )
                WHERE id = col.id
                  AND EXISTS (SELECT 1
                              FROM codes inner join specimens
                                ON codes.referenced_relation = 'specimens'
                                AND codes.record_id = specimens.id
                              WHERE codes.code_category = 'main'
                                AND specimens.collection_ref = col.id
                                AND codes.code_num IS NOT NULL
                              LIMIT 1
                             );
                IF NOT FOUND THEN
                  UPDATE collections
                  SET code_last_value = DEFAULT
                  WHERE id=col.id;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF ;
    RETURN NEW;
  ELSE
    IF OLD.referenced_relation = 'specimens' AND OLD.code_category = 'main' THEN
      SELECT c.* INTO col FROM collections c INNER JOIN specimens s ON s.collection_ref=c.id WHERE s.id=OLD.record_id;
      IF FOUND AND isnumeric(OLD.code) AND strpos(OLD.code, 'E') = 0 THEN
        UPDATE collections
        SET code_last_value = (SELECT max(code_num)
                               FROM codes INNER JOIN specimens
                                 ON  codes.referenced_relation = 'specimens'
                                 AND codes.record_id = specimens.id
                               WHERE codes.code_category = 'main'
                                 AND specimens.collection_ref = col.id
                                 AND codes.code_num IS NOT NULL
                              )
        WHERE id=col.id
          AND EXISTS (SELECT 1
                      FROM codes inner join specimens
                        ON codes.referenced_relation = 'specimens'
                        AND codes.record_id = specimens.id
                      WHERE codes.code_category = 'main'
                        AND specimens.collection_ref = col.id
                        AND codes.code_num IS NOT NULL
                      LIMIT 1
                     );
        IF NOT FOUND THEN
          UPDATE collections
          SET code_last_value = DEFAULT
          WHERE id=col.id;
        END IF;
      END IF;
    END IF ;
    RETURN OLD;
  END IF;
END;
$$;


ALTER FUNCTION darwin2.check_auto_increment_code_in_spec() OWNER TO postgres;

--
-- TOC entry 1705 (class 1255 OID 4816304)
-- Name: chk_part_not_loaned(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.chk_part_not_loaned() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    IF exists( SELECT 1 FROM loan_items i INNER JOIN loan_status s on i.loan_ref = s.loan_ref
        WHERE s.is_last= true AND s.status != 'closed' AND i.part_ref = OLD.id ) THEN
      RAISE EXCEPTION 'The Part is currently used in an ongoing loan';
    END IF;
    RETURN OLD;
END;
$$;


ALTER FUNCTION darwin2.chk_part_not_loaned() OWNER TO postgres;

--
-- TOC entry 1707 (class 1255 OID 4816305)
-- Name: chk_specimens_not_loaned(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.chk_specimens_not_loaned() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

    IF exists( SELECT 1 FROM loan_items i INNER JOIN loan_status s on i.loan_ref = s.loan_ref
        WHERE s.is_last= true AND s.status != 'closed' AND i.specimen_ref = OLD.id ) THEN
      RAISE EXCEPTION 'The Part is currently used in an ongoing loan';
    END IF;
    RETURN OLD;
END;
$$;


ALTER FUNCTION darwin2.chk_specimens_not_loaned() OWNER TO postgres;

--
-- TOC entry 1708 (class 1255 OID 4816306)
-- Name: clean_imports(integer); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.clean_imports(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  recStaging RECORD;
  intCount integer := 0;
begin
  FOR recStaging IN SELECT DISTINCT taxon_ref, taxon_level_name FROM staging where import_ref = 61 and taxon_level_ref is not null order by taxon_level_name desc LOOP
    SELECT COUNT(*) INTO intCount 
    FROM taxonomy INNER JOIN specimens ON taxonomy.id = specimens.taxon_ref
    WHERE taxonomy.id = recStaging.taxon_ref::integer;
    IF intCount = 0 THEN
      SELECT COUNT(*) INTO intCount FROM taxonomy INNER JOIN specimens ON taxonomy.id = specimens.taxon_parent_ref WHERE specimens.taxon_parent_ref = recStaging.taxon_ref::integer;
      IF intCount = 0 THEN
        begin
          DELETE FROM taxonomy WHERE id = recStaging.taxon_ref::integer;
        exception when foreign_key_violation then
          INSERT INTO zzz_taxa_imported_not_cleaned VALUES (recStaging.taxon_ref::integer, 'Other taxa depends on this taxon.');
        end;
      ELSE
        INSERT INTO zzz_taxa_imported_not_cleaned VALUES (recStaging.taxon_ref::integer, 'Taxon linked as taxon_parent_ref to ' || intCount::varchar || ' specimens');
      END IF;
    ELSE
      INSERT INTO zzz_taxa_imported_not_cleaned VALUES (recStaging.taxon_ref::integer, 'Taxon linked as taxon_ref to ' || intCount::varchar || ' specimens');
    END IF;
    intCount:=0;
  END LOOP;
  return true;
exception
  when others then
    RAISE WARNING 'An error occured: %', SQLERRM;
    return false;
end;
$$;


ALTER FUNCTION darwin2.clean_imports(integer) OWNER TO cebmpad;

--
-- TOC entry 1709 (class 1255 OID 4816307)
-- Name: concat(text[]); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.concat(VARIADIC text[]) RETURNS text
    LANGUAGE sql
    AS $_$
    SELECT array_to_string($1,'');
$_$;


ALTER FUNCTION darwin2.concat(VARIADIC text[]) OWNER TO darwin2;

--
-- TOC entry 1710 (class 1255 OID 4816308)
-- Name: convert_to_integer(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.convert_to_integer(v_input character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE v_int_value INTEGER DEFAULT 0;
BEGIN
    BEGIN
        v_int_value := v_input::INTEGER;
    EXCEPTION WHEN OTHERS THEN
/*        RAISE NOTICE 'Invalid integer value: "%".  Returning NULL.', v_input;*/
        RETURN 0;
    END;
RETURN v_int_value;
END;
$$;


ALTER FUNCTION darwin2.convert_to_integer(v_input character varying) OWNER TO darwin2;

--
-- TOC entry 1711 (class 1255 OID 4816309)
-- Name: convert_to_real(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.convert_to_real(v_input character varying) RETURNS real
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE v_int_value REAL DEFAULT 0;
BEGIN
    BEGIN
        v_int_value := v_input::REAL;
    EXCEPTION WHEN OTHERS THEN
/*        RAISE NOTICE 'Invalid integer value: "%".  Returning NULL.', v_input;*/
        RETURN 0;
    END;
RETURN v_int_value;
END;
$$;


ALTER FUNCTION darwin2.convert_to_real(v_input character varying) OWNER TO darwin2;

--
-- TOC entry 1894 (class 1255 OID 4816310)
-- Name: convert_to_unified(character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
    r_val real :=0;
BEGIN
    IF property is NULL THEN
        RETURN NULL;
    END IF;

    BEGIN
      r_val := property::real;
    EXCEPTION WHEN SQLSTATE '22P02' THEN
      RETURN null;
    END;

    IF property_unit IN ('Kt', 'Beaufort', 'm/s') THEN
        RETURN fct_cpy_speed_conversion(r_val, property_unit)::text;
    END IF;

    IF property_unit IN ( 'g', 'hg', 'kg', 'ton', 'dg', 'cg', 'mg', 'lb', 'lbs', 'pound' , 'ounce' , 'grain') THEN
        RETURN fct_cpy_weight_conversion(r_val, property_unit)::text;
    END IF;

    IF property_unit IN ('m³', 'l', 'cm³', 'ml', 'mm³' ,'µl' , 'µm³' , 'km³', 'Ml' , 'hl') THEN
        RETURN fct_cpy_volume_conversion(r_val, property_unit)::text;
    END IF;

    IF property_unit IN ('K', '°C', '°F', '°Ra', '°Re', '°r', '°N', '°Rø', '°De') THEN
        RETURN fct_cpy_temperature_conversion(r_val, property_unit)::text;
    END IF;

    IF property_unit IN ('m', 'dm', 'cm', 'mm', 'µm', 'nm', 'pm', 'fm', 'am', 'zm', 'ym', 'am', 'dam', 'hm', 'km', 'Mm', 'Gm', 'Tm', 'Pm', 'Em', 'Zm', 'Ym', 'mam', 'mom', 'Å', 'ua', 'ch', 'fathom', 'fermi', 'ft', 'in', 'K', 'l.y.', 'ly', 'µ', 'mil', 'mi', 'nautical mi', 'pc', 'point', 'pt', 'pica', 'rd', 'yd', 'arp', 'lieue', 'league', 'cal', 'twp', 'p', 'P', 'fur', 'brasse', 'vadem', 'fms') THEN
        RETURN fct_cpy_length_conversion(r_val, property_unit)::text;
    END IF;

    RETURN  property;

END;
$$;


ALTER FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying) OWNER TO postgres;

--
-- TOC entry 1713 (class 1255 OID 4816311)
-- Name: convert_to_unified(character varying, character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying, property_type character varying) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    r_val real :=0;
BEGIN
    IF property is NULL THEN
        RETURN NULL;
    END IF;

    BEGIN
      r_val := property::real;
    EXCEPTION WHEN SQLSTATE '22P02' THEN
      RETURN null;
    END;

    IF property_type = 'speed' THEN
        RETURN fct_cpy_speed_conversion(r_val, property_unit)::text;
    END IF;

    IF property_type = 'weight' THEN
        RETURN fct_cpy_weight_conversion(r_val, property_unit)::text;
    END IF;

    IF property_type = 'volume' THEN
        RETURN fct_cpy_volume_conversion(r_val, property_unit)::text;
    END IF;

    IF property_type = 'temperature' AND property_unit IN ('K', '°C', '°F', '°Ra', '°Re', '°r', '°N', '°Rø', '°De') THEN
        RETURN fct_cpy_temperature_conversion(r_val, property_unit)::text;
    END IF;

    IF property_type IN ('length') AND property_unit IN ('m', 'dm', 'cm', 'mm', 'µm', 'nm', 'pm', 'fm', 'am', 'zm', 'ym', 'am', 'dam', 'hm', 'km', 'Mm', 'Gm', 'Tm', 'Pm', 'Em', 'Zm', 'Ym', 'mam', 'mom', 'Å', 'ua', 'ch', 'fathom', 'fermi', 'ft', 'in', 'K', 'l.y.', 'ly', 'µ', 'mil', 'mi', 'nautical mi', 'pc', 'point', 'pt', 'pica', 'rd', 'yd', 'arp', 'lieue', 'league', 'cal', 'twp', 'p', 'P', 'fur', 'brasse', 'vadem', 'fms') THEN
        RETURN fct_cpy_length_conversion(r_val, property_unit)::text;
    END IF;

    RETURN  property;
END;
$$;


ALTER FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying, property_type character varying) OWNER TO postgres;

--
-- TOC entry 1712 (class 1255 OID 4816312)
-- Name: fct_add_in_dict(text, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_add_in_dict(ref_relation text, ref_field text, dict_val text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  query_str varchar;
BEGIN
  IF dict_val is NULL THEN 
    RETURN TRUE;
  END IF;
    query_str := ' INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT ' || quote_literal(ref_relation) || ' , ' || quote_literal(ref_field) || ', ' || quote_literal(dict_val) || ' WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = ' || quote_literal(ref_relation) || '
        AND dict_field = ' || quote_literal(ref_field) || '
        AND dict_value = ' || quote_literal(dict_val) || ')
    );';
    execute query_str;
    RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_add_in_dict(ref_relation text, ref_field text, dict_val text) OWNER TO darwin2;

--
-- TOC entry 1714 (class 1255 OID 4816313)
-- Name: fct_add_in_dict(text, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_add_in_dict(ref_relation text, ref_field text, old_value text, new_val text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  query_str varchar;
BEGIN
  IF new_val is NULL OR old_value IS NOT DISTINCT FROM new_val THEN
    RETURN TRUE;
  END IF;
    query_str := ' INSERT INTO flat_dict (referenced_relation, dict_field, dict_value)
    (
      SELECT ' || quote_literal(ref_relation) || ' , ' || quote_literal(ref_field) || ', ' || quote_literal(new_val) || ' WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = ' || quote_literal(ref_relation) || '
        AND dict_field = ' || quote_literal(ref_field) || '
        AND dict_value = ' || quote_literal(new_val) || ')
    );';
    execute query_str;
    RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_add_in_dict(ref_relation text, ref_field text, old_value text, new_val text) OWNER TO darwin2;

--
-- TOC entry 1715 (class 1255 OID 4816314)
-- Name: fct_add_in_dict_dept(text, text, text, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_add_in_dict_dept(ref_relation text, ref_field text, old_value text, new_val text, depending_old_value text, depending_new_value text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  query_str varchar;
  dpt_new_val varchar;
BEGIN
  IF new_val is NULL OR ( old_value IS NOT DISTINCT FROM new_val AND depending_old_value IS NOT DISTINCT FROM depending_new_value ) THEN
    RETURN TRUE;
  END IF;
  dpt_new_val := coalesce(depending_new_value,'');

    query_str := ' INSERT INTO flat_dict (referenced_relation, dict_field, dict_value, dict_depend)
    (
      SELECT ' || quote_literal(ref_relation) || ' , ' || quote_literal(ref_field) || ', ' || quote_literal(new_val) || ', '
        || quote_literal(dpt_new_val) || ' WHERE NOT EXISTS
      (SELECT id FROM flat_dict WHERE
        referenced_relation = ' || quote_literal(ref_relation) || '
        AND dict_field = ' || quote_literal(ref_field) || '
        AND dict_value = ' || quote_literal(new_val) || '
        AND dict_depend = ' || quote_literal(dpt_new_val) || '
      )
    );';
    --RAISE info 'hem %' ,  dpt_new_val;
    execute query_str;
    RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_add_in_dict_dept(ref_relation text, ref_field text, old_value text, new_val text, depending_old_value text, depending_new_value text) OWNER TO postgres;

--
-- TOC entry 1720 (class 1255 OID 4816315)
-- Name: fct_after_save_add_code(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_after_save_add_code(collectionid integer, specimenid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  col collections%ROWTYPE;
BEGIN
  SELECT c.* INTO col FROM collections c WHERE c.id = collectionId;
  IF FOUND THEN
    IF col.code_auto_increment = TRUE THEN
      INSERT INTO codes (referenced_relation, record_id, code_prefix, code_prefix_separator, code, code_suffix_separator, code_suffix)
      SELECT 'specimens', specimenId, col.code_prefix, col.code_prefix_separator, (col.code_last_value+1)::varchar, col.code_suffix_separator, col.code_suffix
      WHERE NOT EXISTS (SELECT 1 
                        FROM codes 
                        WHERE referenced_relation = 'specimens'
                          AND record_id = specimenId
                          AND code_category = 'main'
                          AND code_num IS NOT NULL
                        LIMIT 1
                       );
    END IF;
  END IF;
  RETURN 0;
END;
$$;


ALTER FUNCTION darwin2.fct_after_save_add_code(collectionid integer, specimenid integer) OWNER TO postgres;

--
-- TOC entry 1716 (class 1255 OID 4816316)
-- Name: fct_array_find(anyarray, anyelement); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_array_find(in_array anyarray, elem anyelement, OUT item_order integer) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
    select s from generate_series(1,array_upper($1, 1)) as s where $1[s] = $2;
$_$;


ALTER FUNCTION darwin2.fct_array_find(in_array anyarray, elem anyelement, OUT item_order integer) OWNER TO darwin2;

--
-- TOC entry 1717 (class 1255 OID 4816317)
-- Name: fct_array_find(character varying, anyelement); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_array_find(in_array character varying, elem anyelement, OUT item_order integer) RETURNS integer
    LANGUAGE sql IMMUTABLE
    AS $_$
    select fct_array_find(string_to_array($1,','), $2::text);
$_$;


ALTER FUNCTION darwin2.fct_array_find(in_array character varying, elem anyelement, OUT item_order integer) OWNER TO darwin2;

--
-- TOC entry 1718 (class 1255 OID 4816318)
-- Name: fct_auto_insert_status_history(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_auto_insert_status_history() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
 user_id int;
BEGIN
    SELECT COALESCE(get_setting('darwin.userid'),'0')::integer INTO user_id;
    IF user_id = 0 THEN
      RETURN NEW;
    END IF;

    INSERT INTO loan_status
      (loan_ref, user_ref, status, modification_date_time, comment, is_last)
      VALUES
      (NEW.id, user_id, 'new', now(), '', true);

    INSERT INTO loan_rights
      (loan_ref, user_ref, has_encoding_right)
      VALUES
      (NEW.id, user_id, true);

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_auto_insert_status_history() OWNER TO darwin2;

--
-- TOC entry 1719 (class 1255 OID 4816319)
-- Name: fct_cast_to_real(text); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_cast_to_real(element text) RETURNS real
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE r_val real;
BEGIN
    BEGIN
      r_val := element::real;
      return r_val;
    EXCEPTION WHEN SQLSTATE '22P02' THEN
      RETURN null;
    END;
END;
$$;


ALTER FUNCTION darwin2.fct_cast_to_real(element text) OWNER TO cebmpad;

--
-- TOC entry 1725 (class 1255 OID 4816320)
-- Name: fct_catalogue_import_keywords_update(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_catalogue_import_keywords_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  booContinue BOOLEAN := FALSE;
  intDiag INTEGER;
BEGIN
  IF TG_TABLE_NAME = 'staging_catalogue' THEN
    IF TG_OP IN ('INSERT', 'UPDATE') THEN
      IF COALESCE(NEW.catalogue_ref,0) != 0 AND COALESCE(NEW.level_ref,0) != 0 THEN
        UPDATE classification_keywords as mck
        SET
          referenced_relation = (
            SELECT level_type
            FROM catalogue_levels
            WHERE id = NEW.level_ref
          ),
          record_id = NEW.catalogue_ref
        WHERE mck.referenced_relation = TG_TABLE_NAME
              AND mck.record_id = NEW.id
              AND NOT EXISTS (
            SELECT 1
            FROM classification_keywords as sck
            WHERE sck.referenced_relation = (
              SELECT level_type
              FROM catalogue_levels
              WHERE id = NEW.level_ref
            )
                  AND sck.record_id = NEW.catalogue_ref
                  AND sck.keyword_type = mck.keyword_type
                  AND sck.keyword_indexed = mck.keyword_indexed
        );
      END IF;
      RETURN NEW;
    ELSE
      DELETE FROM classification_keywords
      WHERE referenced_relation = 'staging_catalogue'
            AND record_id = OLD.id;
      RETURN NULL;
    END IF;
  ELSEIF TG_TABLE_NAME = 'staging' THEN
    IF TG_OP IN ('INSERT', 'UPDATE') THEN
      IF COALESCE(NEW.taxon_ref,0) != 0 AND COALESCE(NEW.taxon_level_ref,0) != 0 THEN
        IF TG_OP = 'UPDATE' THEN
          IF COALESCE(NEW.taxon_ref,0) != COALESCE(OLD.taxon_ref,0) THEN
            booContinue := TRUE;
          END IF;
        ELSE
          booContinue := TRUE;
        END IF;
        IF booContinue = TRUE THEN
          UPDATE classification_keywords as mck
          SET
            referenced_relation = 'taxonomy',
            record_id = NEW.taxon_ref
          WHERE mck.referenced_relation = TG_TABLE_NAME
                AND mck.record_id = NEW.id
                AND mck.keyword_type IN (
            'GenusOrMonomial',
            'Subgenus',
            'SpeciesEpithet',
            'FirstEpiteth',
            'SubspeciesEpithet',
            'InfraspecificEpithet',
            'AuthorTeamAndYear',
            'AuthorTeam',
            'AuthorTeamOriginalAndYear',
            'AuthorTeamParenthesisAndYear',
            'SubgenusAuthorAndYear',
            'CultivarGroupName',
            'CultivarName',
            'Breed',
            'CombinationAuthorTeamAndYear',
            'NamedIndividual'
          )
                AND NOT EXISTS (
              SELECT 1
              FROM classification_keywords as sck
              WHERE sck.referenced_relation = 'taxonomy'
                    AND sck.record_id = NEW.taxon_ref
                    AND sck.keyword_type = mck.keyword_type
                    AND sck.keyword_indexed = mck.keyword_indexed
          );
        END IF;
      ELSEIF COALESCE(NEW.mineral_ref,0) != 0 AND COALESCE(NEW.mineral_level_ref,0) != 0 THEN
        IF TG_OP = 'UPDATE' THEN
          IF COALESCE(NEW.mineral_ref,0) != COALESCE(OLD.mineral_ref,0) THEN
            booContinue := TRUE;
          END IF;
        ELSE
          booContinue := TRUE;
        END IF;
        IF booContinue = TRUE THEN
          UPDATE classification_keywords as mck
          SET
            referenced_relation = 'mineralogy',
            record_id = NEW.mineral_ref
          WHERE mck.referenced_relation = TG_TABLE_NAME
                AND mck.record_id = NEW.id
                AND mck.keyword_type IN (
            'AuthorTeamAndYear',
            'AuthorTeam',
            'NamedIndividual'
          )
                AND NOT EXISTS (
              SELECT 1
              FROM classification_keywords as sck
              WHERE sck.referenced_relation = 'mineralogy'
                    AND sck.record_id = NEW.mineral_ref
                    AND sck.keyword_type = mck.keyword_type
                    AND sck.keyword_indexed = mck.keyword_indexed
          );
        END IF;
      END IF;
      RETURN NEW;
    ELSE
      DELETE FROM classification_keywords
      WHERE referenced_relation = 'staging'
            AND record_id = OLD.id;
      RETURN NULL;
    END IF;
  END IF;
END;
$$;


ALTER FUNCTION darwin2.fct_catalogue_import_keywords_update() OWNER TO postgres;

--
-- TOC entry 1721 (class 1255 OID 4816321)
-- Name: fct_chk_arerole(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_arerole() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  IF NEW.people_type = 'author' THEN

    IF NOT EXISTS( SELECT id FROM people WHERE (db_people_type & 2)!=0 AND id=NEW.people_ref) THEN
      RAISE EXCEPTION 'Author must be defined as author.';
    END IF;

  ELSIF NEW.people_type = 'identifier' THEN

    IF NOT EXISTS( SELECT id FROM people WHERE (db_people_type & 4)!=0 AND id=NEW.people_ref) THEN
      RAISE EXCEPTION 'Experts must be defined as identifier.';
    END IF;

  ELSIF NEW.people_type = 'expert' THEN

    IF NOT EXISTS( SELECT id FROM people WHERE (db_people_type & 8)!=0 AND id=NEW.people_ref) THEN
      RAISE EXCEPTION 'Experts must be defined as expert.';
    END IF;

  ELSIF NEW.people_type = 'collector' THEN

    IF NOT EXISTS( SELECT id FROM people WHERE (db_people_type & 16)!=0 AND id=NEW.people_ref) THEN
      RAISE EXCEPTION 'Collectors must be defined as collector.';
    END IF;

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_arerole() OWNER TO darwin2;

--
-- TOC entry 1722 (class 1255 OID 4816322)
-- Name: fct_chk_canupdatecollectionsrights(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_canupdatecollectionsrights() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  mgrName varchar;
  booContinue boolean := false;
BEGIN
  /*Check an unpromotion occurs by modifying db_user_type explicitely or implicitely by replacing a user by an other
    or moving a user from one collection to an other
  */
  IF (NEW.db_user_type < 4 AND OLD.db_user_type >=4) OR NEW.collection_ref IS DISTINCT FROM OLD.collection_ref OR NEW.user_ref IS DISTINCT FROM OLD.user_ref THEN
    SELECT formated_name INTO mgrName
    FROM collections INNER JOIN users ON users.id = collections.main_manager_ref
    WHERE collections.id = OLD.collection_ref
      AND main_manager_ref = OLD.user_ref;
    /*If user concerned still main manager of the collection, cannot be updated*/
    IF FOUND THEN
      RAISE EXCEPTION 'This manager (%) cannot be updated because he/she is still defined as a main manager for this collection', mgrName;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_canupdatecollectionsrights() OWNER TO darwin2;

--
-- TOC entry 1723 (class 1255 OID 4816323)
-- Name: fct_chk_onceinpath(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_onceinpath(path character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM * FROM regexp_split_to_table(path, E'\/') as i_id WHERE i_id != '' GROUP BY i_id HAVING COUNT(*)>1;
    IF FOUND THEN
        RETURN FALSE;
    END IF;
    RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_onceinpath(path character varying) OWNER TO darwin2;

--
-- TOC entry 1724 (class 1255 OID 4816324)
-- Name: fct_chk_parentcollinstitution(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_parentcollinstitution() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  institutionRef integer;
  booContinue boolean := false;
BEGIN
  IF TG_OP = 'INSERT' THEN
    booContinue := true;
  ELSIF TG_OP = 'UPDATE' THEN
    IF NEW.institution_ref IS DISTINCT FROM OLD.institution_ref OR NEW.parent_ref IS DISTINCT FROM OLD.parent_ref THEN
      booContinue := true;
    END IF;
  END IF;
  IF booContinue THEN
    IF NEW.parent_ref IS NOT NULL THEN
      SELECT institution_ref INTO institutionRef FROM collections WHERE id = NEW.parent_ref;
      IF institutionRef != NEW.institution_ref THEN
        RAISE EXCEPTION 'You tried to insert or update a collection with an other institution than the one given for the parent collection';
      END IF;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_parentcollinstitution() OWNER TO darwin2;

--
-- TOC entry 1656 (class 1255 OID 4816325)
-- Name: fct_chk_peopleismoral(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_peopleismoral() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_exists boolean;
BEGIN
   SELECT is_physical FROM people WHERE id=NEW.institution_ref into rec_exists;

   IF rec_exists = TRUE THEN
    RAISE EXCEPTION 'You cannot link a moral person as Institution';
   END IF;

   RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_peopleismoral() OWNER TO darwin2;

--
-- TOC entry 1726 (class 1255 OID 4816326)
-- Name: fct_chk_peopletype(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_peopletype() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  IF NEW.db_people_type IS DISTINCT FROM OLD.db_people_type THEN

    /** AUTHOR FLAG IS 2 **/
    IF NOT (NEW.db_people_type & 2)>0  THEN
      IF EXISTS( SELECT * FROM catalogue_people WHERE people_ref=NEW.id AND people_type='author')  THEN
        RAISE EXCEPTION 'Author still used as author.';
      END IF;
    END IF;

    /** IDENTIFIER FLAG IS 4 **/
    IF NOT (NEW.db_people_type & 4)>0  THEN
      IF EXISTS( SELECT * FROM catalogue_people WHERE people_ref=NEW.id AND people_type='identifier')  THEN
        RAISE EXCEPTION 'Identifier still used as identifier.';
      END IF;
    END IF;

    /** Expert Flag is 8 **/
    IF NOT (NEW.db_people_type & 8)>0  THEN
      IF EXISTS( SELECT * FROM catalogue_people WHERE people_ref=NEW.id AND people_type='expert')  THEN
        RAISE EXCEPTION 'Expert still used as expert.';
      END IF;
    END IF;

          /** COLLECTOR Flag is 16 **/
    IF NOT (NEW.db_people_type & 16)>0   THEN
      IF EXISTS( SELECT * FROM catalogue_people WHERE people_ref=NEW.id AND people_type='collector')  THEN
        RAISE EXCEPTION 'Collector still used as collector.';
      END IF;
    END IF;
  END IF;
  RETURN NEW;

END;
$$;


ALTER FUNCTION darwin2.fct_chk_peopletype() OWNER TO darwin2;

--
-- TOC entry 1727 (class 1255 OID 4816327)
-- Name: fct_chk_possible_upper_level(character varying, integer, integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_possible_upper_level(referenced_relation character varying, new_parent_ref integer, new_level_ref integer, new_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
response boolean;
BEGIN
  EXECUTE 'SELECT true WHERE EXISTS( SELECT * ' ||
          'from possible_upper_levels ' ||
          'where level_ref = ' || quote_literal(new_level_ref) ||
          '  and coalesce(level_upper_ref,0) = case when ' || quote_literal(coalesce(new_parent_ref,0)) || ' != '|| quote_literal(0) || ' then (select level_ref from ' || quote_ident(referenced_relation) || ' where id = ' || quote_literal(coalesce(new_parent_ref,0)) || ') else ' || quote_literal(coalesce(new_parent_ref,0)) || ' end' ||
          '                              )'
    INTO response;
  IF response IS NULL THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;

  RETURN FALSE;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_possible_upper_level(referenced_relation character varying, new_parent_ref integer, new_level_ref integer, new_id integer) OWNER TO darwin2;

--
-- TOC entry 1730 (class 1255 OID 4816328)
-- Name: fct_chk_referencedrecord(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_referencedrecord() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_exists integer;
BEGIN
	  IF NEW.record_id != -1 THEN --ftheeten 2019 01 18
		  EXECUTE 'SELECT 1 WHERE EXISTS ( SELECT id FROM ' || quote_ident(NEW.referenced_relation)  || ' WHERE id=' || quote_literal(NEW.record_id) || ')' INTO rec_exists;
		  IF rec_exists IS NULL THEN
		    RAISE EXCEPTION 'The referenced record does not exists % %',NEW.referenced_relation, NEW.record_id;
		  END IF;	 
	  END IF;	
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_referencedrecord() OWNER TO darwin2;

--
-- TOC entry 1728 (class 1255 OID 4816329)
-- Name: fct_chk_referencedrecordrelationship(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_referencedrecordrelationship() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_exists integer;
BEGIN

  EXECUTE 'SELECT count(id)  FROM ' || quote_ident(NEW.referenced_relation)  || ' WHERE id=' || quote_literal(NEW.record_id_1) ||  ' OR id=' || quote_literal(NEW.record_id_2) INTO rec_exists;

  IF rec_exists != 2 THEN
    RAISE EXCEPTION 'The referenced record does not exists';
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION darwin2.fct_chk_referencedrecordrelationship() OWNER TO darwin2;

--
-- TOC entry 1731 (class 1255 OID 4816330)
-- Name: fct_chk_specimencollectionallowed(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_specimencollectionallowed() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  user_id integer;
  db_user_type_cpy smallint;
  col_ref integer;
BEGIN
  SELECT COALESCE(get_setting('darwin.userid'),'0')::integer INTO user_id;
  /*If no user id allows modification -> if we do a modif in SQL it should be possible*/
  IF user_id = 0 THEN
    IF TG_OP = 'DELETE' THEN
      RETURN OLD;
    END IF;
    RETURN NEW;
  END IF;

  IF user_id = -1 THEN
    RETURN NEW;
  END IF;
  /*If user_id <> 0, get db_user_type of user concerned*/
  SELECT db_user_type INTO db_user_type_cpy FROM users WHERE id = user_id;
  /*If admin allows whatever*/
  IF db_user_type_cpy = 8 THEN
    IF TG_OP = 'DELETE' THEN
      RETURN OLD;
    END IF;
    RETURN NEW;
  END IF;

  IF TG_TABLE_NAME = 'specimens' THEN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
      IF NOT EXISTS (SELECT 1 FROM fct_search_authorized_encoding_collections (user_id) as r WHERE r = NEW.collection_ref) THEN
        RAISE EXCEPTION 'You don''t have the rights to insert into or update a specimen in this collection';
      END IF;
    ELSE /*Delete*/
      PERFORM true WHERE OLD.collection_ref::integer IN (SELECT * FROM fct_search_authorized_encoding_collections(user_id));
      IF NOT EXISTS (SELECT 1 FROM fct_search_authorized_encoding_collections (user_id) as r WHERE r = OLD.collection_ref) THEN
        RAISE EXCEPTION 'You don''t have the rights to delete a specimen from this collection';
      END IF;
    END IF;
  END IF;
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_chk_specimencollectionallowed() OWNER TO darwin2;

--
-- TOC entry 1732 (class 1255 OID 4816331)
-- Name: fct_chk_upper_level_for_childrens(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_chk_upper_level_for_childrens() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_exists integer;
BEGIN

  EXECUTE 'SELECT count(id)  FROM ' || quote_ident(TG_TABLE_NAME::text) ||
    ' WHERE parent_ref=' || quote_literal(NEW.id) ||
    ' AND fct_chk_possible_upper_level('|| quote_literal(TG_TABLE_NAME::text) ||
    ', parent_ref, level_ref, id) = false ' INTO rec_exists;

  IF rec_exists > 0 THEN
    RAISE EXCEPTION 'Children of this record does not follow the level hierarchy';
  END IF;
  RETURN NEW;

END;
$$;


ALTER FUNCTION darwin2.fct_chk_upper_level_for_childrens() OWNER TO darwin2;

--
-- TOC entry 1735 (class 1255 OID 4816332)
-- Name: fct_clean_staging_catalogue(integer); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_clean_staging_catalogue(importref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
  DECLARE
    recDistinctStagingCatalogue RECORD;
  BEGIN
    FOR recDistinctStagingCatalogue IN SELECT DISTINCT ON (level_ref, fullToIndex(name), name)
                                       id, import_ref, name, level_ref
                                       FROM
                                         (
                                           SELECT
                                             id,
                                             import_ref,
                                             name,
                                             level_ref
                                           FROM staging_catalogue
                                           WHERE import_ref = importRef
                                           ORDER BY level_ref, fullToIndex(name), id
                                         ) as subqry
    LOOP
      UPDATE staging_catalogue
      SET parent_ref = recDistinctStagingCatalogue.id
      WHERE
        import_ref = importRef
        AND parent_ref IN
            (
              SELECT id
              FROM staging_catalogue
              WHERE import_ref = importRef
                AND name = recDistinctStagingCatalogue.name
                AND level_ref = recDistinctStagingCatalogue.level_ref
                AND id != recDistinctStagingCatalogue.id
            );
      DELETE FROM staging_catalogue
      WHERE import_ref = importRef
            and name = recDistinctStagingCatalogue.name
            and level_ref = recDistinctStagingCatalogue.level_ref
            and id != recDistinctStagingCatalogue.id;
    END LOOP;
    RETURN TRUE;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE WARNING 'Error:%', SQLERRM;
      RETURN FALSE;
  END;
$$;


ALTER FUNCTION darwin2.fct_clean_staging_catalogue(importref integer) OWNER TO postgres;

--
-- TOC entry 1733 (class 1255 OID 4816333)
-- Name: fct_clear_identifiers_in_flat(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_clear_identifiers_in_flat() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp_user text;
BEGIN
 SELECT COALESCE(get_setting('darwin.userid'),'0') INTO tmp_user;
  PERFORM set_config('darwin.userid', '-1', false) ;

  IF EXISTS(SELECT true FROM catalogue_people cp WHERE cp.record_id = OLD.id AND cp.referenced_relation = 'identifications') THEN
    -- There's NO identifier associated to this identification'
    UPDATE specimens SET spec_ident_ids = fct_remove_array_elem(spec_ident_ids,
      (
        select array_agg(people_ref) FROM catalogue_people p  INNER JOIN identifications i ON p.record_id = i.id AND i.id = OLD.id
        AND people_ref NOT in
          (
            SELECT people_ref from catalogue_people p INNER JOIN identifications i ON p.record_id = i.id AND p.referenced_relation = 'identifications'
            AND p.people_type='identifier' where i.record_id=OLD.record_id AND i.referenced_relation=OLD.referenced_relation AND i.id != OLD.id
          )
      ))
      WHERE id = OLD.record_id;
  END IF;

  PERFORM set_config('darwin.userid', tmp_user, false) ;
  RETURN OLD;

END;
$$;


ALTER FUNCTION darwin2.fct_clear_identifiers_in_flat() OWNER TO darwin2;

--
-- TOC entry 1734 (class 1255 OID 4816334)
-- Name: fct_clear_referencedrecord(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_clear_referencedrecord() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP ='UPDATE' THEN
    IF NEW.id != OLD.id THEN
      UPDATE template_table_record_ref SET record_id = NEW.id WHERE referenced_relation = TG_TABLE_NAME AND record_id = OLD.id;
    END IF;
  ELSEIF TG_OP = 'DELETE' THEN
    DELETE FROM template_table_record_ref where referenced_relation = TG_TABLE_NAME AND record_id = OLD.id;
  END IF;
  RETURN NULL;
 END;
$$;


ALTER FUNCTION darwin2.fct_clear_referencedrecord() OWNER TO darwin2;

--
-- TOC entry 1729 (class 1255 OID 4816335)
-- Name: fct_clr_specialstatus(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_clr_specialstatus() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  newType varchar := fullToIndex(NEW.type);
BEGIN

  -- IF Type not changed
  IF TG_OP = 'UPDATE' THEN
    IF fullToIndex(OLD.type) = newType THEN
      RETURN NEW;
    END IF;
  END IF;

  IF newType = 'specimen' THEN
    NEW.type_search := 'specimen';
    NEW.type_group := 'specimen';
  ELSIF newType = 'type' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  ELSIF newType = 'subtype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  ELSIF newType = 'allotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'allotype';
  ELSIF newType = 'cotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'syntype';
  ELSIF newType = 'genotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  ELSIF newType = 'holotype' THEN
    NEW.type_search := 'holotype';
    NEW.type_group := 'holotype';
  ELSIF newType = 'hypotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'hypotype';
  ELSIF newType = 'lectotype' THEN
    NEW.type_search := 'lectotype';
    NEW.type_group := 'lectotype';
  ELSIF newType = 'locotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'locotype';
  ELSIF newType = 'neallotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  ELSIF newType = 'neotype' THEN
    NEW.type_search := 'neotype';
    NEW.type_group := 'neotype';
  ELSIF newType = 'paralectotype' THEN
    NEW.type_search := 'paralectotype';
    NEW.type_group := 'paralectotype';
  ELSIF newType = 'paratype' THEN
    NEW.type_search := 'paratype';
    NEW.type_group := 'paratype';
  ELSIF newType = 'plastotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'plastotype';
  ELSIF newType = 'plesiotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'plesiotype';
  ELSIF newType = 'syntype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'syntype';
  ELSIF newType = 'topotype' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'topotype';
  ELSIF newType = 'typeinlitteris' THEN
    NEW.type_search := 'type';
    NEW.type_group := 'type in litteris';
  ELSE
    NEW.type_search := 'type';
    NEW.type_group := 'type';
  END IF;

  RETURN NEW;
EXCEPTION
  WHEN RAISE_EXCEPTION THEN
    return NULL;
END;
$$;


ALTER FUNCTION darwin2.fct_clr_specialstatus() OWNER TO darwin2;

--
-- TOC entry 1736 (class 1255 OID 4816336)
-- Name: fct_count_units(); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_count_units() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  rid integer;
  do_with_type boolean default true;
BEGIN

  IF TG_TABLE_NAME = 'specimen_individuals' THEN
    IF TG_OP = 'INSERT' THEN
      rid := NEW.specimen_ref;
    ELSIF TG_OP = 'UPDATE' THEN
      rid := OLD.specimen_ref;
      IF OLD.type_group IS NOT DISTINCT FROM NEW.type_group THEN
        do_with_type := false;
      END IF;
    ELSE
      rid := OLD.specimen_ref;
    END IF;

    IF do_with_type THEN
      UPDATE specimens_flat s set 
        with_types = exists (select 1 from  specimen_individuals  i2 WHERE i2.specimen_ref = s.specimen_ref AND  i2.type_group <> 'specimen')
      WHERE
         s.specimen_ref = rid
        AND with_types != exists (select 1 from  specimen_individuals  i2 WHERE i2.specimen_ref = s.specimen_ref AND  i2.type_group <> 'specimen');
    END IF;

    UPDATE specimens_flat s set 
      with_individuals = exists (select 1 from  specimen_individuals  i2 WHERE i2.specimen_ref = s.specimen_ref)
      WHERE
        s.specimen_ref = rid
      AND with_individuals != exists (select 1 from  specimen_individuals  i2 WHERE i2.specimen_ref = s.specimen_ref);

  ELSIF TG_TABLE_NAME = 'specimen_parts' THEN

    IF TG_OP = 'INSERT' THEN
      rid = NEW.specimen_individual_ref;
    ELSE
      rid = OLD.specimen_individual_ref;
    END IF;

      UPDATE specimen_individuals i SET
      with_parts = exists (select 1 from specimen_parts p WHERE p.specimen_individual_ref = i.id )
      WHERE i.id = rid
      AND with_parts != exists (select 1 from specimen_parts p WHERE p.specimen_individual_ref = i.id );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_count_units() OWNER TO cebmpad;

--
-- TOC entry 1737 (class 1255 OID 4816337)
-- Name: fct_cpy_deleted_file(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_cpy_deleted_file() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO multimedia_todelete (uri) VALUES (OLD.uri);
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_deleted_file() OWNER TO postgres;

--
-- TOC entry 1738 (class 1255 OID 4816338)
-- Name: fct_cpy_formattedname(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_formattedname() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP ='UPDATE' THEN
    IF NEW.family_name = OLD.family_name AND NEW.given_name = OLD.given_name AND NEW.title = OLD.title THEN
      RETURN NEW;
    END IF;
  END IF;

  IF NEW.is_physical THEN
    IF COALESCE(NEW.title, '') = '' THEN
      NEW.formated_name := COALESCE(NEW.family_name,'') || ' ' || COALESCE(NEW.given_name,'');
    ELSE
      NEW.formated_name := COALESCE(NEW.family_name,'') || ' ' || COALESCE(NEW.given_name,'') || ' (' || NEW.title || ')';
    END IF;
  ELSE
    NEW.formated_name := NEW.family_name;
  END IF;

  NEW.formated_name_indexed := fullToIndex(NEW.formated_name);
  NEW.formated_name_unique := toUniqueStr(NEW.formated_name);
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_formattedname() OWNER TO darwin2;

--
-- TOC entry 1739 (class 1255 OID 4816339)
-- Name: fct_cpy_fulltoindex(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_fulltoindex() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  codeNum varchar;
BEGIN
        IF TG_TABLE_NAME = 'properties' THEN
                NEW.applies_to_indexed := COALESCE(fullToIndex(NEW.applies_to),'');
                NEW.method_indexed := COALESCE(fullToIndex(NEW.method),'');
        ELSIF TG_TABLE_NAME = 'chronostratigraphy' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'collections' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'expeditions' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'bibliography' THEN
                NEW.title_indexed := fullToIndex(NEW.title);
        ELSIF TG_TABLE_NAME = 'identifications' THEN
                NEW.value_defined_indexed := COALESCE(fullToIndex(NEW.value_defined),'');
        ELSIF TG_TABLE_NAME = 'lithology' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'lithostratigraphy' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'mineralogy' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
                NEW.formule_indexed := fullToIndex(NEW.formule);
        ELSIF TG_TABLE_NAME = 'people' THEN
                NEW.formated_name_indexed := COALESCE(fullToIndex(NEW.formated_name),'');
                NEW.name_formated_indexed := fulltoindex(coalesce(NEW.given_name,'') || coalesce(NEW.family_name,''));
                NEW.formated_name_unique := COALESCE(toUniqueStr(NEW.formated_name),'');
        ELSIF TG_TABLE_NAME = 'codes' THEN
                codeNum := coalesce(trim(regexp_replace(NEW.code, '[^0-9]','','g')), '');
                IF codeNum = '' THEN
                  NEW.code_num := 0;
                ELSE
                  NEW.code_num := codeNum::bigint;
                END IF;
                NEW.full_code_indexed := fullToIndex(COALESCE(NEW.code_prefix,'') || COALESCE(NEW.code::text,'') || COALESCE(NEW.code_suffix,'') );
        ELSIF TG_TABLE_NAME = 'tag_groups' THEN
                NEW.group_name_indexed := fullToIndex(NEW.group_name);
                NEW.sub_group_name_indexed := fullToIndex(NEW.sub_group_name);
        ELSIF TG_TABLE_NAME = 'taxonomy' THEN
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'classification_keywords' THEN
                NEW.keyword_indexed := fullToIndex(NEW.keyword);
        ELSIF TG_TABLE_NAME = 'users' THEN
                NEW.formated_name_indexed := COALESCE(fullToIndex(NEW.formated_name),'');
                NEW.formated_name_unique := COALESCE(toUniqueStr(NEW.formated_name),'');
        ELSIF TG_TABLE_NAME = 'vernacular_names' THEN
                NEW.community_indexed := fullToIndex(NEW.community);
                NEW.name_indexed := fullToIndex(NEW.name);
        ELSIF TG_TABLE_NAME = 'igs' THEN
                NEW.ig_num_indexed := fullToIndex(NEW.ig_num);
        ELSIF TG_TABLE_NAME = 'collecting_methods' THEN
                NEW.method_indexed := fullToIndex(NEW.method);
        ELSIF TG_TABLE_NAME = 'collecting_tools' THEN
                NEW.tool_indexed := fullToIndex(NEW.tool);
        ELSIF TG_TABLE_NAME = 'loans' THEN
                NEW.search_indexed := fullToIndex(COALESCE(NEW.name,'') || COALESCE(NEW.description,''));
        ELSIF TG_TABLE_NAME = 'multimedia' THEN
                NEW.search_indexed := fullToIndex ( COALESCE(NEW.title,'') ||  COALESCE(NEW.description,'') || COALESCE(NEW.extracted_info,'') ) ;
        ELSIF TG_TABLE_NAME = 'comments' THEN
                NEW.comment_indexed := fullToIndex(NEW.comment);
        ELSIF TG_TABLE_NAME = 'ext_links' THEN
                NEW.comment_indexed := fullToIndex(NEW.comment);
        ELSIF TG_TABLE_NAME = 'specimens' THEN
                NEW.object_name_indexed := fullToIndex(COALESCE(NEW.object_name,'') );
        END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_fulltoindex() OWNER TO darwin2;

--
-- TOC entry 1740 (class 1255 OID 4816340)
-- Name: fct_cpy_gtutags(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_gtutags() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  curs_entry refcursor;
  entry_row RECORD;
  seen_el varchar[];
BEGIN
  IF TG_OP != 'DELETE' THEN
    OPEN curs_entry FOR SELECT distinct(fulltoIndex(tags)) as u_tag, trim(tags) as tags
                        FROM regexp_split_to_table(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value, ';') as tags
                        WHERE fulltoIndex(tags) != '';
    LOOP
      FETCH curs_entry INTO entry_row;
      EXIT WHEN NOT FOUND;

      seen_el := array_append(seen_el, entry_row.u_tag);

     IF EXISTS( SELECT 1 FROM tags
                WHERE gtu_ref = NEW.gtu_ref
                  AND group_ref = NEW.id
                  AND tag_indexed = entry_row.u_tag) THEN
        IF TG_OP = 'UPDATE' THEN
          IF OLD.sub_group_name != NEW.sub_group_name THEN
            UPDATE tags
            SET sub_group_type = NEW.sub_group_name
            WHERE group_ref = NEW.id;
          END IF;
        END IF;
        CONTINUE;
      ELSE
        INSERT INTO tags (gtu_ref, group_ref, tag_indexed, tag, group_type, sub_group_type )
        VALUES ( NEW.gtu_ref, NEW.id, entry_row.u_tag, entry_row.tags, NEW.group_name, NEW.sub_group_name);
      END IF;
    END LOOP;

    CLOSE curs_entry;

    UPDATE gtu
    SET tag_values_indexed = (SELECT array_agg(tags_list)
                              FROM (SELECT lineToTagRows(tag_agg) AS tags_list
                                    FROM (SELECT case when international_name != '' THEN international_name || ';' ELSE '' END || tag_value AS tag_agg
                                          FROM tag_groups
                                          WHERE id <> NEW.id
                                            AND gtu_ref = NEW.gtu_ref
                                          UNION
                                          SELECT case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value
                                         ) as tag_list_selection
                                   ) as tags_rows
                             )
    WHERE id = NEW.gtu_ref;

    DELETE FROM tags
           WHERE group_ref = NEW.id
              AND gtu_ref = NEW.gtu_ref
              AND fct_array_find(seen_el, tag_indexed ) IS NULL;
    RETURN NEW;
  ELSE
    UPDATE gtu
    SET tag_values_indexed = (SELECT array_agg(tags_list)
                              FROM (SELECT lineToTagRows(tag_agg) AS tags_list
                                    FROM (SELECT tag_value AS tag_agg
                                          FROM tag_groups
                                          WHERE id <> OLD.id
                                            AND gtu_ref = OLD.gtu_ref
                                         ) as tag_list_selection
                                   ) as tags_rows
                             )
    WHERE id = OLD.gtu_ref;
    RETURN NULL;
  END IF;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_gtutags() OWNER TO darwin2;

--
-- TOC entry 1741 (class 1255 OID 4816341)
-- Name: fct_cpy_ig_to_loan_items(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_cpy_ig_to_loan_items() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF OLD.ig_ref is distinct from NEW.ig_ref THEN
    UPDATE loan_items li SET ig_ref = NEW.ig_ref
    WHERE specimen_ref = NEW.ID
    AND li.ig_ref IS NOT DISTINCT FROM OLD.ig_ref;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_ig_to_loan_items() OWNER TO postgres;

--
-- TOC entry 1747 (class 1255 OID 4816342)
-- Name: fct_cpy_length_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'dm' THEN
        ($1)*10^(-1)
      WHEN $2 = 'ft' THEN
        ($1)*3.048*10^(-1)
      WHEN $2 = 'P' THEN
        ($1)*3.24839385*10^(-1)
      WHEN $2 = 'yd' THEN
        ($1)*9.144*10^(-1)
      WHEN $2 = 'cm' THEN
        ($1)*10^(-2)
      WHEN $2 = 'in' THEN
        ($1)*2.54*10^(-2)
      WHEN $2 = 'mm' THEN
        ($1)*10^(-3)
      WHEN $2 = 'pica' THEN
        ($1)*4.233333*10^(-3)
      WHEN $2 = 'p' THEN
        ($1)*27.069949*10^(-3)
      WHEN $2 = 'mom' THEN
        ($1)*10^(-4)
      WHEN $2 IN ('pt', 'point') THEN
        ($1)*3.527778*10^(-4)
      WHEN $2 = 'mil' THEN
        ($1)*2.54*10^(-5)
      WHEN $2 IN ('µm', 'µ') THEN
        ($1)*10^(-6)
      WHEN $2 = 'twp' THEN
        ($1)*17.639*10^(-6)
      WHEN $2 = 'cal' THEN
        ($1)*254*10^(-6)
      WHEN $2 = 'nm' THEN
        ($1)*10^(-9)
      WHEN $2 = 'Å' THEN
        ($1)*10^(-10)
      WHEN $2 = 'pm' THEN
        ($1)*10^(-12)
      WHEN $2 IN ('fm', 'fermi') THEN
        ($1)*10^(-15)
      WHEN $2 = 'am' THEN
        ($1)*10^(-18)
      WHEN $2 = 'zm' THEN
        ($1)*10^(-21)
      WHEN $2 = 'ym' THEN
        ($1)*10^(-24)
      WHEN $2 IN ('brasse', 'vadem') THEN
        ($1)*1.8288
      WHEN $2 = 'fathom' THEN
        ($1)*1.828804
      WHEN $2 = 'rd' THEN
        ($1)*5.02921
      WHEN $2 = 'dam' THEN
        ($1)*10
      WHEN $2 = 'ch' THEN
        ($1)*20.11684
      WHEN $2 = 'arp' THEN
        ($1)*58.471089295
      WHEN $2 IN ('hm', 'K') THEN
        ($1)*10^2
      WHEN $2 = 'fur' THEN
        ($1)*201.168
      WHEN $2 = 'km' THEN
        ($1)*10^3
      WHEN $2 = 'mi' THEN
        ($1)*1.609344*10^3
      WHEN $2 = 'nautical mi' THEN
        ($1)*1.852*10^3
      WHEN $2 IN ('lieue', 'league') THEN
        ($1)*4.828032*10^3
      WHEN $2 = 'mam' THEN
        ($1)*10^4
      WHEN $2 = 'Mm' THEN
        ($1)*10^6
      WHEN $2 = 'Gm' THEN
        ($1)*10^9
      WHEN $2 = 'ua' THEN
        ($1)*1.495979*10^11
      WHEN $2 = 'Tm' THEN
        ($1)*10^12
      WHEN $2 = 'Pm' THEN
        ($1)*10^15
      WHEN $2 = 'pc' THEN
        ($1)*3.085678*10^16
      WHEN $2 IN ('ly', 'l.y.') THEN
        ($1)*9.4607304725808*10^15
      WHEN $2 = 'Em' THEN
        ($1)*10^18
      WHEN $2 = 'Zm' THEN
        ($1)*10^21
      WHEN $2 = 'Ym' THEN
        ($1)*10^24
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit text) OWNER TO postgres;

--
-- TOC entry 1742 (class 1255 OID 4816343)
-- Name: fct_cpy_length_conversion(real, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit character varying) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'dm' THEN
        ($1)*10^(-1)
      WHEN $2 = 'ft' THEN
        ($1)*3.048*10^(-1)
      WHEN $2 = 'P' THEN
        ($1)*3.24839385*10^(-1)
      WHEN $2 = 'yd' THEN
        ($1)*9.144*10^(-1)
      WHEN $2 = 'cm' THEN
        ($1)*10^(-2)
      WHEN $2 = 'in' THEN
        ($1)*2.54*10^(-2)
      WHEN $2 = 'mm' THEN
        ($1)*10^(-3)
      WHEN $2 = 'pica' THEN
        ($1)*4.233333*10^(-3)
      WHEN $2 = 'p' THEN
        ($1)*27.069949*10^(-3)
      WHEN $2 = 'mom' THEN
        ($1)*10^(-4)
      WHEN $2 IN ('pt', 'point') THEN
        ($1)*3.527778*10^(-4)
      WHEN $2 = 'mil' THEN
        ($1)*2.54*10^(-5)
      WHEN $2 IN ('µm', 'µ') THEN
        ($1)*10^(-6)
      WHEN $2 = 'twp' THEN
        ($1)*17.639*10^(-6)
      WHEN $2 = 'cal' THEN
        ($1)*254*10^(-6)
      WHEN $2 = 'nm' THEN
        ($1)*10^(-9)
      WHEN $2 = 'Å' THEN
        ($1)*10^(-10)
      WHEN $2 = 'pm' THEN
        ($1)*10^(-12)
      WHEN $2 IN ('fm', 'fermi') THEN
        ($1)*10^(-15)
      WHEN $2 = 'am' THEN
        ($1)*10^(-18)
      WHEN $2 = 'zm' THEN
        ($1)*10^(-21)
      WHEN $2 = 'ym' THEN
        ($1)*10^(-24)
      WHEN $2 IN ('brasse', 'vadem') THEN
        ($1)*1.8288
      WHEN $2 = 'fathom' THEN
        ($1)*1.828804
      WHEN $2 = 'rd' THEN
        ($1)*5.02921
      WHEN $2 = 'dam' THEN
        ($1)*10
      WHEN $2 = 'ch' THEN
        ($1)*20.11684
      WHEN $2 = 'arp' THEN
        ($1)*58.471089295
      WHEN $2 IN ('hm', 'K') THEN
        ($1)*10^2
      WHEN $2 = 'fur' THEN
        ($1)*201.168
      WHEN $2 = 'km' THEN
        ($1)*10^3
      WHEN $2 = 'mi' THEN
        ($1)*1.609344*10^3
      WHEN $2 = 'nautical mi' THEN
        ($1)*1.852*10^3
      WHEN $2 IN ('lieue', 'league') THEN
        ($1)*4.828032*10^3
      WHEN $2 = 'mam' THEN
        ($1)*10^4
      WHEN $2 = 'Mm' THEN
        ($1)*10^6
      WHEN $2 = 'Gm' THEN
        ($1)*10^9
      WHEN $2 = 'ua' THEN
        ($1)*1.495979*10^11
      WHEN $2 = 'Tm' THEN
        ($1)*10^12
      WHEN $2 = 'Pm' THEN
        ($1)*10^15
      WHEN $2 = 'pc' THEN
        ($1)*3.085678*10^16
      WHEN $2 IN ('ly', 'l.y.') THEN
        ($1)*9.4607304725808*10^15
      WHEN $2 = 'Em' THEN
        ($1)*10^18
      WHEN $2 = 'Zm' THEN
        ($1)*10^21
      WHEN $2 = 'Ym' THEN
        ($1)*10^24
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit character varying) OWNER TO darwin2;

--
-- TOC entry 1743 (class 1255 OID 4816344)
-- Name: fct_cpy_loan_history(integer); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_cpy_loan_history(loan_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN

  -- LOAN
  INSERT INTO loan_history (loan_ref, referenced_table, record_line)
  (
    select loan_id, 'loans', hstore(l.*) from loans l where l.id = loan_id

    UNION

    select loan_id, 'catalogue_people', hstore(p.*) from catalogue_people p where
      (referenced_relation='loans'  AND record_id = loan_id) OR (referenced_relation='loan_items'  AND record_id in (select id from loan_items l where l.loan_ref = loan_id) )

    UNION

    select loan_id, 'properties', hstore(c.*) from properties c where
      (referenced_relation='loans'  AND record_id = loan_id) OR (referenced_relation='loan_items'  AND record_id in (select id from loan_items l where l.loan_ref = loan_id) )

  );


  --ITEMS
  INSERT INTO loan_history (loan_ref, referenced_table, record_line)
  (
    select loan_id, 'loan_items', hstore(l.*) from loan_items l where l.loan_ref = loan_id

    UNION

    select loan_id, 'specimens', hstore(sfl.*) from specimens sfl
      where sfl.id in (select specimen_ref from loan_items l where l.loan_ref = loan_id)
  );

  -- BOTH
  INSERT INTO loan_history (loan_ref, referenced_table, record_line)
  (
    select loan_id, 'people', hstore(p.*) from people p where id in (select (record_line->'people_ref')::int from loan_history where loan_ref = loan_id
      and referenced_table='catalogue_people' and modification_date_time = now())

    UNION

    select loan_id, 'people_addresses', hstore(p.*) from people_addresses p where person_user_ref in (select (record_line->'id')::int from loan_history where loan_ref = loan_id
      and referenced_table='people' and modification_date_time = now())
  );
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_loan_history(loan_id integer) OWNER TO postgres;

--
-- TOC entry 1744 (class 1255 OID 4816345)
-- Name: fct_cpy_location(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_location() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.location := POINT(NEW.latitude, NEW.longitude);
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_location() OWNER TO darwin2;

--
-- TOC entry 1745 (class 1255 OID 4816346)
-- Name: fct_cpy_path(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_path() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
      IF TG_TABLE_NAME::text = 'collections' THEN

        IF NEW.id = 0 THEN
          NEW.parent_ref := null;
        END IF;
        IF NEW.parent_ref IS NULL THEN
          NEW.path :='/';
        ELSE
          EXECUTE 'SELECT path || id || ' || quote_literal('/') ||' FROM ' || quote_ident(TG_TABLE_NAME::text) || ' WHERE id=' || quote_literal(NEW.parent_ref) INTO STRICT NEW.path;
        END IF;
      ELSIF TG_TABLE_NAME::text = 'people_relationships' THEN
        SELECT path || NEW.person_1_ref || '/' INTO NEW.path
          FROM people_relationships
          WHERE person_2_ref=NEW.person_1_ref;
        IF NEW.path is NULL THEN
          NEW.path := '/' || NEW.person_1_ref || '/';
        END IF;
      END IF;
    ELSIF TG_OP = 'UPDATE' THEN
      IF TG_TABLE_NAME::text = 'collections' THEN

        IF NEW.parent_ref IS DISTINCT FROM OLD.parent_ref THEN
          IF NEW.parent_ref IS NULL THEN
            NEW.path := '/';
          ELSIF COALESCE(OLD.parent_ref,0) = COALESCE(NEW.parent_ref,0) THEN
            RETURN NEW;
          ELSE
            EXECUTE 'SELECT path || id || ' || quote_literal('/') ||' FROM ' || quote_ident(TG_TABLE_NAME::text) || ' WHERE id=' || quote_literal(NEW.parent_ref) INTO STRICT NEW.path;
          END IF;

          EXECUTE 'UPDATE ' || quote_ident(TG_TABLE_NAME::text) || ' SET path=replace(path, ' ||  quote_literal(OLD.path || OLD.id || '/') ||' , ' || quote_literal( NEW.path || OLD.id || '/') || ') ' ||
            ' WHERE path like ' || quote_literal(OLD.path || OLD.id || '/%');
        END IF;
      ELSE
        IF NEW.person_1_ref IS DISTINCT FROM OLD.person_1_ref OR NEW.person_2_ref IS DISTINCT FROM OLD.person_2_ref THEN
          SELECT path ||  NEW.person_1_ref || '/' INTO NEW.path FROM people_relationships WHERE person_2_ref=NEW.person_1_ref;

            IF NEW.path is NULL THEN
              NEW.path := '/' || NEW.person_1_ref || '/';
            END IF;
            -- AND UPDATE CHILDRENS
            UPDATE people_relationships SET path=replace(path, OLD.path, NEW.path) WHERE person_1_ref=OLD.person_2_ref;
        END IF;
      END IF;
    END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_path() OWNER TO darwin2;

--
-- TOC entry 1748 (class 1255 OID 4816347)
-- Name: fct_cpy_path_catalogs(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_path_catalogs() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' AND (TG_TABLE_NAME::text = 'taxonomy' OR
          TG_TABLE_NAME::text = 'lithology' OR
          TG_TABLE_NAME::text = 'lithostratigraphy' OR
          TG_TABLE_NAME::text = 'mineralogy' OR
          TG_TABLE_NAME::text = 'chronostratigraphy') THEN

          IF NEW.parent_ref IS NULL THEN
            NEW.path ='/';
          ELSE
            EXECUTE 'SELECT path || id || ''/'' FROM ' || quote_ident(TG_TABLE_NAME::text) || ' WHERE id=' || quote_literal(NEW.parent_ref) INTO STRICT NEW.path;
          END IF;
    ELSIF TG_OP = 'UPDATE' AND (TG_TABLE_NAME::text = 'taxonomy' OR
        TG_TABLE_NAME::text = 'lithology' OR
        TG_TABLE_NAME::text = 'lithostratigraphy' OR
        TG_TABLE_NAME::text = 'mineralogy' OR
        TG_TABLE_NAME::text = 'chronostratigraphy') THEN

        IF NEW.parent_ref IS DISTINCT FROM OLD.parent_ref THEN
          IF NEW.parent_ref IS NULL THEN
            NEW.path ='/';
          ELSIF OLD.parent_ref IS NOT DISTINCT FROM NEW.parent_ref THEN
            RETURN NEW;
          ELSE
            EXECUTE 'SELECT  path || id || ''/''  FROM ' || quote_ident(TG_TABLE_NAME::text) || ' WHERE id=' || quote_literal(NEW.parent_ref) INTO STRICT NEW.path;
          END IF;

          EXECUTE 'UPDATE ' || quote_ident(TG_TABLE_NAME::text) || ' SET path=replace(path, ' ||  quote_literal(OLD.path || OLD.id || '/') ||' , ' || quote_literal( NEW.path || OLD.id || '/') || ') ' ||
            ' WHERE path like ' || quote_literal(OLD.path || OLD.id || '/%');
        END IF;
--         RAISE INFO 'nothing diff';
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_path_catalogs() OWNER TO darwin2;

--
-- TOC entry 1749 (class 1255 OID 4816348)
-- Name: fct_cpy_specimensmaincode(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_specimensmaincode() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	spec_code codes%ROWTYPE;
	must_be_copied collections.code_part_code_auto_copy%TYPE;
BEGIN
	SELECT collections.code_part_code_auto_copy INTO must_be_copied FROM collections
			INNER JOIN specimens ON collections.id = specimens.collection_ref
			INNER JOIN specimen_individuals ON specimen_individuals.specimen_ref=specimens.id
				WHERE specimen_individuals.id = NEW.specimen_individual_ref;

	IF must_be_copied = true THEN

		INSERT INTO codes (referenced_relation, record_id, code_category, code_prefix, code_prefix_separator,  code_suffix_separator, code, code_suffix)
		(
			SELECT 'specimen_parts',NEW.id, code_category, code_prefix, code_prefix_separator, code_suffix_separator, code, code_suffix
                               FROM codes
        	               INNER JOIN specimens ON record_id = specimens.id
                	       INNER JOIN specimen_individuals ON specimen_individuals.specimen_ref=specimens.id
                        	WHERE referenced_relation = 'specimens'
		                  AND  specimen_individuals.id = NEW.specimen_individual_ref
                                  AND code_category = 'main'
		);
	END IF;
	RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_specimensmaincode() OWNER TO darwin2;

--
-- TOC entry 1895 (class 1255 OID 4816349)
-- Name: fct_cpy_speed_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'Kt' THEN
        ($1)*0.51444444444444
      WHEN $2 = 'Beaufort' THEN
        CASE
          WHEN $1 = 0 THEN
            0.13888888888888
          WHEN $1 = 1 THEN
            3*0.27777777777778
          WHEN $1 = 2 THEN
            8*0.27777777777778
          WHEN $1 = 3 THEN
            15*0.27777777777778
          WHEN $1 = 4 THEN
            23.5*0.27777777777778
          WHEN $1 = 5 THEN
            33*0.27777777777778
          WHEN $1 = 6 THEN
            44*0.27777777777778
          WHEN $1 = 7 THEN
            55.5*0.27777777777778
          WHEN $1 = 8 THEN
            68*0.27777777777778
          WHEN $1 = 9 THEN
            81.5*0.27777777777778
          WHEN $1 = 10 THEN
            95.5*0.27777777777778
          WHEN $1 = 11 THEN
            110*0.27777777777778
          ELSE
            120*0.27777777777778
        END
      ELSE
        CASE
          WHEN strpos($2, '/') > 0 THEN
            fct_cpy_length_conversion($1, substr($2, 0, strpos($2, '/')))/fct_cpy_time_conversion(1, substr($2, strpos($2, '/')+1))
          ELSE
            $1
        END
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit text) OWNER TO postgres;

--
-- TOC entry 1750 (class 1255 OID 4816350)
-- Name: fct_cpy_speed_conversion(real, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit character varying) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'Kt' THEN
        ($1)*0.51444444444444
      WHEN $2 = 'Beaufort' THEN
        CASE
          WHEN $1 = 0 THEN
            0.13888888888888
          WHEN $1 = 1 THEN
            3*0.27777777777778
          WHEN $1 = 2 THEN
            8*0.27777777777778
          WHEN $1 = 3 THEN
            15*0.27777777777778
          WHEN $1 = 4 THEN
            23.5*0.27777777777778
          WHEN $1 = 5 THEN
            33*0.27777777777778
          WHEN $1 = 6 THEN
            44*0.27777777777778
          WHEN $1 = 7 THEN
            55.5*0.27777777777778
          WHEN $1 = 8 THEN
            68*0.27777777777778
          WHEN $1 = 9 THEN
            81.5*0.27777777777778
          WHEN $1 = 10 THEN
            95.5*0.27777777777778
          WHEN $1 = 11 THEN
            110*0.27777777777778
          ELSE
            120*0.27777777777778
        END
      ELSE
        CASE
          WHEN strpos($2, '/') > 0 THEN
            fct_cpy_length_conversion($1, substr($2, 0, strpos($2, '/')))/fct_cpy_time_conversion(1, substr($2, strpos($2, '/')+1))
          ELSE
            $1
        END
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit character varying) OWNER TO darwin2;

--
-- TOC entry 1936 (class 1255 OID 5308610)
-- Name: fct_cpy_tags_to_distinct_bedic(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_tags_to_distinct_bedic() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
    IF  (NEW.sub_group_name_indexed is not null or NEW.group_name_indexed is not null or NEW.tag_value is not null)  THEN
      CASE TG_OP
        WHEN 'UPDATE' THEN
            IF NEW.sub_group_name_indexed IS DISTINCT FROM OLD.sub_group_name_indexed or NEW.group_name_indexed IS DISTINCT FROM OLD.group_name_indexed or NEW.tag_value IS DISTINCT FROM OLD.tag_value THEN 
            BEGIN
                RAISE NOTICE 'try to update: %, %, % towards  %, %, %', OLD.sub_group_name_indexed, OLD.group_name_indexed,OLD.tag_value, NEW.sub_group_name_indexed, NEW.group_name_indexed,NEW.tag_value;
                UPDATE tag_group_distinct SET 
                sub_group_name_indexed=NEW.sub_group_name_indexed,
                group_name_indexed=NEW.group_name_indexed,
                tag_value=NEW.tag_value
                where 
                sub_group_name_indexed=OLD.sub_group_name_indexed AND
                group_name_indexed=OLD.group_name_indexed AND
                tag_value=OLD.tag_value;
                --delete the representation in the tag_tag_authority because we don't know if the term is still the same! The whole geonames import script will need to be run again for this term! The old vocabulary entry is kept, only the m:n link is severed.
                DELETE FROM tag_tag_authority WHERE tag_group_distinct_ref IN 
                (SELECT id FROM tag_group_distinct 
                where 
                sub_group_name_indexed=OLD.sub_group_name_indexed AND
                group_name_indexed=OLD.group_name_indexed AND
                tag_value=OLD.tag_value);
            EXCEPTION WHEN unique_violation THEN
                RAISE NOTICE 'UQ violation when updating!';
                --if renaming a term to something that already exists in the table, it means that the original has to go. It also means that the representation in the tag_authority has to go
                --delete first the representation in the tag_authority because otherwise a FK constraint error will be raised.
                DELETE FROM tag_authority WHERE tag_group_distinct_ref IN 
                (SELECT id FROM tag_group_distinct 
                WHERE 
                sub_group_name_indexed=OLD.sub_group_name_indexed AND
                group_name_indexed=OLD.group_name_indexed AND
                tag_value=OLD.tag_value);
                
                DELETE FROM tag_group_distinct WHERE
                sub_group_name_indexed=OLD.sub_group_name_indexed and
                group_name_indexed=OLD.group_name_indexed and
                tag_value=OLD.tag_value;
            END;
            END IF;
            RETURN NEW;
        WHEN 'INSERT' THEN
            BEGIN
                RAISE NOTICE 'try to insert: %, %, %', NEW.sub_group_name_indexed, NEW.group_name_indexed,NEW.tag_value;
                with insert_tag_group_distinct_cte as (
                INSERT INTO tag_group_distinct (sub_group_name_indexed,group_name_indexed,tag_value) VALUES
                (NEW.sub_group_name_indexed,
                NEW.group_name_indexed,
                NEW.tag_value) returning id)
                update tag_groups tg set tag_group_distinct_ref=cte.id from insert_tag_group_distinct_cte cte where tg.id=NEW.id;
                RAISE NOTICE 'Insert successful: created tag_group_distinct entry and made FK referral towards this from tag_groups';
                RETURN NEW;
            EXCEPTION WHEN unique_violation THEN
                RAISE NOTICE 'UQ violation when inserting in tag_group_distinct! Nothing new inserted in tag_group_distinct. You can ignore this message.';
            END;
      END CASE;
   END IF;

   RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_tags_to_distinct_bedic() OWNER TO darwin2;

--
-- TOC entry 1752 (class 1255 OID 4816351)
-- Name: fct_cpy_temperature_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = '°C' THEN
        ($1)+273.15
      WHEN $2 = '°F' THEN
        (($1)+459.67)/1.8
      WHEN $2 = '°Ra' THEN
        ($1)/1.8
      WHEN $2 in ('°Ré', '°r') THEN
        (($1)*5/4)+273.15
      WHEN $2 = '°N' THEN
        (($1)+273.15)*0.33
      WHEN $2 = '°Rø' THEN
        (((($1)-7.5)*40)/21)+273.15
      WHEN $2 = '°De' THEN
        373.15-(($1)*2/3)
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit text) OWNER TO postgres;

--
-- TOC entry 1751 (class 1255 OID 4816352)
-- Name: fct_cpy_temperature_conversion(real, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit character varying) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = '°C' THEN
        ($1)+273.15
      WHEN $2 = '°F' THEN
        (($1)+459.67)/1.8
      WHEN $2 = '°Ra' THEN
        ($1)/1.8
      WHEN $2 in ('°Ré', '°r') THEN
        (($1)*5/4)+273.15
      WHEN $2 = '°N' THEN
        (($1)+273.15)*0.33
      WHEN $2 = '°Rø' THEN
        (((($1)-7.5)*40)/21)+273.15
      WHEN $2 = '°De' THEN
        373.15-(($1)*2/3)
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit character varying) OWNER TO darwin2;

--
-- TOC entry 1759 (class 1255 OID 4816353)
-- Name: fct_cpy_time_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'ns' THEN
        ($1)*10^(-9)
      WHEN $2 = 'shake' THEN
        ($1)*10^(-8)
      WHEN $2 = 'µs' THEN
        ($1)*10^(-6)
      WHEN $2 = 'ms' THEN
        ($1)*10^(-3)
      WHEN $2 = 'cs' THEN
        ($1)*10^(-2)
      WHEN $2 = 't' THEN
        ($1)/60
      WHEN $2 = 'ds' THEN
        ($1)*10^(-1)
      WHEN $2 = 'min' THEN
        60*($1)
      WHEN $2 = 'h' THEN
        3600*($1)
      WHEN $2 IN ('d', 'j') THEN
        86400*($1)
      WHEN $2 IN ('y', 'year') THEN
        ($1)*3.1536*10^7
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit text) OWNER TO postgres;

--
-- TOC entry 1753 (class 1255 OID 4816354)
-- Name: fct_cpy_time_conversion(real, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit character varying) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'ns' THEN
        ($1)*10^(-9)
      WHEN $2 = 'shake' THEN
        ($1)*10^(-8)
      WHEN $2 = 'µs' THEN
        ($1)*10^(-6)
      WHEN $2 = 'ms' THEN
        ($1)*10^(-3)
      WHEN $2 = 'cs' THEN
        ($1)*10^(-2)
      WHEN $2 = 't' THEN
        ($1)/60
      WHEN $2 = 'ds' THEN
        ($1)*10^(-1)
      WHEN $2 = 'min' THEN
        60*($1)
      WHEN $2 = 'h' THEN
        3600*($1)
      WHEN $2 IN ('d', 'j') THEN
        86400*($1)
      WHEN $2 IN ('y', 'year') THEN
        ($1)*3.1536*10^7
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit character varying) OWNER TO darwin2;

--
-- TOC entry 1754 (class 1255 OID 4816355)
-- Name: fct_cpy_unified_values(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_unified_values() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  property_line properties%ROWTYPE;
BEGIN
  NEW.lower_value_unified = convert_to_unified(NEW.lower_value, NEW.property_unit);
  NEW.upper_value_unified = convert_to_unified(CASE WHEN NEW.upper_value = '' THEN NEW.lower_value ELSE NEW.upper_value END, NEW.property_unit);
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_unified_values() OWNER TO darwin2;

--
-- TOC entry 1755 (class 1255 OID 4816356)
-- Name: fct_cpy_updatecollectionrights(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_updatecollectionrights() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	db_user_type_val integer ;
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO collections_rights (collection_ref, user_ref, db_user_type)
    (SELECT NEW.id as coll_ref, NEW.main_manager_ref as mgr_ref, 4 as user_type
     UNION
     SELECT NEW.id as coll_ref, user_ref as mgr_ref, db_user_type as user_type
     FROM collections_rights
     WHERE collection_ref = NEW.parent_ref
       AND db_user_type = 4
    );
  ELSIF TG_OP = 'UPDATE' THEN
    IF NEW.main_manager_ref IS DISTINCT FROM OLD.main_manager_ref THEN
      SELECT db_user_type INTO db_user_type_val FROM collections_rights WHERE collection_ref = NEW.id AND user_ref = NEW.main_manager_ref;
      IF FOUND AND db_user_type_val is distinct from 4 THEN
        UPDATE collections_rights
        SET db_user_type = 4
        WHERE collection_ref = NEW.id
          AND user_ref = NEW.main_manager_ref;
      ELSE
        INSERT INTO collections_rights (collection_ref, user_ref, db_user_type)
        VALUES(NEW.id,NEW.main_manager_ref,4);
      END IF;
    END IF;
    IF NEW.parent_ref IS DISTINCT FROM OLD.parent_ref THEN
      INSERT INTO collections_rights (collection_ref, user_ref, db_user_type)
      (
        SELECT NEW.id, user_ref, db_user_type
        FROM collections_rights
        WHERE collection_ref = NEW.parent_ref
          AND db_user_type = 4
          AND user_ref NOT IN
            (
              SELECT user_ref
              FROM collections_rights
              WHERE collection_ref = NEW.id
            )
      );
    END IF;
  END IF;

  RETURN NEW;

EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'An error occured: %', SQLERRM;
    RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_updatecollectionrights() OWNER TO darwin2;

--
-- TOC entry 1756 (class 1255 OID 4816357)
-- Name: fct_cpy_updatecollinstitutioncascade(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_updatecollinstitutioncascade() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NEW.institution_ref IS DISTINCT FROM OLD.institution_ref THEN
    UPDATE collections
    SET institution_ref = NEW.institution_ref
    WHERE id != NEW.id
      AND parent_ref = NEW.id;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_updatecollinstitutioncascade() OWNER TO darwin2;

--
-- TOC entry 1757 (class 1255 OID 4816358)
-- Name: fct_cpy_updatemywidgetscoll(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_updatemywidgetscoll() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  booContinue boolean := false;
BEGIN
  IF TG_TABLE_NAME = 'collections_rights' THEN
    IF TG_OP = 'DELETE' THEN
      booContinue := true;
    ELSE
      IF OLD.collection_ref IS DISTINCT FROM NEW.collection_ref OR OLD.user_ref IS DISTINCT FROM NEW.user_ref THEN
        booContinue := true;
      END IF;
    END IF;
    IF booContinue THEN
      /*!!! Whats done is only removing the old collection reference from list of collections set in widgets !!!
        !!! We considered the add of widgets available for someone in a collection still be a manual action !!!
      */
      UPDATE my_widgets
      SET collections = regexp_replace(collections, E'\,' || OLD.collection_ref || E'\,', E'\,', 'g')
      WHERE user_ref = OLD.user_ref
        AND collections ~ (E'\,' || OLD.collection_ref || E'\,');
    END IF;
  END IF;
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_updatemywidgetscoll() OWNER TO darwin2;

--
-- TOC entry 1758 (class 1255 OID 4816359)
-- Name: fct_cpy_updatespechostimpact(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_updatespechostimpact() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  newTaxonRef specimens.host_taxon_ref%TYPE := 0;
BEGIN
  IF TG_OP = 'UPDATE' THEN
    IF NEW.host_specimen_ref IS DISTINCT FROM OLD.host_specimen_ref AND NEW.host_specimen_ref IS NOT NULL THEN
      SELECT taxon_ref INTO STRICT NEW.host_taxon_ref FROM specimens WHERE id = NEW.host_specimen_ref;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_updatespechostimpact() OWNER TO darwin2;

--
-- TOC entry 1760 (class 1255 OID 4816360)
-- Name: fct_cpy_updateuserrights(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_updateuserrights() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  db_user_type_val integer ;
  booCollFound boolean;
  booContinue boolean;
BEGIN
  /*When updating main manager ref -> impact potentially db_user_type
    of new user chosen as manager
  */
  IF TG_TABLE_NAME = 'collections' THEN
    /*We take in count only an update
      An insertion as it's creating an entry in collections_rights will trigger this current trigger again ;)
    */
    IF TG_OP = 'UPDATE' THEN
      IF NEW.main_manager_ref IS DISTINCT FROM OLD.main_manager_ref THEN
        UPDATE users
        SET db_user_type = 4
        WHERE id = NEW.main_manager_ref
          AND db_user_type < 4;
      END IF;
    END IF;
  ELSE -- trigger on collections_rights table
    IF TG_OP = 'INSERT' THEN
      /*If user is promoted by inserting her/him
        with a higher db_user_type than she/he is -> promote her/him
      */
      UPDATE users
      SET db_user_type = NEW.db_user_type
      WHERE id = NEW.user_ref
        AND db_user_type < NEW.db_user_type;
    END IF;
    IF TG_OP = 'UPDATE' THEN
      /*First case: replacing a user by an other*/
      IF NEW.user_ref IS DISTINCT FROM OLD.user_ref THEN
        /*Update the user db_user_type chosen as the new one as if it would be an insertion*/
        UPDATE users
        SET db_user_type = NEW.db_user_type
        WHERE id = NEW.user_ref
          AND db_user_type < NEW.db_user_type;
        /*Un promote the user replaced if necessary*/
        UPDATE users
          SET db_user_type = subq.db_user_type_max
          FROM (
                SELECT COALESCE(MAX(db_user_type),1) as db_user_type_max
                FROM collections_rights
                WHERE user_ref = OLD.user_ref
              ) subq
          WHERE id = OLD.user_ref
            AND db_user_type != 8;
      END IF;
      IF NEW.db_user_type IS DISTINCT FROM OLD.db_user_type THEN
        /* Promotion */
        IF NEW.db_user_type > OLD.db_user_type THEN
          UPDATE users
          SET db_user_type = NEW.db_user_type
          WHERE id = NEW.user_ref
            AND db_user_type < NEW.db_user_type;
        /* Unpromotion */
        ELSE
          UPDATE users
          SET db_user_type = subq.db_user_type_max
          FROM (
                SELECT COALESCE(MAX(db_user_type),1) as db_user_type_max
                FROM collections_rights
                WHERE user_ref = NEW.user_ref
              ) subq
          WHERE id = NEW.user_ref
            AND db_user_type != 8;
        END IF;
      END IF;
    END IF;
    IF TG_OP = 'DELETE' THEN
      IF OLD.db_user_type >=4 THEN
        SELECT true
        INTO booCollFound
        FROM collections
        WHERE id = OLD.collection_ref
          AND main_manager_ref = OLD.user_ref;
        IF FOUND THEN
          RAISE EXCEPTION 'You try to delete a manager who is still defined as a main manager of the current collection';
        END IF;
      END IF;
      UPDATE users
      SET db_user_type = subq.db_user_type_max
      FROM (
            SELECT COALESCE(MAX(db_user_type),1) as db_user_type_max
            FROM collections_rights
            WHERE user_ref = OLD.user_ref
           ) subq
      WHERE id = OLD.user_ref
        AND db_user_type != 8;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_cpy_updateuserrights() OWNER TO darwin2;

--
-- TOC entry 1766 (class 1255 OID 4816361)
-- Name: fct_cpy_volume_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'l' THEN
        ($1)*10^(-3)
      WHEN $2 = 'cm³' OR $2 = 'ml' THEN
        ($1)*10^(-6)
      WHEN $2 = 'mm³' OR $2 = 'µl' THEN
        ($1)*10^(-9)
      WHEN $2 = 'µm³' THEN
        ($1)*10^(-18)
      WHEN $2 = 'km³' THEN
        ($1)*10^(9)
      WHEN $2 = 'Ml' THEN
        ($1)*10^(3)
      WHEN $2 = 'hl' THEN
        ($1)*10
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit text) OWNER TO postgres;

--
-- TOC entry 1761 (class 1255 OID 4816362)
-- Name: fct_cpy_volume_conversion(real, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit character varying) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'l' THEN
        ($1)*10^(-3)
      WHEN $2 = 'cm³' OR $2 = 'ml' THEN
        ($1)*10^(-6)
      WHEN $2 = 'mm³' OR $2 = 'µl' THEN
        ($1)*10^(-9)
      WHEN $2 = 'µm³' THEN
        ($1)*10^(-18)
      WHEN $2 = 'km³' THEN
        ($1)*10^(9)
      WHEN $2 = 'Ml' THEN
        ($1)*10^(3)
      WHEN $2 = 'hl' THEN
        ($1)*10
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit character varying) OWNER TO darwin2;

--
-- TOC entry 1767 (class 1255 OID 4816363)
-- Name: fct_cpy_weight_conversion(real, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit text) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'hg' THEN
        ($1)*10^(2)
      WHEN $2 = 'kg' THEN
        ($1)*10^(3)
      WHEN $2 = 'Mg' OR $2 = 'ton' THEN
        ($1)*10^(6)
      WHEN $2 = 'dg' THEN
        ($1)*10^(-1)
      WHEN $2 = 'cg' THEN
        ($1)*10^(-2)
      WHEN $2 = 'mg' THEN
        ($1)*10^(-3)
      WHEN $2 = 'lb' OR $2 = 'lbs' OR $2 = 'pound' THEN
        ($1)*453.59237
      WHEN $2 = 'ounce' THEN
        ($1)*28.349523125
      WHEN $2 = 'grain' THEN
        ($1)*6.479891*10^(-2)
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit text) OWNER TO postgres;

--
-- TOC entry 1762 (class 1255 OID 4816364)
-- Name: fct_cpy_weight_conversion(real, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit character varying) RETURNS real
    LANGUAGE sql STABLE
    AS $_$
  SELECT  CASE
      WHEN $2 = 'hg' THEN
        ($1)*10^(2)
      WHEN $2 = 'kg' THEN
        ($1)*10^(3)
      WHEN $2 = 'Mg' OR $2 = 'ton' THEN
        ($1)*10^(6)
      WHEN $2 = 'dg' THEN
        ($1)*10^(-1)
      WHEN $2 = 'cg' THEN
        ($1)*10^(-2)
      WHEN $2 = 'mg' THEN
        ($1)*10^(-3)
      WHEN $2 = 'lb' OR $2 = 'lbs' OR $2 = 'pound' THEN
        ($1)*453.59237
      WHEN $2 = 'ounce' THEN
        ($1)*28.349523125
      WHEN $2 = 'grain' THEN
        ($1)*6.479891*10^(-2)
      ELSE
        $1
    END::real;
$_$;


ALTER FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit character varying) OWNER TO darwin2;

--
-- TOC entry 1763 (class 1255 OID 4816365)
-- Name: fct_del_in_dict(text, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_del_in_dict(ref_relation text, ref_field text, dict_val text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result integer;
  query_str text;
BEGIN
  IF dict_val is NULL THEN 
    RETURN TRUE;
  END IF;
  query_str := ' SELECT 1 WHERE EXISTS( SELECT id from ' || quote_ident(ref_relation) || ' where ' || quote_ident(ref_field) || ' = ' || quote_literal(dict_val) || ');';
  execute query_str into result;

  IF result IS NULL THEN
    DELETE FROM flat_dict where 
          referenced_relation = ref_relation
          AND dict_field = ref_field
          AND dict_value = dict_val;
  END IF;
  RETURN TRUE;
END;
$$;


ALTER FUNCTION darwin2.fct_del_in_dict(ref_relation text, ref_field text, dict_val text) OWNER TO darwin2;

--
-- TOC entry 1764 (class 1255 OID 4816366)
-- Name: fct_del_in_dict(text, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_del_in_dict(ref_relation text, ref_field text, old_value text, new_val text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result boolean;
  query_str text;
BEGIN
  IF old_value IS null OR old_value IS NOT DISTINCT FROM new_val THEN
    RETURN TRUE;
  END IF;
  query_str := ' SELECT EXISTS( SELECT 1 from ' || quote_ident(ref_relation) || ' where ' || quote_ident(ref_field) || ' = ' || quote_literal(old_value) || ');';
  execute query_str into result;

  IF result = false THEN
    DELETE FROM flat_dict where
          referenced_relation = ref_relation
          AND dict_field = ref_field
          AND dict_value = old_value;
  END IF;
  RETURN TRUE;
END;
$$;


ALTER FUNCTION darwin2.fct_del_in_dict(ref_relation text, ref_field text, old_value text, new_val text) OWNER TO darwin2;

--
-- TOC entry 1765 (class 1255 OID 4816367)
-- Name: fct_del_in_dict_dept(text, text, text, text, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_del_in_dict_dept(ref_relation text, ref_field text, old_value text, new_val text, depending_old_value text, depending_new_value text, depending_field text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result boolean;
  query_str text;
BEGIN
  IF old_value is NULL OR ( old_value IS NOT DISTINCT FROM new_val AND depending_old_value IS NOT DISTINCT FROM depending_new_value ) THEN
    RETURN TRUE;
  END IF;
  query_str := ' SELECT EXISTS( SELECT id from ' || quote_ident(ref_relation) || ' where ' || quote_ident(ref_field) || ' = ' || quote_literal(old_value)
  || ' AND ' || quote_ident(depending_field) || ' = ' || quote_literal(depending_old_value) || ' );';
  execute query_str into result;

  IF result = false THEN
    DELETE FROM flat_dict where
          referenced_relation = ref_relation
          AND dict_field = ref_field
          AND dict_value = old_value
          AND dict_depend = depending_old_value;
  END IF;
  RETURN TRUE;
END;
$$;


ALTER FUNCTION darwin2.fct_del_in_dict_dept(ref_relation text, ref_field text, old_value text, new_val text, depending_old_value text, depending_new_value text, depending_field text) OWNER TO postgres;

--
-- TOC entry 1773 (class 1255 OID 4816368)
-- Name: fct_duplicate_loans(integer); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_duplicate_loans(loan_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    new_loan_id loans.id%TYPE;
    new_loan_item_id loan_items.id%TYPE;
    rec_loan_items RECORD;
  BEGIN
    INSERT INTO loans (name, description)
      (SELECT name, description FROM loans WHERE id = loan_id)
    RETURNING id INTO new_loan_id;
    INSERT INTO loan_rights (loan_ref, user_ref, has_encoding_right)
      (SELECT new_loan_id, user_ref, has_encoding_right from loan_rights where loan_ref = loan_id);
    INSERT INTO catalogue_people (referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
      (
        SELECT referenced_relation, new_loan_id, people_type, people_sub_type, order_by, people_ref
        FROM catalogue_people
        WHERE referenced_relation = 'loans'
          AND record_id = loan_id
      );
    INSERT INTO insurances (referenced_relation,
                            record_id,
                            insurance_value,
                            insurance_currency,
                            insurer_ref,
                            date_from_mask,
                            date_from,
                            date_to_mask,
                            date_to,
                            contact_ref)
      (SELECT
         referenced_relation,
         new_loan_id,
         insurance_value,
         insurance_currency,
         insurer_ref,
         date_from_mask,
         date_from,
         date_to_mask,
         date_to,
         contact_ref
       FROM insurances
        WHERE referenced_relation = 'loans'
          AND record_id = loan_id
      );
    INSERT INTO comments (referenced_relation, record_id, notion_concerned, comment)
      (SELECT referenced_relation, new_loan_id, notion_concerned, comment from comments where referenced_relation = 'loans' AND record_id = loan_id);
    INSERT INTO properties (
      referenced_relation,
      record_id,
      property_type,
      applies_to,
      date_from_mask,
      date_from,
      date_to_mask,
      date_to,
      is_quantitative,
      property_unit,
      method,
      lower_value,
      upper_value,
      property_accuracy
    )
      (
        SELECT
          referenced_relation,
          new_loan_id,
          property_type,
          applies_to,
          date_from_mask,
          date_from,
          date_to_mask,
          date_to,
          is_quantitative,
          property_unit,
          method,
          lower_value,
          upper_value,
          property_accuracy
        FROM properties
        WHERE referenced_relation = 'loans'
          AND record_id = loan_id
      );
    FOR rec_loan_items IN SELECT id FROM loan_items WHERE loan_ref = loan_id
      LOOP
        INSERT INTO loan_items (loan_ref, ig_ref, specimen_ref, details)
          (SELECT new_loan_id, ig_ref, specimen_ref, details FROM loan_items WHERE id = rec_loan_items.id)
        RETURNING id INTO new_loan_item_id;
        INSERT INTO catalogue_people (referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
          (
            SELECT referenced_relation, new_loan_item_id, people_type, people_sub_type, order_by, people_ref
            FROM catalogue_people
            WHERE referenced_relation = 'loan_items'
                  AND record_id = rec_loan_items.id
          );
        INSERT INTO codes (
          referenced_relation,
          record_id,
          code_category,
          code_prefix,
          code_prefix_separator,
          code,
          code_suffix_separator,
          code_suffix,
          code_date,
          code_date_mask
        )
        (
          SELECT
           referenced_relation,
           new_loan_item_id,
           code_category,
           code_prefix,
           code_prefix_separator,
           code,
           code_suffix_separator,
           code_suffix,
           code_date,
           code_date_mask
          FROM codes
          WHERE referenced_relation = 'loan_items'
            AND record_id = rec_loan_items.id
        );
        INSERT INTO insurances (referenced_relation,
                                record_id,
                                insurance_value,
                                insurance_currency,
                                insurer_ref,
                                date_from_mask,
                                date_from,
                                date_to_mask,
                                date_to,
                                contact_ref)
          (SELECT
             referenced_relation,
             new_loan_item_id,
             insurance_value,
             insurance_currency,
             insurer_ref,
             date_from_mask,
             date_from,
             date_to_mask,
             date_to,
             contact_ref
           FROM insurances
           WHERE referenced_relation = 'loan_items'
                 AND record_id = rec_loan_items.id
          );
        INSERT INTO comments (referenced_relation, record_id, notion_concerned, comment)
          (SELECT referenced_relation, new_loan_item_id, notion_concerned, comment from comments where referenced_relation = 'loan_items' AND record_id = rec_loan_items.id);
        INSERT INTO properties (
          referenced_relation,
          record_id,
          property_type,
          applies_to,
          date_from_mask,
          date_from,
          date_to_mask,
          date_to,
          is_quantitative,
          property_unit,
          method,
          lower_value,
          upper_value,
          property_accuracy
        )
          (
            SELECT
              referenced_relation,
              new_loan_item_id,
              property_type,
              applies_to,
              date_from_mask,
              date_from,
              date_to_mask,
              date_to,
              is_quantitative,
              property_unit,
              method,
              lower_value,
              upper_value,
              property_accuracy
            FROM properties
            WHERE referenced_relation = 'loan_items'
                  AND record_id = rec_loan_items.id
          );
      END LOOP;
    RETURN new_loan_id;
  EXCEPTION
    WHEN OTHERS THEN
      RETURN 0;
  END;
  $$;


ALTER FUNCTION darwin2.fct_duplicate_loans(loan_id integer) OWNER TO postgres;

--
-- TOC entry 1768 (class 1255 OID 4816369)
-- Name: fct_explode_array(anyarray); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_explode_array(in_array anyarray) RETURNS SETOF anyelement
    LANGUAGE sql IMMUTABLE
    AS $_$
    select ($1)[s] from generate_series(1,array_upper($1, 1)) as s;
$_$;


ALTER FUNCTION darwin2.fct_explode_array(in_array anyarray) OWNER TO darwin2;

--
-- TOC entry 1769 (class 1255 OID 4816370)
-- Name: fct_filter_encodable_row(character varying, character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_filter_encodable_row(ids character varying, col_name character varying, user_id integer) RETURNS SETOF integer
    LANGUAGE sql
    AS $_$
with user_right as (
    select db_user_type
    from users
    where id = $3
)
select id
from specimens
where id in (select X::int from regexp_split_to_table($1, ',' ) as X)
      and case
          when (select db_user_type from user_right) = 8 then
            TRUE
          else
            collection_ref in (select X FROM fct_search_authorized_encoding_collections($3) as X)
          end
      and $2 = 'spec_ref';
$_$;


ALTER FUNCTION darwin2.fct_filter_encodable_row(ids character varying, col_name character varying, user_id integer) OWNER TO darwin2;

--
-- TOC entry 1770 (class 1255 OID 4816371)
-- Name: fct_find_tax_level(text, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_find_tax_level(tax_path text, searched_level integer) RETURNS integer
    LANGUAGE sql STABLE
    AS $_$
   SELECT id FROM taxonomy where  level_ref = $2 and id in (select i::int from regexp_split_to_table($1, E'\/') as i where i != '');
$_$;


ALTER FUNCTION darwin2.fct_find_tax_level(tax_path text, searched_level integer) OWNER TO darwin2;

--
-- TOC entry 1917 (class 1255 OID 5308662)
-- Name: fct_get_tax_hierarchy(integer, integer[]); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_get_tax_hierarchy(start_id integer, levels integer[]) RETURNS TABLE(r_start_id integer, id integer, name text, level_ref integer, parent_ref integer)
    LANGUAGE sql
    AS $$
WITH RECURSIVE select_levels AS (
        SELECT  t.id,t.name,t.level_ref,t.parent_ref
        FROM    taxonomy t
        where t.id=start_id
        UNION ALL
        SELECT   tn.id, tn.name,tn.level_ref,tn.parent_ref
        FROM    taxonomy tn
        JOIN    select_levels
        ON      tn.id = select_levels.parent_ref
        )
        select start_id,* from select_levels sl where sl.level_ref = ANY(levels);
$$;


ALTER FUNCTION darwin2.fct_get_tax_hierarchy(start_id integer, levels integer[]) OWNER TO darwin2;

--
-- TOC entry 235 (class 1259 OID 4816372)
-- Name: staging_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_id_seq OWNER TO darwin2;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- TOC entry 236 (class 1259 OID 4816374)
-- Name: staging; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging (
    id integer DEFAULT nextval('darwin2.staging_id_seq'::regclass) NOT NULL,
    import_ref integer NOT NULL,
    spec_ref integer,
    category character varying,
    expedition_ref integer,
    expedition_name character varying,
    expedition_from_date date,
    expedition_from_date_mask integer,
    expedition_to_date date,
    expedition_to_date_mask integer,
    station_visible boolean,
    gtu_ref integer,
    gtu_code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_latitude double precision,
    gtu_longitude double precision,
    gtu_lat_long_accuracy double precision,
    gtu_elevation double precision,
    gtu_elevation_accuracy double precision,
    taxon_ref integer,
    taxon_name character varying,
    taxon_level_ref integer,
    taxon_level_name character varying,
    taxon_status character varying,
    taxon_extinct boolean,
    taxon_parents public.hstore,
    litho_ref integer,
    litho_name character varying,
    litho_level_ref integer,
    litho_level_name character varying,
    litho_status character varying,
    litho_local boolean,
    litho_color character varying,
    litho_parents public.hstore,
    chrono_ref integer,
    chrono_name character varying,
    chrono_level_ref integer,
    chrono_level_name character varying,
    chrono_status character varying,
    chrono_local boolean,
    chrono_color character varying,
    chrono_upper_bound numeric(10,3),
    chrono_lower_bound numeric(10,3),
    chrono_parents public.hstore,
    lithology_ref integer,
    lithology_name character varying,
    lithology_level_ref integer,
    lithology_level_name character varying,
    lithology_status character varying,
    lithology_local boolean,
    lithology_color character varying,
    lithology_parents public.hstore,
    mineral_ref integer,
    mineral_name character varying,
    mineral_level_ref integer,
    mineral_level_name character varying,
    mineral_status character varying,
    mineral_local boolean,
    mineral_color character varying,
    mineral_path character varying,
    mineral_parents public.hstore,
    host_taxon_name character varying,
    host_taxon_level_ref integer,
    host_taxon_level_name character varying,
    host_taxon_status character varying,
    ig_ref integer,
    ig_num character varying,
    ig_date_mask integer,
    ig_date date,
    acquisition_category character varying,
    acquisition_date_mask integer,
    acquisition_date date,
    individual_type character varying,
    individual_sex character varying,
    individual_state character varying,
    individual_stage character varying,
    individual_social_status character varying,
    individual_rock_form character varying,
    individual_count_min integer,
    individual_count_max integer,
    collectors text[],
    donators text[],
    part character varying,
    institution_ref integer,
    institution_name character varying,
    building character varying,
    floor character varying,
    room character varying,
    "row" character varying,
    shelf character varying,
    container_type character varying,
    container_storage character varying,
    container character varying,
    sub_container_type character varying,
    sub_container_storage character varying,
    sub_container character varying,
    part_count_min integer,
    part_count_max integer,
    specimen_status character varying,
    complete boolean,
    surnumerary boolean,
    status public.hstore DEFAULT ''::public.hstore NOT NULL,
    to_import boolean DEFAULT false,
    object_name text,
    create_taxon boolean DEFAULT false NOT NULL,
    col text,
    mineral_classification text,
    specimen_taxonomy_ref integer,
    darwin_hierarchy character varying
);


ALTER TABLE darwin2.staging OWNER TO darwin2;

--
-- TOC entry 1771 (class 1255 OID 4816384)
-- Name: fct_imp_checker(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_rec integer :=0;
  tags staging_tag_groups ;
  tags_tag RECORD;
  update_count integer;
  tag_groups_line RECORD;
BEGIN
  IF import THEN
    /* If gtu_ref already defined, that means that check was already
       made for the line and there's no need to reassociate it
    */
    IF line.gtu_ref is not null THEN
      RETURN true;
    END IF;
    /* If no code is given, not even from date and not even tags (tag_groups here),
       that means there's not enough information to associate a gtu
    */
    IF (line.gtu_code is null OR COALESCE(fullToIndex(line.gtu_code),'')  = '') AND (line.gtu_from_date is null) AND NOT EXISTS (select 1 from staging_tag_groups g where g.staging_ref = line.id ) THEN
      RETURN true;
    END IF;
    /* Otherwise, we should try to associate a gtu_ref */
    select substr.id into ref_rec from (
       /* This part try to select gtu id for line.gtu_code NULL or line.gtu_code = '' making the comparison on all the
          other fields ensuring uniqueness (latitude, longitude, from_date and to_date)
          The criteria position('import/' in code) > 0 filter also on the already imported gtu without code only
       */
       select DISTINCT id from gtu g 
			/* ftheeten 2018 09 18*/
			--1 link staging-> prop
				LEFT JOIN staging_info
				ON line.id=staging_info.staging_ref
				AND referenced_relation='gtu'
				LEFT JOIN properties AS properties_staging_info
				ON properties_staging_info.referenced_relation='staging_info'
				AND properties_staging_info.record_id=staging_info.id
			--2 link gtu -> prop
				LEFT JOIN properties properties_gtu
				ON 
				gtu.id=properties_gtu.record_id
				AND properties_gtu.referenced_relation = 'gtu'
			--3 link staging tags
				LEFT JOIN staging_tag_groups
				ON
				line.id= staging_tag_groups.staging_ref
			--4 link gtu tags
				LEFT JOIN
				tag_groups
				ON gtu.id=tag_groups.gtu_ref
				
		/*  */
	   
			WHERE
         position('import/' in code) > 0 AND
         COALESCE(latitude,0) = COALESCE(line.gtu_latitude,0) AND
         COALESCE(longitude,0) = COALESCE(line.gtu_longitude,0) AND
         COALESCE(fullToIndex(line.gtu_code), '') = '' AND
         fct_mask_date(gtu_from_date,gtu_from_date_mask) = fct_mask_date(COALESCE(line.gtu_from_date, '01/01/0001')::timestamp,line.gtu_from_date_mask) AND
         fct_mask_date(gtu_to_date,gtu_to_date_mask) = fct_mask_date(COALESCE(line.gtu_to_date, '31/12/2038')::timestamp,line.gtu_to_date_mask) AND
         COALESCE(elevation,0) = COALESCE(line.gtu_elevation,0)
		  /* ftheeten 2018 09 18*/
			--compare props staging with props gtu
			AND array_agg(properties_staging_info.property_type ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.property_type ORDER BY properties_gtu.property_type) 
			AND array_agg(properties_staging_info.lower_value ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.lower_value ORDER BY properties_gtu.property_type)
			AND array_agg(properties_staging_info.upper_value ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.upper_value ORDER BY properties_gtu.property_type)
			--compare gtu tags with staging tags
			AND 
			array_agg( tag_groups.tag_value ORDER BY tag_groups.group_name, tag_groups.sub_group_name ) @> array_agg( stagin_tag_groups.tag_value ORDER BY staging_tag_groups.group_name, staging_tag_groups.sub_group_name )
			AND
			array_agg( tag_groups.tag_value ORDER BY tag_groups.group_name, tag_groups.sub_group_name ) <@ array_agg( stagin_tag_groups.tag_value ORDER BY staging_tag_groups.group_name, staging_tag_groups.sub_group_name )
			GROUP BY gtu.id

		 
		 /**/
         /* if we're not in the case of already imported gtu without code,
            we've got to find a gtu that correspond to the criterias of the current line
         */

       union
       select DISTINCT id from gtu g 
			/* ftheeten 2018 09 18*/
			--1 link staging-> prop
				LEFT JOIN staging_info
				ON line.id=staging_info.staging_ref
				AND referenced_relation='gtu'
				LEFT JOIN properties AS properties_staging_info
				ON properties_staging_info.referenced_relation='staging_info'
				AND properties_staging_info.record_id=staging_info.id
			--2 link gtu -> prop
				LEFT JOIN properties properties_gtu
				ON 
				gtu.id=properties_gtu.record_id
				AND properties_gtu.referenced_relation = 'gtu'
			--3 link staging tags
				LEFT JOIN staging_tag_groups
				ON
				line.id= staging_tag_groups.staging_ref
			--4 link gtu tags
				LEFT JOIN
				tag_groups
				ON gtu.id=tag_groups.gtu_ref
				
		/*  */
	   where
         position('import/' in code) = 0 AND
         COALESCE(latitude,0) = COALESCE(line.gtu_latitude,0) AND
         COALESCE(longitude,0) = COALESCE(line.gtu_longitude,0) AND
         COALESCE(fullToIndex(code),'') = COALESCE(fullToIndex(line.gtu_code),'') AND
         fct_mask_date(gtu_from_date,gtu_from_date_mask) = fct_mask_date(COALESCE(line.gtu_from_date, '01/01/0001')::timestamp,line.gtu_from_date_mask) AND
         fct_mask_date(gtu_to_date,gtu_to_date_mask) = fct_mask_date(COALESCE(line.gtu_to_date, '31/12/2038')::timestamp,line.gtu_to_date_mask) AND
         COALESCE(elevation,0) = COALESCE(line.gtu_elevation,0)
		 /* ftheeten 2018 09 18*/
			--compare props staging with props gtu
			AND array_agg(properties_staging_info.property_type ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.property_type ORDER BY properties_gtu.property_type) 
			AND array_agg(properties_staging_info.lower_value ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.lower_value ORDER BY properties_gtu.property_type)
			AND array_agg(properties_staging_info.upper_value ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.upper_value ORDER BY properties_gtu.property_type)
			--compare gtu tags with staging tags
			AND 
			array_agg( tag_groups.tag_value ORDER BY tag_groups.group_name, tag_groups.sub_group_name ) @> array_agg( stagin_tag_groups.tag_value ORDER BY staging_tag_groups.group_name, staging_tag_groups.sub_group_name )
			AND
			array_agg( tag_groups.tag_value ORDER BY tag_groups.group_name, tag_groups.sub_group_name ) <@ array_agg( stagin_tag_groups.tag_value ORDER BY staging_tag_groups.group_name, staging_tag_groups.sub_group_name )
			GROUP BY gtu.id

		 
		 /**/
       LIMIT 1
      ) as substr
    WHERE substr.id != 0 LIMIT 1;

    /* If no corresponding gtu found and we've chosen to import... insert the new gtu */
    IF NOT FOUND THEN
      INSERT into gtu
      (code,
       gtu_from_date_mask,
       gtu_from_date,
       gtu_to_date_mask,
       gtu_to_date,
       latitude,
       longitude,
       lat_long_accuracy,
       elevation,
       elevation_accuracy
      )
      VALUES
        (
          CASE COALESCE(fullToIndex(line.gtu_code),'') WHEN '' THEN 'import/'|| line.import_ref || '/' || line.id ELSE line.gtu_code END,
          COALESCE(line.gtu_from_date_mask,0),
          COALESCE(line.gtu_from_date, '01/01/0001'),
          COALESCE(line.gtu_to_date_mask,0),
          COALESCE(line.gtu_to_date, '31/12/2038'),
          line.gtu_latitude,
          line.gtu_longitude,
          line.gtu_lat_long_accuracy,
          line.gtu_elevation,
          line.gtu_elevation_accuracy
        )
      RETURNING id INTO line.gtu_ref;
      /* The new id is returned in line.gtu_ref and stored in ref_rec so it can be used further on */
      ref_rec := line.gtu_ref;
      /* Browse all tags to try importing them one by one and associate them with the newly created gtu */
      FOR tags IN SELECT * FROM staging_tag_groups WHERE staging_ref = line.id LOOP
        BEGIN
          INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value)
            SELECT ref_rec,tags.group_name, tags.sub_group_name, tags.tag_value;
          EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Error in fct_imp_checker_gtu (case non existing gtu): %', SQLERRM;
            /* Do nothing and continue */
        END ;
      END LOOP ;
    ELSE
      /* Define gtu_ref of the line object, so it can be used afterwards in the perform to bring correctly
         the additional comments and additional properties
      */
      line.gtu_ref = ref_rec;
      /* ELSE ADDED HERE TO CHECK IF THE TAGS (and the staging infos) OF THE EXISTING GTU EXISTS TOO */
      /* This case happens when a gtu that correspond to info entered in staging has been found */
      /* Browse all tags to try importing them one by one and associate them with the newly created gtu */
      FOR tags IN SELECT * FROM staging_tag_groups WHERE staging_ref = line.id LOOP
        /* We split all the tags entered by ; as it's the case in the interface */
        FOR tags_tag IN SELECT trim(regexp_split_to_table(tags.tag_value, E';+')) as value LOOP
          BEGIN
            /* We use an upsert here.
               Ideally, we should use locking, but we consider it's isolated.
             */
            UPDATE tag_groups
            SET tag_value = tag_value || ';' || tags.tag_value
            WHERE gtu_ref = ref_rec
                  AND group_name_indexed = fullToIndex(tags.group_name)
                  AND sub_group_name_indexed = fullToIndex(tags.sub_group_name)
                  AND fullToIndex(tags_tag.value) NOT IN (SELECT fullToIndex(regexp_split_to_table(tag_value, E';+')));
            GET DIAGNOSTICS update_count = ROW_COUNT;
            IF update_count = 0 THEN
              INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value)
                SELECT ref_rec,tags.group_name, tags.sub_group_name, tags_tag.value
                WHERE NOT EXISTS (SELECT id
                                  FROM tag_groups
                                  WHERE gtu_ref = ref_rec
                                        AND group_name_indexed = fullToIndex(tags.group_name)
                                        AND sub_group_name_indexed = fullToIndex(tags.sub_group_name)
                                  LIMIT 1
                );
            END IF;
            EXCEPTION WHEN OTHERS THEN
              RAISE NOTICE 'Error in fct_imp_checker_gtu (case from existing gtu): %', SQLERRM;
              RAISE NOTICE 'gtu_ref is %', ref_rec;
              RAISE NOTICE 'group name is %', tags.group_name;
              RAISE NOTICE 'subg  roup name is %', tags.sub_group_name;
              RAISE NOTICE 'tag value is %', tags_tag.value;
              /* Do nothing here */
          END ;
        END LOOP;
      END LOOP ;
    END IF;
    /* Execute (perform = execute without any output) the update of reference_relation
       for the current staging line and for the gtu type of relationship.
       Referenced relation currently named 'staging_info' is replaced by gtu
       and record_id currently set to line.id (staging id) is replaced by line.gtu_ref (id of the new gtu created)
    */
    PERFORM fct_imp_checker_staging_info(line, 'gtu');

    /* Associate the gtu_ref in the staging and erase in hstore status the gtu tag signaling gtu has still to be treated */
    UPDATE staging SET status = delete(status,'gtu'), gtu_ref = ref_rec where id=line.id;

  END IF;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker(line darwin2.staging, import boolean) OWNER TO darwin2;

--
-- TOC entry 1772 (class 1255 OID 4816387)
-- Name: fct_imp_checker_catalogue(darwin2.staging, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_catalogue(line darwin2.staging, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  ref_record RECORD;
  rec_id integer := null;
  line_store hstore;
  field_name text;
  field_level_name text;
  test text;
  ref refcursor;

     --ftheeten 2017 08 03
  taxonomy_ref_str varchar;
  restrict_taxonomy boolean;
  filter_taxonomy_str varchar;
   --ftheeten 2017 08 03
BEGIN
    line_store := hstore(line);
    field_name := prefix || '_name';
    field_name := line_store->field_name;
    field_level_name := prefix || '_level_name';
    field_level_name := coalesce(line_store->field_level_name,'');

         --ftheeten 2017 08 03
  taxonomy_ref_str :=line_store->'specimen_taxonomy_ref';
  restrict_taxonomy := false;
  filter_taxonomy_str:='';
  IF LENGTH(TRIM(taxonomy_ref_str))> 0 THEN
	IF(taxonomy_ref_str::int)>0 AND catalogue_table='taxonomy'  THEN
		restrict_taxonomy:=TRUE;
		filter_taxonomy_str:='  metadata_ref = '|| taxonomy_ref_str||' AND ';		
	END IF;
  END IF;
   --ftheeten 2017 08 03

    OPEN ref FOR EXECUTE 'SELECT * FROM ' || catalogue_table || ' t
    INNER JOIN catalogue_levels c on t.level_ref = c.id
    WHERE  '||filter_taxonomy_str ||' name = ' || quote_literal( field_name) || ' AND  level_sys_name = CASE WHEN ' || quote_literal(field_level_name) || ' = '''' THEN level_sys_name ELSE ' || quote_literal(field_level_name) || ' END
    LIMIT 2';
    LOOP
      FETCH ref INTO ref_record;
      IF  NOT FOUND THEN
        EXIT;  -- exit loop
      END IF;

      rec_id := ref_record.id;
      result_nbr := result_nbr +1;
    END LOOP;

    IF result_nbr = 1 THEN -- It's Ok!

      PERFORM fct_imp_checker_catalogues_parents(line,rec_id, catalogue_table, prefix);
      RETURN true;
    END IF;

    IF result_nbr >= 2 THEN
      UPDATE staging SET status = (status || hstore(prefix , 'too_much')) where id= line.id;
      RETURN true;
    END IF;

    CLOSE ref;

  /*** Then CHECK fuzzy name ***/

  result_nbr := 0;
  IF catalogue_table = 'mineralogy' THEN
    /*
     * @ToDo: We'll need to evaluate if we keep the fuzzyness here or if we apply the same as it's for the other catalogues (=)
     */
    OPEN ref FOR EXECUTE 'SELECT * FROM ' || catalogue_table || ' t
    INNER JOIN catalogue_levels c on t.level_ref = c.id
    WHERE   name_indexed like fullToIndex(' || quote_literal( field_name) || ') || ''%'' AND  level_sys_name = CASE WHEN ' || quote_literal(field_level_name) || ' = '''' THEN level_sys_name ELSE ' || quote_literal(field_level_name) || ' END
    LIMIT 2';
    LOOP
      FETCH ref INTO ref_record;
      IF  NOT FOUND THEN
        EXIT;  -- exit loop
      END IF;

      rec_id := ref_record.id;
      result_nbr := result_nbr +1;
    END LOOP;
  ELSE
    OPEN ref FOR EXECUTE 'SELECT * FROM ' || catalogue_table || ' t
    INNER JOIN catalogue_levels c on t.level_ref = c.id
    WHERE '||filter_taxonomy_str ||' name_indexed = fullToIndex(' || quote_literal( field_name) || ') AND  level_sys_name = CASE WHEN ' || quote_literal(field_level_name) || ' = '''' THEN level_sys_name ELSE ' || quote_literal(field_level_name) || ' END
    LIMIT 2';
    LOOP
      FETCH ref INTO ref_record;
      IF  NOT FOUND THEN
        EXIT;  -- exit loop
      END IF;

      rec_id := ref_record.id;
      result_nbr := result_nbr +1;
    END LOOP;
  END IF ;

  IF result_nbr = 1 THEN -- It's Ok!
    PERFORM fct_imp_checker_catalogues_parents(line,rec_id, catalogue_table, prefix);
    RETURN true;
  END IF;

  IF result_nbr >= 2 THEN
    UPDATE staging SET status = (status || hstore(prefix , 'too_much')) where id= line.id;
    RETURN true;
  END IF;

  IF result_nbr = 0 THEN
    UPDATE staging SET status = (status || hstore(prefix, 'not_found')) where id=line.id;
    RETURN true;
  END IF;

  CLOSE ref;
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_catalogue(line darwin2.staging, catalogue_table text, prefix text) OWNER TO darwin2;

--
-- TOC entry 1774 (class 1255 OID 4816388)
-- Name: fct_imp_checker_catalogue_bck20180829(darwin2.staging, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_catalogue_bck20180829(line darwin2.staging, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  ref_record RECORD;
  rec_id integer := null;
  line_store hstore;
  field_name text;
  field_level_name text;
  test text;
  ref refcursor;
BEGIN
    line_store := hstore(line);
    field_name := prefix || '_name';
    field_name := line_store->field_name;
    field_level_name := prefix || '_level_name';
    field_level_name := coalesce(line_store->field_level_name,'');

    OPEN ref FOR EXECUTE 'SELECT * FROM ' || catalogue_table || ' t
    INNER JOIN catalogue_levels c on t.level_ref = c.id
    WHERE name = ' || quote_literal( field_name) || ' AND  level_sys_name = CASE WHEN ' || quote_literal(field_level_name) || ' = '''' THEN level_sys_name ELSE ' || quote_literal(field_level_name) || ' END
    LIMIT 2';
    LOOP
      FETCH ref INTO ref_record;
      IF  NOT FOUND THEN
        EXIT;  -- exit loop
      END IF;

      rec_id := ref_record.id;
      result_nbr := result_nbr +1;
    END LOOP;

    IF result_nbr = 1 THEN -- It's Ok!

      PERFORM fct_imp_checker_catalogues_parents(line,rec_id, catalogue_table, prefix);
      RETURN true;
    END IF;

    IF result_nbr >= 2 THEN
      UPDATE staging SET status = (status || (prefix => 'too_much')) where id= line.id;
      RETURN true;
    END IF;

    CLOSE ref;

  /*** Then CHECK fuzzy name ***/

  result_nbr := 0;
  IF catalogue_table = 'mineralogy' THEN
    /*
     * @ToDo: We'll need to evaluate if we keep the fuzzyness here or if we apply the same as it's for the other catalogues (=)
     */
    OPEN ref FOR EXECUTE 'SELECT * FROM ' || catalogue_table || ' t
    INNER JOIN catalogue_levels c on t.level_ref = c.id
    WHERE name_indexed like fullToIndex(' || quote_literal( field_name) || ') || ''%'' AND  level_sys_name = CASE WHEN ' || quote_literal(field_level_name) || ' = '''' THEN level_sys_name ELSE ' || quote_literal(field_level_name) || ' END
    LIMIT 2';
    LOOP
      FETCH ref INTO ref_record;
      IF  NOT FOUND THEN
        EXIT;  -- exit loop
      END IF;

      rec_id := ref_record.id;
      result_nbr := result_nbr +1;
    END LOOP;
  ELSE
    OPEN ref FOR EXECUTE 'SELECT * FROM ' || catalogue_table || ' t
    INNER JOIN catalogue_levels c on t.level_ref = c.id
    WHERE name_indexed = fullToIndex(' || quote_literal( field_name) || ') AND  level_sys_name = CASE WHEN ' || quote_literal(field_level_name) || ' = '''' THEN level_sys_name ELSE ' || quote_literal(field_level_name) || ' END
    LIMIT 2';
    LOOP
      FETCH ref INTO ref_record;
      IF  NOT FOUND THEN
        EXIT;  -- exit loop
      END IF;

      rec_id := ref_record.id;
      result_nbr := result_nbr +1;
    END LOOP;
  END IF ;

  IF result_nbr = 1 THEN -- It's Ok!
    PERFORM fct_imp_checker_catalogues_parents(line,rec_id, catalogue_table, prefix);
    RETURN true;
  END IF;

  IF result_nbr >= 2 THEN
    UPDATE staging SET status = (status || (prefix => 'too_much')) where id= line.id;
    RETURN true;
  END IF;

  IF result_nbr = 0 THEN
    UPDATE staging SET status = (status || (prefix => 'not_found')) where id=line.id;
    RETURN true;
  END IF;

  CLOSE ref;
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_catalogue_bck20180829(line darwin2.staging, catalogue_table text, prefix text) OWNER TO darwin2;

--
-- TOC entry 1775 (class 1255 OID 4816389)
-- Name: fct_imp_checker_catalogues_parents(darwin2.staging, integer, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_catalogues_parents(line darwin2.staging, rec_id integer, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  row_record record;
  lvl_name varchar;
  lvl_value varchar;
  rec_parents hstore;
  line_store hstore;
  field_name text;

   --ftheeten 2017 08 03
  taxonomy_ref_str varchar;
  restrict_taxonomy boolean;
  filter_taxonomy_str varchar;
   --ftheeten 2017 08 03

   --ftheeten 2018 08 14
   rec_parents_darwin hstore;
BEGIN
  line_store := hstore(line);
  field_name := prefix || '_parents';
  rec_parents := line_store->field_name;

   --ftheeten 2017 08 03
  taxonomy_ref_str :=line_store->'specimen_taxonomy_ref';
  restrict_taxonomy := false;
  filter_taxonomy_str:='';
  IF LENGTH(TRIM(taxonomy_ref_str))> 0 THEN
	IF(taxonomy_ref_str::int)>0 AND catalogue_table='taxonomy'  THEN
		restrict_taxonomy:=TRUE;
		filter_taxonomy_str:='  metadata_ref = '|| taxonomy_ref_str||' AND ';		
	END IF;
  END IF;
   --ftheeten 2017 08 03
--ftheeten 2018 06 16
If catalogue_table='taxonomy' THEN
	IF rec_parents is not null AND rec_parents != ''::hstore  AND rec_id is not null THEN
		
		 SELECT fct_rmca_sort_taxon_path_alphabetically_hstore(path) INTO rec_parents_darwin FROM taxonomy where id = rec_id; 
		 rec_parents := rec_parents - line.taxon_level_name;		
		 IF (rec_parents_darwin @> rec_parents) = FALSE THEN
					 EXECUTE 'UPDATE staging SET status = (status || ('|| quote_literal(prefix) || ' => ''bad_hierarchy'')), ' || prefix || '_ref = null where id=' || line.id;
			RETURN TRUE;

		 END IF;
	END IF;
ELSE

  IF rec_parents is not null AND rec_parents != ''::hstore  AND rec_id is not null THEN
    EXECUTE 'select * from '|| quote_ident(catalogue_table) || ' where id = ' || rec_id into row_record ;

    FOR lvl_name in SELECT s FROM fct_explode_array(akeys(rec_parents)) as s
    LOOP
      lvl_value := rec_parents->lvl_name;
      EXECUTE 'SELECT count(*) from ' || quote_ident(catalogue_table) || ' t
        INNER JOIN catalogue_levels c on t.level_ref = c.id
        WHERE level_sys_name = ' || quote_literal(lvl_name) || ' AND
          name_indexed like fullToIndex( ' || quote_literal(lvl_value) || '  ) || ''%''
          AND ' || quote_literal(row_record.path) || 'like t.path || t.id || ''/%'' ' INTO result_nbr;
      IF result_nbr = 0 THEN
        EXECUTE 'UPDATE staging SET status = (status || hstore('|| quote_literal(prefix) || ' ,''bad_hierarchy'')), ' || prefix || '_ref = null where id=' || line.id;
        RETURN TRUE;
      END IF;
    END LOOP;
  END IF;
END IF;
  EXECUTE 'UPDATE staging SET status = delete(status, ' || quote_literal(prefix) ||'), ' || prefix|| '_ref = ' || rec_id || ' where id=' || line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_catalogues_parents(line darwin2.staging, rec_id integer, catalogue_table text, prefix text) OWNER TO darwin2;

--
-- TOC entry 1776 (class 1255 OID 4816390)
-- Name: fct_imp_checker_catalogues_parents_bck20180829(darwin2.staging, integer, text, text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_catalogues_parents_bck20180829(line darwin2.staging, rec_id integer, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  row_record record;
  lvl_name varchar;
  lvl_value varchar;
  rec_parents hstore;
  line_store hstore;
  field_name text;
BEGIN
  line_store := hstore(line);
  field_name := prefix || '_parents';
  rec_parents := line_store->field_name;

  IF rec_parents is not null AND rec_parents != ''::hstore  AND rec_id is not null THEN
    EXECUTE 'select * from '|| quote_ident(catalogue_table) || ' where id = ' || rec_id into row_record ;

    FOR lvl_name in SELECT s FROM fct_explode_array(akeys(rec_parents)) as s
    LOOP
      lvl_value := rec_parents->lvl_name;
      EXECUTE 'SELECT count(*) from ' || quote_ident(catalogue_table) || ' t
        INNER JOIN catalogue_levels c on t.level_ref = c.id
        WHERE level_sys_name = ' || quote_literal(lvl_name) || ' AND
          name_indexed like fullToIndex( ' || quote_literal(lvl_value) || '  ) || ''%''
          AND ' || quote_literal(row_record.path) || 'like t.path || t.id || ''/%'' ' INTO result_nbr;
      IF result_nbr = 0 THEN
        EXECUTE 'UPDATE staging SET status = (status || ('|| quote_literal(prefix) || ' => ''bad_hierarchy'')), ' || prefix || '_ref = null where id=' || line.id;
        RETURN TRUE;
      END IF;
    END LOOP;
  END IF;

  EXECUTE 'UPDATE staging SET status = delete(status, ' || quote_literal(prefix) ||'), ' || prefix|| '_ref = ' || rec_id || ' where id=' || line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_catalogues_parents_bck20180829(line darwin2.staging, rec_id integer, catalogue_table text, prefix text) OWNER TO darwin2;

--
-- TOC entry 1777 (class 1255 OID 4816391)
-- Name: fct_imp_checker_expeditions(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_expeditions(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  ref_record RECORD;
  ref_rec integer :=0;
  ref refcursor;
BEGIN
  IF line.expedition_name is null OR line.expedition_name ='' OR line.expedition_ref is not null THEN
    RETURN true;
  END IF;
  OPEN ref FOR select * from expeditions where name_indexed = fulltoindex(line.expedition_name) ; 
  LOOP
    FETCH ref INTO ref_record ;    
    IF NOT FOUND THEN
  EXIT ;
    END IF;
    ref_rec = ref_record.id ;
    result_nbr := result_nbr +1;
  END LOOP ;
  IF result_nbr = 0 THEN
    IF import THEN
      INSERT INTO expeditions (name, expedition_from_date, expedition_to_date, expedition_from_date_mask,expedition_to_date_mask)
      VALUES (
        line.expedition_name, COALESCE(line.expedition_from_date,'01/01/0001'),
        COALESCE(line.expedition_to_date,'31/12/2038'), COALESCE(line.expedition_from_date_mask,0),
        COALESCE(line.expedition_to_date_mask,0)
      )
      RETURNING id INTO line.expedition_ref;

      ref_rec := line.expedition_ref;
      PERFORM fct_imp_checker_staging_info(line, 'expeditions');
    ELSE
      RETURN TRUE;
    END IF;
  END IF;
  IF result_nbr >= 2 THEN
    UPDATE staging SET status = (status || ('expedition' => 'too_much')) where id= line.id;
    RETURN true;
  END IF; 
  /* So result_nbr = 1 ! */
  UPDATE staging SET status = delete(status,'expedition'), expedition_ref = ref_rec where id=line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_expeditions(line darwin2.staging, import boolean) OWNER TO darwin2;

--
-- TOC entry 1780 (class 1255 OID 4816392)
-- Name: fct_imp_checker_gtu(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_gtu(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_rec integer :=0;
  tags staging_tag_groups ;
  tags_tag RECORD;
  update_count integer;
  tag_groups_line RECORD;
BEGIN
  IF import THEN
    /* If gtu_ref already defined, that means that check was already
       made for the line and there's no need to reassociate it
    */
    IF line.gtu_ref is not null THEN
      RETURN true;
    END IF;
    /* If no code is given, not even from date and not even tags (tag_groups here),
       that means there's not enough information to associate a gtu
    */
    IF (line.gtu_code is null OR COALESCE(fullToIndex(line.gtu_code),'')  = '') AND (line.gtu_from_date is null) AND NOT EXISTS (select 1 from staging_tag_groups g where g.staging_ref = line.id ) THEN
      RETURN true;
    END IF;
	
	
	---!!!!!!!!!!!!!!!!!!!!!!!!!!
	
		--fheeten 2018 10 31
		--ftheeten 2018 09 18 if just code and rest null (except date) then search gtu
		IF length(trim(line.gtu_code))=0 AND line.gtu_latitude Is NULL AND line.gtu_longitude IS NULL AND line.gtu_elevation IS NULL AND (SELECT COUNT(*) FROM staging_info WHERE staging_info.referenced_relation='gtu' AND  line.id=staging_info.staging_ref)=0 AND (SELECT COUNT(*) FROM staging_tag_groups WHERE line.id= staging_tag_groups.staging_ref )=0 
		AND
			(SELECT count(distinct comments.id)+
				count(distinct properties.id)
				from staging_info
				LEFT JOIN 
				 properties
				ON 
				 staging_info.id=properties.record_id
				AND properties.referenced_relation='staging_info'
				  LEFT JOIN 
				 comments
				ON 
				 staging_info.id=comments.record_id
				AND comments.referenced_relation='staging_info'
				WHERE
				staging_info.referenced_relation='gtu'
				AND
				staging_ref=line.id
				)=0 
		THEN
			return true;

		ELSIF

		-- position('import/' in line.gtu_code) = 0 AND 

		length(trim(line.gtu_code))>0 AND line.gtu_latitude Is NULL AND line.gtu_longitude IS NULL AND line.gtu_elevation IS NULL AND (SELECT COUNT(*) FROM staging_info WHERE staging_info.referenced_relation='gtu' AND  line.id=staging_info.staging_ref)=0 AND (SELECT COUNT(*) FROM staging_tag_groups WHERE line.id= staging_tag_groups.staging_ref )=0
		AND --no properties and comment in loaded data
		--ftheeten 2018 10 31
			(SELECT count(distinct comments.id)+
				count(distinct properties.id)
				from staging_info
				LEFT JOIN 
				 properties
				ON 
				 staging_info.id=properties.record_id
				AND properties.referenced_relation='staging_info'
				  LEFT JOIN 
				 comments
				ON 
				 staging_info.id=comments.record_id
				AND comments.referenced_relation='staging_info'
				WHERE
				staging_info.referenced_relation='gtu'
				AND
				staging_ref=line.id
				)=0 
		AND
		--only one GTU with indexed form of code  
		(SELECT count(DISTINCT id) FROM gtu g  
			
						WHERE COALESCE(fullToIndex(code),'') = COALESCE(fullToIndex(line.gtu_code),'') AND
					 fct_mask_date(gtu_from_date,gtu_from_date_mask) = fct_mask_date(COALESCE(line.gtu_from_date, '01/01/0001')::timestamp,line.gtu_from_date_mask) AND
					 fct_mask_date(gtu_to_date,gtu_to_date_mask) = fct_mask_date(COALESCE(line.gtu_to_date, '31/12/2038')::timestamp,line.gtu_to_date_mask))=1
	
		THEN
			SELECT substr.id INTO  ref_rec FROM (SELECT id FROM gtu g  
			
						WHERE COALESCE(fullToIndex(code),'') = COALESCE(fullToIndex(line.gtu_code),'') AND
					 fct_mask_date(gtu_from_date,gtu_from_date_mask) = fct_mask_date(COALESCE(line.gtu_from_date, '01/01/0001')::timestamp,line.gtu_from_date_mask) AND
					 fct_mask_date(gtu_to_date,gtu_to_date_mask) = fct_mask_date(COALESCE(line.gtu_to_date, '31/12/2038')::timestamp,line.gtu_to_date_mask)
					 
					 ) as substr
					WHERE substr.id != 0 LIMIT 1;
		ELSE
	
			/* Otherwise, we should try to associate a gtu_ref */
			select substr.id into ref_rec from (
			   /* This part try to select gtu id for line.gtu_code NULL or line.gtu_code = '' making the comparison on all the
				  other fields ensuring uniqueness (latitude, longitude, from_date and to_date)
				  The criteria position('import/' in code) > 0 filter also on the already imported gtu without code only
			   */
				   select DISTINCT g.id from gtu g 
						/* ftheeten 2018 09 18*/
						--1 link staging-> prop
							LEFT JOIN staging_info
							ON line.id=staging_info.staging_ref
							AND staging_info.referenced_relation='gtu'
							LEFT JOIN properties AS properties_staging_info
							ON properties_staging_info.referenced_relation='staging_info'
							AND properties_staging_info.record_id=staging_info.id
						--2 link gtu -> prop
							LEFT JOIN properties properties_gtu
							ON 
							g.id=properties_gtu.record_id
							AND properties_gtu.referenced_relation = 'gtu'
						--3 link staging tags
							LEFT JOIN staging_tag_groups
							ON
							line.id= staging_tag_groups.staging_ref
						--4 link gtu tags
							LEFT JOIN
							tag_groups
							ON g.id=tag_groups.gtu_ref
                        --5 link gtu comments
                            LEFT JOIN comments
                            ON comments.referenced_relation = 'staging_info'
                            AND comments.record_id=staging_info.id
							
					/*  */
				   
						WHERE
					 position('import/' in code) > 0 AND
					 COALESCE(latitude,0) = COALESCE(line.gtu_latitude,0) AND
					 COALESCE(longitude,0) = COALESCE(line.gtu_longitude,0) AND
					 COALESCE(fullToIndex(line.gtu_code), '') = '' AND
					 fct_mask_date(gtu_from_date,gtu_from_date_mask) = fct_mask_date(COALESCE(line.gtu_from_date, '01/01/0001')::timestamp,line.gtu_from_date_mask) AND
					 fct_mask_date(gtu_to_date,gtu_to_date_mask) = fct_mask_date(COALESCE(line.gtu_to_date, '31/12/2038')::timestamp,line.gtu_to_date_mask) AND
					 COALESCE(elevation,0) = COALESCE(line.gtu_elevation,0)
					  /* ftheeten 2018 09 18*/
						--compare props staging with props gtu
						GROUP BY g.id
						HAVING array_agg(properties_staging_info.property_type ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.property_type ORDER BY properties_gtu.property_type) 
						AND array_agg(properties_staging_info.lower_value ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.lower_value ORDER BY properties_gtu.property_type)
						AND array_agg(properties_staging_info.upper_value ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.upper_value ORDER BY properties_gtu.property_type)
						--compare gtu tags with staging tags
						AND 
						array_agg( tag_groups.tag_value ORDER BY tag_groups.group_name, tag_groups.sub_group_name ) @> array_agg( staging_tag_groups.tag_value ORDER BY staging_tag_groups.group_name, staging_tag_groups.sub_group_name )
						AND
						array_agg( tag_groups.tag_value ORDER BY tag_groups.group_name, tag_groups.sub_group_name ) <@ array_agg( staging_tag_groups.tag_value ORDER BY staging_tag_groups.group_name, staging_tag_groups.sub_group_name )
						

					 
					 /**/
					 /* if we're not in the case of already imported gtu without code,
						we've got to find a gtu that correspond to the criterias of the current line
					 */

				   union
				   select DISTINCT g.id from gtu g 
						/* ftheeten 2018 09 18*/
						--1 link staging-> prop
							LEFT JOIN staging_info
							ON line.id=staging_info.staging_ref
							AND referenced_relation='gtu'
							LEFT JOIN properties AS properties_staging_info
							ON properties_staging_info.referenced_relation='staging_info'
							AND properties_staging_info.record_id=staging_info.id
						--2 link gtu -> prop
							LEFT JOIN properties properties_gtu
							ON 
							g.id=properties_gtu.record_id
							AND properties_gtu.referenced_relation = 'gtu'
						--3 link staging tags
							LEFT JOIN staging_tag_groups
							ON
							line.id= staging_tag_groups.staging_ref
						--4 link gtu tags
							LEFT JOIN
							tag_groups
							ON g.id=tag_groups.gtu_ref
                        --5 link gtu comments
                            LEFT JOIN comments
                            ON comments.referenced_relation = 'staging_info'
                            AND comments.record_id=staging_info.id
							
					/*  */
				   where
					 position('import/' in code) = 0 AND
					 COALESCE(latitude,0) = COALESCE(line.gtu_latitude,0) AND
					 COALESCE(longitude,0) = COALESCE(line.gtu_longitude,0) AND
					 COALESCE(fullToIndex(code),'') = COALESCE(fullToIndex(line.gtu_code),'') AND
					 fct_mask_date(gtu_from_date,gtu_from_date_mask) = fct_mask_date(COALESCE(line.gtu_from_date, '01/01/0001')::timestamp,line.gtu_from_date_mask) AND
					 fct_mask_date(gtu_to_date,gtu_to_date_mask) = fct_mask_date(COALESCE(line.gtu_to_date, '31/12/2038')::timestamp,line.gtu_to_date_mask) AND
					 COALESCE(elevation,0) = COALESCE(line.gtu_elevation,0)
					 /* ftheeten 2018 09 18*/
					 GROUP BY g.id
						--compare props staging with props gtu
						HAVING array_agg(properties_staging_info.property_type ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.property_type ORDER BY properties_gtu.property_type) 
						AND array_agg(properties_staging_info.lower_value ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.lower_value ORDER BY properties_gtu.property_type)
						AND array_agg(properties_staging_info.upper_value ORDER BY properties_staging_info.property_type) = array_agg(properties_gtu.upper_value ORDER BY properties_gtu.property_type)
						--compare gtu tags with staging tags
						AND 
						array_agg( tag_groups.tag_value ORDER BY tag_groups.group_name, tag_groups.sub_group_name ) @> array_agg( staging_tag_groups.tag_value ORDER BY staging_tag_groups.group_name, staging_tag_groups.sub_group_name )
						AND
						array_agg( tag_groups.tag_value ORDER BY tag_groups.group_name, tag_groups.sub_group_name ) <@ array_agg( staging_tag_groups.tag_value ORDER BY staging_tag_groups.group_name, staging_tag_groups.sub_group_name )
						

					 
					 /**/
				   LIMIT 1
				  ) as substr
				WHERE substr.id != 0 LIMIT 1;
		END IF;
		---!!!!!!!!!!!!!!!!!!!!!!!!!!

    /* If no corresponding gtu found and we've chosen to import... insert the new gtu */
    IF NOT FOUND THEN
      INSERT into gtu
      (code,
      import_ref,
       gtu_from_date_mask,
       gtu_from_date,
       gtu_to_date_mask,
       gtu_to_date,
       latitude,
       longitude,
       lat_long_accuracy,
       elevation,
       elevation_accuracy
      )
      VALUES
        (
          CASE COALESCE(fullToIndex(line.gtu_code),'') WHEN '' THEN 'import/'|| line.import_ref || '/' || line.id ELSE line.gtu_code END,
          line.import_ref,
          COALESCE(line.gtu_from_date_mask,0),
          COALESCE(line.gtu_from_date, '01/01/0001'),
          COALESCE(line.gtu_to_date_mask,0),
          COALESCE(line.gtu_to_date, '31/12/2038'),
          line.gtu_latitude,
          line.gtu_longitude,
          line.gtu_lat_long_accuracy,
          line.gtu_elevation,
          line.gtu_elevation_accuracy
        )
      RETURNING id INTO line.gtu_ref;
      /* The new id is returned in line.gtu_ref and stored in ref_rec so it can be used further on */
      ref_rec := line.gtu_ref;
      /* Browse all tags to try importing them one by one and associate them with the newly created gtu */
      FOR tags IN SELECT * FROM staging_tag_groups WHERE staging_ref = line.id LOOP
        BEGIN
          INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value)
            SELECT ref_rec,tags.group_name, tags.sub_group_name, tags.tag_value;
          EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Error in fct_imp_checker_gtu (case non existing gtu): %', SQLERRM;
            /* Do nothing and continue */
        END ;
      END LOOP ;
    ELSE
      /* Define gtu_ref of the line object, so it can be used afterwards in the perform to bring correctly
         the additional comments and additional properties
      */
      line.gtu_ref = ref_rec;
      /* ELSE ADDED HERE TO CHECK IF THE TAGS (and the staging infos) OF THE EXISTING GTU EXISTS TOO */
      /* This case happens when a gtu that correspond to info entered in staging has been found */
      /* Browse all tags to try importing them one by one and associate them with the newly created gtu */
      FOR tags IN SELECT * FROM staging_tag_groups WHERE staging_ref = line.id LOOP
        /* We split all the tags entered by ; as it's the case in the interface */
        FOR tags_tag IN SELECT trim(regexp_split_to_table(tags.tag_value, E';+')) as value LOOP
          BEGIN
            /* We use an upsert here.
               Ideally, we should use locking, but we consider it's isolated.
             */
            UPDATE tag_groups
            SET tag_value = tag_value || ';' || tags.tag_value
            WHERE gtu_ref = ref_rec
                  AND group_name_indexed = fullToIndex(tags.group_name)
                  AND sub_group_name_indexed = fullToIndex(tags.sub_group_name)
                  AND fullToIndex(tags_tag.value) NOT IN (SELECT fullToIndex(regexp_split_to_table(tag_value, E';+')));
            GET DIAGNOSTICS update_count = ROW_COUNT;
            IF update_count = 0 THEN
              INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value)
                SELECT ref_rec,tags.group_name, tags.sub_group_name, tags_tag.value
                WHERE NOT EXISTS (SELECT id
                                  FROM tag_groups
                                  WHERE gtu_ref = ref_rec
                                        AND group_name_indexed = fullToIndex(tags.group_name)
                                        AND sub_group_name_indexed = fullToIndex(tags.sub_group_name)
                                  LIMIT 1
                );
            END IF;
            EXCEPTION WHEN OTHERS THEN
              RAISE NOTICE 'Error in fct_imp_checker_gtu (case from existing gtu): %', SQLERRM;
              RAISE NOTICE 'gtu_ref is %', ref_rec;
              RAISE NOTICE 'group name is %', tags.group_name;
              RAISE NOTICE 'subg  roup name is %', tags.sub_group_name;
              RAISE NOTICE 'tag value is %', tags_tag.value;
              /* Do nothing here */
          END ;
        END LOOP;
      END LOOP ;
    END IF;
    /* Execute (perform = execute without any output) the update of reference_relation
       for the current staging line and for the gtu type of relationship.
       Referenced relation currently named 'staging_info' is replaced by gtu
       and record_id currently set to line.id (staging id) is replaced by line.gtu_ref (id of the new gtu created)
    */
    PERFORM fct_imp_checker_staging_info(line, 'gtu');

    /* Associate the gtu_ref in the staging and erase in hstore status the gtu tag signaling gtu has still to be treated */
    UPDATE staging SET status = delete(status,'gtu'), gtu_ref = ref_rec where id=line.id;

  END IF;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_gtu(line darwin2.staging, import boolean) OWNER TO darwin2;

--
-- TOC entry 1778 (class 1255 OID 4816395)
-- Name: fct_imp_checker_gtu_bck20180918(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_gtu_bck20180918(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_rec integer :=0;
  tags staging_tag_groups ;
  tags_tag RECORD;
  update_count integer;
  tag_groups_line RECORD;
BEGIN
  IF import THEN
    /* If gtu_ref already defined, that means that check was already
       made for the line and there's no need to reassociate it
    */
    IF line.gtu_ref is not null THEN
      RETURN true;
    END IF;
    /* If no code is given, not even from date and not even tags (tag_groups here),
       that means there's not enough information to associate a gtu
    */
    IF (line.gtu_code is null OR COALESCE(fullToIndex(line.gtu_code),'')  = '') AND (line.gtu_from_date is null) AND NOT EXISTS (select 1 from staging_tag_groups g where g.staging_ref = line.id ) THEN
      RETURN true;
    END IF;
    /* Otherwise, we should try to associate a gtu_ref */
    select substr.id into ref_rec from (
       /* This part try to select gtu id for line.gtu_code NULL or line.gtu_code = '' making the comparison on all the
          other fields ensuring uniqueness (latitude, longitude, from_date and to_date)
          The criteria position('import/' in code) > 0 filter also on the already imported gtu without code only
       */
       select id from gtu g where
         position('import/' in code) > 0 AND
         COALESCE(latitude,0) = COALESCE(line.gtu_latitude,0) AND
         COALESCE(longitude,0) = COALESCE(line.gtu_longitude,0) AND
         COALESCE(fullToIndex(line.gtu_code), '') = '' AND
         fct_mask_date(gtu_from_date,gtu_from_date_mask) = fct_mask_date(COALESCE(line.gtu_from_date, '01/01/0001')::timestamp,line.gtu_from_date_mask) AND
         fct_mask_date(gtu_to_date,gtu_to_date_mask) = fct_mask_date(COALESCE(line.gtu_to_date, '31/12/2038')::timestamp,line.gtu_to_date_mask) AND
         COALESCE(elevation,0) = COALESCE(line.gtu_elevation,0)
         
         /* if we're not in the case of already imported gtu without code,
            we've got to find a gtu that correspond to the criterias of the current line
         */
       union
       select id from gtu g where
         position('import/' in code) = 0 AND
         COALESCE(latitude,0) = COALESCE(line.gtu_latitude,0) AND
         COALESCE(longitude,0) = COALESCE(line.gtu_longitude,0) AND
         COALESCE(fullToIndex(code),'') = COALESCE(fullToIndex(line.gtu_code),'') AND
         fct_mask_date(gtu_from_date,gtu_from_date_mask) = fct_mask_date(COALESCE(line.gtu_from_date, '01/01/0001')::timestamp,line.gtu_from_date_mask) AND
         fct_mask_date(gtu_to_date,gtu_to_date_mask) = fct_mask_date(COALESCE(line.gtu_to_date, '31/12/2038')::timestamp,line.gtu_to_date_mask) AND
         COALESCE(elevation,0) = COALESCE(line.gtu_elevation,0)
       LIMIT 1
      ) as substr
    WHERE substr.id != 0 LIMIT 1;

    /* If no corresponding gtu found and we've chosen to import... insert the new gtu */
    IF NOT FOUND THEN
      INSERT into gtu
      (code,
       gtu_from_date_mask,
       gtu_from_date,
       gtu_to_date_mask,
       gtu_to_date,
       latitude,
       longitude,
       lat_long_accuracy,
       elevation,
       elevation_accuracy
      )
      VALUES
        (
          CASE COALESCE(fullToIndex(line.gtu_code),'') WHEN '' THEN 'import/'|| line.import_ref || '/' || line.id ELSE line.gtu_code END,
          COALESCE(line.gtu_from_date_mask,0),
          COALESCE(line.gtu_from_date, '01/01/0001'),
          COALESCE(line.gtu_to_date_mask,0),
          COALESCE(line.gtu_to_date, '31/12/2038'),
          line.gtu_latitude,
          line.gtu_longitude,
          line.gtu_lat_long_accuracy,
          line.gtu_elevation,
          line.gtu_elevation_accuracy
        )
      RETURNING id INTO line.gtu_ref;
      /* The new id is returned in line.gtu_ref and stored in ref_rec so it can be used further on */
      ref_rec := line.gtu_ref;
      /* Browse all tags to try importing them one by one and associate them with the newly created gtu */
      FOR tags IN SELECT * FROM staging_tag_groups WHERE staging_ref = line.id LOOP
        BEGIN
          INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value)
            SELECT ref_rec,tags.group_name, tags.sub_group_name, tags.tag_value;
          EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Error in fct_imp_checker_gtu (case non existing gtu): %', SQLERRM;
            /* Do nothing and continue */
        END ;
      END LOOP ;
    ELSE
      /* Define gtu_ref of the line object, so it can be used afterwards in the perform to bring correctly
         the additional comments and additional properties
      */
      line.gtu_ref = ref_rec;
      /* ELSE ADDED HERE TO CHECK IF THE TAGS (and the staging infos) OF THE EXISTING GTU EXISTS TOO */
      /* This case happens when a gtu that correspond to info entered in staging has been found */
      /* Browse all tags to try importing them one by one and associate them with the newly created gtu */
      FOR tags IN SELECT * FROM staging_tag_groups WHERE staging_ref = line.id LOOP
        /* We split all the tags entered by ; as it's the case in the interface */
        FOR tags_tag IN SELECT trim(regexp_split_to_table(tags.tag_value, E';+')) as value LOOP
          BEGIN
            /* We use an upsert here.
               Ideally, we should use locking, but we consider it's isolated.
             */
            UPDATE tag_groups
            SET tag_value = tag_value || ';' || tags.tag_value
            WHERE gtu_ref = ref_rec
                  AND group_name_indexed = fullToIndex(tags.group_name)
                  AND sub_group_name_indexed = fullToIndex(tags.sub_group_name)
                  AND fullToIndex(tags_tag.value) NOT IN (SELECT fullToIndex(regexp_split_to_table(tag_value, E';+')));
            GET DIAGNOSTICS update_count = ROW_COUNT;
            IF update_count = 0 THEN
              INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value)
                SELECT ref_rec,tags.group_name, tags.sub_group_name, tags_tag.value
                WHERE NOT EXISTS (SELECT id
                                  FROM tag_groups
                                  WHERE gtu_ref = ref_rec
                                        AND group_name_indexed = fullToIndex(tags.group_name)
                                        AND sub_group_name_indexed = fullToIndex(tags.sub_group_name)
                                  LIMIT 1
                );
            END IF;
            EXCEPTION WHEN OTHERS THEN
              RAISE NOTICE 'Error in fct_imp_checker_gtu (case from existing gtu): %', SQLERRM;
              RAISE NOTICE 'gtu_ref is %', ref_rec;
              RAISE NOTICE 'group name is %', tags.group_name;
              RAISE NOTICE 'subg  roup name is %', tags.sub_group_name;
              RAISE NOTICE 'tag value is %', tags_tag.value;
              /* Do nothing here */
          END ;
        END LOOP;
      END LOOP ;
    END IF;
    /* Execute (perform = execute without any output) the update of reference_relation
       for the current staging line and for the gtu type of relationship.
       Referenced relation currently named 'staging_info' is replaced by gtu
       and record_id currently set to line.id (staging id) is replaced by line.gtu_ref (id of the new gtu created)
    */
    PERFORM fct_imp_checker_staging_info(line, 'gtu');

    /* Associate the gtu_ref in the staging and erase in hstore status the gtu tag signaling gtu has still to be treated */
    UPDATE staging SET status = delete(status,'gtu'), gtu_ref = ref_rec where id=line.id;

  END IF;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_gtu_bck20180918(line darwin2.staging, import boolean) OWNER TO darwin2;

--
-- TOC entry 1779 (class 1255 OID 4816398)
-- Name: fct_imp_checker_igs(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_igs(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_rec integer :=0;
BEGIN
  IF line.ig_num is null OR  line.ig_num = '' OR line.ig_ref is not null THEN
    RETURN true;
  END IF;

  select id into ref_rec from igs where ig_num = line.ig_num ;
  IF NOT FOUND THEN
    IF import THEN
        INSERT INTO igs (ig_num, ig_date_mask, ig_date)
        VALUES (line.ig_num,  COALESCE(line.ig_date_mask,line.ig_date_mask,'0'), COALESCE(line.ig_date,'01/01/0001'))
        RETURNING id INTO line.ig_ref;

        ref_rec := line.ig_ref;
        PERFORM fct_imp_checker_staging_info(line, 'igs');
    ELSE
    --UPDATE staging SET status = (status || ('igs' => 'not_found')), ig_ref = null where id=line.id;
      RETURN TRUE;
    END IF;
  END IF;

  UPDATE staging SET status = delete(status,'igs'), ig_ref = ref_rec where id=line.id;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_igs(line darwin2.staging, import boolean) OWNER TO darwin2;

--
-- TOC entry 1783 (class 1255 OID 4816399)
-- Name: fct_imp_checker_manager(darwin2.staging); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_manager(line darwin2.staging) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN

  IF line.taxon_name IS NOT NULL AND line.taxon_name is distinct from '' AND line.taxon_ref is null THEN
    PERFORM fct_imp_create_catalogues_and_parents(line, 'taxonomy','taxon');
    PERFORM fct_imp_checker_catalogue(line,'taxonomy','taxon');
  END IF;

  IF line.chrono_name IS NOT NULL AND line.chrono_name is distinct from '' AND line.chrono_ref is null THEN
    PERFORM fct_imp_checker_catalogue(line,'chronostratigraphy','chrono');
  END IF;

  IF line.lithology_name IS NOT NULL AND line.lithology_name is distinct from '' AND line.lithology_ref is null THEN
    PERFORM fct_imp_checker_catalogue(line,'lithology','lithology');
  END IF;

  IF line.mineral_name IS NOT NULL AND line.mineral_name is distinct from '' AND line.mineral_ref is null THEN
    PERFORM fct_imp_checker_catalogue(line,'mineralogy','mineral');
  END IF;

  IF line.litho_name IS NOT NULL AND line.litho_name is distinct from '' AND line.litho_ref is null THEN
    PERFORM fct_imp_checker_catalogue(line,'lithostratigraphy','litho');
  END IF;



  PERFORM fct_imp_checker_igs(line);
  PERFORM fct_imp_checker_expeditions(line);
  --MADAM FTHEETEN 2019 01 29 (DEV LINK TO GTU)
  --PERFORM fct_imp_checker_gtu(line);
  raise notice 'check gtu';
  PERFORM fct_rmca_imp_checker_gtu_search_code(line);
  PERFORM fct_imp_checker_people(line);
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_manager(line darwin2.staging) OWNER TO darwin2;

--
-- TOC entry 1781 (class 1255 OID 4816400)
-- Name: fct_imp_checker_people(darwin2.staging); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_people(line darwin2.staging) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_record integer :=0;
  cnt integer :=-1;
  p_name text;
  merge_status integer :=1;
  ident_line RECORD;
  people_line RECORD ;
BEGIN


  --  Donators and collectors

  FOR people_line IN select * from staging_people WHERE referenced_relation ='staging' AND record_id = line.id and  TRIM(formated_name)  != '' --ftheeten 2018 10 31 avoid null string
  LOOP
    IF people_line.people_ref is not null THEN
      continue;
    END IF;
    SELECT fct_look_for_people(people_line.formated_name) into ref_record;
    CASE ref_record
      WHEN -1,0 THEN merge_status := -1 ;
      --WHEN 0 THEN merge_status := 0;
      ELSE
        UPDATE staging_people SET people_ref = ref_record WHERE id=people_line.id ;
    END CASE;
  END LOOP;
  IF merge_status = 1 THEN
    UPDATE staging SET status = delete(status,'people') where id=line.id;
  ELSE
    UPDATE staging SET status = (status || hstore('people', 'people')) where id= line.id;
  END IF;

  -- Identifiers

  merge_status := 1 ;
  FOR ident_line in select * from identifications where referenced_relation ='staging' AND  record_id = line.id
  LOOP
    FOR people_line IN select * from staging_people WHERE referenced_relation ='identifications' AND record_id = ident_line.id
    and  TRIM(formated_name)  != '' --ftheeten 2018 10 31 avoid null string
    LOOP
      IF people_line.people_ref is not null THEN
        continue;
      END IF;
      SELECT fct_look_for_people(people_line.formated_name) into ref_record;
      CASE ref_record
        WHEN -1,0 THEN merge_status := -1 ;
        --WHEN 0 THEN merge_status := 0;
        ELSE
          UPDATE staging_people SET people_ref = ref_record WHERE id=people_line.id ;
      END CASE;
    END LOOP;
  END LOOP;

  IF merge_status = 1 THEN
    UPDATE staging SET status = delete(status,'identifiers') where id=line.id;
  ELSE
    UPDATE staging SET status = (status || hstore('identifiers' , 'people')) where id= line.id;
  END IF;

  -- Sequencers

  merge_status := 1 ;
  FOR ident_line in select * from collection_maintenance where referenced_relation ='staging' AND  record_id = line.id
  LOOP
    FOR people_line IN select * from staging_people WHERE referenced_relation ='collection_maintenance' AND record_id = ident_line.id
    and  TRIM(formated_name)  != '' --ftheeten 2018 10 31 avoid null string
    LOOP
      IF people_line.people_ref is not null THEN
        continue;
      END IF;
      SELECT fct_look_for_people(people_line.formated_name) into ref_record;
      CASE ref_record
        WHEN -1,0 THEN merge_status := -1 ;
        --WHEN 0 THEN merge_status := 0;
        ELSE
          UPDATE staging_people SET people_ref = ref_record WHERE id=people_line.id ;
      END CASE;
    END LOOP;
  END LOOP;

  IF merge_status = 1 THEN
    UPDATE staging SET status = delete(status,'operator') where id=line.id;
  ELSE
    UPDATE staging SET status = (status || hstore('operator', 'people')) where id= line.id;
  END IF;

  /**********
  * Institution
  **********/
  IF line.institution_name IS NOT NULL and line.institution_name  != '' AND line.institution_ref is null THEN
    SELECT fct_look_for_institution(line.institution_name) into ref_record ;
  CASE ref_record
  WHEN -1 THEN
    UPDATE staging SET status = (status || hstore('institution', 'too_much')) where id= line.id;
  WHEN 0 THEN
    UPDATE staging SET status = (status || hstore('institution' ,'not_found')) where id= line.id;
  ELSE
    UPDATE staging SET status = delete(status,'institution'), institution_ref = ref_record where id=line.id;
      END CASE;
  END IF;

  /**********
  * Institution in staging_relationship
  **********/
  FOR ident_line in select * from staging_relationship where record_id = line.id
  LOOP
    IF ident_line.institution_name IS NOT NULL and ident_line.institution_name  != '' AND ident_line.institution_ref is null AND ident_line.institution_name  != 'Not defined' THEN
      SELECT fct_look_for_institution(ident_line.institution_name) into ref_record;
      CASE ref_record
      WHEN -1 THEN
        UPDATE staging SET status = (status || hstore('institution_relationship' , 'too_much')) where id= line.id;
      WHEN 0 THEN
        UPDATE staging SET status = (status || hstore('institution_relationship', 'not_found')) where id= line.id;
        ELSE
          UPDATE staging_relationship SET institution_ref = ref_record WHERE id=ident_line.id ;
          UPDATE staging SET status = delete(status,'institution_relationship') where id=line.id;
      END CASE;
    END IF;
  END LOOP;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_people(line darwin2.staging) OWNER TO darwin2;

--
-- TOC entry 1782 (class 1255 OID 4816401)
-- Name: fct_imp_checker_people_bck20180829(darwin2.staging); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_imp_checker_people_bck20180829(line darwin2.staging) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_record integer :=0;
  cnt integer :=-1;
  p_name text;
  merge_status integer :=1;
  ident_line RECORD;
  people_line RECORD ;
BEGIN


  --  Donators and collectors

  FOR people_line IN select * from staging_people WHERE referenced_relation ='staging' AND record_id = line.id
  LOOP
    IF people_line.people_ref is not null THEN
      continue;
    END IF;
    SELECT fct_look_for_people(people_line.formated_name) into ref_record;
    CASE ref_record
      WHEN -1,0 THEN merge_status := -1 ;
      --WHEN 0 THEN merge_status := 0;
      ELSE
        UPDATE staging_people SET people_ref = ref_record WHERE id=people_line.id ;
    END CASE;
  END LOOP;
  IF merge_status = 1 THEN
    UPDATE staging SET status = delete(status,'people') where id=line.id;
  ELSE
    UPDATE staging SET status = (status || ('people' => 'people')) where id= line.id;
  END IF;

  -- Identifiers

  merge_status := 1 ;
  FOR ident_line in select * from identifications where referenced_relation ='staging' AND  record_id = line.id
  LOOP
    FOR people_line IN select * from staging_people WHERE referenced_relation ='identifications' AND record_id = ident_line.id
    LOOP
      IF people_line.people_ref is not null THEN
        continue;
      END IF;
      SELECT fct_look_for_people(people_line.formated_name) into ref_record;
      CASE ref_record
        WHEN -1,0 THEN merge_status := -1 ;
        --WHEN 0 THEN merge_status := 0;
        ELSE
          UPDATE staging_people SET people_ref = ref_record WHERE id=people_line.id ;
      END CASE;
    END LOOP;
  END LOOP;

  IF merge_status = 1 THEN
    UPDATE staging SET status = delete(status,'identifiers') where id=line.id;
  ELSE
    UPDATE staging SET status = (status || ('identifiers' => 'people')) where id= line.id;
  END IF;

  -- Sequencers

  merge_status := 1 ;
  FOR ident_line in select * from collection_maintenance where referenced_relation ='staging' AND  record_id = line.id
  LOOP
    FOR people_line IN select * from staging_people WHERE referenced_relation ='collection_maintenance' AND record_id = ident_line.id
    LOOP
      IF people_line.people_ref is not null THEN
        continue;
      END IF;
      SELECT fct_look_for_people(people_line.formated_name) into ref_record;
      CASE ref_record
        WHEN -1,0 THEN merge_status := -1 ;
        --WHEN 0 THEN merge_status := 0;
        ELSE
          UPDATE staging_people SET people_ref = ref_record WHERE id=people_line.id ;
      END CASE;
    END LOOP;
  END LOOP;

  IF merge_status = 1 THEN
    UPDATE staging SET status = delete(status,'operator') where id=line.id;
  ELSE
    UPDATE staging SET status = (status || ('operator' => 'people')) where id= line.id;
  END IF;

  /**********
  * Institution
  **********/
  IF line.institution_name IS NOT NULL and line.institution_name  != '' AND line.institution_ref is null THEN
    SELECT fct_look_for_institution(line.institution_name) into ref_record ;
  CASE ref_record
  WHEN -1 THEN
    UPDATE staging SET status = (status || ('institution' => 'too_much')) where id= line.id;
  WHEN 0 THEN
    UPDATE staging SET status = (status || ('institution' => 'not_found')) where id= line.id;
  ELSE
    UPDATE staging SET status = delete(status,'institution'), institution_ref = ref_record where id=line.id;
      END CASE;
  END IF;

  /**********
  * Institution in staging_relationship
  **********/
  FOR ident_line in select * from staging_relationship where record_id = line.id
  LOOP
    IF ident_line.institution_name IS NOT NULL and ident_line.institution_name  != '' AND ident_line.institution_ref is null AND ident_line.institution_name  != 'Not defined' THEN
      SELECT fct_look_for_institution(ident_line.institution_name) into ref_record;
      CASE ref_record
      WHEN -1 THEN
        UPDATE staging SET status = (status || ('institution_relationship' => 'too_much')) where id= line.id;
      WHEN 0 THEN
        UPDATE staging SET status = (status || ('institution_relationship' => 'not_found')) where id= line.id;
        ELSE
          UPDATE staging_relationship SET institution_ref = ref_record WHERE id=ident_line.id ;
          UPDATE staging SET status = delete(status,'institution_relationship') where id=line.id;
      END CASE;
    END IF;
  END LOOP;

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_people_bck20180829(line darwin2.staging) OWNER TO darwin2;

--
-- TOC entry 1886 (class 1255 OID 4816402)
-- Name: fct_imp_checker_staging_info(darwin2.staging, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_imp_checker_staging_info(line darwin2.staging, st_type text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  info_line staging_info ;
  record_line RECORD ;

BEGIN

  FOR info_line IN select * from staging_info WHERE staging_ref = line.id AND referenced_relation = st_type
  LOOP
      CASE info_line.referenced_relation
      WHEN 'gtu' THEN
        IF line.gtu_ref IS NOT NULL THEN

          PERFORM fct_imp_checker_staging_info_comments('staging_info', info_line.id, info_line.referenced_relation, line.gtu_ref);
          PERFORM fct_imp_checker_staging_info_ext_links('staging_info', info_line.id, info_line.referenced_relation, line.gtu_ref);

          PERFORM fct_imp_checker_staging_info_properties('staging_info', info_line.id, info_line.referenced_relation, line.gtu_ref);
          PERFORM fct_imp_checker_staging_info_multimedia('staging_info', info_line.id, info_line.referenced_relation, line.gtu_ref);

        END IF;
      WHEN 'taxonomy' THEN
        IF line.taxon_ref IS NOT NULL THEN

          PERFORM fct_imp_checker_staging_info_comments('staging_info', info_line.id, info_line.referenced_relation, line.taxon_ref);
          PERFORM fct_imp_checker_staging_info_ext_links('staging_info', info_line.id, info_line.referenced_relation, line.taxon_ref);

          PERFORM fct_imp_checker_staging_info_properties('staging_info', info_line.id, info_line.referenced_relation, line.taxon_ref);
          PERFORM fct_imp_checker_staging_info_multimedia('staging_info', info_line.id, info_line.referenced_relation, line.taxon_ref);

        END IF;
      WHEN 'expeditions' THEN
        IF line.expedition_ref IS NOT NULL THEN

          PERFORM fct_imp_checker_staging_info_comments('staging_info', info_line.id, info_line.referenced_relation, line.expedition_ref);
          PERFORM fct_imp_checker_staging_info_ext_links('staging_info', info_line.id, info_line.referenced_relation, line.expedition_ref);

          PERFORM fct_imp_checker_staging_info_multimedia('staging_info', info_line.id, info_line.referenced_relation, line.expedition_ref);

        END IF;
      WHEN 'lithostratigraphy' THEN
        IF line.litho_ref IS NOT NULL THEN

          PERFORM fct_imp_checker_staging_info_comments('staging_info', info_line.id, info_line.referenced_relation, line.litho_ref);
          PERFORM fct_imp_checker_staging_info_ext_links('staging_info', info_line.id, info_line.referenced_relation, line.litho_ref);

          PERFORM fct_imp_checker_staging_info_properties('staging_info', info_line.id, info_line.referenced_relation, line.litho_ref);
          PERFORM fct_imp_checker_staging_info_multimedia('staging_info', info_line.id, info_line.referenced_relation, line.litho_ref);

        END IF;
      WHEN 'lithology' THEN
        IF line.lithology_ref IS NOT NULL THEN

          PERFORM fct_imp_checker_staging_info_comments('staging_info', info_line.id, info_line.referenced_relation, line.lithology_ref);
          PERFORM fct_imp_checker_staging_info_ext_links('staging_info', info_line.id, info_line.referenced_relation, line.lithology_ref);

          PERFORM fct_imp_checker_staging_info_properties('staging_info', info_line.id, info_line.referenced_relation, line.lithology_ref);
          PERFORM fct_imp_checker_staging_info_multimedia('staging_info', info_line.id, info_line.referenced_relation, line.lithology_ref);

        END IF;
      WHEN 'chronostratigraphy' THEN
        IF line.chrono_ref IS NOT NULL THEN

          PERFORM fct_imp_checker_staging_info_comments('staging_info', info_line.id, info_line.referenced_relation, line.chrono_ref);
          PERFORM fct_imp_checker_staging_info_ext_links('staging_info', info_line.id, info_line.referenced_relation, line.chrono_ref);

          PERFORM fct_imp_checker_staging_info_properties('staging_info', info_line.id, info_line.referenced_relation, line.chrono_ref);
          PERFORM fct_imp_checker_staging_info_multimedia('staging_info', info_line.id, info_line.referenced_relation, line.chrono_ref);

        END IF;
      WHEN 'mineralogy' THEN
        IF line.mineral_ref IS NOT NULL THEN

          PERFORM fct_imp_checker_staging_info_comments('staging_info', info_line.id, info_line.referenced_relation, line.mineral_ref);
          PERFORM fct_imp_checker_staging_info_ext_links('staging_info', info_line.id, info_line.referenced_relation, line.mineral_ref);

          PERFORM fct_imp_checker_staging_info_properties('staging_info', info_line.id, info_line.referenced_relation, line.mineral_ref);
          PERFORM fct_imp_checker_staging_info_multimedia('staging_info', info_line.id, info_line.referenced_relation, line.mineral_ref);

        END IF;
      WHEN 'igs' THEN
        IF line.ig_ref IS NOT NULL THEN

          PERFORM fct_imp_checker_staging_info_comments('staging_info', info_line.id, info_line.referenced_relation, line.ig_ref);
          PERFORM fct_imp_checker_staging_info_ext_links('staging_info', info_line.id, info_line.referenced_relation, line.ig_ref);

          PERFORM fct_imp_checker_staging_info_insurances('staging_info', info_line.id, info_line.referenced_relation, line.ig_ref);

        END IF;
      ELSE continue ;
      END CASE ;
  END LOOP;
  DELETE FROM staging_info WHERE staging_ref = line.id ;
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_staging_info(line darwin2.staging, st_type text) OWNER TO postgres;

--
-- TOC entry 1784 (class 1255 OID 4816403)
-- Name: fct_imp_checker_staging_info_comments(character varying, integer, character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_imp_checker_staging_info_comments(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) RETURNS void
    LANGUAGE sql
    AS $_$
UPDATE comments as mc
SET referenced_relation = $3, record_id = $4
WHERE mc.referenced_relation = $1
      AND record_id = $2
      AND NOT EXISTS(SELECT 1
                     FROM comments AS sc
                     WHERE sc.referenced_relation = $3
                           AND sc.record_id = $4
                           AND sc.notion_concerned = mc.notion_concerned
                           AND sc.comment_indexed = mc.comment_indexed
                     LIMIT 1
);
$_$;


ALTER FUNCTION darwin2.fct_imp_checker_staging_info_comments(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) OWNER TO postgres;

--
-- TOC entry 1785 (class 1255 OID 4816404)
-- Name: fct_imp_checker_staging_info_ext_links(character varying, integer, character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_imp_checker_staging_info_ext_links(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) RETURNS void
    LANGUAGE sql
    AS $_$
UPDATE ext_links as mel
SET referenced_relation = $3, record_id = $4
WHERE mel.referenced_relation = $1
  AND record_id = $2
  AND NOT EXISTS(SELECT 1
                 FROM ext_links AS sel
                 WHERE sel.referenced_relation = $3
                       AND sel.record_id = $4
                       AND sel.url = mel.url
                );
$_$;


ALTER FUNCTION darwin2.fct_imp_checker_staging_info_ext_links(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) OWNER TO postgres;

--
-- TOC entry 1786 (class 1255 OID 4816405)
-- Name: fct_imp_checker_staging_info_insurances(character varying, integer, character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_imp_checker_staging_info_insurances(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) RETURNS void
    LANGUAGE sql
    AS $_$
UPDATE insurances as mi
SET referenced_relation = $3, record_id = $4
WHERE mi.referenced_relation = $1
      AND record_id = $2
      AND NOT EXISTS(SELECT 1
                     FROM insurances AS si
                     WHERE si.referenced_relation = $3
                           AND si.record_id = $4
                           AND si.insurance_value = mi.insurance_value
                           AND si.insurance_currency = mi.insurance_currency
                           AND si.date_from_mask = mi.date_from_mask
                           AND si.date_from = mi.date_from
                           AND si.date_to_mask = mi.date_to_mask
                           AND si.date_to = mi.date_to
                           AND COALESCE(si.insurer_ref,0) = COALESCE(mi.insurer_ref,0)
);
$_$;


ALTER FUNCTION darwin2.fct_imp_checker_staging_info_insurances(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) OWNER TO postgres;

--
-- TOC entry 1787 (class 1255 OID 4816406)
-- Name: fct_imp_checker_staging_info_multimedia(character varying, integer, character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_imp_checker_staging_info_multimedia(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) RETURNS void
    LANGUAGE sql
    AS $_$
UPDATE multimedia as mm
SET referenced_relation = $3, record_id = $4
WHERE mm.referenced_relation = $1
  AND record_id = $2
  AND NOT EXISTS(SELECT 1
                 FROM multimedia AS sm
                 WHERE sm.referenced_relation = $3
                       AND sm.record_id = $4
                       AND sm.mime_type = mm.mime_type
                       AND sm.search_indexed = mm.search_indexed
                );
$_$;


ALTER FUNCTION darwin2.fct_imp_checker_staging_info_multimedia(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) OWNER TO postgres;

--
-- TOC entry 1788 (class 1255 OID 4816407)
-- Name: fct_imp_checker_staging_info_properties(character varying, integer, character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_imp_checker_staging_info_properties(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) RETURNS void
    LANGUAGE sql
    AS $_$
UPDATE properties as mp
SET referenced_relation = $3, record_id = $4
WHERE mp.referenced_relation = $1
  AND record_id = $2
  AND NOT EXISTS(SELECT 1
                 FROM properties AS sp
                 WHERE sp.referenced_relation = $3
                       AND sp.record_id = $4
                       AND sp.property_type = mp.property_type
                       AND sp.applies_to = mp.applies_to
                       AND sp.date_from_mask = mp.date_from_mask
                       AND sp.date_from = mp.date_from
                       AND sp.date_to_mask = mp.date_to_mask
                       AND sp.date_to = mp.date_to
                       AND sp.is_quantitative = mp.is_quantitative
                       AND sp.property_unit = mp.property_unit
                       AND sp.method_indexed = mp.method_indexed
                       AND sp.lower_value = mp.lower_value
                       AND sp.upper_value = mp.upper_value
                       AND sp.property_accuracy = mp.property_accuracy
                );
$_$;


ALTER FUNCTION darwin2.fct_imp_checker_staging_info_properties(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) OWNER TO postgres;

--
-- TOC entry 1896 (class 1255 OID 4816408)
-- Name: fct_imp_checker_staging_relationship(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_imp_checker_staging_relationship() RETURNS integer[]
    LANGUAGE plpgsql
    AS $$
DECLARE
  relation_line RECORD ;
  specimen_ref INTEGER ;
  id_array integer ARRAY ;
BEGIN

  FOR relation_line IN select sr.*, s.spec_ref from staging_relationship sr, staging s WHERE sr.record_id = s.id AND s.spec_ref IS NOT NULL
  LOOP
    IF relation_line.staging_related_ref IS NOT NULL THEN
      SELECT spec_ref INTO specimen_ref FROM staging where id=relation_line.staging_related_ref ;
      IF specimen_ref IS NULL THEN
        id_array := array_append(id_array, relation_line.record_id);
        continue ;
      ELSE
        INSERT INTO specimens_relationships(id, specimen_ref, relationship_type, unit_type, specimen_related_ref, institution_ref)
        SELECT nextval('specimens_relationships_id_seq'), relation_line.spec_ref, relation_line.relationship_type, unit_type, specimen_ref, institution_ref
        from staging_relationship where id=relation_line.id AND staging_related_ref=relation_line.staging_related_ref;
      END IF;
    ELSE
    INSERT INTO specimens_relationships(id, specimen_ref, relationship_type, unit_type, institution_ref,taxon_ref, mineral_ref, source_name,
    source_id, quantity, unit)
        SELECT nextval('specimens_relationships_id_seq'), relation_line.spec_ref, relation_line.relationship_type, unit_type, institution_ref,
        taxon_ref, mineral_ref, source_name, source_id, quantity, unit
        from staging_relationship where id=relation_line.id ;
    END IF ;
    DELETE FROM staging_relationship WHERE id = relation_line.id ;
  END LOOP;
  RETURN id_array;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_checker_staging_relationship() OWNER TO postgres;

--
-- TOC entry 1792 (class 1255 OID 4816409)
-- Name: fct_imp_create_catalogues_and_parents(darwin2.staging, text, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  result_nbr integer :=0;
  row_record record;
  lvl_name varchar;
  lvl_value varchar;
  lvl_id integer;

  old_parent_id integer;
  parent_id integer;
  rec_parents hstore;
  line_store hstore;
  field_name1 text;
  field_name2 text;

  tmp text;
BEGIN
  line_store := hstore(line);
  field_name1 := prefix || '_parents';
  rec_parents := line_store->field_name1;

  IF line.create_taxon AND rec_parents is not null AND rec_parents != ''::hstore  THEN
    BEGIN
      field_name2 := prefix || '_name';
      field_name1 := prefix || '_level_name';

      IF line_store->field_name2 != '' THEN
        rec_parents = rec_parents || hstore(line_store->field_name1, line_store->field_name2);
      END IF;

      FOR row_record in SELECT s.key as lvl_name, s.value as lvl_value, l.id as lvl_id
        FROM each(rec_parents) as s LEFT JOIN catalogue_levels l on s.key = l.level_sys_name
        ORDER BY l.level_order ASC
      LOOP
        old_parent_id := parent_id;
        EXECUTE 'SELECT count(*), min(t.id) as id from ' || quote_ident(catalogue_table) || ' t
          INNER JOIN catalogue_levels c on t.level_ref = c.id
          WHERE level_sys_name = ' || quote_literal(row_record.lvl_name) || ' AND
            name_indexed like fullToIndex( ' || quote_literal(row_record.lvl_value) || '  ) || ''%'' '
          INTO result_nbr, parent_id;

        IF result_nbr = 0 THEN
          IF old_parent_id IS NULL THEN
            RAISE EXCEPTION 'Unable to create taxon with no common parents';
          END IF;
          EXECUTE 'INSERT INTO ' || quote_ident(catalogue_table) || '  (name, level_ref, parent_ref) VALUES
            (' || quote_literal(row_record.lvl_value) || ', ' ||
            quote_literal(row_record.lvl_id) ||', '|| quote_literal(old_parent_id) ||') returning ID' into parent_id ;

        END IF;
      END LOOP;

    EXCEPTION WHEN OTHERS THEN
      UPDATE staging set create_taxon = false where id = line.id;
      RETURN TRUE;
    END;
  END IF;
  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text) OWNER TO postgres;

--
-- TOC entry 1789 (class 1255 OID 4816410)
-- Name: fct_importer_abcd(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_abcd(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  userid integer;
  rec_id integer;
  people_id integer;
  all_line RECORD ;
  line staging;
  people_line RECORD;
  maintenance_line collection_maintenance;
  staging_line staging;
  id_to_delete integer ARRAY;
  id_to_keep integer ARRAY ;
  collection collections%ROWTYPE;
  code_count integer;
BEGIN
  SELECT * INTO collection FROM collections WHERE id = (SELECT collection_ref FROM imports WHERE id = req_import_ref AND is_finished = FALSE LIMIT 1);
  select user_ref into userid from imports where id=req_import_ref ;
  PERFORM set_config('darwin.userid',userid::varchar, false) ;
  INSERT INTO classification_keywords (referenced_relation, record_id, keyword_type, keyword)
    (
      SELECT DISTINCT ON (referenced_relation, taxon_ref, keyword_type, keyword_indexed)
        'taxonomy',
        taxon_ref,
        keyword_type,
        "keyword"
      FROM staging INNER JOIN classification_keywords as ckmain ON ckmain.referenced_relation = 'staging'
                                                               AND staging.id = ckmain.record_id
                   INNER JOIN imports as i ON i.id = staging.import_ref
      WHERE import_ref = req_import_ref
        AND to_import=true
        AND status = ''::hstore
        AND i.is_finished =  FALSE
        AND NOT EXISTS (
          SELECT 1
          FROM classification_keywords
          WHERE referenced_relation = 'taxonomy'
            AND record_id = staging.taxon_ref
            AND keyword_type = ckmain.keyword_type
            AND keyword_indexed = ckmain.keyword_indexed
        )
  );
  EXECUTE 'DELETE FROM classification_keywords
           WHERE referenced_relation = ''staging''
             AND record_id IN (
                                SELECT s.id
                                FROM staging s INNER JOIN imports i ON  s.import_ref = i.id
                                WHERE import_ref = $1
                                  AND to_import=true
                                  AND status = ''''::hstore
                                  AND i.is_finished =  FALSE
                             )'
  USING req_import_ref;
  FOR all_line IN SELECT * from staging s INNER JOIN imports i on  s.import_ref = i.id
  WHERE import_ref = req_import_ref AND to_import=true and status = ''::hstore AND i.is_finished =  FALSE
  LOOP
    BEGIN
      -- I know it's dumb but....
      -- @ToDo: We need to correct this to avoid reselecting from the staging table !!!
      select * into staging_line from staging where id = all_line.id;
      PERFORM fct_imp_checker_igs(staging_line, true);
      PERFORM fct_imp_checker_expeditions(staging_line, true);
      PERFORM fct_imp_checker_gtu(staging_line, true);

      --RE SELECT WITH UPDATE
      select * into line from staging s INNER JOIN imports i on  s.import_ref = i.id where s.id=all_line.id;

      rec_id := nextval('specimens_id_seq');
      IF line.spec_ref IS NULL THEN
        INSERT INTO specimens (id, category, collection_ref, expedition_ref, gtu_ref, taxon_ref, litho_ref, chrono_ref, lithology_ref, mineral_ref,
                               acquisition_category, acquisition_date_mask, acquisition_date, station_visible, ig_ref, type, sex, stage, state, social_status, rock_form,
                               specimen_part, complete, institution_ref, building, floor, room, row, col, shelf, container, sub_container,container_type, sub_container_type,
                               container_storage, sub_container_storage, surnumerary, specimen_status, specimen_count_min, specimen_count_max, object_name,
--ftheeten 2018 03 26
import_ref

                               )
        VALUES (rec_id, COALESCE(line.category,'physical') , all_line.collection_ref, line.expedition_ref, line.gtu_ref, line.taxon_ref, line.litho_ref, line.chrono_ref,
                        line.lithology_ref, line.mineral_ref, COALESCE(line.acquisition_category,''), COALESCE(line.acquisition_date_mask,0), COALESCE(line.acquisition_date,'01/01/0001'),
                                                                                                      COALESCE(line.station_visible,true),  line.ig_ref, COALESCE(line.individual_type,'specimen'), COALESCE(line.individual_sex,'undefined'),
                                                                                                      COALESCE(line.individual_stage,'undefined'), COALESCE(line.individual_state,'not applicable'),COALESCE(line.individual_social_status,'not applicable'),
                                                                                                      COALESCE(line.individual_rock_form,'not applicable'), COALESCE(line.part,'specimen'), COALESCE(line.complete,true), line.institution_ref, line.building,
                                                                                                                                                            line.floor, line.room, line.row,  line.col, line.shelf, line.container, line.sub_container,COALESCE(line.container_type,'container'),
                                                                                                                                                                                                                                    COALESCE(line.sub_container_type, 'container'), COALESCE(line.container_storage,''),COALESCE(line.sub_container_storage,''),
                                                                                                                                                                                                                                    COALESCE(line.surnumerary,false), COALESCE(line.specimen_status,''),COALESCE(line.part_count_min,1), COALESCE(line.part_count_max,line.part_count_min,1), line.object_name,

                                                                                                                                                                                                                                    --ftheeten 2018 03 26
                                                                                                                                                                                                                                    req_import_ref
        );
        FOR maintenance_line IN SELECT * from collection_maintenance where referenced_relation = 'staging' AND record_id=line.id
        LOOP
          SELECT people_ref into people_id FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
          UPDATE collection_maintenance set people_ref=people_id where id=maintenance_line.id ;
          DELETE FROM staging_people where referenced_relation='collection_maintenance' AND record_id=maintenance_line.id ;
        END LOOP;

        SELECT COUNT(*) INTO code_count FROM codes WHERE referenced_relation = 'staging' AND record_id = line.id AND code_category = 'main' AND code IS NOT NULL;
        IF code_count = 0 THEN
          PERFORM fct_after_save_add_code(all_line.collection_ref, rec_id);
        ELSE
          UPDATE codes SET referenced_relation = 'specimens',
            record_id = rec_id,
            code_prefix = CASE WHEN code_prefix IS NULL THEN collection.code_prefix ELSE code_prefix END,
            code_prefix_separator = CASE WHEN code_prefix_separator IS NULL THEN collection.code_prefix_separator ELSE code_prefix_separator END,
            code_suffix = CASE WHEN code_suffix IS NULL THEN collection.code_suffix ELSE code_suffix END,
            code_suffix_separator = CASE WHEN code_suffix_separator IS NULL THEN collection.code_suffix_separator ELSE code_suffix_separator END
          WHERE referenced_relation = 'staging'
                AND record_id = line.id
                AND code_category = 'main';
        END IF;

        UPDATE template_table_record_ref SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
        --UPDATE collection_maintenance SET referenced_relation ='specimens', record_id = rec_id where referenced_relation ='staging' and record_id = line.id;
        -- Import identifiers whitch identification have been updated to specimen
        INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
          SELECT nextval('catalogue_people_id_seq'), s.referenced_relation, s.record_id, s.people_type, s.people_sub_type, s.order_by, s.people_ref
          FROM staging_people s, identifications i
          WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' 
--ftheeten 2018 10 31
AND s.people_ref  IS NOT NULL
          ;
        DELETE FROM staging_people where id in (SELECT s.id FROM staging_people s, identifications i WHERE i.id = s.record_id AND s.referenced_relation = 'identifications' AND i.record_id = rec_id AND i.referenced_relation = 'specimens' ) ;
        -- Import collecting_methods
        INSERT INTO specimen_collecting_methods(id, specimen_ref, collecting_method_ref)
          SELECT nextval('specimen_collecting_methods_id_seq'), rec_id, collecting_method_ref
          FROM staging_collecting_methods
          WHERE staging_ref = line.id;

        DELETE FROM staging_collecting_methods where staging_ref = line.id;
        UPDATE staging set spec_ref=rec_id WHERE id=all_line.id;

        FOR people_line IN SELECT * from staging_people WHERE referenced_relation = 'specimens'
        LOOP
          INSERT INTO catalogue_people(id, referenced_relation, record_id, people_type, people_sub_type, order_by, people_ref)
          VALUES(nextval('catalogue_people_id_seq'),people_line.referenced_relation, people_line.record_id, people_line.people_type, people_line.people_sub_type, people_line.order_by, people_line.people_ref) ;
        END LOOP;
        DELETE FROM staging_people WHERE referenced_relation = 'specimens' ;
      END IF ;
      id_to_delete = array_append(id_to_delete,all_line.id) ;
    END;
  END LOOP;
  select fct_imp_checker_staging_relationship() into id_to_keep ;
  IF id_to_keep IS NOT NULL THEN
    DELETE from staging where (id = ANY (id_to_delete)) AND NOT (id = ANY (id_to_keep)) ;
  else
    DELETE from staging where (id = ANY (id_to_delete)) ;
  END IF ;
  IF EXISTS( select id FROM  staging WHERE import_ref = req_import_ref) THEN
    UPDATE imports set state = 'pending' where id = req_import_ref;
  ELSE
    UPDATE imports set state = 'finished', is_finished = true where id = req_import_ref;
  END IF;
  RETURN true;
END;
$_$;


ALTER FUNCTION darwin2.fct_importer_abcd(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1926 (class 1255 OID 4816413)
-- Name: fct_importer_catalogue(integer, text, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
        var_taxonomy_name varchar;
	is_reference boolean;
	var_creation_date date;
	var_creation_date_mask integer;
	var_definition_taxonomy varchar;
	var_source_taxonomy varchar;
	var_url_website_taxonomy varchar;
	var_url_webservice_taxonomy varchar;
	last_id_metadata integer;
	taxonomy_ref integer;	 
	--ftheeten 2019 02 19
	staging_catalogue_line staging_catalogue;
	kingdom_id integer;
	
BEGIN
	SELECT imports.specimen_taxonomy_ref , taxonomy_metadata.is_reference_taxonomy into taxonomy_ref, is_reference FROM imports LEFT JOIN taxonomy_metadata
	ON imports.specimen_taxonomy_ref=taxonomy_metadata.id	 WHERE imports.id=req_import_ref;
	IF taxonomy_ref IS NULL THEN
		--raise notice 'init';
		SELECT taxonomy_name, creation_date, creation_date_mask,definition_taxonomy, is_reference_taxonomy , source_taxonomy ,
		url_website_taxonomy,  url_webservice_taxonomy INTO var_taxonomy_name , var_creation_date, var_creation_date_mask , var_definition_taxonomy, is_reference, var_source_taxonomy,  var_url_website_taxonomy , var_url_webservice_taxonomy FROM imports WHERE id=req_import_ref;
		INSERT INTO taxonomy_metadata (taxonomy_name, creation_date, creation_date_mask, import_ref, 
	       definition, is_reference_taxonomy, source, url_website, url_webservice) VALUES (var_taxonomy_name, var_creation_date, var_creation_date_mask, req_import_ref, var_definition_taxonomy, is_reference, var_source_taxonomy, var_url_website_taxonomy, var_url_webservice_taxonomy) RETURNING id INTO last_id_metadata;
       ELSE
		last_id_metadata:=taxonomy_ref;
       END IF;

	
	IF is_reference = true THEN
		raise notice 'ref';
		raise notice 'import = %', req_import_ref;
		raise notice 'metadata %', last_id_metadata;
		return fct_importer_catalogue_reference_taxonomy(req_import_ref , last_id_metadata, referenced_relation, exclude_invalid_entries   );
	ELSE	
		raise notice 'non ref';
		raise notice 'import = %', req_import_ref;
		raise notice 'metadata %', last_id_metadata;
		return fct_rmca_handle_non_reference_taxonomies(req_import_ref , last_id_metadata, exclude_invalid_entries   );

		/*raise notice 'test kingdom';
                FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue where import_ref=req_import_ref and  parent_ref is null   and  parent_ref_internal is null  and level_ref<=34
			LOOP
				IF staging_catalogue_line.level_ref>2 THEN
					raise notice 'force kingdom';
					INSERT INTO darwin2.staging_catalogue(
						import_ref, name , level_ref,
						parent_ref, parent_ref_internal, catalogue_ref, 
						parent_updated,	is_reference_taxonomy, source_taxonomy, 
						name_cluster, imported)
						VALUES (
						staging_catalogue_line.import_ref, (SELECT taxonomy.name FROM imports LEFT JOIN taxonomy ON imports.taxonomy_kingdom=taxonomy.id::varchar where imports.id= staging_catalogue_line.import_ref LIMIT 1), 2
						, NULL, NULL, NULL, 
						false, 	staging_catalogue_line.is_reference_taxonomy, staging_catalogue_line.source_taxonomy, 
						staging_catalogue_line.name_cluster, false) RETURNING id into kingdom_id;
					UPDATE staging_catalogue SET parent_ref = kingdom_id  , parent_ref_internal= kingdom_id WHERE id=staging_catalogue_line.id;
				END IF;
			END LOOP;
	        RAISE NOTICE '2nd pass';
		return fct_rmca_handle_non_reference_taxonomies(req_import_ref , last_id_metadata, exclude_invalid_entries   );*/
	
	END IF;
END;
$$;


ALTER FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1912 (class 1255 OID 5308235)
-- Name: fct_importer_catalogue_backup_pad(integer, text, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_backup_pad(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    staging_catalogue_line staging_catalogue;
    where_clause_complement_1 text := ' ';
    where_clause_complement_2 text := ' ';
    where_clause_complement_3 text := ' ';
    where_clause_complement_3_bis text := ' ';
    where_clause_complement_4 text := ' ';
    where_clause_complement_5 text := ' ';
    where_clause_exclude_invalid text := ' ';
    recCatalogue RECORD;
    parent_path template_classifications.path%TYPE;
    parentRef staging_catalogue.parent_ref%TYPE;
    parent_level catalogue_levels.id%TYPE;
    catalogueRef staging_catalogue.catalogue_ref%TYPE;
    levelRef staging_catalogue.level_ref%TYPE;
    error_msg TEXT := '';
    children_move_forward BOOLEAN := FALSE;
    level_naming TEXT;
    tempSQL TEXT;

    --ftheeten 2018 09 24
    taxonomy_ref INTEGER:=NULL;
  BEGIN

    
    --ftheeten 2018 09 24
    IF referenced_relation ='taxonomy' THEN
	SELECT specimen_taxonomy_ref INTO taxonomy_ref FROM imports WHERE id= req_import_ref;	
    END IF;
    --ftheeten 2018 09 24 end
    -- Browse all staging_catalogue lines
    FOR staging_catalogue_line IN SELECT * from staging_catalogue WHERE import_ref = req_import_ref ORDER BY level_ref, fullToIndex(name)
    LOOP
      IF trim(touniquestr(staging_catalogue_line.name)) = '' THEN
        RAISE EXCEPTION E'Case 0, Could not import this file, % is not a valid name.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
      END IF;
      SELECT parent_ref, catalogue_ref, level_ref INTO parentRef, catalogueRef, levelRef FROM staging_catalogue WHERE id = staging_catalogue_line.id;
      IF catalogueRef IS NULL THEN
        -- Check if we're at a top taxonomic entry in the template/staging_catalogue line
        IF parentRef IS NULL THEN
          -- If top entry, we have not parent defined and we therefore have no other filtering criteria
          where_clause_complement_1 := ' ';
          where_clause_complement_2 := ' ';
          where_clause_complement_3 := ' ';
          where_clause_complement_3_bis := ' ';
        ELSE
          -- If a child entry, we've got to use the informations from the already matched or created parent
          where_clause_complement_1 := '  AND tax.parent_ref = ' || parentRef || ' ';
          where_clause_complement_2 := '  AND tax.parent_ref != ' || parentRef || ' ';
          -- Select the path from parent catalogue unit
          EXECUTE 'SELECT path, level_ref FROM ' || quote_ident(referenced_relation) || ' WHERE id = $1'
          INTO parent_path, parent_level
          USING parentRef;
          where_clause_complement_3 := '  AND position (' || quote_literal(parent_path) || ' IN tax.path) = 1 ';
          where_clause_complement_3_bis := '  AND (select t2.level_ref from ' || quote_ident(referenced_relation) || ' as t2 where t2.id = tax.parent_ref) > ' || parent_level || ' ';
        END IF;
        where_clause_complement_4 := '  AND left(substring(tax.name from length(trim(' ||
                                     quote_literal(staging_catalogue_line.name) || '))+1),1) IN (' ||
                                     quote_literal(' ') || ', ' || quote_literal(',') || ') ';
        where_clause_complement_5 := '  AND left(substring(' || quote_literal(staging_catalogue_line.name) ||
                                     ' from length(trim(tax.name))+1),1) IN (' ||
                                     quote_literal(' ') || ', ' || quote_literal(',') || ') ';
        -- Set the invalid where clause if asked
        IF exclude_invalid_entries = TRUE THEN
          where_clause_exclude_invalid := '  AND tax.status != ' || quote_literal('invalid') || ' ';
        END IF;
        -- Check a perfect match entry
        -- Take care here, a limit 1 has been set, we only kept the EXIT in case the limit would be accidently removed
        FOR recCatalogue IN EXECUTE 'SELECT COUNT(id) OVER () as total_count, * ' ||
                                    'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                                    'WHERE tax.level_ref = $1 ' ||
                                    '  AND tax.name_indexed = fullToIndex( $2 ) ' ||
                                    where_clause_exclude_invalid ||
                                    where_clause_complement_1 ||
                                    'LIMIT 1;'
        USING staging_catalogue_line.level_ref, staging_catalogue_line.name
        LOOP
          -- If more than one entry found, we set an error...
          IF recCatalogue.total_count > 1 THEN
            RAISE EXCEPTION E'Case 1, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
          END IF;
          EXIT;
        END LOOP;
        -- No perfect match occured with the same parent (if it applies - doesn't apply for top taxonomic entry in template)
        IF NOT FOUND THEN
          -- For this step, as it depends upon the existence of a parent, we test well we are on that case
          -- It concerns a perfect match with parents differents but with a path common
          -- That means, if only one entry exists, that they are the same but with a more detailed hierarchy in the
          -- already existing entry
          IF parentRef IS NOT NULL THEN
            FOR recCatalogue IN EXECUTE 'SELECT COUNT(id) OVER () as total_count, * ' ||
                                        'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                                        'WHERE tax.level_ref = $1 ' ||
                                        '  AND tax.name_indexed = fullToIndex( $2 ) ' ||
                                        where_clause_exclude_invalid ||
                                        where_clause_complement_2 ||
                                        where_clause_complement_3 ||
                                        where_clause_complement_3_bis ||
                                        'LIMIT 1;'
            USING staging_catalogue_line.level_ref, staging_catalogue_line.name
            LOOP
              -- If for this kind of perfect match with different parent but kind of same path start, we get multiple
              -- possibilities, then fail
              IF recCatalogue.total_count > 1 THEN
                RAISE EXCEPTION E'Case 2, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
              END IF;
              EXIT;
            END LOOP;
            -- If it gave no result, we've got to move forward and try the next option
            IF NOT FOUND THEN
              children_move_forward := TRUE;
            END IF;
          END IF;
          IF parentRef IS NULL OR children_move_forward = TRUE THEN
            -- This next option try a fuzzy match, with, if it's a child entry in the template, a verification that
            -- the parent specified in the template and the path of the potential corresponding entry in catalogue
            -- have a common path...
            tempSQL := 'SELECT COUNT(id) OVER () as total_count, * ' ||
                       'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                       'WHERE tax.level_ref = $1 ' ||
                       '  AND tax.name_indexed LIKE fullToIndex( $2 ) || ' || quote_literal('%') ||
                       where_clause_exclude_invalid ||
                       where_clause_complement_3 ||
                       where_clause_complement_4;
            IF parentRef IS NOT NULL THEN
              tempSQL := tempSQL || where_clause_complement_1;
            END IF;
            tempSQL := tempSQL || 'LIMIT 1;';
            FOR recCatalogue IN EXECUTE tempSQL
            USING staging_catalogue_line.level_ref, staging_catalogue_line.name
            LOOP
              -- If we're on the case of a top entry in the template, we cannot afford the problem of multiple entries
              IF recCatalogue.total_count > 1 THEN
                RAISE EXCEPTION E'Case 3, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
              END IF;
              EXIT;
            END LOOP;
            -- Last chance is to try to find if the entry in DaRWIN shouldn't be completed
            -- This entry should be "alone" of its kind - check the NOT EXIST clause
            IF NOT FOUND THEN
              FOR recCatalogue IN EXECUTE 'SELECT COUNT(id) OVER () as total_count, * ' ||
                                          'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                                          'WHERE tax.level_ref = $1 ' ||
                                          '  AND position(tax.name_indexed IN fullToIndex( $2 )) = 1 ' ||
                                          where_clause_exclude_invalid ||
                                          '  AND NOT EXISTS (SELECT 1 ' ||
                                          '                  FROM ' || quote_ident(referenced_relation) || ' as stax ' ||
                                          '                  WHERE stax.id != tax.id ' ||
                                          '                  AND stax.level_ref = tax.level_ref ' ||
                                          '                  AND stax.path = tax.path ' ||
                                          '                  AND stax.name_indexed LIKE tax.name_indexed || ' || quote_literal('%') ||
                                          '                  LIMIT 1 ' ||
                                          '                 ) ' ||
                                          where_clause_complement_3 ||
                                          where_clause_complement_5 ||
                                          'LIMIT 1;'
              USING staging_catalogue_line.level_ref, staging_catalogue_line.name
              LOOP
                IF recCatalogue.total_count > 1 THEN
                  RAISE EXCEPTION E'Case 4, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
                ELSE
                  -- If only one entry is found, we can replace the name of this entry
                  EXECUTE 'UPDATE ' || quote_ident(referenced_relation) || ' ' ||
                          'SET name = ' || quote_literal(staging_catalogue_line.name) || ' ' ||
                          'WHERE id = ' || recCatalogue.id || ';';
                END IF;
                EXIT;
              END LOOP;
              IF NOT FOUND THEN
                IF parentRef IS NOT NULL THEN
		  --ftheeten 2018 04 29 
	          IF referenced_relation ='taxonomy' THEN
			--ftheeten 2018 04 29 
			EXECUTE 'INSERT INTO taxonomy (id,name,level_ref,parent_ref, metadata_ref , import_ref) ' ||
				  'VALUES(DEFAULT,$1,$2,$3, $4, $5) ' ||
				  'RETURNING *;'
			  INTO recCatalogue
			  USING staging_catalogue_line.name,staging_catalogue_line.level_ref,parentRef, taxonomy_ref, req_import_ref;
	          ELSE
			  EXECUTE 'INSERT INTO ' || quote_ident(referenced_relation) || '(id,name,level_ref,parent_ref) ' ||
				  'VALUES(DEFAULT,$1,$2,$3) ' ||
				  'RETURNING *;'
			  INTO recCatalogue
			  USING staging_catalogue_line.name,staging_catalogue_line.level_ref,parentRef;
		  END IF;--ftheeten 2018 04 29 
                -- tell to update the staging line to set the catalogue_ref with the id found
                ELSE
                  SELECT level_name INTO level_naming FROM catalogue_levels WHERE id = staging_catalogue_line.level_ref;
                  RAISE EXCEPTION 'Could not import this file, % (level %) does not exist in DaRWIN and cannot be attached, correct your file or create this % manually', staging_catalogue_line.name,  level_naming, quote_ident(referenced_relation);
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
        -- update the staging line to set the catalogue_ref with the id found
        -- update the staging children lines
        WITH staging_catalogue_updated(updated_id/*, catalogue_ref_updated*/) AS (
          UPDATE staging_catalogue as sc
          SET catalogue_ref = recCatalogue.id
          WHERE sc.import_ref = staging_catalogue_line.import_ref
                AND sc.name = staging_catalogue_line.name
                AND sc.level_ref = staging_catalogue_line.level_ref
          RETURNING id
        )
        UPDATE staging_catalogue as msc
        SET parent_ref = recCatalogue.id,
          parent_updated = TRUE
        WHERE msc.import_ref = staging_catalogue_line.import_ref
              AND msc.parent_ref IN (
          SELECT updated_id FROM staging_catalogue_updated
        )
              AND parent_updated = FALSE;
      END IF;
      children_move_forward := FALSE;
    END LOOP;
    RETURN TRUE;
    EXCEPTION WHEN OTHERS THEN
    IF SQLERRM = 'This record does not follow the level hierarchy' THEN
      SELECT level_name INTO level_naming FROM catalogue_levels WHERE id = staging_catalogue_line.level_ref;
      RAISE EXCEPTION E'Could not import this file, % (level %) does not follow the accepted level hierarchy in DaRWIN an cannot be attached nor created.\nPlease correct your file.\nStaging Catalogue Line: %', staging_catalogue_line.name,  level_naming, staging_catalogue_line.id;
    ELSE
      RAISE EXCEPTION '%', SQLERRM;
    END IF;
  END;
  $_$;


ALTER FUNCTION darwin2.fct_importer_catalogue_backup_pad(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1906 (class 1255 OID 5308249)
-- Name: fct_importer_catalogue_reference_taxonomy(integer, integer, text, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
  DECLARE
	returned BOOLEAN;
	check_duplicates_hierarchies RECORD;
	duplicate_hierarchies_msg varchar;

  BEGIN	
  raise notice 'test';
	IF referenced_relation= 'taxonomy' THEN
		raise notice '0';
		
		PERFORM fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref, true, false, not exclude_invalid_entries);
		SELECT fct_importer_catalogue_reference_taxonomy_logic_reference INTO returned FROM  fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref , var_metadata_ref ,  exclude_invalid_entries );
	ELSE
		SELECT fct_importer_catalogue_reference_taxonomy_rmca_non_taxo INTO returned  FROM fct_importer_catalogue_reference_taxonomy_rmca_non_taxo(req_import_ref , var_metadata_ref , referenced_relation , exclude_invalid_entries );
	END IF;

	 RETURN returned;
  END;
  $$;


ALTER FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1918 (class 1255 OID 5308248)
-- Name: fct_importer_catalogue_reference_taxonomy_logic(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
  DECLARE
	returned boolean;
	i integer;
	array_levels integer[];
	current_level integer;
	current_names RECORD;
	
	--taxo_path varchar[];
	reference_kingdom int;
	recCatalogue RECORD;
	line_created boolean;
	existing_taxon integer;
	taxon_to_copy integer;
	parent_to_update integer;

	name_parent varchar;
	--updated_id integer;
	is_updated boolean;


  BEGIN	
	PERFORM setval('taxonomy_id_seq', (SELECT MAX(id)+1 FROM taxonomy ), false);
	returned :=FALSE;

	SELECT taxonomy_kingdom INTO reference_kingdom FROM imports where id=req_import_ref LIMIT 1;
	SELECT  array_agg(distinct level_ref order by level_ref) INTO array_levels FROM  staging_catalogue WHERE  import_ref=req_import_ref ;


	FOR i in 1..ARRAY_LENGTH(array_levels, 1)
	LOOP
		current_level := array_levels[i];
		RAISE NOTICE '%', current_level;
		FOR  current_names in SELECT DISTINCT min(id) as min_id, min(parent_ref) as min_parent_ref, name,  fulltoindex(name,FALSE) as name_indexed FROM  staging_catalogue WHERE  import_ref=req_import_ref and level_ref = current_level --AND catalogue_ref IS NULL --AND parent_updated=false 
		GROUP BY name ORDER BY name_indexed
		LOOP
			line_created:=FALSE;
			raise notice '%', current_names.name;
			--SELECT fct_rmca_taxo_staging_path_in_reference INTO taxo_path FROM fct_rmca_taxo_staging_path_in_reference(current_names.min_id);
			--raise notice '%', taxo_path;
			IF exclude_invalid_entries =FALSE THEN
				SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.is_reference_taxonomy = TRUE and name_indexed=current_names.name_indexed and level_ref=current_level;
			ELSE
				SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.is_reference_taxonomy = TRUE and name_indexed=current_names.name_indexed and level_ref=current_level  AND status != 'invalid' ;
			END IF;
			IF existing_taxon IS NULL THEN
				--create higher of taxonomy
				IF current_level = 4 AND i=1 THEN 
					--raise notice 'init';
					parent_to_update:=reference_kingdom;
				ELSE
					SELECT parent_updated into is_updated FROM staging_catalogue WHERE id=current_names.min_id;
					--raise notice 'min parent ref %',current_names.min_parent_ref;
					IF is_updated IS TRUE THEN
						--raise notice 'found updated';
						parent_to_update:=current_names.min_parent_ref;
					ELSE
						SELECT catalogue_ref, name INTO parent_to_update, name_parent FROM staging_catalogue WHERE id=current_names.min_parent_ref;
					END IF;
					--parent_to_update:=current_names.min_parent_ref;
				END IF;
				--raise notice 'parent_to_update %',parent_to_update;
				IF parent_to_update IS NOT NULL THEN
					EXECUTE 'INSERT INTO taxonomy  (id,name,level_ref,parent_ref, metadata_ref, import_ref) ' ||
						  'VALUES(DEFAULT,$1,$2,$3,$4,$5) ' ||
						  'RETURNING *;'
						INTO recCatalogue
						USING current_names.name,current_level , parent_to_update , var_metadata_ref, req_import_ref;
					line_created:=TRUE;
						  --2019 02 10
						UPDATE staging_catalogue set imported =true WHERE id=current_names.min_id;


				END IF;	
				--in principle we'll be never in this case as the previosu row of the same staging record shoudl have created the taxonomy			
				
			ELSE
				
				taxon_to_copy:=existing_taxon;
				line_created:=TRUE;

				
				
			END IF;
			IF line_created=TRUE THEN
				--raise notice 'taxon_to_copy %',taxon_to_copy;
				--raise notice 'UPDATE staging';
				WITH staging_catalogue_updated(updated_id) AS (
				  UPDATE staging_catalogue as sc
				  SET catalogue_ref = taxon_to_copy
				  WHERE sc.import_ref = req_import_ref
					AND sc.name = current_names.name
					AND sc.level_ref = current_level
				  RETURNING id
				)
				UPDATE staging_catalogue as msc
				SET parent_ref = taxon_to_copy,
				  parent_updated = TRUE
				WHERE msc.import_ref = req_import_ref
				      AND msc.parent_ref IN (
				  SELECT updated_id FROM staging_catalogue_updated
				)
				      AND parent_updated = FALSE;
			      END IF;

		END LOOP;
	END LOOP;

	returned =TRUE;
	 RETURN returned;
  END;
  $_$;


ALTER FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1935 (class 1255 OID 5309216)
-- Name: fct_importer_catalogue_reference_taxonomy_logic_reference(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
  DECLARE
	returned boolean;
	i integer;
	array_levels integer[];
	current_level integer;
	current_names RECORD;
	
	--taxo_path varchar[];
	reference_kingdom int;
	recCatalogue RECORD;
	line_created boolean;
	existing_taxon integer;
	taxon_to_copy integer;
	parent_to_update integer;

	name_parent varchar;
	--updated_id integer;
	is_updated boolean;


  BEGIN	
	PERFORM setval('taxonomy_id_seq', (SELECT MAX(id)+1 FROM taxonomy ), false);
	returned :=FALSE;

	SELECT taxonomy_kingdom INTO reference_kingdom FROM imports where id=req_import_ref LIMIT 1;
	SELECT  array_agg(distinct level_ref order by level_ref) INTO array_levels FROM  staging_catalogue WHERE  import_ref=req_import_ref ;


	FOR i in 1..ARRAY_LENGTH(array_levels, 1)
	LOOP
		current_level := array_levels[i];
		RAISE NOTICE '%', current_level;
		FOR  current_names in SELECT DISTINCT min(id) as min_id, min(parent_ref) as min_parent_ref, name,  fulltoindex(name,FALSE) as name_indexed FROM  staging_catalogue WHERE  import_ref=req_import_ref and level_ref = current_level AND name_cluster IN (select distinct s2.name_cluster FROM staging_catalogue s2 WHERE s2.import_exception= 'taxon_to_be_created' AND s2.import_ref=req_import_ref) --AND catalogue_ref IS NULL --AND parent_updated=false 
		GROUP BY name ORDER BY name_indexed
		LOOP
			line_created:=FALSE;
			raise notice 'NAME TO IMPORT %', current_names.name;
			--SELECT fct_rmca_taxo_staging_path_in_reference INTO taxo_path FROM fct_rmca_taxo_staging_path_in_reference(current_names.min_id);
			--raise notice '%', taxo_path;
			IF exclude_invalid_entries =FALSE THEN
			RAISE NOTICE 'INVALID_INCLUDED';
				SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.is_reference_taxonomy = TRUE and name_indexed=current_names.name_indexed and level_ref=current_level;
			ELSE
			RAISE NOTICE 'EXCLUDE_INVALID';
				SELECT taxonomy.id INTO existing_taxon FROM taxonomy INNER JOIN taxonomy_metadata ON metadata_ref=taxonomy_metadata.id WHERE  taxonomy_metadata.is_reference_taxonomy = TRUE and name_indexed=current_names.name_indexed and level_ref=current_level  AND status != 'invalid' ;
			END IF;
			IF existing_taxon IS NULL THEN
				RAISE NOTICE 'CREATE';
				--create higher of taxonomy
				IF current_level = 4 AND i=1 THEN 
					--raise notice 'init';
					parent_to_update:=reference_kingdom;
				ELSE
					SELECT parent_updated into is_updated FROM staging_catalogue WHERE id=current_names.min_id;
					--raise notice 'min parent ref %',current_names.min_parent_ref;
					IF is_updated IS TRUE THEN
						--raise notice 'found updated';
						parent_to_update:=current_names.min_parent_ref;
					ELSE
						SELECT catalogue_ref, name INTO parent_to_update, name_parent FROM staging_catalogue WHERE id=current_names.min_parent_ref;
					END IF;
					--parent_to_update:=current_names.min_parent_ref;
				END IF;
				raise notice 'parent_to_update %',parent_to_update;
				IF parent_to_update IS NOT NULL THEN
					EXECUTE 'INSERT INTO taxonomy  (id,name,level_ref,parent_ref, metadata_ref, import_ref) ' ||
						  'VALUES(DEFAULT,$1,$2,$3,$4,$5) ' ||
						  'RETURNING *;'
						INTO recCatalogue
						USING current_names.name,current_level , parent_to_update , var_metadata_ref, req_import_ref;
					line_created:=TRUE;
						  --2019 02 10
						UPDATE staging_catalogue set imported =true , import_exception='imported_taxon' WHERE id=current_names.min_id;

				ELSE
					UPDATE staging_catalogue set imported =false , import_exception='taxon_to_be_created_without_suitable_parent' WHERE id=current_names.min_id;
				END IF;	
				--in principle we'll be never in this case as the previosu row of the same staging record shoudl have created the taxonomy			
				
			ELSE
				RAISE NOTICE 'EXISTS';
				taxon_to_copy:=existing_taxon;
				line_created:=TRUE;

				
				
			END IF;
			IF line_created=TRUE THEN
				--raise notice 'taxon_to_copy %',taxon_to_copy;
				--raise notice 'UPDATE staging';
				WITH staging_catalogue_updated(updated_id) AS (
				  UPDATE staging_catalogue as sc
				  SET catalogue_ref = taxon_to_copy
				  WHERE sc.import_ref = req_import_ref
					AND sc.name = current_names.name
					AND sc.level_ref = current_level
				  RETURNING id
				)
				UPDATE staging_catalogue as msc
				SET parent_ref = taxon_to_copy,
				  parent_updated = TRUE
				WHERE msc.import_ref = req_import_ref
				      AND msc.parent_ref IN (
				  SELECT updated_id FROM staging_catalogue_updated
				)
				      AND parent_updated = FALSE;
			      END IF;

		END LOOP;
	END LOOP;

	returned =TRUE;
	 RETURN returned;
  END;
  $_$;


ALTER FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1907 (class 1255 OID 5308246)
-- Name: fct_importer_catalogue_reference_taxonomy_rmca_non_taxo(integer, integer, text, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_rmca_non_taxo(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    staging_catalogue_line staging_catalogue;
    where_clause_complement_1 text := ' ';
    where_clause_complement_2 text := ' ';
    where_clause_complement_3 text := ' ';
    where_clause_complement_3_bis text := ' ';
    where_clause_complement_4 text := ' ';
    where_clause_complement_5 text := ' ';
    where_clause_exclude_invalid text := ' ';
    recCatalogue RECORD;
    id_existing_taxon integer;
    existing_text_hierarchy varchar;
    staging_text_hierarchy varchar;
    parent_path template_classifications.path%TYPE;
    parentRef staging_catalogue.parent_ref%TYPE;
    parent_level catalogue_levels.id%TYPE;
    catalogueRef staging_catalogue.catalogue_ref%TYPE;
    levelRef staging_catalogue.level_ref%TYPE;
    error_msg TEXT := '';
    children_move_forward BOOLEAN := FALSE;
    level_naming TEXT;
    tempSQL TEXT;
    check_duplicates_hierarchies RECORD;
    duplicate_hierarchies_msg varchar;


  BEGIN

    FOR staging_catalogue_line IN SELECT * from staging_catalogue WHERE import_ref = req_import_ref ORDER BY level_ref, fullToIndex(name)
    LOOP
	
      IF trim(touniquestr(staging_catalogue_line.name)) = '' THEN
        RAISE EXCEPTION E'Case 0, Could not import this file, % is not a valid name.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
      END IF;
      SELECT parent_ref, catalogue_ref, level_ref INTO parentRef, catalogueRef, levelRef FROM staging_catalogue WHERE id = staging_catalogue_line.id;
      --raise notice 'lie id % assign parentRef % found if %', staging_catalogue_line.id, parentRef, (SELECT parent_ref FROM staging_catalogue WHERE id = staging_catalogue_line.id) ;
      IF catalogueRef IS NULL THEN
        -- Check if we're at a top taxonomic entry in the template/staging_catalogue line
        IF parentRef IS NULL THEN
          -- If top entry, we have not parent defined and we therefore have no other filtering criteria
          where_clause_complement_1 := ' ';
          where_clause_complement_2 := ' ';
          where_clause_complement_3 := ' ';
          where_clause_complement_3_bis := ' ';
        ELSE
          -- If a child entry, we've got to use the informations from the already matched or created parent
          where_clause_complement_1 := '  AND tax.parent_ref = ' || parentRef || ' ';
          where_clause_complement_2 := '  AND tax.parent_ref != ' || parentRef || ' ';
          -- Select the path from parent catalogue unit
          EXECUTE 'SELECT path, level_ref FROM ' || quote_ident(referenced_relation) || ' WHERE id = $1'
          INTO parent_path, parent_level
          USING parentRef;
          where_clause_complement_3 := '  AND position (' || quote_literal(parent_path) || ' IN tax.path) = 1 ';
          where_clause_complement_3_bis := '  AND (select t2.level_ref from ' || quote_ident(referenced_relation) || ' as t2 where t2.id = tax.parent_ref) > ' || parent_level || ' ';
        END IF;
        where_clause_complement_4 := '  AND left(substring(tax.name from length(trim(' ||
                                     quote_literal(staging_catalogue_line.name) || '))+1),1) IN (' ||
                                     quote_literal(' ') || ', ' || quote_literal(',') || ') ';
        where_clause_complement_5 := '  AND left(substring(' || quote_literal(staging_catalogue_line.name) ||
                                     ' from length(trim(tax.name))+1),1) IN (' ||
                                     quote_literal(' ') || ', ' || quote_literal(',') || ') ';
        -- Set the invalid where clause if asked
        IF exclude_invalid_entries = TRUE THEN
          where_clause_exclude_invalid := '  AND tax.status != ' || quote_literal('invalid') || ' ';
        END IF;
        -- Check a perfect match entry
        -- Take care here, a limit 1 has been set, we only kept the EXIT in case the limit would be accidently removed
        FOR recCatalogue IN EXECUTE 'SELECT COUNT(id) OVER () as total_count, * ' ||
                                    'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                                    'WHERE tax.level_ref = $1 ' ||
                                    '  AND tax.name_indexed = fullToIndex( $2 ) ' ||
                                    where_clause_exclude_invalid ||
                                    where_clause_complement_1 ||
                                    'LIMIT 1;'
        USING staging_catalogue_line.level_ref, staging_catalogue_line.name
        LOOP
          -- If more than one entry found, we set an error...
          IF recCatalogue.total_count > 1 THEN
            --RAISE notice E'Case 1, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
          END IF;
          EXIT;
        END LOOP;
        -- No perfect match occured with the same parent (if it applies - doesn't apply for top taxonomic entry in template)
        IF NOT FOUND THEN
          -- For this step, as it depends upon the existence of a parent, we test well we are on that case
          -- It concerns a perfect match with parents differents but with a path common
          -- That means, if only one entry exists, that they are the same but with a more detailed hierarchy in the
          -- already existing entry
          IF parentRef IS NOT NULL THEN
            FOR recCatalogue IN EXECUTE 'SELECT COUNT(id) OVER () as total_count, * ' ||
                                        'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                                        'WHERE tax.level_ref = $1 ' ||
                                        '  AND tax.name_indexed = fullToIndex( $2 ) ' ||
                                        where_clause_exclude_invalid ||
                                        where_clause_complement_2 ||
                                        where_clause_complement_3 ||
                                        where_clause_complement_3_bis ||
                                        'LIMIT 1;'
            USING staging_catalogue_line.level_ref, staging_catalogue_line.name
            LOOP
              -- If for this kind of perfect match with different parent but kind of same path start, we get multiple
              -- possibilities, then fail
              IF recCatalogue.total_count > 1 THEN
                RAISE EXCEPTION E'Case 2, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
              END IF;
              EXIT;
            END LOOP;
            -- If it gave no result, we've got to move forward and try the next option
            IF NOT FOUND THEN
              children_move_forward := TRUE;
            END IF;
          END IF;
          IF parentRef IS NULL OR children_move_forward = TRUE THEN
            -- This next option try a fuzzy match, with, if it's a child entry in the template, a verification that
            -- the parent specified in the template and the path of the potential corresponding entry in catalogue
            -- have a common path...
            --RAISE NOTICE 'FOUND 1';
            tempSQL := 'SELECT COUNT(id) OVER () as total_count, * ' ||
                       'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                       'WHERE tax.level_ref = $1 ' ||
                       '  AND tax.name_indexed LIKE fullToIndex( $2 ) || ' || quote_literal('%') ||
                       where_clause_exclude_invalid ||
                       where_clause_complement_3 ||
                       where_clause_complement_4;
            IF parentRef IS NOT NULL THEN
              tempSQL := tempSQL || where_clause_complement_1;
            END IF;
            tempSQL := tempSQL || 'LIMIT 1;';
            FOR recCatalogue IN EXECUTE tempSQL
            USING staging_catalogue_line.level_ref, staging_catalogue_line.name
            LOOP
              -- If we're on the case of a top entry in the template, we cannot afford the problem of multiple entries
              IF recCatalogue.total_count > 1 THEN
                RAISE EXCEPTION E'Case 3, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
              END IF;
              EXIT;
            END LOOP;
            -- Last chance is to try to find if the entry in DaRWIN shouldn't be completed
            -- This entry should be "alone" of its kind - check the NOT EXIST clause
            IF NOT FOUND THEN
           -- RAISE NOTICE 'FOUND 2';
              FOR recCatalogue IN EXECUTE 'SELECT COUNT(id) OVER () as total_count, * ' ||
                                          'FROM ' || quote_ident(referenced_relation) || ' as tax ' ||
                                          'WHERE tax.level_ref = $1 ' ||
                                          '  AND position(tax.name_indexed IN fullToIndex( $2 )) = 1 ' ||
                                          where_clause_exclude_invalid ||
                                          '  AND NOT EXISTS (SELECT 1 ' ||
                                          '                  FROM ' || quote_ident(referenced_relation) || ' as stax ' ||
                                          '                  WHERE stax.id != tax.id ' ||
                                          '                  AND stax.level_ref = tax.level_ref ' ||
                                          '                  AND stax.path = tax.path ' ||
                                          '                  AND stax.name_indexed LIKE tax.name_indexed || ' || quote_literal('%') ||
                                          '                  LIMIT 1 ' ||
                                          '                 ) ' ||
                                          where_clause_complement_3 ||
                                          where_clause_complement_5 ||
                                          'LIMIT 1;'
              USING staging_catalogue_line.level_ref, staging_catalogue_line.name
              LOOP
                IF recCatalogue.total_count > 1 THEN
                  RAISE EXCEPTION E'Case 4, Could not import this file, % exists more than 1 time in DaRWIN, correct the catalogue (or file) to import this tree.\nStaging Catalogue Line: %', staging_catalogue_line.name, staging_catalogue_line.id;
                ELSE
                --raise notice 'upd 4';
                  -- If only one entry is found, we can replace the name of this entry
                  EXECUTE 'UPDATE ' || quote_ident(referenced_relation) || ' ' ||
                          'SET name = ' || quote_literal(staging_catalogue_line.name) || ' ' ||
                          'WHERE id = ' || recCatalogue.id || ';';
                END IF;
                EXIT;
              END LOOP;
              IF NOT FOUND THEN
               --raise notice 'not found';
              -- raise notice 'parentRef %', parentRef;
                IF parentRef IS NOT NULL THEN
               -- raise notice 'test';
		  IF LOWER(referenced_relation) = 'taxonomy' THEN
			--ftheeten 2018 04 15
			PERFORM * FROM taxonomy WHERE (name_indexed=fulltoindex(staging_catalogue_line.name) 
						OR (fct_rmca_taxonomy_split_name_author(name, level_ref))[1]=(fct_rmca_taxonomy_split_name_author(staging_catalogue_line.name, staging_catalogue_line.level_ref))[1])
								AND
										level_ref = staging_catalogue_line.level_ref 
										AND is_reference_taxonomy =TRUE;
			IF NOT FOUND THEN
				raise notice 'insert %', staging_catalogue_line.name;
				EXECUTE 'INSERT INTO ' || quote_ident(referenced_relation) || '(id,name,level_ref,parent_ref, metadata_ref, import_ref) ' ||
		 			  'VALUES(DEFAULT,$1,$2,$3,$4,$5) ' ||
					  'RETURNING *;'
				  INTO recCatalogue
				  USING staging_catalogue_line.name,staging_catalogue_line.level_ref,parentRef, var_metadata_ref, req_import_ref;
				 --2019 02 10
				UPDATE staging_catalogue set imported =true WHERE id=staging_catalogue_line.id;
			ELSE
				raise notice 'insert %', staging_catalogue_line.name;
				
				--compare existing hierarchy with hierarchy in staging
				--ftheeten 2018 06 05
				SELECT id, fct_rmca_sort_taxon_path_alphabetically(path||id) INTO id_existing_taxon , existing_text_hierarchy FROM taxonomy WHERE (name_indexed=fulltoindex(staging_catalogue_line.name) 
						OR (fct_rmca_taxonomy_split_name_author(name, level_ref))[1]=(fct_rmca_taxonomy_split_name_author(staging_catalogue_line.name, staging_catalogue_line.level_ref))[1])
								AND
										level_ref = staging_catalogue_line.level_ref 
										AND is_reference_taxonomy =TRUE LIMIT 1;
				SELECT  fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue_line.id) INTO staging_text_hierarchy;
				RAISE NOTICE E'Hierarchy in staging\t % (line %)', staging_text_hierarchy, staging_catalogue_line.id;
				RAISE NOTICE E'Hierarchy in Darwin \t %',existing_text_hierarchy;
				raise notice 'parent= %', parentRef;
				IF  staging_text_hierarchy != existing_text_hierarchy THEN
					RAISE EXCEPTION E'CASE 7  Could not import this file, % (level %) may already exists in DaRWIN with a different hierarchy and cannot be attached, please check  or create this % manually (line staging %, apparent parent %) \r\n Hierarchy in staging\t % \r\nHierarchy in Darwin\t %\r\n ', 

staging_catalogue_line.name,  
level_naming, 
quote_ident(referenced_relation), 
staging_catalogue_line.id, 
staging_catalogue_line.parent_ref,
staging_text_hierarchy, 
existing_text_hierarchy ;
				ELSE
					raise notice 'hierarchy exists (possibily overlapping with Paul-André code)';
					recCatalogue.id:=id_existing_taxon;
				END IF;
			END IF;	  
		     ELSE
			  EXECUTE 'INSERT INTO ' || quote_ident(referenced_relation) || '(id,name,level_ref,parent_ref) ' ||
				  'VALUES(DEFAULT,$1,$2,$3) ' ||
				  'RETURNING *;'
			  INTO recCatalogue
			  USING staging_catalogue_line.name,staging_catalogue_line.level_ref,parentRef;
			  --2019 02 10
			  UPDATE staging_catalogue set imported =true WHERE id=staging_catalogue_line.id;
			-- tell to update the staging line to set the catalogue_ref with the id found
	           END IF;
                ELSE
                  SELECT level_name INTO level_naming FROM catalogue_levels WHERE id = staging_catalogue_line.level_ref;
                  RAISE EXCEPTION 'CASE 6 Could not import this file, % (level %) does not exist in DaRWIN and cannot be attached, correct your file or create this % manually (line staging %, apparent parent %) ', staging_catalogue_line.name,  level_naming, quote_ident(referenced_relation), staging_catalogue_line.id, staging_catalogue_line.parent_ref;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
        -- update the staging line to set the catalogue_ref with the id found
        -- update the staging children lines
        IF recCatalogue.id is NULL then
		RAISe exception 'Problem for % (line %)', staging_catalogue_line.name, recCatalogue.id ;
	end if;
        WITH staging_catalogue_updated(updated_id/*, catalogue_ref_updated*/) AS (
          UPDATE staging_catalogue as sc
          SET catalogue_ref = recCatalogue.id
          WHERE sc.import_ref = staging_catalogue_line.import_ref
                AND sc.name = staging_catalogue_line.name
                AND sc.level_ref = staging_catalogue_line.level_ref
          RETURNING id
        )
        UPDATE staging_catalogue as msc
        SET parent_ref = recCatalogue.id,
          parent_updated = TRUE
        WHERE msc.import_ref = staging_catalogue_line.import_ref
              AND msc.parent_ref IN (
          SELECT updated_id FROM staging_catalogue_updated
        )
              AND parent_updated = FALSE;
      END IF;
      children_move_forward := FALSE;
    END LOOP;
    RETURN TRUE;
    /*EXCEPTION WHEN OTHERS THEN
    IF SQLERRM = 'This record does not follow the level hierarchy' THEN
      SELECT level_name INTO level_naming FROM catalogue_levels WHERE id = staging_catalogue_line.level_ref;
      RAISE EXCEPTION E'Could not import this file, % (level %) does not follow the accepted level hierarchy in DaRWIN an cannot be attached nor created.\nPlease correct your file.\nStaging Catalogue Line: %', staging_catalogue_line.name,  level_naming, staging_catalogue_line.id;
      
    ELSE
      RAISE EXCEPTION 'exception %', SQLERRM;
    END IF;*/
  END;
  $_$;


ALTER FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_rmca_non_taxo(req_import_ref integer, var_metadata_ref integer, referenced_relation text, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1791 (class 1255 OID 4816416)
-- Name: fct_informative_reset_last_flag(); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_informative_reset_last_flag() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE informative_workflow
    SET is_last = true
    WHERE referenced_relation = OLD.referenced_relation
      AND record_id = OLD.record_id
      AND id = (select id from informative_workflow
        WHERE referenced_relation = OLD.referenced_relation AND record_id = OLD.record_id ORDER BY modification_date_time desc LIMIT 1)
    ;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_informative_reset_last_flag() OWNER TO cebmpad;

--
-- TOC entry 1897 (class 1255 OID 4816417)
-- Name: fct_listing_botany(integer, integer[]); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_listing_botany(nbr_records integer, VARIADIC taxon_ids integer[]) RETURNS TABLE(referenced_by_at_least_one_specimen integer, domain text, kingdom text, super_phylum text, phylum text, sub_phylum text, infra_phylum text, super_cohort_botany text, cohort_botany text, sub_cohort_botany text, infra_cohort_botany text, super_class text, class text, sub_class text, infra_class text, super_division text, division text, sub_division text, infra_division text, super_legion text, legion text, sub_legion text, infra_legion text, super_order text, "order" text, sub_order text, infra_order text, super_family text, family text, sub_family text, infra_family text, super_tribe text, tribe text, sub_tribe text, infra_tribe text, genus text, sub_genus text, section_botany text, sub_section_botany text, serie text, sub_serie text, super_species text, species text, sub_species text, variety text, sub_variety text, form text, sub_form text, abberans text)
    LANGUAGE sql
    AS $_$
  SELECT "referenced_by_at_least_one_specimen","domain","kingdom","super_phylum","phylum","sub_phylum","infra_phylum","super_cohort_botany","cohort_botany","sub_cohort_botany","infra_cohort_botany","super_class","class","sub_class","infra_class","super_division","division","sub_division","infra_division","super_legion","legion","sub_legion","infra_legion","super_order","order","sub_order","infra_order","super_family","family","sub_family","infra_family","super_tribe","tribe","sub_tribe","infra_tribe","genus","sub_genus","section_botany","sub_section_botany","serie","sub_serie","super_species","species","sub_species","variety","sub_variety","form","sub_form","abberans" from fct_listing_taxonomy($1, variadic $2);
$_$;


ALTER FUNCTION darwin2.fct_listing_botany(nbr_records integer, VARIADIC taxon_ids integer[]) OWNER TO cebmpad;

--
-- TOC entry 1793 (class 1255 OID 4816418)
-- Name: fct_listing_chronostratigraphy(integer, integer[]); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_listing_chronostratigraphy(nbr_records integer, VARIADIC chrono_unit_ids integer[]) RETURNS TABLE(referenced_by_at_least_one_specimen integer, eon text, era text, sub_era text, system text, serie text, stage text, sub_stage text, sub_level_1 text, sub_level_2 text)
    LANGUAGE plpgsql
    AS $$
  DECLARE
    select_sql_part TEXT; -- Variable dedicated to store the select part of sql
    from_sql_part TEXT;
    where_sql_part TEXT;  -- Variable dedicated to store the where part of sql - this part being dynamically constructed
    where_first_list_of_ids TEXT; -- Will store the list of chrono_unit ids as string with comma as separation delimiter
    where_second_sql TEXT; -- Will store the second part of the where clause dynamically constructed
    order_by_sql_part TEXT;
    limit_sql_part TEXT DEFAULT '';
    chrono_unit_id INTEGER;
    recChronostratigraphic_levels RECORD;
  BEGIN
    -- First, test that there's at least one chrono_unit to search the hierarchy from
    IF array_length(chrono_unit_ids, 1) > 0 THEN
      -- Compose the list of chrono_unit ids as comma separated string
      where_first_list_of_ids := array_to_string(chrono_unit_ids, ',');
      -- Loop through these chrono_unit ids to compose the second part of the sql where clause
      FOREACH chrono_unit_id IN ARRAY chrono_unit_ids LOOP
        where_second_sql := 'or strpos	(chronos.path, (select ssschronos.path || ssschronos.id
                                                    from chronostratigraphy ssschronos
                                                    where ssschronos.id = ' || chrono_unit_id || '
                                                   )
                                        ) != 0 ';
        where_sql_part := COALESCE(where_sql_part, '') || where_second_sql;
      END LOOP;
      where_sql_part := 'where chronos.id in (select sschronos.id
                                          from chronostratigraphy sschronos
                                          where sschronos.id in (' || where_first_list_of_ids || ')
                                         ) ' ||  where_sql_part;
      select_sql_part := 'select distinct on ((chronos.path || chronos.id), chronos.level_ref)
                          case
                            when specimens.id is null then 0
                            else 1
                          end as "referenced_by_at_least_one_specimen", ';
      -- Browse all chronostratigraphic levels and for each of them, include a select clause
      FOR recChronostratigraphic_levels IN SELECT id, level_sys_name FROM catalogue_levels WHERE level_type = 'chronostratigraphy' ORDER BY level_order, id LOOP
        select_sql_part := select_sql_part ||
                           '(select subchronos.name
                             from chronostratigraphy as subchronos inner join (select unnest(string_to_array(substring(chronos.path || chronos.id from 2), ' || CHR(39) || CHR(47) || CHR(39) || ')) as id) as chronosids
                             on subchronos.id = chronosids.id::integer
                             where chronosids.id != ' || CHR(39) || CHR(39) || '
                               and subchronos.level_ref = ' || recChronostratigraphic_levels.id || '
                            )::text as "' || recChronostratigraphic_levels.level_sys_name || '" ,';
      END LOOP;
      select_sql_part := substring(select_sql_part for (length(select_sql_part) - 1));
      from_sql_part := 'from chronostratigraphy as chronos left join specimens on chronos.id = specimens.chrono_ref ';
      order_by_sql_part := 'order by (chronos.path || chronos.id), chronos.level_ref ';
      -- Get a limit part only if set
      IF nbr_records IS NOT NULL AND nbr_records != 0 THEN
        limit_sql_part := 'limit ' || nbr_records;
      END IF;
    END IF;
    RETURN QUERY EXECUTE select_sql_part || from_sql_part || where_sql_part || order_by_sql_part || limit_sql_part;
  EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error is %', SQLERRM;
    RETURN;
  END;
$$;


ALTER FUNCTION darwin2.fct_listing_chronostratigraphy(nbr_records integer, VARIADIC chrono_unit_ids integer[]) OWNER TO cebmpad;

--
-- TOC entry 1794 (class 1255 OID 4816419)
-- Name: fct_listing_lithology(integer, integer[]); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_listing_lithology(nbr_records integer, VARIADIC litholo_unit_ids integer[]) RETURNS TABLE(referenced_by_at_least_one_specimen integer, unit_main_group text, unit_group text, unit_sub_group text, unit_rock text, unit_main_class text, unit_class text, unit_clan text, unit_category text)
    LANGUAGE plpgsql
    AS $$
  DECLARE
    select_sql_part TEXT; -- Variable dedicated to store the select part of sql
    from_sql_part TEXT;
    where_sql_part TEXT;  -- Variable dedicated to store the where part of sql - this part being dynamically constructed
    where_first_list_of_ids TEXT; -- Will store the list of litholo_unit ids as string with comma as separation delimiter
    where_second_sql TEXT; -- Will store the second part of the where clause dynamically constructed
    order_by_sql_part TEXT;
    limit_sql_part TEXT DEFAULT '';
    litholo_unit_id INTEGER;
    reclithologic_levels RECORD;
  BEGIN
    -- First, test that there's at least one litholo_unit to search the hierarchy from
    IF array_length(litholo_unit_ids, 1) > 0 THEN
      -- Compose the list of litholo_unit ids as comma separated string
      where_first_list_of_ids := array_to_string(litholo_unit_ids, ',');
      -- Loop through these litholo_unit ids to compose the second part of the sql where clause
      FOREACH litholo_unit_id IN ARRAY litholo_unit_ids LOOP
        where_second_sql := 'or strpos	(litholos.path, (select ssslitholos.path || ssslitholos.id
                                                    from lithology ssslitholos
                                                    where ssslitholos.id = ' || litholo_unit_id || '
                                                   )
                                        ) != 0 ';
        where_sql_part := COALESCE(where_sql_part, '') || where_second_sql;
      END LOOP;
      where_sql_part := 'where litholos.id in (select sslitholos.id
                                          from lithology sslitholos
                                          where sslitholos.id in (' || where_first_list_of_ids || ')
                                         ) ' ||  where_sql_part;
      select_sql_part := 'select distinct on ((litholos.path || litholos.id), litholos.level_ref)
                          case
                            when specimens.id is null then 0
                            else 1
                          end as "referenced_by_at_least_one_specimen", ';
      -- Browse all lithologic levels and for each of them, include a select clause
      FOR reclithologic_levels IN SELECT id, level_sys_name FROM catalogue_levels WHERE level_type = 'lithology' ORDER BY level_order, id LOOP
        select_sql_part := select_sql_part ||
                           '(select sublitholos.name
                             from lithology as sublitholos inner join (select unnest(string_to_array(substring(litholos.path || litholos.id from 2), ' || CHR(39) || CHR(47) || CHR(39) || ')) as id) as litholosids
                             on sublitholos.id = litholosids.id::integer
                             where litholosids.id != ' || CHR(39) || CHR(39) || '
                               and sublitholos.level_ref = ' || reclithologic_levels.id || '
                            )::text as "' || reclithologic_levels.level_sys_name || '" ,';
      END LOOP;
      select_sql_part := substring(select_sql_part for (length(select_sql_part) - 1));
      from_sql_part := 'from lithology as litholos left join specimens on litholos.id = specimens.lithology_ref ';
      order_by_sql_part := 'order by (litholos.path || litholos.id), litholos.level_ref ';
      -- Get a limit part only if set
      IF nbr_records IS NOT NULL AND nbr_records != 0 THEN
        limit_sql_part := 'limit ' || nbr_records;
      END IF;
    END IF;
    RETURN QUERY EXECUTE select_sql_part || from_sql_part || where_sql_part || order_by_sql_part || limit_sql_part;
  EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error is %', SQLERRM;
    RETURN;
  END;
$$;


ALTER FUNCTION darwin2.fct_listing_lithology(nbr_records integer, VARIADIC litholo_unit_ids integer[]) OWNER TO cebmpad;

--
-- TOC entry 1795 (class 1255 OID 4816420)
-- Name: fct_listing_lithostratigraphy(integer, integer[]); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_listing_lithostratigraphy(nbr_records integer, VARIADIC litho_unit_ids integer[]) RETURNS TABLE(referenced_by_at_least_one_specimen integer, supergroup text, "group" text, formation text, member text, layer text, sub_level_1 text, sub_level_2 text)
    LANGUAGE plpgsql
    AS $$
  DECLARE
    select_sql_part TEXT; -- Variable dedicated to store the select part of sql
    from_sql_part TEXT;
    where_sql_part TEXT;  -- Variable dedicated to store the where part of sql - this part being dynamically constructed
    where_first_list_of_ids TEXT; -- Will store the list of litho_unit ids as string with comma as separation delimiter
    where_second_sql TEXT; -- Will store the second part of the where clause dynamically constructed
    order_by_sql_part TEXT;
    limit_sql_part TEXT DEFAULT '';
    litho_unit_id INTEGER;
    reclithostratigraphic_levels RECORD;
  BEGIN
    -- First, test that there's at least one litho_unit to search the hierarchy from
    IF array_length(litho_unit_ids, 1) > 0 THEN
      -- Compose the list of litho_unit ids as comma separated string
      where_first_list_of_ids := array_to_string(litho_unit_ids, ',');
      -- Loop through these litho_unit ids to compose the second part of the sql where clause
      FOREACH litho_unit_id IN ARRAY litho_unit_ids LOOP
        where_second_sql := 'or strpos	(lithos.path, (select ssslithos.path || ssslithos.id
                                                    from lithostratigraphy ssslithos
                                                    where ssslithos.id = ' || litho_unit_id || '
                                                   )
                                        ) != 0 ';
        where_sql_part := COALESCE(where_sql_part, '') || where_second_sql;
      END LOOP;
      where_sql_part := 'where lithos.id in (select sslithos.id
                                          from lithostratigraphy sslithos
                                          where sslithos.id in (' || where_first_list_of_ids || ')
                                         ) ' ||  where_sql_part;
      select_sql_part := 'select distinct on ((lithos.path || lithos.id), lithos.level_ref)
                          case
                            when specimens.id is null then 0
                            else 1
                          end as "referenced_by_at_least_one_specimen", ';
      -- Browse all lithostratigraphic levels and for each of them, include a select clause
      FOR reclithostratigraphic_levels IN SELECT id, level_sys_name FROM catalogue_levels WHERE level_type = 'lithostratigraphy' ORDER BY level_order, id LOOP
        select_sql_part := select_sql_part ||
                           '(select sublithos.name
                             from lithostratigraphy as sublithos inner join (select unnest(string_to_array(substring(lithos.path || lithos.id from 2), ' || CHR(39) || CHR(47) || CHR(39) || ')) as id) as lithosids
                             on sublithos.id = lithosids.id::integer
                             where lithosids.id != ' || CHR(39) || CHR(39) || '
                               and sublithos.level_ref = ' || reclithostratigraphic_levels.id || '
                            )::text as "' || reclithostratigraphic_levels.level_sys_name || '" ,';
      END LOOP;
      select_sql_part := substring(select_sql_part for (length(select_sql_part) - 1));
      from_sql_part := 'from lithostratigraphy as lithos left join specimens on lithos.id = specimens.litho_ref ';
      order_by_sql_part := 'order by (lithos.path || lithos.id), lithos.level_ref ';
      -- Get a limit part only if set
      IF nbr_records IS NOT NULL AND nbr_records != 0 THEN
        limit_sql_part := 'limit ' || nbr_records;
      END IF;
    END IF;
    RETURN QUERY EXECUTE select_sql_part || from_sql_part || where_sql_part || order_by_sql_part || limit_sql_part;
  EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error is %', SQLERRM;
    RETURN;
  END;
$$;


ALTER FUNCTION darwin2.fct_listing_lithostratigraphy(nbr_records integer, VARIADIC litho_unit_ids integer[]) OWNER TO cebmpad;

--
-- TOC entry 1796 (class 1255 OID 4816421)
-- Name: fct_listing_mineralogy(integer, integer[]); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_listing_mineralogy(nbr_records integer, VARIADIC mineralo_unit_ids integer[]) RETURNS TABLE(referenced_by_at_least_one_specimen integer, unit_class text, unit_sub_class text, unit_series text, unit_variety text)
    LANGUAGE plpgsql
    AS $$
  DECLARE
    select_sql_part TEXT; -- Variable dedicated to store the select part of sql
    from_sql_part TEXT;
    where_sql_part TEXT;  -- Variable dedicated to store the where part of sql - this part being dynamically constructed
    where_first_list_of_ids TEXT; -- Will store the list of mineralo_unit ids as string with comma as separation delimiter
    where_second_sql TEXT; -- Will store the second part of the where clause dynamically constructed
    order_by_sql_part TEXT;
    limit_sql_part TEXT DEFAULT '';
    mineralo_unit_id INTEGER;
    recmineralogic_levels RECORD;
  BEGIN
    -- First, test that there's at least one mineralo_unit to search the hierarchy from
    IF array_length(mineralo_unit_ids, 1) > 0 THEN
      -- Compose the list of mineralo_unit ids as comma separated string
      where_first_list_of_ids := array_to_string(mineralo_unit_ids, ',');
      -- Loop through these mineralo_unit ids to compose the second part of the sql where clause
      FOREACH mineralo_unit_id IN ARRAY mineralo_unit_ids LOOP
        where_second_sql := 'or strpos	(mineralos.path, (select sssmineralos.path || sssmineralos.id
                                                    from mineralogy sssmineralos
                                                    where sssmineralos.id = ' || mineralo_unit_id || '
                                                   )
                                        ) != 0 ';
        where_sql_part := COALESCE(where_sql_part, '') || where_second_sql;
      END LOOP;
      where_sql_part := 'where mineralos.id in (select ssmineralos.id
                                          from mineralogy ssmineralos
                                          where ssmineralos.id in (' || where_first_list_of_ids || ')
                                         ) ' ||  where_sql_part;
      select_sql_part := 'select distinct on ((mineralos.path || mineralos.id), mineralos.level_ref)
                          case
                            when specimens.id is null then 0
                            else 1
                          end as "referenced_by_at_least_one_specimen", ';
      -- Browse all mineralogic levels and for each of them, include a select clause
      FOR recmineralogic_levels IN SELECT id, level_sys_name FROM catalogue_levels WHERE level_type = 'mineralogy' ORDER BY level_order, id LOOP
        select_sql_part := select_sql_part ||
                           '(select submineralos.name
                             from mineralogy as submineralos inner join (select unnest(string_to_array(substring(mineralos.path || mineralos.id from 2), ' || CHR(39) || CHR(47) || CHR(39) || ')) as id) as mineralosids
                             on submineralos.id = mineralosids.id::integer
                             where mineralosids.id != ' || CHR(39) || CHR(39) || '
                               and submineralos.level_ref = ' || recmineralogic_levels.id || '
                            )::text as "' || recmineralogic_levels.level_sys_name || '" ,';
      END LOOP;
      select_sql_part := substring(select_sql_part for (length(select_sql_part) - 1));
      from_sql_part := 'from mineralogy as mineralos left join specimens on mineralos.id = specimens.mineral_ref ';
      order_by_sql_part := 'order by (mineralos.path || mineralos.id), mineralos.level_ref ';
      -- Get a limit part only if set
      IF nbr_records IS NOT NULL AND nbr_records != 0 THEN
        limit_sql_part := 'limit ' || nbr_records;
      END IF;
    END IF;
    RETURN QUERY EXECUTE select_sql_part || from_sql_part || where_sql_part || order_by_sql_part || limit_sql_part;
  EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error is %', SQLERRM;
    RETURN;
  END;
$$;


ALTER FUNCTION darwin2.fct_listing_mineralogy(nbr_records integer, VARIADIC mineralo_unit_ids integer[]) OWNER TO cebmpad;

--
-- TOC entry 1790 (class 1255 OID 4816422)
-- Name: fct_listing_taxonomy(integer, integer[]); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_listing_taxonomy(nbr_records integer, VARIADIC taxon_ids integer[]) RETURNS TABLE(referenced_by_at_least_one_specimen integer, domain text, kingdom text, super_phylum text, phylum text, sub_phylum text, infra_phylum text, super_cohort_botany text, cohort_botany text, sub_cohort_botany text, infra_cohort_botany text, super_class text, class text, sub_class text, infra_class text, super_division text, division text, sub_division text, infra_division text, super_legion text, legion text, sub_legion text, infra_legion text, super_cohort_zoology text, cohort_zoology text, sub_cohort_zoology text, infra_cohort_zoology text, super_order text, "order" text, sub_order text, infra_order text, section_zoology text, sub_section_zoology text, super_family text, family text, sub_family text, infra_family text, super_tribe text, tribe text, sub_tribe text, infra_tribe text, genus text, sub_genus text, section_botany text, sub_section_botany text, serie text, sub_serie text, super_species text, species text, sub_species text, variety text, sub_variety text, form text, sub_form text, abberans text)
    LANGUAGE plpgsql
    AS $$
  DECLARE
    select_sql_part TEXT; -- Variable dedicated to store the select part of sql
    from_sql_part TEXT;
    where_sql_part TEXT;  -- Variable dedicated to store the where part of sql - this part being dynamically constructed
    where_first_list_of_ids TEXT; -- Will store the list of taxon ids as string with comma as separation delimiter
    where_second_sql TEXT; -- Will store the second part of the where clause dynamically constructed
    order_by_sql_part TEXT;
    limit_sql_part TEXT DEFAULT '';
    taxon_id INTEGER;
    recTaxonomic_levels RECORD;
  BEGIN
    -- First, test that there's at least one taxon to search the hierarchy from
    IF array_length(taxon_ids, 1) > 0 THEN
      -- Compose the list of taxon ids as comma separated string
      where_first_list_of_ids := array_to_string(taxon_ids, ',');
      -- Loop through these taxon ids to compose the second part of the sql where clause
      FOREACH taxon_id IN ARRAY taxon_ids LOOP
        where_second_sql := 'or strpos	(tax.path, (select ssstax.path || ssstax.id
                                                    from taxonomy ssstax
                                                    where ssstax.id = ' || taxon_id || '
                                                   )
                                        ) != 0 ';
        where_sql_part := COALESCE(where_sql_part, '') || where_second_sql;
      END LOOP;
      where_sql_part := 'where tax.id in (select sstax.id
                                          from taxonomy sstax
                                          where sstax.id in (' || where_first_list_of_ids || ')
                                         ) ' ||  where_sql_part;
      select_sql_part := 'select distinct on ((tax.path || tax.id), tax.level_ref)
                          case
                            when specimens.id is null then 0
                            else 1
                          end as "referenced_by_at_least_one_specimen", ';
      -- Browse all taxonomic levels and for each of them, include a select clause
      FOR recTaxonomic_levels IN SELECT id, level_sys_name FROM catalogue_levels WHERE level_type = 'taxonomy' ORDER BY level_order, id LOOP
        select_sql_part := select_sql_part ||
                           '(select subtax.name
                             from taxonomy as subtax inner join (select unnest(string_to_array(substring(tax.path || tax.id from 2), ' || CHR(39) || CHR(47) || CHR(39) || ')) as id) as taxids
                             on subtax.id = taxids.id::integer
                             where taxids.id != ' || CHR(39) || CHR(39) || '
                               and subtax.level_ref = ' || recTaxonomic_levels.id || '
                            )::text as "' || recTaxonomic_levels.level_sys_name || '" ,';
      END LOOP;
      select_sql_part := substring(select_sql_part for (length(select_sql_part) - 1));
      from_sql_part := 'from taxonomy as tax left join specimens on tax.id = specimens.taxon_ref ';
      order_by_sql_part := 'order by (tax.path || tax.id), tax.level_ref ';
      -- Get a limit part only if set
      IF nbr_records IS NOT NULL AND nbr_records != 0 THEN
        limit_sql_part := 'limit ' || nbr_records;
      END IF;
    END IF;
    RETURN QUERY EXECUTE select_sql_part || from_sql_part || where_sql_part || order_by_sql_part || limit_sql_part;
  EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error is %', SQLERRM;
    RETURN;
  END;
$$;


ALTER FUNCTION darwin2.fct_listing_taxonomy(nbr_records integer, VARIADIC taxon_ids integer[]) OWNER TO cebmpad;

--
-- TOC entry 1800 (class 1255 OID 4816425)
-- Name: fct_listing_zoology(integer, integer[]); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_listing_zoology(nbr_records integer, VARIADIC taxon_ids integer[]) RETURNS TABLE(referenced_by_at_least_one_specimen integer, domain text, kingdom text, super_phylum text, phylum text, sub_phylum text, infra_phylum text, super_class text, class text, sub_class text, infra_class text, super_division text, division text, sub_division text, infra_division text, super_legion text, legion text, sub_legion text, infra_legion text, super_cohort_zoology text, cohort_zoology text, sub_cohort_zoology text, infra_cohort_zoology text, super_order text, "order" text, sub_order text, infra_order text, section_zoology text, sub_section_zoology text, super_family text, family text, sub_family text, infra_family text, super_tribe text, tribe text, sub_tribe text, infra_tribe text, genus text, sub_genus text, serie text, sub_serie text, super_species text, species text, sub_species text, variety text, sub_variety text, form text, sub_form text, abberans text)
    LANGUAGE sql
    AS $_$
  SELECT "referenced_by_at_least_one_specimen","domain","kingdom","super_phylum","phylum","sub_phylum","infra_phylum","super_class","class","sub_class","infra_class","super_division","division","sub_division","infra_division","super_legion","legion","sub_legion","infra_legion","super_cohort_zoology","cohort_zoology","sub_cohort_zoology","infra_cohort_zoology","super_order","order","sub_order","infra_order","section_zoology","sub_section_zoology","super_family","family","sub_family","infra_family","super_tribe","tribe","sub_tribe","infra_tribe","genus","sub_genus","serie","sub_serie","super_species","species","sub_species","variety","sub_variety","form","sub_form","abberans" from fct_listing_taxonomy($1, variadic $2);
$_$;


ALTER FUNCTION darwin2.fct_listing_zoology(nbr_records integer, VARIADIC taxon_ids integer[]) OWNER TO cebmpad;

--
-- TOC entry 1797 (class 1255 OID 4816426)
-- Name: fct_look_for_institution(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_look_for_institution(fullname text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_record integer :=0;
  result_nbr integer;

BEGIN
    result_nbr := 0;
    FOR ref_record IN SELECT id from people p
      WHERE is_physical = false  AND
      ( formated_name_indexed like fulltoindex(fullname) || '%' OR fulltoindex(additional_names) =  fulltoindex(fullname) )
      LIMIT 2
    LOOP
      result_nbr := result_nbr +1;
    END LOOP;

    IF result_nbr = 1 THEN -- It's Ok!
      return ref_record;
    END IF;

    IF result_nbr >= 2 THEN
      return -1 ;-- To Much
      continue;
    END IF;
  RETURN 0;
END;
$$;


ALTER FUNCTION darwin2.fct_look_for_institution(fullname text) OWNER TO darwin2;

--
-- TOC entry 1798 (class 1255 OID 4816427)
-- Name: fct_look_for_people(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_look_for_people(fullname text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  ref_record integer :=0;
  result_nbr integer;
  searched_name text;
BEGIN
    result_nbr := 0;
    searched_name := fulltoindex(fullname)|| '%'  ;
    FOR ref_record IN SELECT id from people p
      WHERE
        formated_name_indexed like searched_name
        OR  name_formated_indexed like searched_name LIMIT 2
    LOOP
      result_nbr := result_nbr +1;
    END LOOP;

    IF result_nbr = 1 THEN -- It's Ok!
      return ref_record;
    END IF;

    IF result_nbr >= 2 THEN
      return -1 ;-- To Much
     --ftheeten continue shouldn'y be there
      -- continue;
    END IF;
  RETURN 0;
END;
$$;


ALTER FUNCTION darwin2.fct_look_for_people(fullname text) OWNER TO darwin2;

--
-- TOC entry 1799 (class 1255 OID 4816428)
-- Name: fct_mask_date(timestamp without time zone, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_mask_date(date_fld timestamp without time zone, mask_fld integer) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$

  SELECT
CASE WHEN ($2 & 32)!=0 THEN date_part('year',$1)::text ELSE 'xxxx' END || '-' ||
CASE WHEN ($2 & 16)!=0 THEN date_part('month',$1)::text ELSE 'xx' END || '-' ||
CASE WHEN ($2 & 8)!=0 THEN date_part('day',$1)::text ELSE 'xx' END;
$_$;


ALTER FUNCTION darwin2.fct_mask_date(date_fld timestamp without time zone, mask_fld integer) OWNER TO darwin2;

--
-- TOC entry 1801 (class 1255 OID 4816429)
-- Name: fct_nbr_in_relation(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_nbr_in_relation() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  nbr integer = 0 ;
BEGIN
  SELECT count(record_id_2) INTO nbr FROM catalogue_relationships WHERE
      relationship_type = NEW.relationship_type
      AND record_id_1 = NEW.record_id_1
      AND referenced_relation = NEW.referenced_relation;

  IF NEW.relationship_type = 'current_name' THEN
    IF TG_OP = 'INSERT' THEN
      IF nbr > 0 THEN
	RAISE EXCEPTION 'Maximum number of renamed item reach';
      END IF;
    ELSE
      IF nbr > 1 THEN
	RAISE EXCEPTION 'Maximum number of renamed item reach';
      END IF;
    END IF;
  ELSEIF NEW.relationship_type = 'recombined from' THEN
    IF TG_OP = 'INSERT' THEN
      IF nbr > 1 THEN
	RAISE EXCEPTION 'Maximum number of recombined item reach';
      END IF;
    ELSE
      IF nbr > 2 THEN
	RAISE EXCEPTION 'Maximum number of recombined item reach';
      END IF;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_nbr_in_relation() OWNER TO darwin2;

--
-- TOC entry 1802 (class 1255 OID 4816430)
-- Name: fct_nbr_in_synonym(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_nbr_in_synonym() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  nbr integer = 0 ;
BEGIN

  SELECT count(id) INTO nbr FROM classification_synonymies WHERE
      referenced_relation = NEW.referenced_relation
      AND record_id = NEW.record_id
      AND group_name = NEW.group_name;

  IF TG_OP = 'INSERT' THEN
    IF nbr > 1 THEN
      RAISE EXCEPTION 'You can ''t set this synonym twice!';
    END IF;
  ELSE
--     RAISE info 'nbr %', nbr;
    IF nbr > 2 THEN
      RAISE EXCEPTION 'You can ''t set this synonym twice!';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_nbr_in_synonym() OWNER TO darwin2;

--
-- TOC entry 1803 (class 1255 OID 4816431)
-- Name: fct_remove_array_elem(anyarray, anyarray); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_array_elem(in_array anyarray, elem anyarray, OUT out_array anyarray) RETURNS anyarray
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	SELECT array(select s FROM fct_explode_array (in_array)  as s WHERE NOT elem @> ARRAY[s]) INTO out_array;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_array_elem(in_array anyarray, elem anyarray, OUT out_array anyarray) OWNER TO darwin2;

--
-- TOC entry 1804 (class 1255 OID 4816432)
-- Name: fct_remove_array_elem(anyarray, anyelement); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_array_elem(in_array anyarray, elem anyelement, OUT out_array anyarray) RETURNS anyarray
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	SELECT array(select s FROM fct_explode_array (in_array)  as s WHERE s != elem) INTO out_array;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_array_elem(in_array anyarray, elem anyelement, OUT out_array anyarray) OWNER TO darwin2;

--
-- TOC entry 1805 (class 1255 OID 4816433)
-- Name: fct_remove_last_flag(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_last_flag() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE informative_workflow
    SET is_last = false
    WHERE referenced_relation = NEW.referenced_relation
      AND record_id = NEW.record_id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_last_flag() OWNER TO darwin2;

--
-- TOC entry 1806 (class 1255 OID 4816434)
-- Name: fct_remove_last_flag_loan(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_last_flag_loan() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE loan_status
    SET is_last = false
    WHERE loan_ref = NEW.loan_ref;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_last_flag_loan() OWNER TO darwin2;

--
-- TOC entry 1925 (class 1255 OID 5308995)
-- Name: fct_remove_null_array_elem(anyarray); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_remove_null_array_elem(in_array anyarray, OUT out_array anyarray) RETURNS anyarray
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	SELECT array(select s FROM fct_explode_array (in_array)  as s WHERE  s is not null) INTO out_array;
END;
$$;


ALTER FUNCTION darwin2.fct_remove_null_array_elem(in_array anyarray, OUT out_array anyarray) OWNER TO darwin2;

--
-- TOC entry 1807 (class 1255 OID 4816435)
-- Name: fct_report_loans_addresses(integer, text); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_report_loans_addresses(loan_id integer, target_copy text) RETURNS TABLE(people_name text, institution_name text, address text)
    LANGUAGE sql
    AS $_$
  with
  people_infos as
  (
    select regexp_replace(p.formated_name, '\s+', ' ', 'g') as formated_name,
          regexp_replace(pp.formated_name, '\s+', ' ', 'g') as institution_name,
          case
          when (ppa.entry is not null
                AND trim(ppa.entry) != ''
                AND ppa.locality is not null
                AND trim(ppa.locality) != ''
                AND ppa.country is not null
                AND trim(ppa.country) != ''
          ) then
            ppa.entry ||
            case when (ppa.po_box is not null AND trim(ppa.po_box) != '') then
              ', ' || ppa.po_box
            else
              ''
            end ||
            case when (ppa.extended_address is not null AND trim(ppa.extended_address) != '') then
              E'\n' || ppa.extended_address
            else
              ''
            end ||
            case when (ppa.zip_code is not null AND trim(ppa.zip_code) != '') then
              E'\n' || ppa.zip_code || ' ' || ppa.locality ||
              case when (ppa.region is not null and trim(ppa.region) != '') then
                ' - ' || ppa.region
              else
                ''
              end
            else
              E'\n' || ppa.locality ||
              case when (ppa.region is not null and trim(ppa.region) != '') then
                ' - ' || ppa.region
              else
                ''
              end
            end ||
            E'\n' || ppa.country
          when (pa.entry is not null
                     AND trim(pa.entry) != ''
                     AND pa.locality is not null
                     AND trim(pa.locality) != ''
                     AND pa.country is not null
                     AND trim(pa.country) != ''
          ) then
            pa.entry ||
            case when (pa.po_box is not null AND trim(pa.po_box) != '') then
              ', ' || pa.po_box
            else
              ''
            end ||
            case when (pa.extended_address is not null AND trim(pa.extended_address) != '') then
              E'\n' || pa.extended_address
            else
              ''
            end ||
            case when (pa.zip_code is not null AND trim(pa.zip_code) != '') then
              E'\n' || pa.zip_code || ' ' || pa.locality ||
              case when (pa.region is not null and trim(pa.region) != '') then
                ' - ' || pa.region
              else
                ''
              end
            else
              E'\n' || pa.locality ||
              case when (pa.region is not null and trim(pa.region) != '') then
                ' - ' || pa.region
              else
                ''
              end
            end ||
            E'\n' || pa.country
          else
            null
          end::text as address
    from catalogue_people cp inner join people p on cp.people_ref = p.id
                             left join people_addresses pa on p.id = pa.person_user_ref and strpos(pa.tag, 'work') > 0
                             left join (
                                        people_relationships pr
                                        inner join
                                        people pp on pr.person_1_ref = pp.id and NOT pp.is_physical
                                        inner join people_addresses ppa on pp.id = ppa.person_user_ref
                                       ) on pr.person_2_ref = p.id and pr.relationship_type IN ('works for', 'belongs to')
    where referenced_relation = 'loans'
      and record_id = $1
      and people_type = 'receiver'
      and case when $2 IN ('Responsible copy', 'Copie responsable', 'Verantwoordelijk copie') then
            people_sub_type::integer&2 != 0
          else
            people_sub_type::integer&4 != 0
          end
      and p.is_physical
    order by order_by,(strpos(pa.tag, 'work') > 0),pr.activity_date_from desc
  ),
  institution_address as
  (
    select p.formated_name::text as name,
          case when (pa.entry is not null
                     AND trim(pa.entry) != ''
                     AND pa.locality is not null
                     AND trim(pa.locality) != ''
                     AND pa.country is not null
                     AND trim(pa.country) != ''
                    ) then
              pa.entry ||
              case when (pa.po_box is not null AND trim(pa.po_box) != '') then
                  ', ' || pa.po_box
              else
                  ''
              end ||
              case when (pa.extended_address is not null AND trim(pa.extended_address) != '') then
                  E'\n' || pa.extended_address
              else
                  ''
              end ||
              case when (pa.zip_code is not null AND trim(pa.zip_code) != '') then
                  E'\n' || pa.zip_code || ' ' || pa.locality ||
                  case when (pa.region is not null and trim(pa.region) != '') then
                    ' - ' || pa.region
                  else
                    ''
                  end
              else
                  E'\n' || pa.locality ||
                  case when (pa.region is not null and trim(pa.region) != '') then
                  ' - ' || pa.region
                  else
                  ''
                  end
              end ||
              E'\n' || pa.country
          else
              null
          end as address
    from catalogue_people cp inner join people p on cp.people_ref = p.id
                             left join people_addresses pa on p.id = pa.person_user_ref
    where referenced_relation = 'loans'
      and record_id = $1
      and people_type = 'receiver'
      and case when $2 IN ('Responsible copy', 'Copie responsable', 'Verantwoordelijk copie') then
            people_sub_type::integer&2 != 0
          else
            people_sub_type::integer&4 != 0
          end
      and NOT p.is_physical
    order by order_by
    limit 1
  )
  select
    array_to_string(array(select distinct on (formated_name) formated_name from people_infos),', ') as people_name,
    coalesce(
        (select name from institution_address),
        (select institution_name from people_infos where institution_name is not null limit 1)
    ) as institution_name,
    coalesce(
        (select address from institution_address),
        (select address from people_infos where address is not null limit 1)
    ) as address
$_$;


ALTER FUNCTION darwin2.fct_report_loans_addresses(loan_id integer, target_copy text) OWNER TO cebmpad;

--
-- TOC entry 1808 (class 1255 OID 4816436)
-- Name: fct_report_loans_forms(integer, text, text, text, text, boolean, text); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_report_loans_forms(loan_id integer, full_target_list text, short_target_list text, selected_target_list text, targeted_catalogues text, with_addr boolean DEFAULT false, lang text DEFAULT 'en'::text) RETURNS TABLE(target_copy text, loan_id integer, loan_name character varying, loan_description character varying, loan_purposes text, loan_conditions text, loan_reception_conditions text, loan_return_conditions text, loan_from_date text, loan_to_date text, loan_extended_to_date text, loan_receiver_name text, loan_receiver_institution_name text, loan_receiver_address text, loan_items_id text, loan_items_name character varying, loan_items_description text, loan_items_value numeric, loan_phantom_id text, loan_rbins_phantom_id text)
    LANGUAGE sql
    AS $_$
select vals.val as target_copy,
       loans.id,
       loans.name,
       loans.description,
       (select array_to_string(array_agg(comment), E'\n') from comments where referenced_relation = 'loans' and record_id = $1 and notion_concerned = 'usage') as loan_purposes,
       (select array_to_string(array_agg(comment), E'\n') from comments where referenced_relation = 'loans' and record_id = $1 and notion_concerned = 'state_observation') as loan_conditions,
       (select array_to_string(array_agg(comment), E'\n') from comments where referenced_relation = 'loans' and record_id = $1 and notion_concerned = 'reception_state_observation') as loan_reception_conditions,
       (select array_to_string(array_agg(comment), E'\n') from comments where referenced_relation = 'loans' and record_id = $1 and notion_concerned = 'return_state_observation') as loan_return_conditions,
       to_char(loans.from_date,'DD/MM/YYYY'),
       to_char(loans.to_date,'DD/MM/YYYY'),
       to_char(loans.extended_to_date,'DD/MM/YYYY'),
       case
        when $6 then
          (select people_name from fct_report_loans_addresses($1,vals.val))::text
        else
          ''::text
       end as loan_receiver_name,
       case
        when $6 then
          (select institution_name from fct_report_loans_addresses($1,vals.val))
        else
          ''::text
       end as loan_receiver_institution_name,
       case
        when $6 then
          (select address from fct_report_loans_addresses($1,vals.val))
        else
          ''::text
       end as loan_receiver_address,
       case
        when specimen_ref is null then
          coalesce (
              (
                select
                  case
                    when $7 = 'fr' then
                      'Codes temporaires: '
                    when $7 = 'nl' then
                      'Tijdelijke codes: '
                    else
                      'Temporary codes: '
                  end
                  ||
                  trim(
                       array_to_string(
                           array_agg(
                                       case
                                       when coalesce(code_prefix,'') != '' then
                                         code_prefix || coalesce(code_prefix_separator,'')
                                       else
                                         ''
                                       end ||
                                       coalesce(code,'') ||
                                       case
                                       when coalesce(code_suffix,'') != '' then
                                         coalesce(code_suffix_separator,'') || code_suffix
                                       else
                                         ''
                                       end
                                     ),
                           ', '
                       ),
                       ', '
                  )
                from codes
                where referenced_relation = 'loan_items'
                      and record_id = loan_items.id
                      and code_category = 'main'
                limit 3
              ), '')
        else
          'RBINS ID: ' || specimens.id  ||
          coalesce (
          (
            select E'\nCodes: ' || trim(array_to_string(array_agg(
              case
                when coalesce(code_prefix,'') != '' then
                  code_prefix || coalesce(code_prefix_separator,'')
                else
                  ''
              end ||
              coalesce(code,'') ||
              case
              when coalesce(code_suffix,'') != '' then
                coalesce(code_suffix_separator,'') || code_suffix
              else
                ''
              end
            ), ', '), ', ')
            from codes
            where referenced_relation = 'specimens'
              and record_id = specimens.id
              and code_category = 'main'
            limit 3
          ), '')
       end as loan_items_id,
       case
        when loan_items.specimen_ref is null then
          loan_items.details
        else
           trim(
             CASE
             WHEN 'taxonomy' = ANY (string_to_array(trim($5, '[]'), ', ')) AND coalesce(taxon_name, '') != ''
               THEN
                 taxon_name || E'\n'
             ELSE
               E'\n'
             END ||
             CASE
             WHEN 'chronostratigraphy' = ANY (string_to_array(trim($5, '[]'), ', ')) AND coalesce(chrono_name, '') != ''
               THEN
                 chrono_name || E'\n'
             ELSE
               E'\n'
             END ||
             CASE
             WHEN 'lithostratigraphy' = ANY (string_to_array(trim($5, '[]'), ', ')) AND coalesce(litho_name, '') != ''
               THEN
                 litho_name || E'\n'
             ELSE
               E'\n'
             END ||
             CASE
             WHEN 'lithology' = ANY (string_to_array(trim($5, '[]'), ', ')) AND coalesce(lithology_name, '') != ''
               THEN
                 lithology_name || E'\n'
             ELSE
               E'\n'
             END ||
             CASE
             WHEN 'mineralogy' = ANY (string_to_array(trim($5, '[]'), ', ')) AND coalesce(mineral_name, '') != ''
               THEN
                 mineral_name || E'\n'
             ELSE
               E'\n'
             END
           ,E'\n')
        end::text as loan_items_name,
        coalesce
        (
           (
             select trim(array_to_string(array_agg(comment), E'\n'), E'\n')
             from comments
             where referenced_relation = 'loan_items'
               and record_id = loan_items.id
               and notion_concerned = 'description'
             limit 3
           )
          ,
           (
             select trim(array_to_string(array_agg(comment), E'\n'), E'\n')
             from comments
             where referenced_relation = 'specimens'
                   and record_id = loan_items.specimen_ref
                   and notion_concerned = 'description'
             limit 3
           )
        ) as loan_items_description,
        coalesce
       (
            (
              select insurance_value
              from insurances
              where referenced_relation = 'loan_items'
                and record_id = loan_items.id
                and insurance_currency = '€'
                order by date_to desc
              limit 1
            )
          ,
            (
              select insurance_value
              from insurances
              where referenced_relation = 'specimens'
                    and record_id = loan_items.specimen_ref
                    and insurance_currency = '€'
              order by date_to desc
              limit 1
            )
        ) as loan_items_value,
       case
        when vals.val IN ('RBINS copy', 'Copie RBINS', 'RBINS copie') then
         loan_items.id::text
        else
         trim(coalesce(to_char(loans.from_date,'YY/MM-'),'') || loans.name || '-' || row_number() over (PARTITION BY vals.val ORDER BY vals.val_index, loans.id, loan_items.id))
       end as loan_phantom_id,
       case
        when vals.val IN ('RBINS copy', 'Copie RBINS', 'RBINS copie') then
          case
            when $7 = 'fr' then
              'ID item prêté: '
            when $7 = 'nl' then
              'ID geleend item: '
            else
              'Loan item ID: '
          end
          ||  loan_items.id || E'\n' ||
          case
            when $7 = 'fr' then
              'ID Fantôme: '
            else
              'Phantom ID: '
          end
          || trim(coalesce(to_char(loans.from_date,'YY/MM-'),'') || loans.name || '-' || row_number() over (PARTITION BY vals.val ORDER BY vals.val_index, loans.id, loan_items.id))
        else
          null::text
       end as loan_rbins_phantom_id
from ( select unnest(array_vals.val) as val, generate_series(1,array_vals.val_index) as val_index
       from (select case when exists ( select 1
                                       from catalogue_people
                                       where referenced_relation = 'loans'
                                         and record_id = $1
                                         and people_type = 'receiver'
                                         and people_sub_type::integer&2 != 0
                                       limit 1
                                     ) then
                      string_to_array(trim($2,'[]'), ', ')
                    else
                      string_to_array(trim($3,'[]'), ', ')
                    end as val,
                    case when exists ( select 1
                                       from catalogue_people
                                       where referenced_relation = 'loans'
                                         and record_id = $1
                                         and people_type = 'receiver'
                                         and people_sub_type::integer&2 != 0
                                       limit 1
                                     ) then
                      array_length(string_to_array(trim($2,'[]'), ', '),1)
                    else
                      array_length(string_to_array(trim($3,'[]'), ', '),1)
                    end as val_index
            ) as array_vals
     ) as vals,
loans
inner join loan_items on loans.id = loan_items.loan_ref
left join specimens on loan_items.specimen_ref = specimens.id
where loans.id = $1
  and exists(select 1
             from catalogue_people
             where referenced_relation = 'loans'
               and record_id = $1
               and people_type = 'receiver'
               and people_sub_type::integer&4 != 0
             limit 1
            )
  and vals.val IN ( select unnest(string_to_array(trim($4,'[]'), ', ')) )
order by vals.val_index,loans.id,row_number() over (PARTITION BY vals.val ORDER BY vals.val_index, loans.id, loan_items.id);
$_$;


ALTER FUNCTION darwin2.fct_report_loans_forms(loan_id integer, full_target_list text, short_target_list text, selected_target_list text, targeted_catalogues text, with_addr boolean, lang text) OWNER TO cebmpad;

--
-- TOC entry 1810 (class 1255 OID 4816439)
-- Name: fct_report_loans_maintenances(integer, text); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_report_loans_maintenances(loan_id integer, maintenance_type text) RETURNS TABLE(maintenance_date text, maintenance_people text, maintenance_people_functions text)
    LANGUAGE sql
    AS $_$
    with maintenance_people as (
        SELECT
          DISTINCT ON (maintenance_date, formated_name)
          CASE
          WHEN modification_date_time IN ('0001-01-01' :: TIMESTAMP, '2038-12-31' :: TIMESTAMP)
            THEN
              NULL
          ELSE
            TO_CHAR(modification_date_time, 'DD/MM/YYYY')
          END::TEXT                                      AS maintenance_date,
          regexp_replace(formated_name, '\s+', ' ', 'g') AS formated_name,
          case
            when person_user_role = '' then
              '*'
            else
              person_user_role
          end::text AS people_function
        FROM
          collection_maintenance
          INNER JOIN people
            ON collection_maintenance.people_ref = people.id
          LEFT JOIN people_relationships pr
            ON people.id = pr.person_2_ref
               AND pr.relationship_type IN ('works for', 'belongs to')
        WHERE collection_maintenance.referenced_relation = 'loans'
          AND collection_maintenance.record_id = $1
          AND collection_maintenance.action_observation = $2
        ORDER BY
          maintenance_date DESC,
          formated_name,
          pr.activity_date_to DESC,
          pr.activity_date_from DESC,
          case when person_user_role = '' then 'zzz' else person_user_role end::TEXT
    )
    select distinct on (maintenance_date)
      maintenance_date,
      trim(array_to_string(array_agg(formated_name) OVER (PARTITION BY maintenance_date), ', '), ', ') as maintenance_people,
      case
        when trim(array_to_string(array_agg(people_function) OVER (PARTITION BY maintenance_date), ', '), ', ') = '*' then
          null
        else
          trim(array_to_string(array_agg(people_function) OVER (PARTITION BY maintenance_date), ', '), ', ')
      end as maintenance_people
    from maintenance_people
    order by maintenance_date desc;
  $_$;


ALTER FUNCTION darwin2.fct_report_loans_maintenances(loan_id integer, maintenance_type text) OWNER TO cebmpad;

--
-- TOC entry 1811 (class 1255 OID 4816440)
-- Name: fct_report_loans_return_to(integer, text); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_report_loans_return_to(loan_id integer, lang text DEFAULT 'en'::text) RETURNS TABLE(return_message text)
    LANGUAGE sql
    AS $_$
  with communications as
  (
      select entry, comm_type, tag
      from collection_maintenance
        inner join people on collection_maintenance.people_ref = people.id
        inner join people_comm on people.id = people_comm.person_user_ref
      where referenced_relation = 'loans'
            and record_id = $1
            and action_observation = 'approval'
            and strpos(tag, 'work') > 0
  )
  select
    case
      when $2 = 'fr' then
        'Veuillez retourner une copie de ce formulaire par FAX au '
      when $2 = 'nl' then
        'Stuur een kopie van dit formulier per fax naar '
      else
        'Return a copy of this form by FAX at '
    end ||
    coalesce((select trim(array_to_string(array_agg(entry), ', '), ', ') from communications where comm_type = 'phone/fax' and strpos(tag, 'fax') > 0), '+32(0)2.627.41.13.') ||
    coalesce((select
                case
                  when $2 = 'fr' then
                    E'\nou par email à '
                  when $2 = 'nl' then
                    E'\nof bij email naar '
                  else
                    E'\nor by email at '
                end
                || trim(array_to_string(array_agg(entry), ', '), ', ') from communications where comm_type = 'e-mail'
             ), ''
            ) as return_message
  $_$;


ALTER FUNCTION darwin2.fct_report_loans_return_to(loan_id integer, lang text) OWNER TO cebmpad;

--
-- TOC entry 1812 (class 1255 OID 4816441)
-- Name: fct_report_loans_transporters(integer, text, text); Type: FUNCTION; Schema: darwin2; Owner: cebmpad
--

CREATE FUNCTION darwin2.fct_report_loans_transporters(loan_id integer, transporter_side text DEFAULT 'sender'::text, lang text DEFAULT 'en'::text) RETURNS TABLE(transport_dispatched_by text, transport_transporter_names text, transport_track_ids text)
    LANGUAGE sql
    AS $_$
    with
    transporters as (
        select
          case
          when cp.people_type = 'sender' then
            case
              when $3 = 'fr' then
                'prêteur'
              when $3 = 'nl' then
                'lener'
              else
                'loaner'
            end
          else
            case
              when $3 = 'fr' then
                'emprunteur'
              when $3 = 'nl' then
                'lener'
              else
                'borrower'
            end
          end as transport_dispatched_by,
          p.formated_name as transport_transporter_name
        from loans inner join catalogue_people cp
                   on cp.referenced_relation = 'loans'
                      and cp.record_id = loans.id
                      and cp.people_type IN ('sender', 'receiver')
                      and people_sub_type::integer&64 != 0
                   inner join people p on cp.people_ref = p.id
        where loans.id = $1
          and case
                when $2 IN ('sender', 'loaner') then
                  cp.people_type = 'sender'
                when $2 IN ('receiver', 'borrower') then
                  cp.people_type = 'receiver'
              else
                  false
              end
        order by cp.people_type, cp.order_by
    )
    select distinct on (transport_dispatched_by)
      transport_dispatched_by,
      trim(array_to_string(array_agg(transport_transporter_name) OVER (PARTITION BY transport_dispatched_by), ', '), ', ') as transport_transporter_names,
      case
        when transport_dispatched_by = 'loaner' then
          (
            select trim(array_to_string(array_agg(lower_value), ', '), ', ') as tracking_id
            from properties
            where referenced_relation = 'loans'
              and record_id = $1
              and fullToIndex(property_type) = 'trackingid'
              and applies_to_indexed = 'sender'
            group by fullToIndex(property_type)
            limit 1
          )
        else
        (
          select trim(array_to_string(array_agg(lower_value), ', '), ', ') as tracking_id
          from properties
          where referenced_relation = 'loans'
                and record_id = $1
                and fullToIndex(property_type) = 'trackingid'
                and applies_to_indexed = 'receiver'
          group by fullToIndex(property_type)
          limit 1
        )
      end as transport_track_ids
    from transporters;
  $_$;


ALTER FUNCTION darwin2.fct_report_loans_transporters(loan_id integer, transporter_side text, lang text) OWNER TO cebmpad;

--
-- TOC entry 1898 (class 1255 OID 4816442)
-- Name: fct_rmca_abbreviate_names(character varying); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_rmca_abbreviate_names(given_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 
	returned varchar;
	tmp varchar; --varchar[];
	i integer;
	i2 integer;
	begin_word boolean;
	delimiter_word boolean;
BEGIN
	IF TRIM(COALESCE(given_name,''))='' THEN
		return '';
	END IF;
	
	given_name:=given_name||'.';
	returned:=given_name;
	
	i2:=1;
	begin_word:=true;
	delimiter_word:=false;
	
	IF CHAR_LENGTH(TRIM(given_name)) >0 THEN
		returned:='';
	END IF;
	given_name:=regexp_replace(given_name, '\W?(\s)(\W)(\s)','\2');
	FOR i IN 1..CHAR_LENGTH(TRIM(given_name)) 
	LOOP
		tmp:=SUBSTRING(given_name FROM i FOR 1);
		
		IF begin_word  AND  tmp ~ '\w'  THEN
			returned:=returned||tmp;
			begin_word:=FALSE;
			delimiter_word:=FALSE;
		END IF;
		
		IF tmp ~ '\w' = FALSE AND delimiter_word = FALSE THEN
			IF tmp=' ' OR tmp='.' THEN 
				tmp:='. ';
			END IF;
			
			returned:=returned||tmp;
			delimiter_word:=TRUE;
			begin_word:=TRUE;
		END IF;
		
	END LOOP;
	RETURN TRIM(returned);
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_abbreviate_names(given_name character varying) OWNER TO postgres;

--
-- TOC entry 1815 (class 1255 OID 4816443)
-- Name: fct_rmca_chk_is_already_reference_taxo(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_chk_is_already_reference_taxo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	tmp_taxon varchar;
	check_is_reference boolean;
BEGIN
--ftheeten 2017 07 03
 SELECT is_reference_taxonomy INTO check_is_reference FROM taxonomy_metadata WHERE id=NEW.metadata_ref LIMIT 1;
  IF check_is_reference=TRUE THEN
	IF (TG_OP = 'INSERT') THEN
	   PERFORM * FROM taxonomy 
	   LEFT JOIN taxonomy_metadata
	   ON taxonomy.metadata_ref=taxonomy_metadata.id

	   WHERE name_indexed=fulltoindex(NEW.name) AND level_ref=NEW.level_ref  AND taxonomy_metadata.is_reference_taxonomy=true;
	    IF FOUND THEN
		RAISE EXCEPTION 'This taxon can be only present once in the reference taxonomy, check %', NEW.name;
	    END IF;
	ELSEIF (TG_OP = 'UPDATE') THEN
		SELECT name INTO tmp_taxon FROM taxonomy
		LEFT JOIN taxonomy_metadata
		ON taxonomy.metadata_ref=taxonomy_metadata.id
		 WHERE name_indexed=fulltoindex(NEW.name) AND level_ref=NEW.level_ref  AND taxonomy_metadata.is_reference_taxonomy=true AND taxonomy.id <>NEW.id ;
	    IF FOUND THEN
		RAISE EXCEPTION 'This taxon can be only present once in the reference taxonomy, check %', tmp_taxon;
	    END IF;
	END IF;
   --ELSE
   --      IF LENGTH(TRIM(COALESCE(NEW.source,'')))=0 THEN
--		RAISE EXCEPTION 'Please specify a source for alternate taxonomies';
   --      END IF;	    
   END IF;	    
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_chk_is_already_reference_taxo() OWNER TO darwin2;

--
-- TOC entry 1929 (class 1255 OID 5309160)
-- Name: fct_rmca_chk_only_one_reference_taxo(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_chk_only_one_reference_taxo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN
  
	IF (SELECT COUNT(*) FROM taxonomy_metadata where is_reference_taxonomy=TRUE)>=1 THEN
		RAISE EXCEPTION 'A reference taxonomy already exists in this database (only one is supported)';
	END IF;
   
 	    
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_chk_only_one_reference_taxo() OWNER TO darwin2;

--
-- TOC entry 1817 (class 1255 OID 4816444)
-- Name: fct_rmca_chk_uniqueness_reference_taxo(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_chk_uniqueness_reference_taxo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	cursor_tmp RECORD;
	duplicates  varchar[];
	test_refs int[];
	i INTEGER;	
BEGIN
--ftheeten 2017 07 03

   IF new.is_reference_taxonomy =TRUE THEN
		IF (SELECT COUNT(*) FROM taxonomy_metadata where is_reference_taxonomy=TRUE)>=1 THEN
			RAISE EXCEPTION 'A reference taxonomy already exists in this database (only one is supported)';
		END IF;
		IF TG_OP = 'UPDATE' THEN
			i:=0;
			test_refs:=test_refs||new.id;
			FOR  cursor_tmp IN 
			SELECT  DISTINCT a.name, a.level_ref, a.metadata_ref as metadata_refs 
			--,fct_find_tax_level(a.path,4 ) as phylum
			from taxonomy a
			LEFT JOIN taxonomy b
			ON fulltoindex(a.name)=fulltoindex(b.name)
			AND a.level_ref=b.level_ref
			LEFT JOIN taxonomy_metadata c
			ON a.metadata_ref=c.id AND a.id<> b.id
			WHERe 
			b.metadata_ref=NEW.id
			AND c.is_reference_taxonomy=true
			AND fct_find_tax_level(a.path,4 )=fct_find_tax_level(b.path,4 )


			LOOP 
				duplicates:=duplicates||cursor_tmp.name;
				i:=i+1;
			END LOOP;
			IF i>0 THEN
				RAISE EXCEPTION 'Some taxa are present several times in the reference taxonomy, check %', array_to_string(duplicates,',');
			END IF;
		END IF;
   END IF;

	    
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_chk_uniqueness_reference_taxo() OWNER TO darwin2;

--
-- TOC entry 1928 (class 1255 OID 5309144)
-- Name: fct_rmca_compare_taxonomy_staging_darwin(integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin(req_import_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS TABLE(id integer, name character varying, staging_catalogue_hierarchy character varying, darwin_hierarchy character varying, level_name character varying, level_ref integer)
    LANGUAGE sql
    AS $_$ SELECT distinct staging_catalogue.id, staging_catalogue.name, fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue.id,$2, $3)

as staging_catalogue_hierarchy 

, 
fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

,
1 , true, false
) as darwin_hierarchy, level_name, 
staging_catalogue.level_ref
 from staging_catalogue

LEFT JOIN taxonomy ON fulltoindex(name_indexed, false)= fulltoindex(staging_catalogue.name, false) and staging_catalogue.level_ref=taxonomy.level_ref
LEFT JOIN catalogue_levels
ON staging_catalogue.level_ref=catalogue_levels.id
 WHERE staging_catalogue.import_ref=$1
 AND taxonomy.is_reference_taxonomy=TRUE
 AND path !='/' and

fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

,
1 , $2, $3
)
 !=

 fct_rmca_sort_taxon_path_alphabetically_staging(staging_catalogue.id,$2, $3) order by staging_catalogue.level_ref, staging_catalogue.name;
 $_$;


ALTER FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin(req_import_ref integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1937 (class 1255 OID 5309225)
-- Name: fct_rmca_compare_taxonomy_staging_darwin_reference(integer, boolean, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false, match_invalid_units boolean DEFAULT true) RETURNS TABLE(id integer, name character varying, staging_catalogue_hierarchy character varying, darwin_hierarchy character varying, level_name character varying, level_ref integer, taxonomic_id integer, msg character varying)
    LANGUAGE plpgsql
    AS $_$ 
BEGIN
IF match_invalid_units IS FALSE THEN
	RETURN QUERY SELECT a.*, 
	CASE 
	WHEN 
	taxonomy_id is NULL THEN
	'taxon_to_be_created'::varchar
	when
	staging_catalogue_hierarchy_db=darwin_hierarchy_db THEN
	'taxonomic_hierarchy_already_exists'::varchar
	WHEN 
	staging_catalogue_hierarchy_db <> darwin_hierarchy_db THEN
	'taxonomic_conflict_in_reference'::varchar

	END

	 FROM (SELECT distinct 

	staging_catalogue.id, staging_catalogue.name, fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(staging_catalogue.id,req_import_ref, $2, $3)

	as staging_catalogue_hierarchy_db 

	, 
	fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

	,
	1 , true, false
	) as darwin_hierarchy_db, catalogue_levels.level_name,

	staging_catalogue.level_ref,
	taxonomy.id  as taxonomy_id
	 from staging_catalogue

	LEFT JOIN taxonomy ON fulltoindex(name_indexed, false)= fulltoindex(staging_catalogue.name, false) and staging_catalogue.level_ref=taxonomy.level_ref
	 AND taxonomy.is_reference_taxonomy=TRUE
	LEFT JOIN catalogue_levels
	ON staging_catalogue.level_ref=catalogue_levels.id
	 WHERE staging_catalogue.import_ref=$1 AND taxonomy.status !='invalid'

	 ORDER BY staging_catalogue.level_ref, staging_catalogue.name) a ;

ELSE

	RETURN QUERY SELECT a.*, 
	CASE 
	WHEN 
	taxonomy_id is NULL THEN
	'taxon_to_be_created'::varchar
	when
	staging_catalogue_hierarchy_db=darwin_hierarchy_db THEN
	'taxonomic_hierarchy_already_exists'::varchar
	WHEN 
	staging_catalogue_hierarchy_db <> darwin_hierarchy_db THEN
	'taxonomic_conflict_in_reference'::varchar

	END

	 FROM (SELECT distinct 

	staging_catalogue.id, staging_catalogue.name, fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(staging_catalogue.id,req_import_ref, $2, $3)

	as staging_catalogue_hierarchy_db 

	, 
	fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

	,
	1 , true, false
	) as darwin_hierarchy_db,  catalogue_levels.level_name,

	staging_catalogue.level_ref,
	taxonomy.id  as taxonomy_id
	 from staging_catalogue

	LEFT JOIN taxonomy ON fulltoindex(name_indexed, false)= fulltoindex(staging_catalogue.name, false) and staging_catalogue.level_ref=taxonomy.level_ref
	 AND taxonomy.is_reference_taxonomy=TRUE
	LEFT JOIN catalogue_levels
	ON staging_catalogue.level_ref=catalogue_levels.id
	 WHERE staging_catalogue.import_ref=$1

	 ORDER BY  staging_catalogue.level_ref, staging_catalogue.name) a ;
   END IF;
 END 
 $_$;


ALTER FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean, is_indexed boolean, match_invalid_units boolean) OWNER TO darwin2;

--
-- TOC entry 1934 (class 1255 OID 5309228)
-- Name: fct_rmca_compare_taxonomy_staging_darwin_reference_bck(integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_reference_bck(req_import_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS TABLE(id integer, name character varying, staging_catalogue_hierarchy character varying, darwin_hierarchy character varying, level_name character varying, level_ref integer, taxonomic_id integer, msg character varying)
    LANGUAGE sql
    AS $_$ SELECT *, 
cASE 
WHEN 
taxonomy_id is NULL THEN
'taxon_to_be_created'
when
staging_catalogue_hierarchy=darwin_hierarchy THEN
'taxonomic_hierarchy_already_exists'
WHEN 
staging_catalogue_hierarchy <> darwin_hierarchy THEN
'taxonomic_conflict_in_reference'

END

 FROM (SELECT distinct 

staging_catalogue.id, staging_catalogue.name, fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(staging_catalogue.id,req_import_ref, $2, $3)

as staging_catalogue_hierarchy 

, 
fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

,
1 , true, false
) as darwin_hierarchy, level_name,

staging_catalogue.level_ref,
taxonomy.id  as taxonomy_id
 from staging_catalogue

LEFT JOIN taxonomy ON fulltoindex(name_indexed, false)= fulltoindex(staging_catalogue.name, false) and staging_catalogue.level_ref=taxonomy.level_ref
 AND taxonomy.is_reference_taxonomy=TRUE
LEFT JOIN catalogue_levels
ON staging_catalogue.level_ref=catalogue_levels.id
 WHERE staging_catalogue.import_ref=$1

 /*AND path !='/' and

fct_rmca_sort_taxon_path_alphabetically(path||taxonomy.id::varchar

,
1 , $2, $3
)
 !=

 fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(staging_catalogue.id, req_import_ref, $2, $3)*/ order by staging_catalogue.level_ref, staging_catalogue.name) a ;
 $_$;


ALTER FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_reference_bck(req_import_ref integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1927 (class 1255 OID 5309116)
-- Name: fct_rmca_compare_taxonomy_staging_darwin_tagging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_tagging(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	check_duplicates_hierarchies RECORD;
	returned  boolean;
BEGIN 

	returned:=TRUE;
	UPDATE staging_catalogue SET hierarchical_conflict = FALSE WHERE import_ref=req_import_ref;
	PERFORM * FROM  fct_rmca_compare_taxonomy_staging_darwin(req_import_ref);
		IF FOUND THEN
			
			FOR check_duplicates_hierarchies IN SELECT * FROM  fct_rmca_compare_taxonomy_staging_darwin(req_import_ref)
			LOOP 			
				UPDATE staging_catalogue SET hierarchical_conflict = TRUE WHERE import_ref=req_import_ref AND staging_catalogue.level_ref=check_duplicates_hierarchies.level_ref AND staging_catalogue.name=check_duplicates_hierarchies.name;
			END LOOP;
			UPDATE imports SET state='error' , errors_in_import= 'taxonomic_conflict' ,working=false WHERE id=req_import_ref;
			returned:=FALSE;
		END IF;
		RETURN returned;
END;


 $$;


ALTER FUNCTION darwin2.fct_rmca_compare_taxonomy_staging_darwin_tagging(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1931 (class 1255 OID 5309230)
-- Name: fct_rmca_document_taxonomy_staging_darwin_reference(integer, boolean, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false, match_invalid_taxonomies boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	curs_taxo  RECORD ; 
	returned boolean;
BEGIN 

	returned = false;
	for curs_taxo IN SELECT *  FROM fct_rmca_compare_taxonomy_staging_darwin_reference(req_import_ref, with_rank, is_indexed, match_invalid_taxonomies)
	LOOP
		UPDATE staging_catalogue SET import_exception=curs_taxo.msg, staging_hierarchy=curs_taxo.staging_catalogue_hierarchy, darwin_hierarchy=curs_taxo.darwin_hierarchy WHERE id=curs_taxo.id;
	END LOOP;
	returned:=TRUE;
	return returned;
END
 $$;


ALTER FUNCTION darwin2.fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean, is_indexed boolean, match_invalid_taxonomies boolean) OWNER TO darwin2;

--
-- TOC entry 1816 (class 1255 OID 4816445)
-- Name: fct_rmca_dynamic_saved_search(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search(id_query integer, id_user integer) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	sql varchar;

	where_part varchar;
	param_part varchar;
	param_part_array varchar[];
	elem varchar;
	
BEGIN

	SELECT  query_where, query_parameters  into   where_part, param_part FROM my_saved_searches WHERE id=id_query AND user_ref= id_user LIMIT 1;
	
	
	param_part_array=regexp_split_to_array(param_part, ';(?=|)'); 
	
	FOR i in 2..array_length( param_part_array,1)	LOOP
		elem:=regexp_replace(trim(param_part_array[i]), '^(\|)','');
		elem:=regexp_replace(trim(elem), '(\|)$','');
		
		where_part:=regexp_replace(where_part, '(\?)',''''||elem||'''');
		
	END LOOP;

	 RETURN QUERY EXECUTE 'SELECT s.id '||where_part;
END
$_$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search(id_query integer, id_user integer) OWNER TO darwin2;

--
-- TOC entry 1809 (class 1255 OID 4816446)
-- Name: fct_rmca_dynamic_saved_search_geojson(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search_geojson(id_query integer, id_user integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned varchar;
	
BEGIN

	SELECT 
		'{  "type": "FeatureCollection",
		  "features": ['||
		string_agg('{"type" : "Feature", 
			"geometry" : {
				"type" : "Point",
				"coordinates" : ['||longitude||', '||latitude||']
			},
			"properties": {
				"collection_number" : "'||code_display::varchar||'",
				"taxon_name" : "'||taxon_name::varchar||'",
				"type" : "'||coll_type::varchar||'",
				"collecting_date" : "'||date_from_display::varchar||'",
				"collecting_date_end" : "'||NULLIF(date_from_display, 'xxxx-xx-xx')::varchar||'",

				"country" : "'||gtu_country_tag_value::varchar||'",
				"latitude" : "'||latitude::varchar||'",
				"longitude" : "'||longitude::varchar||'"
			}
		}'::varchar,',')||']
		}'INTO returned 
 FROM   v_rmca_public_view WHERE id in (SELECT fct_rmca_dynamic_saved_search(id_query, id_user)) and latitude is not null and longitude is not null LIMIT 1;

 return returned;
END
$$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search_geojson(id_query integer, id_user integer) OWNER TO darwin2;

--
-- TOC entry 1813 (class 1255 OID 4816447)
-- Name: fct_rmca_dynamic_saved_search_taxonomy(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_dynamic_saved_search_taxonomy(id_query integer, id_user integer) RETURNS SETOF darwin2.rmca_taxon_report
    LANGUAGE plpgsql
    AS $$
DECLARE
 tmp RECORD;
 declare tmp_ret RECORD;
BEGIN
		FOR tmp in
		
			SELECT
	 DISTINCT fct_rmca_sort_taxon_path_alphabetically_hstore(taxon_path||taxon_ref::varchar) as hstore_field ,

	fct_rmca_sort_taxon_path_alphabetically(taxon_path||taxon_ref::varchar) as alpha_path
	 from specimens where specimens.id in (SELECT fct_rmca_dynamic_saved_search(
				id_query, id_user
			)) order by alpha_path
		LOOP
				BEGIN
					IF  tmp.hstore_field is not null then
					tmp_ret:=populate_record(null::rmca_taxon_report,tmp.hstore_field);				
					RETURN NEXT tmp_ret ;
					end if;
				END;
		END LOOP;
END; $$;


ALTER FUNCTION darwin2.fct_rmca_dynamic_saved_search_taxonomy(id_query integer, id_user integer) OWNER TO darwin2;

--
-- TOC entry 1923 (class 1255 OID 5308877)
-- Name: fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(id_staging_taxon integer, exclude_invalid_entries boolean DEFAULT false) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar[];
 returned_tmp varchar;
 --ftheeten 2019 02 15
 returned_tmp_levels varchar;
 returned_name varchar;
 returned_ids_staging varchar;

 staging_path_name varchar;
 staging_path_level varchar;
 staging_path_level_array int[];
 staging_path_name_array varchar[];
 --ftheeten 2019 02 15
taxonomy_path_level_array int[];
 
 parent integer;
 i integer;
 tmp_id integer;
 tmp_name_path varchar;
 name_tmp varchar;
 level_tmp integer;
  level_tmp_char varchar;
  level_of_parent_staging int;
  level_of_parent_taxonomy int;
  
 id_main_taxon integer;
 --ftheeten 2019 02 15
 id_level_taxon integer;
 staging_path_found boolean;
 array_ids integer[];
 array_ids_string varchar;
 last_id varchar;
 last_id_set boolean;
 catalogue_ref_tmp integer;
 import_ref_tmp integer;
 parent_updated_tmp boolean;
 parent_updated_refs_array integer[];
 --ftheeten 2019 02 15
  parent_updated_levels_array integer[];
 taxon_found_in_staging boolean;
BEGIN
--raise notice 'ENTRY';
	SELECT parent_updated INTO parent_updated_tmp FROM  staging_catalogue WHERE id=tmp_id;
	IF parent_updated_tmp=true THEN
		return NULL;
	END IF;
		tmp_id:= id_staging_taxon;
		i:=0;
		parent:=-1;

		--staging_path_name:='/';
		--staging_path_level:='/';
		
		--array_ids_string:='/'||tmp_id||'/';
		array_ids:=tmp_id||array_ids;
		WHILE parent is not null and i<30 LOOP
			SELECT parent_ref, name, level_ref, catalogue_ref, import_ref  INTO parent, name_tmp, level_of_parent_staging , catalogue_ref_tmp, import_ref_tmp FROM staging_catalogue WHERE id=tmp_id --and catalogue_ref is NULL 
			LIMIT 1;
			
			IF parent is not null THEN
				
				IF catalogue_ref_tmp IS NULL THEN
					tmp_id:=parent;
				ELSE
					--raise notice 'APPEND';
					SELECT id, level_ref into tmp_id, level_tmp  FROM  staging_catalogue WHERE import_ref=import_ref_tmp AND catalogue_ref=parent; --AND parent_updated=TRUE;
					parent_updated_refs_array:=parent||parent_updated_refs_array;
					--ftheeten 2019 02 15
					parent_updated_levels_array:= level_tmp||parent_updated_levels_array;
					--raise notice 'APPENDED';
				END IF;
				IF tmp_id IS NOT NULL THEN
					
					array_ids := tmp_id||array_ids;
					--raise notice '%',array_ids_string;
				END IF;
			END IF;
			
			staging_path_name_array:= name_tmp::varchar||staging_path_name_array;
			--raise notice '%',staging_path_name;
			staging_path_level_array:= level_of_parent_staging||staging_path_level_array;
			
			i:=i+1;
		END LOOP;
		--raise notice '%', staging_path_name_array;
		--raise notice '%', staging_path_level_array;
		--raise notice '%', array_ids;
		--raise notice '%', parent_updated_refs_array;
		/*IF staging_path_name='/' OR
		staging_path_level='/' OR 
		array_ids_string='/' THEN
			RETURN NULL;
		END IF;*/
		
		IF ARRAY_LENGTH(staging_path_name_array,1)=0 OR
		ARRAY_LENGTH(staging_path_level_array,1)=0 OR 
		ARRAY_LENGTH(array_ids,1)=0 THEN
		--RAISE NOTICE 'EXIT 0';
			RETURN NULL;
		END IF;
		--staging_path_level_array:=string_to_array(staging_path_level, '/');
		--staging_path_name_array:=string_to_array(staging_path_name, '/');
		--array_ids=string_to_array(array_ids_string, '/');
		
		returned_tmp:='/';
		returned_tmp_levels:='/';
		returned_name:='/';
		returned_ids_staging='/';
		staging_path_found:=false;
		taxon_found_in_staging:=false;
		last_id_set:=false;
--raise notice 'staging_path_name_array %', staging_path_name_array;
		IF ARRAY_LENGTH(staging_path_level_array, 1)=ARRAY_LENGTH(staging_path_name_array, 1) THEN
			FOR i IN  1..ARRAY_LENGTH(staging_path_name_array,1) LOOP
				--RAISe NOTICE '%d', i;
				--RAISe NOTICE '%d', ARRAY_LENGTH(staging_path_name_array,1);
				--RAISe NOTICE '%d', ARRAY_LENGTH(parent_updated_refs_array,1);
				tmp_name_path:=staging_path_name_array[i];
--raise notice 'tmp_name_path %',tmp_name_path;
				IF LENGTH(tmp_name_path)>0 THEN
				
					--raise notice 'TEST';
					level_tmp_char:=staging_path_level_array[i];
					--taxonomic parent already in staging
					IF ARRAY_LENGTH( parent_updated_refs_array ,1)> 0 AND i < ARRAY_LENGTH( parent_updated_refs_array ,1) THEN
						
						id_main_taxon:=parent_updated_refs_array[i];
						--ftheeten 2019 02 15
						id_level_taxon=parent_updated_levels_array[i];
						--raise notice 'id_main_taxon %', id_main_taxon;
						taxon_found_in_staging:=true;
					--find taxonomuic parent from string
					ELSE
						taxon_found_in_staging:=false;

						IF exclude_invalid_entries=true THEN
							SELECT id, level_ref INTO id_main_taxon, id_level_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int AND status !='invalid' LIMIT 1;
							--SELECT id INTO id_main_taxon FROM taxonomy WHERE fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int AND status !='invalid' LIMIT 1;
						
						ELSE
							SELECT id, level_ref INTO id_main_taxon, id_level_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int LIMIT 1;
							--SELECT id INTO id_main_taxon FROM taxonomy WHERE fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int LIMIT 1;
						END IF;
					END IF;
					IF id_main_taxon IS NULL THEN
						--raise notice 'NOT_FOUND';
						returned_tmp:= returned_tmp||'NOT_FOUND/';
						returned_tmp_levels:= returned_tmp_levels||'NOT_FOUND/';
						staging_path_found:=false;
					ELSE						
						--RAISE NOTICE 'FOUND';
						returned_tmp:= returned_tmp||id_main_taxon::varchar||'/';
						--ftheeten 2019 02 15
						returned_tmp_levels:= returned_tmp_levels||id_level_taxon::varchar||'/';
						returned_name:=returned_name||tmp_name_path||'/';
						returned_ids_staging:=returned_ids_staging||array_ids[i]::varchar||'/';
						
						last_id:=array_ids[i];
						staging_path_found:=TRUE;
					END IF;
					IF staging_path_found=TRUE THEN
						IF exclude_invalid_entries=true AND taxon_found_in_staging=false THEN
							
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp AND status !='invalid';
						ELSIF taxon_found_in_staging=false THEN
						
						--raise notice 'returned_tmp : %',returned_tmp; 
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp;
							IF NOT FOUND THEN
								PERFORM id FROM taxonomy WHERE path||id::varchar||'/'LIKE '%'||returned_tmp;
							END IF;
						--ELSE
						--	RAISE NOTICE 'NO check';
						END IF;
						IF FOUND OR taxon_found_in_staging=true THEN
							--RAISE NOTICE 'DEF';
							--parent path found in taxonomy (longest prefix)

							--eg for complete path in staging /97909/97910/97911/97912/97913/97914/97922/ )
							--eg. /1/5/5953/5954/5955/
							returned[1]:=returned_tmp;
							--string trascription of the path
							--eg. /Eucaryota/Animalia/CHORDATA/ACTINOPTERYGII/PERCIFORMES/
							returned[2]:=returned_name;
							--path corresponding to the longest taxonomical prefix with the staging ids
							--/97909/97910/97911/97912/97913/
							returned[3]:=returned_ids_staging;
							--lowest taxon of the path 
							--eg. 97913
							returned[4]:=last_id;
							--path the parents in staging not found in taxonomy (remainded of the longest prefix)
							--eg. /97914/97922/ 
							IF(i<ARRAY_LENGTH(array_ids,1)) THEN
								returned[5]:='/'||array_to_string(array_ids[i+1:ARRAY_LENGTH(array_ids,1)],'/')||'/';
							ELSE
								
								returned[5]:='/';
							END IF;

							--levels in staging
							returned[6]:='/'||array_to_string(staging_path_level_array,'/')||'/';
							--levels in taxonomy
							returned[7]:=returned_tmp_levels;
							
							--SUBSTRING(array_ids_string FROM  POSITION ('/'||last_id||'/' IN array_ids_string) + LENGTH('/'||last_id));
						ELSE
							--RAISE NOTICE 'EXIT 1';
							RETURN returned;
						END IF;
					ELSE 
						--RAISE NOTICE 'EXIT 2';
						RETURN returned;
					END IF;
				END IF;
				
			END LOOP;
		END IF;
--RAISE NOTICE 'EXIT 3';
	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(id_staging_taxon integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1939 (class 1255 OID 5309273)
-- Name: fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(id_staging_taxon integer, taxonomy_metadata_id integer, exclude_invalid_entries boolean DEFAULT false) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
 --new 2019 02 26
 --this function searches a taxon path insde the same taxonomy
 returned varchar[];
 returned_tmp varchar;
 --ftheeten 2019 02 15
 returned_tmp_levels varchar;
 returned_name varchar;
 returned_ids_staging varchar;

 staging_path_name varchar;
 staging_path_level varchar;
 staging_path_level_array int[];
 staging_path_name_array varchar[];
 --ftheeten 2019 02 15
taxonomy_path_level_array int[];
 
 parent integer;
 i integer;
 tmp_id integer;
 tmp_name_path varchar;
 name_tmp varchar;
 level_tmp integer;
  level_tmp_char varchar;
  level_of_parent_staging int;
  level_of_parent_taxonomy int;
  
 id_main_taxon integer;
 --ftheeten 2019 02 15
 id_level_taxon integer;
 staging_path_found boolean;
 array_ids integer[];
 array_ids_string varchar;
 last_id varchar;
 last_id_set boolean;
 catalogue_ref_tmp integer;
 import_ref_tmp integer;
 parent_updated_tmp boolean;
 parent_updated_refs_array integer[];
 --ftheeten 2019 02 15
  parent_updated_levels_array integer[];
 taxon_found_in_staging boolean;
BEGIN
--raise notice 'ENTRY';
	SELECT parent_updated INTO parent_updated_tmp FROM  staging_catalogue WHERE id=tmp_id;
	IF parent_updated_tmp=true THEN
		return NULL;
	END IF;
		tmp_id:= id_staging_taxon;
		i:=0;
		parent:=-1;

		--staging_path_name:='/';
		--staging_path_level:='/';
		
		--array_ids_string:='/'||tmp_id||'/';
		array_ids:=tmp_id||array_ids;
		WHILE parent is not null and i<30 LOOP
			SELECT parent_ref, name, level_ref, catalogue_ref, import_ref  INTO parent, name_tmp, level_of_parent_staging , catalogue_ref_tmp, import_ref_tmp FROM staging_catalogue WHERE id=tmp_id --and catalogue_ref is NULL 
			LIMIT 1;
			
			IF parent is not null THEN
				
				IF catalogue_ref_tmp IS NULL THEN
					tmp_id:=parent;
				ELSE
					--raise notice 'APPEND';
					SELECT id, level_ref into tmp_id, level_tmp  FROM  staging_catalogue WHERE import_ref=import_ref_tmp AND catalogue_ref=parent; --AND parent_updated=TRUE;
					parent_updated_refs_array:=parent||parent_updated_refs_array;
					--ftheeten 2019 02 15
					parent_updated_levels_array:= level_tmp||parent_updated_levels_array;
					--raise notice 'APPENDED';
				END IF;
				IF tmp_id IS NOT NULL THEN
					
					array_ids := tmp_id||array_ids;
					--raise notice '%',array_ids_string;
				END IF;
			END IF;
			
			staging_path_name_array:= name_tmp::varchar||staging_path_name_array;
			--raise notice '%',staging_path_name;
			staging_path_level_array:= level_of_parent_staging||staging_path_level_array;
			
			i:=i+1;
		END LOOP;
		--raise notice '%', staging_path_name_array;
		--raise notice '%', staging_path_level_array;
		--raise notice '%', array_ids;
		--raise notice '%', parent_updated_refs_array;
		/*IF staging_path_name='/' OR
		staging_path_level='/' OR 
		array_ids_string='/' THEN
			RETURN NULL;
		END IF;*/
		
		IF ARRAY_LENGTH(staging_path_name_array,1)=0 OR
		ARRAY_LENGTH(staging_path_level_array,1)=0 OR 
		ARRAY_LENGTH(array_ids,1)=0 THEN
		--RAISE NOTICE 'EXIT 0';
			RETURN NULL;
		END IF;
		--staging_path_level_array:=string_to_array(staging_path_level, '/');
		--staging_path_name_array:=string_to_array(staging_path_name, '/');
		--array_ids=string_to_array(array_ids_string, '/');
		
		returned_tmp:='/';
		returned_tmp_levels:='/';
		returned_name:='/';
		returned_ids_staging='/';
		staging_path_found:=false;
		taxon_found_in_staging:=false;
		last_id_set:=false;
--raise notice 'staging_path_name_array %', staging_path_name_array;
		IF ARRAY_LENGTH(staging_path_level_array, 1)=ARRAY_LENGTH(staging_path_name_array, 1) THEN
			FOR i IN  1..ARRAY_LENGTH(staging_path_name_array,1) LOOP
				--RAISe NOTICE '%d', i;
				--RAISe NOTICE '%d', ARRAY_LENGTH(staging_path_name_array,1);
				--RAISe NOTICE '%d', ARRAY_LENGTH(parent_updated_refs_array,1);
				tmp_name_path:=staging_path_name_array[i];
--raise notice 'tmp_name_path %',tmp_name_path;
				IF LENGTH(tmp_name_path)>0 THEN
				
					raise notice 'TEST tmp_name_path';
					level_tmp_char:=staging_path_level_array[i];
					--taxonomic parent already in staging
					IF ARRAY_LENGTH( parent_updated_refs_array ,1)> 0 AND i < ARRAY_LENGTH( parent_updated_refs_array ,1) THEN
						
						id_main_taxon:=parent_updated_refs_array[i];
						--ftheeten 2019 02 15
						id_level_taxon=parent_updated_levels_array[i];
						--raise notice 'id_main_taxon %', id_main_taxon;
						taxon_found_in_staging:=true;
					--find taxonomuic parent from string
					ELSE
						
						taxon_found_in_staging:=false;

						IF exclude_invalid_entries=true THEN
							SELECT id, level_ref INTO id_main_taxon, id_level_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int AND status !='invalid' AND metadata_ref=taxonomy_metadata_id LIMIT 1;

						
						ELSE
							SELECT id, level_ref INTO id_main_taxon, id_level_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int AND metadata_ref=taxonomy_metadata_id LIMIT 1;
							
						END IF;
					END IF;
					IF id_main_taxon IS NULL THEN
						--raise notice 'NOT_FOUND';
						returned_tmp:= returned_tmp||'NOT_FOUND/';
						returned_tmp_levels:= returned_tmp_levels||'NOT_FOUND/';
						staging_path_found:=false;
					ELSE						
						--RAISE NOTICE 'FOUND';
						returned_tmp:= returned_tmp||id_main_taxon::varchar||'/';
						--ftheeten 2019 02 15
						returned_tmp_levels:= returned_tmp_levels||id_level_taxon::varchar||'/';
						returned_name:=returned_name||tmp_name_path||'/';
						returned_ids_staging:=returned_ids_staging||array_ids[i]::varchar||'/';
						
						last_id:=array_ids[i];
						staging_path_found:=TRUE;
					END IF;
					IF staging_path_found=TRUE THEN
						IF exclude_invalid_entries=true AND taxon_found_in_staging=false THEN
							
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp AND status !='invalid' AND metadata_ref=taxonomy_metadata_id;
						ELSIF taxon_found_in_staging=false THEN
						
						--raise notice 'returned_tmp : %',returned_tmp; 
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'=returned_tmp AND metadata_ref=taxonomy_metadata_id;
							IF NOT FOUND THEN
								PERFORM id FROM taxonomy WHERE path||id::varchar||'/'LIKE '%'||returned_tmp AND metadata_ref=taxonomy_metadata_id;
							END IF;
						--ELSE
						--	RAISE NOTICE 'NO check';
						END IF;
						IF FOUND OR taxon_found_in_staging=true THEN
							--RAISE NOTICE 'DEF';
							--parent path found in taxonomy (longest prefix)

							--eg for complete path in staging /97909/97910/97911/97912/97913/97914/97922/ )
							--eg. /1/5/5953/5954/5955/
							returned[1]:=returned_tmp;
							--string trascription of the path
							--eg. /Eucaryota/Animalia/CHORDATA/ACTINOPTERYGII/PERCIFORMES/
							returned[2]:=returned_name;
							--path corresponding to the longest taxonomical prefix with the staging ids
							--/97909/97910/97911/97912/97913/
							returned[3]:=returned_ids_staging;
							--lowest taxon of the path 
							--eg. 97913
							returned[4]:=last_id;
							--path the parents in staging not found in taxonomy (remainded of the longest prefix)
							--eg. /97914/97922/ 
							IF(i<ARRAY_LENGTH(array_ids,1)) THEN
								returned[5]:='/'||array_to_string(array_ids[i+1:ARRAY_LENGTH(array_ids,1)],'/')||'/';
							ELSE
								
								returned[5]:='/';
							END IF;

							--levels in staging
							returned[6]:='/'||array_to_string(staging_path_level_array,'/')||'/';
							--levels in taxonomy
							returned[7]:=returned_tmp_levels;
							
							--SUBSTRING(array_ids_string FROM  POSITION ('/'||last_id||'/' IN array_ids_string) + LENGTH('/'||last_id));
						ELSE
							--RAISE NOTICE 'EXIT 1';
							RETURN returned;
						END IF;
					ELSE 
						RAISE NOTICE 'EXIT 2';
						RETURN returned;
					END IF;
				END IF;
				
			END LOOP;
		END IF;
--RAISE NOTICE 'EXIT 3';
	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(id_staging_taxon integer, taxonomy_metadata_id integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1920 (class 1255 OID 5308865)
-- Name: fct_rmca_get_merge_catalogue_path_in_staging_json_mauvais(integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_json_mauvais(id_staging_taxon integer, exclude_invalid_entries boolean DEFAULT false) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned jsonb;
 returned_tmp integer[];
 returned_name varchar[];
 returned_ids_staging integer[];

 staging_path_name varchar;
 staging_path_level varchar;
 staging_path_level_array int[];
 staging_path_name_array varchar[];
 parent integer;
 i integer;
 tmp_id integer;
 tmp_name_path varchar;
 name_tmp varchar;
 level_tmp varchar;
  level_tmp_char varchar;
  level_of_parent_staging int;
  level_of_parent_taxonomy int;
  
 id_main_taxon integer;
 staging_path_found boolean;
 array_ids integer[];
 array_ids_string varchar;
 last_id varchar;
 last_id_set boolean;
 catalogue_ref_tmp integer;
 import_ref_tmp integer;
 parent_updated_tmp boolean;
 parent_updated_refs_array integer[];
 taxon_found_in_staging boolean;
BEGIN
--raise notice 'entry';
	SELECT parent_updated INTO parent_updated_tmp FROM  staging_catalogue WHERE id=tmp_id;
	IF parent_updated_tmp=true THEN
		return NULL;
	END IF;
		tmp_id:= id_staging_taxon;
		i:=0;
		parent:=-1;

		--staging_path_name:='/';
		--staging_path_level:='/';
		
		--array_ids_string:='/'||tmp_id||'/';
		array_ids:=tmp_id||array_ids;
		WHILE parent is not null and i<30 LOOP
			SELECT parent_ref, name, level_ref, catalogue_ref, import_ref  INTO parent, name_tmp, level_of_parent_staging , catalogue_ref_tmp, import_ref_tmp FROM staging_catalogue WHERE id=tmp_id --and catalogue_ref is NULL 
			LIMIT 1;
			
			IF parent is not null THEN
				
				IF catalogue_ref_tmp IS NULL THEN
					tmp_id:=parent;
				ELSE
					--raise notice 'append';
					SELECT id into tmp_id FROM  staging_catalogue WHERE import_ref=import_ref_tmp AND catalogue_ref=parent; --AND parent_updated=TRUE;
					parent_updated_refs_array:=parent||parent_updated_refs_array;
				END IF;
				IF tmp_id IS NOT NULL THEN
					
					array_ids := tmp_id||array_ids;
					--raise notice '%',array_ids_string;
				END IF;
			END IF;
			
			staging_path_name_array:= name_tmp::varchar||staging_path_name_array;
			--raise notice '%',staging_path_name;
			staging_path_level_array:= level_of_parent_staging||staging_path_level_array;
			
			i:=i+1;
		END LOOP;
		--raise notice '%', staging_path_name_array;
		--raise notice '%', staging_path_level_array;
		--raise notice '%', array_ids;
		--raise notice '%', parent_updated_refs_array;
		/*IF staging_path_name='/' OR
		staging_path_level='/' OR 
		array_ids_string='/' THEN
			RETURN NULL;
		END IF;*/
		
		IF ARRAY_LENGTH(staging_path_name_array,1)=0 OR
		ARRAY_LENGTH(staging_path_level_array,1)=0 OR 
		ARRAY_LENGTH(array_ids,1)=0 THEN
		--RAISE NOTICE 'EXIT 0';
			RETURN NULL;
		END IF;
		--staging_path_level_array:=string_to_array(staging_path_level, '/');
		--staging_path_name_array:=string_to_array(staging_path_name, '/');
		--array_ids=string_to_array(array_ids_string, '/');
		
		returned_tmp:=ARRAY[]::INTEGER[];
		returned_name:=ARRAY[]::VARCHAR[];
		returned_ids_staging=ARRAY[]::INTEGER[];
		staging_path_found:=false;
		taxon_found_in_staging:=false;
		last_id_set:=false;
--raise notice 'staging_path_name_array %', staging_path_name_array;
		IF ARRAY_LENGTH(staging_path_level_array, 1)=ARRAY_LENGTH(staging_path_name_array, 1) THEN
			FOR i IN  1..ARRAY_LENGTH(staging_path_name_array,1) LOOP
				--RAISe NOTICE '%d', i;
				--RAISe NOTICE '%d', ARRAY_LENGTH(staging_path_name_array,1);
				--RAISe NOTICE '%d', ARRAY_LENGTH(parent_updated_refs_array,1);
				tmp_name_path:=staging_path_name_array[i];
--raise notice 'tmp_name_path %',tmp_name_path;
				IF LENGTH(tmp_name_path)>0 THEN
				
					--raise notice 'TEST';
					level_tmp_char:=staging_path_level_array[i];
					--taxonomic parent already in staging
					IF ARRAY_LENGTH( parent_updated_refs_array ,1)> 0 AND i < ARRAY_LENGTH( parent_updated_refs_array ,1) THEN
						
						id_main_taxon:=parent_updated_refs_array[i];
						--raise notice 'id_main_taxon %', id_main_taxon;
						taxon_found_in_staging:=true;
					--find taxonomuic parent from string
					ELSE
						taxon_found_in_staging:=false;

						IF exclude_invalid_entries=true THEN
							--SELECT id INTO id_main_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int AND status !='invalid' LIMIT 1;
							SELECT id INTO id_main_taxon FROM taxonomy WHERE fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int AND status !='invalid' LIMIT 1;
						
						ELSE
							--SELECT id INTO id_main_taxon FROM taxonomy WHERE name_indexed=fulltoindex(tmp_name_path) AND level_ref=level_tmp_char::int LIMIT 1;
							SELECT id INTO id_main_taxon FROM taxonomy WHERE fulltoindex((fct_rmca_taxonomy_split_name_author(name, level_ref))[1])=fulltoindex((fct_rmca_taxonomy_split_name_author(tmp_name_path, level_tmp_char::int))[1]) AND level_ref=level_tmp_char::int LIMIT 1;
						END IF;
					END IF;
					IF id_main_taxon IS NULL THEN
						--raise notice 'NOT_FOUND';
						returned_tmp:= returned_tmp|| -1;
						staging_path_found:=false;
					ELSE						
						--RAISE NOTICE 'FOUND';
						returned_tmp:= returned_tmp||id_main_taxon;
						returned_name:=returned_name||tmp_name_path;
						returned_ids_staging:=returned_ids_staging||array_ids[i];
						
						last_id:=array_ids[i];
						staging_path_found:=TRUE;
					END IF;
					IF staging_path_found=TRUE THEN
						IF exclude_invalid_entries=true AND taxon_found_in_staging=false THEN
							
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'='/'||array_to_string(returned_tmp,'/')||'/' AND status !='invalid';
						ELSIF taxon_found_in_staging=false THEN
						
						--raise notice 'returned_tmp : %',returned_tmp; 
							PERFORM id FROM taxonomy WHERE path||id::varchar||'/'='/'||array_to_string(returned_tmp,'/')||'/';
							IF NOT FOUND THEN
								PERFORM id FROM taxonomy WHERE path||id::varchar||'/'LIKE '%'||'/'||array_to_string(returned_tmp,'/')||'/';
							END IF;
						--ELSE
						--	RAISE NOTICE 'NO check';
						END IF;
						IF FOUND OR taxon_found_in_staging=true THEN
/*
							--RAISE NOTICE 'DEF';
							--parent path found in taxonomy (longest prefix)

							--eg for complete path in staging /97909/97910/97911/97912/97913/97914/97922/ )
							--eg. /1/5/5953/5954/5955/
							returned[1]:=returned_tmp;
							--string trascription of the path
							--eg. /Eucaryota/Animalia/CHORDATA/ACTINOPTERYGII/PERCIFORMES/
							returned[2]:=returned_name;
							--path corresponding to the longest taxonomical prefix with the staging ids
							--/97909/97910/97911/97912/97913/
							returned[3]:=returned_ids_staging;
							--lowest taxon of the path 
							--eg. 97913
							returned[4]:=last_id;
							--path the parents in staging not found in taxonomy (remainded of the longest prefix)
							--eg. /97914/97922/ */
							IF(i<ARRAY_LENGTH(array_ids,1)) THEN
								--returned[5]:=array_ids[i+1:ARRAY_LENGTH(array_ids,1)];
								returned=jsonb_build_object('taxonomy_path', returned_tmp,
											    'taxonomy_string_path', returned_name,											       'matching_staging_path',returned_ids_staging,
											     'lowest_matching' ,last_id,
											     'non_matching_staging',array_ids[i+1:ARRAY_LENGTH(array_ids,1)] 
												);
							ELSE
								
								returned=jsonb_build_object('taxonomy_path', returned_tmp,
											    'taxonomy_string_path', returned_name,											       'matching_staging_path',returned_ids_staging,
											     'lowest_matching' ,last_id,
											     'non_matching_staging',ARRAY[]::INTEGER[]); 
							END IF;
							--SUBSTRING(array_ids_string FROM  POSITION ('/'||last_id||'/' IN array_ids_string) + LENGTH('/'||last_id));
						ELSE
							--RAISE NOTICE 'EXIT 1';
							RETURN returned;
						END IF;
					ELSE 
						--RAISE NOTICE 'EXIT 2';
						RETURN returned;
					END IF;
				END IF;
				
			END LOOP;
		END IF;
--RAISE NOTICE 'EXIT 3';
	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_get_merge_catalogue_path_in_staging_json_mauvais(id_staging_taxon integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1908 (class 1255 OID 5307647)
-- Name: fct_rmca_gtu_linetotagarray_pattern(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_gtu_linetotagarray_pattern(pattern text) RETURNS TABLE(gtu_id integer)
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
--select array_agg(tags_list) FROM (SELECT lineToTagRows($1) AS tags_list ) as x;
BEGIN
pattern := LOWER('(^|\W)'||pattern||'($|\W)') ;
RETURN QUERY SELECT gtu.id as gtu_id  FROM (SELECT gtu.id, UNNEST(tag_values_indexed) as tag FROM gtu) gtu  WHERE LOWER(tag) ~ pattern;
END;

$_$;


ALTER FUNCTION darwin2.fct_rmca_gtu_linetotagarray_pattern(pattern text) OWNER TO darwin2;

--
-- TOC entry 1922 (class 1255 OID 5308883)
-- Name: fct_rmca_handle_non_reference_taxonomies(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
		staging_catalogue_line staging_catalogue;
		test_taxo  varchar[];
		higher_found_taxon varchar;
		existing_longest_path varchar;
		existing_longest_path_staging varchar;
		existing_longest_path_array varchar[];
		--marielle adam 2019 02 28
		existing_longest_path_array_no_null varchar[];
		existing_longest_path_staging_array varchar[];
		tmp_staging_id VARCHAR;
		tmp_taxonomy_id VARCHAR;
		is_parent boolean;
		i INTEGER;
		previous_staging_id_as_parent varchar;
		previous_taxonomy_id_as_parent varchar;
		staging_path_to_create_in_taxonomy varchar;
		staging_path_to_create_in_taxonomy_array varchar[];
		tmp_new_parent varchar;
		catalogue_ref_var integer;
		parent_ref_var integer; 
		staging_ref integer;
		parent_updated_var boolean;
		source_text varchar;
		tmp_name varchar;
		tmp_level_ref integer;
		last_id integer;
		parent_ref_var_staging integer;
		--ftheeten 2019 02 15
		staging_levels varchar;
		--ftheeten 2019 02 15
		taxonomy_levels varchar;
		--hierarchy_name varchar;
		 _c text;
		 kingdom_id integer;
		 staging_kingdom_id integer;
		 kingdom_name varchar;
		 --kingdom_name varchar;
		
		
	BEGIN
				--FTHEETEN 2019 02 14
		UPDATE staging_catalogue SET  import_exception=NULL WHERE import_ref=req_import_ref; 
		UPDATE staging_catalogue SET import_exception='taxon_already_exists_in_taxonomy' FROM taxonomy WHERE staging_catalogue.import_ref=req_import_ref AND fulltoindex(staging_catalogue.name)=taxonomy.name_indexed AND taxonomy.metadata_ref=var_metadata_ref ;
		--raise notice 'enter handle';
		--2019 02 26 create kingdom if not exists
		PERFORM FROM staging_catalogue WHERE import_ref= req_import_ref AND level_ref=2 ;
		IF NOT FOUND THEN
			SELECT name INTO kingdom_name FROM taxonomy LEFT JOIN imports on taxonomy.id::varchar=imports.taxonomy_kingdom WHERE imports.id=req_import_ref;
			SELECT id INTO kingdom_id  FROM taxonomy WHERE metadata_ref=var_metadata_ref AND level_ref=2 AND fulltoindex(name)=fulltoindex(kingdom_name);
			IF NOT FOUND THEN
				INSERT INTO taxonomy (name, level_ref, metadata_ref, parent_ref) VALUES (kingdom_name, 2, var_metadata_ref, -1) RETURNING id INTO kingdom_id;
			END IF;
			INSERT INTO staging_catalogue (import_ref, name, level_ref, name_cluster, imported) VALUES
				(req_import_ref, kingdom_name, 2, (SELECT MAX(name_cluster::integer)+1 FROM staging_catalogue WHERE import_ref= req_import_ref ), FALSE) RETURNING id INTO staging_kingdom_id;
			RAISE NOTICE 'ADDED KINGDOM';
			UPDATE staging_catalogue SET parent_ref= staging_kingdom_id WHERe parent_ref IS NULL and level_ref>2 AND import_ref=req_import_ref;
		END IF;
		
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=2 and taxonomy_metadata.id=var_metadata_ref
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=2 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name) AND metadata_ref= var_metadata_ref;
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,2,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
				END IF;
			END LOOP;
		--create phylum beforehand if not exists
		i:=0;
		--ftheeten 2018 12 14
		/*FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=4 and taxonomy_metadata.id=var_metadata_ref
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=4 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name) AND metadata_ref= var_metadata_ref;
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,4,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
				END IF;
			END LOOP;

                */
		
		
		FOR staging_catalogue_line IN SELECT staging_catalogue.*, taxonomy_metadata.id as metadata_id FROM staging_catalogue 
		LEFT JOIN imports ON
		staging_catalogue.import_ref=imports.id
		LEFT JOIN taxonomy_metadata
		ON 
		imports.specimen_taxonomy_ref=taxonomy_metadata.id 
		WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE 
		AND 
		--new 2019 02 26
		taxonomy_metadata.id=var_metadata_ref  
		ORDER BY staging_catalogue.level_ref 
		DESC
		, fulltoindex(staging_catalogue.name) ASC
		--LOOP 1			
		LOOP
				raise notice 'in loop';
				raise notice '------------------------------%',(i::varchar);
				raise notice '------------------------------%',(staging_catalogue_line.id::varchar);
				--raise notice 'id %', staging_catalogue_line.id;
				--raise notice 'catalogue_ref %', staging_catalogue_line.catalogue_ref;
				raise notice 'name %', staging_catalogue_line.name;
				--take only not yet updated lines into considerations 
				--(attention this field can bbe updated from within the cursor) !

				--IF ONE
				IF staging_catalogue_line.catalogue_ref IS NULL AND staging_catalogue_line.parent_updated = FALSE THEN

					--FTHEETEN 2019 02 14


					
 					RAISE NOTICE 'try import';
					raise notice 'line id=%',staging_catalogue_line.id ;
					raise notice 'test %',staging_catalogue_line.id;
					SELECT fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy INTO test_taxo FROM fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(staging_catalogue_line.id);
					existing_longest_path=test_taxo[1];
					existing_longest_path_staging=test_taxo[3];
					higher_found_taxon=test_taxo[4];
					staging_levels=test_taxo[6];
					taxonomy_levels=test_taxo[7];
					existing_longest_path_array=string_to_array( existing_longest_path, '/');
					existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');

					RAISE NOTICE 'Existing longest path %', existing_longest_path; 
					RAISE NOTICE 'Existing longest path staging %', existing_longest_path_staging;
					RAISE NOTICE 'Higher found taxon %', higher_found_taxon;
					RAISE NOTICE 'Staging level path %', staging_levels;
					RAISE NOTICE 'Taxonomy level path %', taxonomy_levels;
					--IF TWO 
					IF higher_found_taxon::varchar= staging_catalogue_line.id::varchar THEN
						RAISE notice 'taxon found !';
						--whole taxonomic path already in taxonomy
						--update parent_ref and catalogue_ref for the whole path
						--IF THIRD
						existing_longest_path_array_no_null:=array_remove(existing_longest_path_array,'');
						--SELECT taxonomy_name INTO hierarchy_name FROM taxonomy_metadata WHERE taxonomy_metadata.id=(SELECT taxonomy.metadata_ref FROM taxonomy WHERE taxonomy.id::varchar= existing_longest_path_array_no_null[ARRAY_LENGTH(existing_longest_path_array_no_null,1)]) LIMIT 1;
						RAISE NOTICE 'taxonomy of taxon %',  array_remove(existing_longest_path_array,''); 
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
							is_parent:=TRUE;
							--LOOP 2
							FOR i IN  1..ARRAY_LENGTH(existing_longest_path_staging_array,1) LOOP
								tmp_taxonomy_id:=existing_longest_path_array[i];
								tmp_staging_id:=existing_longest_path_staging_array[i];
								--IF FOUR
								If LENGTH(TRIM(tmp_taxonomy_id))>0 AND LENGTH(trim(tmp_staging_id))>0 THEN
									--IF FIVE
									IF is_parent=TRUE THEN
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer WHERE id= staging_catalogue_line.id;								
									--ELSE FIVE	
									ELSE
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer, parent_updated=true, parent_ref=previous_taxonomy_id_as_parent::integer WHERE id= staging_catalogue_line.id;
									--END IF FIVE		
									END IF;
									--MENTION source in the original taxonomy
									--UPDATE taxonomy SET source=TRIM(COALESCE(source,'')||'; '||staging_catalogue_line.source_taxonomy) WHERE id=tmp_taxonomy_id::integer;
									is_parent:=FALSE;
									previous_staging_id_as_parent:=staging_catalogue_line.id;
									previous_taxonomy_id_as_parent:=tmp_taxonomy_id;
								--END IF FOUR
								END IF;
							--END LOOP 2	
							END LOOP;
						--END IF THIRD	
						--ftheeten 2019 02 18
						--RAISE notice 'TRY 1 % %',  staging_catalogue_line.id, hierarchy_name;
							--UPDATE staging_catalogue SET import_exception = 'taxon_already_exists (check '||hierarchy_name||')' WHERE id= staging_catalogue_line.id;
						--ELSE
						--RAISE notice 'TRY 2';
							--ftheeten 2019 02 18
							--UPDATE staging_catalogue SET import_exception = 'taxon_already_exists (check '||hierarchy_name||')' WHERE id= staging_catalogue_line.id;
						END IF;
						--lowest taxon is not in taxonomy
					--END IF TWO
					ELSE
						RAISE notice 'taxon to be created %', staging_catalogue_line.name;
						--take part of path which is already in taxonomy
						--(longest prefix)
						--existing_longest_path=test_taxo[1];
						--existing_longest_path_staging=test_taxo[3];
						--higher_found_taxon=test_taxo[4];
						staging_path_to_create_in_taxonomy=test_taxo[5];
						--RAISE NOTICE 'staging path to create in taxonomy (all) %' , test_taxo;  
						--RAISE NOTICE 'staging path to create in taxonomy %' , test_taxo[5];  
						--first create exisint hierarchy 
						--create taxon in taxonomy and keep id
						--update parent_ref and catalogue_ref

						existing_longest_path_array=string_to_array( existing_longest_path, '/');
						existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
						staging_path_to_create_in_taxonomy_array=string_to_array(staging_path_to_create_in_taxonomy, '/');	
						--IF THIRD B	
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
						
						parent_updated_var:=false;
						--existing taxa
							--LOOP 3
							FOR i IN   1 .. ARRAY_LENGTH( existing_longest_path_array,1) LOOP
								--IF FOUR B
								IF LENGTH(TRIM(existing_longest_path_array[i]))>0 AND LENGTH(TRIM(existing_longest_path_staging_array[i]))>0 THEN
									--RAISE NOTICE 'IN IF';
									catalogue_ref_var:=existing_longest_path_array[i]::int;
									staging_ref:=existing_longest_path_staging_array[i]::int;
									--RAISE NOTICE 'catalogue_ref_var %', catalogue_ref_var;
									--RAISE NOTICE 'staging_ref %', staging_ref;
									--IF FIVE B
									IF parent_updated_var=false THEN
										--RAISE NOTICE 'UPDATE NO PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var
										WHERE id=staging_ref AND parent_updated=false AND parent_ref IS NULL;
									--ELSE FIVE B
									ELSE
										--RAISE NOTICE 'UPDATE  PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var,
										parent_ref=parent_ref_var, parent_updated=true
										WHERE id=staging_ref and parent_updated=false;
									--END IF FIVE B
									END IF;
									parent_updated_var:=true;
									parent_ref_var:=catalogue_ref_var;
									--update source in taxonomy
									--UPDATe taxonomy SET source=COALESCE(source||', '||source_text) WHERE id=catalogue_ref_var;
									--RAISE notice 'parent_ref_var %', parent_ref_var;
								--END IF FOUR B
								END IF;
							--END LOOP 3	
							END LOOP;
						--create new taxa
						--raise notice 'To create array %', staging_path_to_create_in_taxonomy_array; 
						--raise notice 'length array %' , ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1);
						--RAISE notice 'parent_ref_var between loops %', parent_ref_var;
							--LOOP 3 B
							FOR i IN  1..ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1) LOOP
							
								--RAISE NOTICE 'IN LOOP NEW TAXA';
								--IF FOUR C
								IF LENGTH(TRIM(staging_path_to_create_in_taxonomy_array[i]))>0 THEN

								--raise notice 'new taxa id %', staging_path_to_create_in_taxonomy_array[i];
									SELECT name , level_ref, parent_ref INTO tmp_name, tmp_level_ref, parent_ref_var_staging FROM staging_catalogue WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									SELECT catalogue_ref INTO parent_ref_var FROM staging_catalogue WHERe id=parent_ref_var_staging;
									--IF FIVE C
									IF parent_updated_var=false AND parent_ref_var IS NULL THEN 
									BEGIN
										--raise notice 'tmp_name %', tmp_name;
										PERFORM FROM taxonomy WHERe name=tmp_name AND  level_ref=tmp_level_ref;
										IF NOT FOUND THEN

											INSERT INTO taxonomy (id, name, level_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
											tmp_name, tmp_level_ref, var_metadata_ref, req_import_ref) 
											RETURNING id INTO last_id;
											UPDATE staging_catalogue SET catalogue_ref=last_id, imported=true
											FROM inserted WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										--raise notice 'last_id A %', last_id;
											parent_ref_var:=last_id;
										ELSE
											RAISE NOTICE 'HIERARCHY EXISTS !!!!!!!!!!!!!!!!!!!!!';
											UPDATE staging_catalogue SET imported=FALSE,
											import_exception='path_already_exists (Hierarchy)'
											||(SELECT taxonomy_metadata.taxonomy_name FROM taxonomy_metadata WHERE taxonomy_metadata.id = (SELECT metadata_ref FROM taxonomy WHERE taxonomy.name=tmp_name AND  taxonomy.level_ref=tmp_level_ref ) LIMIT 1)||')' 
											WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										END IF;
									EXCEPTION WHEN OTHERS THEN
										UPDATE staging_catalogue SET import_exception= SQLERRM WHERE staging_catalogue.id=staging_path_to_create_in_taxonomy_array[i]::int;
									END;
									--ELSIF FIVE C
									ELSIF parent_ref_var IS NOT NULL THEN
									BEGIN
										PERFORM FROM taxonomy WHERe name=tmp_name AND  level_ref=tmp_level_ref AND parent_ref=parent_ref_var;
										IF NOT FOUND THEN
											--raise notice 'tmp_name %', tmp_name;
											--raise notice 'tmp_level_ref %', tmp_level_ref;
											--raise notice 'parent_ref_var %', parent_ref_var;
											--raise notice 'source_text %', source_text;
											INSERT INTO taxonomy (id, name, level_ref, parent_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
											tmp_name, tmp_level_ref, parent_ref_var,  var_metadata_ref, req_import_ref) RETURNING id INTO last_id;
											/*IF staging_levels != taxonomy_levels THEN
												UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true , import_exception = 'taxon_already_exists_with_another_hierarchy' WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											ELSE
											
												UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											END IF;*/
											UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true , import_exception = 'taxon_imported' WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											--raise notice 'last_id B %', last_id;
											 parent_ref_var:=last_id; 
										ELSE
											UPDATE staging_catalogue SET imported=FALSE,
											import_exception='path_already_exists' WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											--raise notice 'last_id B %', last_id;
											 
										END IF;
									--END IF FIVE C
									EXCEPTION WHEN OTHERS THEN
										UPDATE staging_catalogue SET import_exception= SQLERRM WHERE staging_catalogue.id=staging_path_to_create_in_taxonomy_array[i]::int;
									END;
									END IF;
								--END IF FOUR C	
								END IF;
							--END LOOP 3 B	
							END LOOP;
						--END IF THIRD B
						END IF;
					--END IF TWO 	
					END IF;
				ELSE --IF ONE	
				--ELSIF staging_catalogue_line.catalogue_ref IS NOT NULL AND staging_catalogue_line.parent_updated = FALSE THEN
				--partially updated
					raise notice 'else 2';
				--END IF ONE
				END IF;
		--END LOOP ONE
		i:=i+1;
		END LOOP;
		--RAISE NOTICE 'exit';

		UPDATE staging_catalogue
		SET import_exception='taxon_already_exists (check '||taxonomy_name||')'
			FROM taxonomy
			LEFT JOIN taxonomy_metadata
			ON taxonomy.metadata_ref=taxonomy_metadata.id
			 WHERE  
			staging_catalogue.catalogue_ref=taxonomy.id AND staging_catalogue.import_ref=req_import_ref AND imported=FALSE AND catalogue_ref IS NOT NULL
			--new 2019 02 26
			AND taxonomy.metadata_ref=var_metadata_ref;
		UPDATE staging_catalogue
		SET import_exception='could_not_link_taxon_check_upper_ranks'			
			WHERE staging_catalogue.import_ref=req_import_ref AND imported=FALSE AND import_exception IS NULL;
					
		RETURN TRUE;
	EXCEPTION WHEN OTHERS THEN
		RAISE NOTICE 'EXCEPTION';
		RAISE NOTICE '% %', SQLERRM, SQLSTATE;
	        GET STACKED DIAGNOSTICS _c = PG_EXCEPTION_CONTEXT;
		RAISE NOTICE 'context: >>%<<', _c;
		UPDATE imports SET state='error', errors_in_import=SQLERRM||' NAME ('||staging_catalogue_line.name||')'  WHERE id=req_import_ref;
		RETURN FALSE;
	END;
	$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1924 (class 1255 OID 5308897)
-- Name: fct_rmca_handle_non_reference_taxonomies_bck(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_bck(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
		staging_catalogue_line staging_catalogue;
		test_taxo  varchar[];
		higher_found_taxon varchar;
		existing_longest_path varchar;
		existing_longest_path_staging varchar;
		existing_longest_path_array varchar[];
		existing_longest_path_staging_array varchar[];
		tmp_staging_id VARCHAR;
		tmp_taxonomy_id VARCHAR;
		is_parent boolean;
		i INTEGER;
		previous_staging_id_as_parent varchar;
		previous_taxonomy_id_as_parent varchar;
		staging_path_to_create_in_taxonomy varchar;
		staging_path_to_create_in_taxonomy_array varchar[];
		tmp_new_parent varchar;
		catalogue_ref_var integer;
		parent_ref_var integer; 
		staging_ref integer;
		parent_updated_var boolean;
		source_text varchar;
		tmp_name varchar;
		tmp_level_ref integer;
		last_id integer;
		parent_ref_var_staging integer;
		
		
	BEGIN
		--raise notice 'enter handle';

		--create phylum beforehand if not exists
		--ftheeten 2018 12 14
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=4
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=4 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name);
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,4,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
					--2019 02 10
					UPDATE staging_catalogue set imported =true WHERE id=staging_catalogue_line.id;
				ELSE
					UPDATE staging_catalogue set import_exception ='taxon_already_exists' WHERE id=staging_catalogue_line.id;
				END IF;
			END LOOP;
		
		FOR staging_catalogue_line IN SELECT staging_catalogue.*, taxonomy_metadata.id as metadata_id FROM staging_catalogue 
		LEFT JOIN imports ON
		staging_catalogue.import_ref=imports.id
		LEFT JOIN taxonomy_metadata
		ON 
		imports.specimen_taxonomy_ref=taxonomy_metadata.id 
		WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE ORDER BY staging_catalogue.level_ref DESC
		, fulltoindex(staging_catalogue.name) ASC
		--LOOP 1	
		LOOP
				raise notice 'in loop';
				raise notice '------------------------------';
				--raise notice 'id %', staging_catalogue_line.id;
				--raise notice 'catalogue_ref %', staging_catalogue_line.catalogue_ref;
				raise notice 'name %', staging_catalogue_line.name;
				--take only not yet updated lines into considerations 
				--(attention this field can bbe updated from within the cursor) !

				--IF ONE
				IF staging_catalogue_line.catalogue_ref IS NULL AND staging_catalogue_line.parent_updated = FALSE THEN

					--FTHEETEN 2019 02 14
					/*PERFORM FROM taxonomy WHERE taxonomy.name_indexed=fulltoindex(name)
 AND taxonomy.level_ref=staging_catalogue.level_ref AND taxonomy.metadata_ref=metadata_id;
					IF FOUND THEN
						UPDATE staging_catalogue SET import_exception='taxon_already_exists' WHERE id=staging_catalogue_line.id;
					END IF;*/

					
 					--RAISE NOTICE 'try import';
					--raise notice 'line id=%',staging_catalogue_line.id ;
					--raise notice 'test %',staging_catalogue_line.id;
					SELECT fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy INTO test_taxo FROM fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(staging_catalogue_line.id);
					existing_longest_path=test_taxo[1];
					existing_longest_path_staging=test_taxo[3];
					higher_found_taxon=test_taxo[4];
					existing_longest_path_array=string_to_array( existing_longest_path, '/');
					existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
					raise notice '1';
					RAISE NOTICE 'Existing longest path %', existing_longest_path; 
					RAISE NOTICE 'Existing longest path staging %', existing_longest_path_staging;
					RAISE NOTICE 'Higher found taxon %', higher_found_taxon;
					--IF TWO 
					IF higher_found_taxon::varchar= staging_catalogue_line.id::varchar THEN
						RAISE notice 'taxon found';
						--whole taxonomic path already in taxonomy
						--update parent_ref and catalogue_ref for the whole path
						--IF THIRD
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
							is_parent:=TRUE;
							--LOOP 2
							FOR i IN  1..ARRAY_LENGTH(existing_longest_path_staging_array,1) LOOP
								tmp_taxonomy_id:=existing_longest_path_array[i];
								tmp_staging_id:=existing_longest_path_staging_array[i];
								--IF FOUR
								If LENGTH(TRIM(tmp_taxonomy_id))>0 AND LENGTH(trim(tmp_staging_id))>0 THEN
									--IF FIVE
									IF is_parent=TRUE THEN
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer WHERE id= staging_catalogue_line.id;								
									--ELSE FIVE	
									ELSE
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer, parent_updated=true, parent_ref=previous_taxonomy_id_as_parent::integer WHERE id= staging_catalogue_line.id;
									--END IF FIVE		
									END IF;
									--MENTION source in the original taxonomy
									--UPDATE taxonomy SET source=TRIM(COALESCE(source,'')||'; '||staging_catalogue_line.source_taxonomy) WHERE id=tmp_taxonomy_id::integer;
									is_parent:=FALSE;
									previous_staging_id_as_parent:=staging_catalogue_line.id;
									previous_taxonomy_id_as_parent:=tmp_taxonomy_id;
								--END IF FOUR
								END IF;
							--END LOOP 2	
							END LOOP;
						--END IF THIRD	
						END IF;
						--lowest taxon is not in taxonomy
					--END IF TWO
					ELSE
						RAISE notice 'taxon to be created %', staging_catalogue_line.name;
						--take part of path which is already in taxonomy
						--(longest prefix)
						--existing_longest_path=test_taxo[1];
						--existing_longest_path_staging=test_taxo[3];
						--higher_found_taxon=test_taxo[4];
						staging_path_to_create_in_taxonomy=test_taxo[5];
						--RAISE NOTICE 'staging path to create in taxonomy (all) %' , test_taxo;  
						--RAISE NOTICE 'staging path to create in taxonomy %' , test_taxo[5];  
						--first create exisint hierarchy 
						--create taxon in taxonomy and keep id
						--update parent_ref and catalogue_ref

						existing_longest_path_array=string_to_array( existing_longest_path, '/');
						existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
						staging_path_to_create_in_taxonomy_array=string_to_array(staging_path_to_create_in_taxonomy, '/');	
						--IF THIRD B	
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
						
						parent_updated_var:=false;
						--existing taxa
							--LOOP 3
							FOR i IN   1 .. ARRAY_LENGTH( existing_longest_path_array,1) LOOP
								--IF FOUR B
								IF LENGTH(TRIM(existing_longest_path_array[i]))>0 AND LENGTH(TRIM(existing_longest_path_staging_array[i]))>0 THEN
									--RAISE NOTICE 'IN IF';
									catalogue_ref_var:=existing_longest_path_array[i]::int;
									staging_ref:=existing_longest_path_staging_array[i]::int;
									--RAISE NOTICE 'catalogue_ref_var %', catalogue_ref_var;
									--RAISE NOTICE 'staging_ref %', staging_ref;
									--IF FIVE B
									IF parent_updated_var=false THEN
										--RAISE NOTICE 'UPDATE NO PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var
										WHERE id=staging_ref AND parent_updated=false AND parent_ref IS NULL;
									--ELSE FIVE B
									ELSE
										--RAISE NOTICE 'UPDATE  PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var,
										parent_ref=parent_ref_var, parent_updated=true
										WHERE id=staging_ref and parent_updated=false;
									--END IF FIVE B
									END IF;
									parent_updated_var:=true;
									parent_ref_var:=catalogue_ref_var;
									--update source in taxonomy
									--UPDATe taxonomy SET source=COALESCE(source||', '||source_text) WHERE id=catalogue_ref_var;
									--RAISE notice 'parent_ref_var %', parent_ref_var;
								--END IF FOUR B
								END IF;
							--END LOOP 3	
							END LOOP;
						--create new taxa
						--raise notice 'To create array %', staging_path_to_create_in_taxonomy_array; 
						--raise notice 'length array %' , ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1);
						--RAISE notice 'parent_ref_var between loops %', parent_ref_var;
							--LOOP 3 B
							FOR i IN  1..ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1) LOOP
							
								--RAISE NOTICE 'IN LOOP NEW TAXA';
								--IF FOUR C
								IF LENGTH(TRIM(staging_path_to_create_in_taxonomy_array[i]))>0 THEN

								--raise notice 'new taxa id %', staging_path_to_create_in_taxonomy_array[i];
									SELECT name , level_ref, parent_ref INTO tmp_name, tmp_level_ref, parent_ref_var_staging FROM staging_catalogue WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									SELECT catalogue_ref INTO parent_ref_var FROM staging_catalogue WHERe id=parent_ref_var_staging;
									--IF FIVE C
									IF parent_updated_var=false AND parent_ref_var IS NULL THEN 
										--raise notice 'tmp_name %', tmp_name;
										INSERT INTO taxonomy (id, name, level_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
										tmp_name, tmp_level_ref, var_metadata_ref, req_import_ref) 
										RETURNING id INTO last_id;
										UPDATE staging_catalogue SET catalogue_ref=last_id, imported=true
										FROM inserted WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										--raise notice 'last_id A %', last_id;
										 parent_ref_var:=last_id;
									--ELSIF FIVE C
									ELSIF parent_ref_var IS NOT NULL THEN
										--raise notice 'tmp_name %', tmp_name;
										--raise notice 'tmp_level_ref %', tmp_level_ref;
										--raise notice 'parent_ref_var %', parent_ref_var;
										--raise notice 'source_text %', source_text;
										INSERT INTO taxonomy (id, name, level_ref, parent_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
										tmp_name, tmp_level_ref, parent_ref_var,  var_metadata_ref, req_import_ref) RETURNING id INTO last_id;
										UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										--raise notice 'last_id B %', last_id;
										 parent_ref_var:=last_id; 
									--END IF FIVE C
									END IF;
								--END IF FOUR C	
								END IF;
							--END LOOP 3 B	
							END LOOP;
						--END IF THIRD B
						END IF;
					--END IF TWO 	
					END IF;
				--ELSE IF ONE	
				--ELSIF staging_catalogue_line.catalogue_ref IS NOT NULL AND staging_catalogue_line.parent_updated = FALSE THEN
				--partially updated
					--raise notice 'Catalogue_updated';
				--END IF ONE
				END IF;
		--END LOOP ONE
		END LOOP;
		--RAISE NOTICE 'exit';

		--FTHEETEN 2019 02 14
		UPDATE staging_catalogue SET import_exception='taxon_already_exists_in_taxonomy' FROM taxonomy WHERE staging_catalogue.import_ref=req_import_ref AND fulltoindex(staging_catalogue.name)=taxonomy.name_indexed AND taxonomy.metadata_ref=var_metadata_ref;
		RETURN TRUE;
	EXCEPTION WHEN OTHERS THEN
		UPDATE imports SET errors_in_import=SQLERRM  WHERE id=req_import_ref;
		RETURN FALSE;
	END;
	$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_bck(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1919 (class 1255 OID 5308851)
-- Name: fct_rmca_handle_non_reference_taxonomies_bck20190214(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_bck20190214(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
		staging_catalogue_line staging_catalogue;
		test_taxo  varchar[];
		higher_found_taxon varchar;
		existing_longest_path varchar;
		existing_longest_path_staging varchar;
		existing_longest_path_array varchar[];
		existing_longest_path_staging_array varchar[];
		tmp_staging_id VARCHAR;
		tmp_taxonomy_id VARCHAR;
		is_parent boolean;
		i INTEGER;
		previous_staging_id_as_parent varchar;
		previous_taxonomy_id_as_parent varchar;
		staging_path_to_create_in_taxonomy varchar;
		staging_path_to_create_in_taxonomy_array varchar[];
		tmp_new_parent varchar;
		catalogue_ref_var integer;
		parent_ref_var integer; 
		staging_ref integer;
		parent_updated_var boolean;
		source_text varchar;
		tmp_name varchar;
		tmp_level_ref integer;
		last_id integer;
		parent_ref_var_staging integer;
		
		
	BEGIN
		--raise notice 'enter handle';

		--create phylum beforehand if not exists
		--ftheeten 2018 12 14
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=4
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=4 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name);
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,4,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
					--2019 02 10
					UPDATE staging_catalogue set imported =true WHERE id=staging_catalogue_line.id;
				ELSE
					UPDATE staging_catalogue set import_exception ='taxon_already_exists' WHERE id=staging_catalogue_line.id;
				END IF;
			END LOOP;
		
		FOR staging_catalogue_line IN SELECT staging_catalogue.*, taxonomy_metadata.id as metadata_id FROM staging_catalogue 
		LEFT JOIN imports ON
		staging_catalogue.import_ref=imports.id
		LEFT JOIN taxonomy_metadata
		ON 
		imports.specimen_taxonomy_ref=taxonomy_metadata.id 
		WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE ORDER BY staging_catalogue.level_ref DESC
		, fulltoindex(staging_catalogue.name) ASC
		--LOOP 1	
		LOOP
				--raise notice 'in loop';
				--raise notice '------------------------------';
				--raise notice 'id %', staging_catalogue_line.id;
				--raise notice 'catalogue_ref %', staging_catalogue_line.catalogue_ref;
				--raise notice 'name %', staging_catalogue_line.name;
				--take only not yet updated lines into considerations 
				--(attention this field can bbe updated from within the cursor) !

				--IF ONE
				IF staging_catalogue_line.catalogue_ref IS NULL AND staging_catalogue_line.parent_updated = FALSE THEN

					--FTHEETEN 2019 02 14
					/*PERFORM FROM taxonomy WHERE taxonomy.name_indexed=fulltoindex(name)
 AND taxonomy.level_ref=staging_catalogue.level_ref AND taxonomy.metadata_ref=metadata_id;
					IF FOUND THEN
						UPDATE staging_catalogue SET import_exception='taxon_already_exists' WHERE id=staging_catalogue_line.id;
					END IF;*/

					
 					--RAISE NOTICE 'try import';
					--raise notice 'line id=%',staging_catalogue_line.id ;
					--raise notice 'test %',staging_catalogue_line.id;
					SELECT fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy INTO test_taxo FROM fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(staging_catalogue_line.id);
					existing_longest_path=test_taxo[1];
					existing_longest_path_staging=test_taxo[3];
					higher_found_taxon=test_taxo[4];
					existing_longest_path_array=string_to_array( existing_longest_path, '/');
					existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
					--raise notice '1';
					--RAISE NOTICE 'Existing longest path %', existing_longest_path; 
					--RAISE NOTICE 'Existing longest path staging %', existing_longest_path_staging;
					--RAISE NOTICE 'Higher found taxon %', higher_found_taxon;
					--IF TWO 
					IF higher_found_taxon::varchar= staging_catalogue_line.id::varchar THEN
						RAISE notice 'taxon found';
						--whole taxonomic path already in taxonomy
						--update parent_ref and catalogue_ref for the whole path
						--IF THIRD
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
							is_parent:=TRUE;
							--LOOP 2
							FOR i IN  1..ARRAY_LENGTH(existing_longest_path_staging_array,1) LOOP
								tmp_taxonomy_id:=existing_longest_path_array[i];
								tmp_staging_id:=existing_longest_path_staging_array[i];
								--IF FOUR
								If LENGTH(TRIM(tmp_taxonomy_id))>0 AND LENGTH(trim(tmp_staging_id))>0 THEN
									--IF FIVE
									IF is_parent=TRUE THEN
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer WHERE id= staging_catalogue_line.id;								
									--ELSE FIVE	
									ELSE
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer, parent_updated=true, parent_ref=previous_taxonomy_id_as_parent::integer WHERE id= staging_catalogue_line.id;
									--END IF FIVE		
									END IF;
									--MENTION source in the original taxonomy
									--UPDATE taxonomy SET source=TRIM(COALESCE(source,'')||'; '||staging_catalogue_line.source_taxonomy) WHERE id=tmp_taxonomy_id::integer;
									is_parent:=FALSE;
									previous_staging_id_as_parent:=staging_catalogue_line.id;
									previous_taxonomy_id_as_parent:=tmp_taxonomy_id;
								--END IF FOUR
								END IF;
							--END LOOP 2	
							END LOOP;
						--END IF THIRD	
						END IF;
						--lowest taxon is not in taxonomy
					--END IF TWO
					ELSE
						--RAISE notice 'taxon to be created %', staging_catalogue_line.name;
						--take part of path which is already in taxonomy
						--(longest prefix)
						--existing_longest_path=test_taxo[1];
						--existing_longest_path_staging=test_taxo[3];
						--higher_found_taxon=test_taxo[4];
						staging_path_to_create_in_taxonomy=test_taxo[5];
						--RAISE NOTICE 'staging path to create in taxonomy (all) %' , test_taxo;  
						--RAISE NOTICE 'staging path to create in taxonomy %' , test_taxo[5];  
						--first create exisint hierarchy 
						--create taxon in taxonomy and keep id
						--update parent_ref and catalogue_ref

						existing_longest_path_array=string_to_array( existing_longest_path, '/');
						existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
						staging_path_to_create_in_taxonomy_array=string_to_array(staging_path_to_create_in_taxonomy, '/');	
						--IF THIRD B	
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
						
						parent_updated_var:=false;
						--existing taxa
							--LOOP 3
							FOR i IN   1 .. ARRAY_LENGTH( existing_longest_path_array,1) LOOP
								--IF FOUR B
								IF LENGTH(TRIM(existing_longest_path_array[i]))>0 AND LENGTH(TRIM(existing_longest_path_staging_array[i]))>0 THEN
									--RAISE NOTICE 'IN IF';
									catalogue_ref_var:=existing_longest_path_array[i]::int;
									staging_ref:=existing_longest_path_staging_array[i]::int;
									--RAISE NOTICE 'catalogue_ref_var %', catalogue_ref_var;
									--RAISE NOTICE 'staging_ref %', staging_ref;
									--IF FIVE B
									IF parent_updated_var=false THEN
										--RAISE NOTICE 'UPDATE NO PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var
										WHERE id=staging_ref AND parent_updated=false AND parent_ref IS NULL;
									--ELSE FIVE B
									ELSE
										--RAISE NOTICE 'UPDATE  PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var,
										parent_ref=parent_ref_var, parent_updated=true
										WHERE id=staging_ref and parent_updated=false;
									--END IF FIVE B
									END IF;
									parent_updated_var:=true;
									parent_ref_var:=catalogue_ref_var;
									--update source in taxonomy
									--UPDATe taxonomy SET source=COALESCE(source||', '||source_text) WHERE id=catalogue_ref_var;
									--RAISE notice 'parent_ref_var %', parent_ref_var;
								--END IF FOUR B
								END IF;
							--END LOOP 3	
							END LOOP;
						--create new taxa
						--raise notice 'To create array %', staging_path_to_create_in_taxonomy_array; 
						--raise notice 'length array %' , ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1);
						--RAISE notice 'parent_ref_var between loops %', parent_ref_var;
							--LOOP 3 B
							FOR i IN  1..ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1) LOOP
							
								--RAISE NOTICE 'IN LOOP NEW TAXA';
								--IF FOUR C
								IF LENGTH(TRIM(staging_path_to_create_in_taxonomy_array[i]))>0 THEN

								--raise notice 'new taxa id %', staging_path_to_create_in_taxonomy_array[i];
									SELECT name , level_ref, parent_ref INTO tmp_name, tmp_level_ref, parent_ref_var_staging FROM staging_catalogue WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									SELECT catalogue_ref INTO parent_ref_var FROM staging_catalogue WHERe id=parent_ref_var_staging;
									--IF FIVE C
									IF parent_updated_var=false AND parent_ref_var IS NULL THEN 
										--raise notice 'tmp_name %', tmp_name;
										INSERT INTO taxonomy (id, name, level_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
										tmp_name, tmp_level_ref, var_metadata_ref, req_import_ref) 
										RETURNING id INTO last_id;
										UPDATE staging_catalogue SET catalogue_ref=last_id, imported=true
										FROM inserted WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										--raise notice 'last_id A %', last_id;
										 parent_ref_var:=last_id;
									--ELSIF FIVE C
									ELSIF parent_ref_var IS NOT NULL THEN
										--raise notice 'tmp_name %', tmp_name;
										--raise notice 'tmp_level_ref %', tmp_level_ref;
										--raise notice 'parent_ref_var %', parent_ref_var;
										--raise notice 'source_text %', source_text;
										INSERT INTO taxonomy (id, name, level_ref, parent_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
										tmp_name, tmp_level_ref, parent_ref_var,  var_metadata_ref, req_import_ref) RETURNING id INTO last_id;
										UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										--raise notice 'last_id B %', last_id;
										 parent_ref_var:=last_id; 
									--END IF FIVE C
									END IF;
								--END IF FOUR C	
								END IF;
							--END LOOP 3 B	
							END LOOP;
						--END IF THIRD B
						END IF;
					--END IF TWO 	
					END IF;
				--ELSE IF ONE	
				--ELSIF staging_catalogue_line.catalogue_ref IS NOT NULL AND staging_catalogue_line.parent_updated = FALSE THEN
				--partially updated
					--raise notice 'Catalogue_updated';
				--END IF ONE
				END IF;
		--END LOOP ONE
		END LOOP;
		--RAISE NOTICE 'exit';

		--FTHEETEN 2019 02 14
		UPDATE staging_catalogue SET import_exception='taxon_already_exists' FROM taxonomy WHERE staging_catalogue.import_ref=req_import_ref AND fulltoindex(staging_catalogue.name)=taxonomy.name_indexed AND taxonomy.metadata_ref=var_metadata_ref;
		RETURN TRUE;
	END;
	$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_bck20190214(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1921 (class 1255 OID 5308879)
-- Name: fct_rmca_handle_non_reference_taxonomies_json_mauvais(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_json_mauvais(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
		staging_catalogue_line staging_catalogue;
		test_taxo  jsonb;
		higher_found_taxon varchar;
		--existing_longest_path varchar;
		--existing_longest_path_staging varchar;
		existing_longest_path_array varchar[];
		existing_longest_path_staging_array varchar[];
		tmp_staging_id VARCHAR;
		tmp_taxonomy_id VARCHAR;
		is_parent boolean;
		i INTEGER;
		previous_staging_id_as_parent varchar;
		previous_taxonomy_id_as_parent varchar;
		--staging_path_to_create_in_taxonomy varchar;
		staging_path_to_create_in_taxonomy_array varchar[];
		tmp_new_parent varchar;
		catalogue_ref_var integer;
		parent_ref_var integer; 
		staging_ref integer;
		parent_updated_var boolean;
		source_text varchar;
		tmp_name varchar;
		tmp_level_ref integer;
		last_id integer;
		parent_ref_var_staging integer;
		
		
	BEGIN
		--raise notice 'enter handle';

		--create phylum beforehand if not exists
		--ftheeten 2018 12 14
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=4
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=4 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name);
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,4,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
					--2019 02 10
					UPDATE staging_catalogue set imported =true WHERE id=staging_catalogue_line.id;
				ELSE
					UPDATE staging_catalogue set import_exception ='taxon_already_exists' WHERE id=staging_catalogue_line.id;
				END IF;
			END LOOP;
		
		FOR staging_catalogue_line IN SELECT staging_catalogue.*, taxonomy_metadata.id as metadata_id FROM staging_catalogue 
		LEFT JOIN imports ON
		staging_catalogue.import_ref=imports.id
		LEFT JOIN taxonomy_metadata
		ON 
		imports.specimen_taxonomy_ref=taxonomy_metadata.id 
		WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE ORDER BY staging_catalogue.level_ref DESC
		, fulltoindex(staging_catalogue.name) ASC
		--LOOP 1	
		LOOP
				--raise notice 'in loop';
				--raise notice '------------------------------';
				--raise notice 'id %', staging_catalogue_line.id;
				--raise notice 'catalogue_ref %', staging_catalogue_line.catalogue_ref;
				--raise notice 'name %', staging_catalogue_line.name;
				--take only not yet updated lines into considerations 
				--(attention this field can bbe updated from within the cursor) !

				--IF ONE
				IF staging_catalogue_line.catalogue_ref IS NULL AND staging_catalogue_line.parent_updated = FALSE THEN

					--FTHEETEN 2019 02 14
					/*PERFORM FROM taxonomy WHERE taxonomy.name_indexed=fulltoindex(name)
 AND taxonomy.level_ref=staging_catalogue.level_ref AND taxonomy.metadata_ref=metadata_id;
					IF FOUND THEN
						UPDATE staging_catalogue SET import_exception='taxon_already_exists' WHERE id=staging_catalogue_line.id;
					END IF;*/

					
 					--RAISE NOTICE 'try import';
					--raise notice 'line id=%',staging_catalogue_line.id ;
					--raise notice 'test %',staging_catalogue_line.id;
					SELECT fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy INTO test_taxo FROM fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(staging_catalogue_line.id);
					existing_longest_path_array=test_taxo->1;
					existing_longest_path_staging_array=test_taxo->3;
					higher_found_taxon=test_taxo->4;
					--existing_longest_path_array= existing_longest_path;
					--existing_longest_path_staging_array= existing_longest_path_staging;
					--raise notice '1';
					--RAISE NOTICE 'Existing longest path %', existing_longest_path; 
					--RAISE NOTICE 'Existing longest path staging %', existing_longest_path_staging;
					--RAISE NOTICE 'Higher found taxon %', higher_found_taxon;
					--IF TWO 
					IF higher_found_taxon::varchar= staging_catalogue_line.id::varchar THEN
						RAISE notice 'taxon found';
						--whole taxonomic path already in taxonomy
						--update parent_ref and catalogue_ref for the whole path
						--IF THIRD
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
							is_parent:=TRUE;
							--LOOP 2
							FOR i IN  1..ARRAY_LENGTH(existing_longest_path_staging_array,1) LOOP
								tmp_taxonomy_id:=existing_longest_path_array[i];
								tmp_staging_id:=existing_longest_path_staging_array[i];
								--IF FOUR
								If LENGTH(TRIM(tmp_taxonomy_id))>0 AND LENGTH(trim(tmp_staging_id))>0 THEN
									--IF FIVE
									IF is_parent=TRUE THEN
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer WHERE id= staging_catalogue_line.id;								
									--ELSE FIVE	
									ELSE
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer, parent_updated=true, parent_ref=previous_taxonomy_id_as_parent::integer WHERE id= staging_catalogue_line.id;
									--END IF FIVE		
									END IF;
									--MENTION source in the original taxonomy
									--UPDATE taxonomy SET source=TRIM(COALESCE(source,'')||'; '||staging_catalogue_line.source_taxonomy) WHERE id=tmp_taxonomy_id::integer;
									is_parent:=FALSE;
									previous_staging_id_as_parent:=staging_catalogue_line.id;
									previous_taxonomy_id_as_parent:=tmp_taxonomy_id;
								--END IF FOUR
								END IF;
							--END LOOP 2	
							END LOOP;
						--END IF THIRD	
						END IF;
						--lowest taxon is not in taxonomy
					--END IF TWO
					ELSE
						--RAISE notice 'taxon to be created %', staging_catalogue_line.name;
						--take part of path which is already in taxonomy
						--(longest prefix)
						--existing_longest_path=test_taxo[1];
						--existing_longest_path_staging=test_taxo[3];
						--higher_found_taxon=test_taxo[4];
						--staging_path_to_create_in_taxonomy=test_taxo->5;
						--RAISE NOTICE 'staging path to create in taxonomy (all) %' , test_taxo;  
						--RAISE NOTICE 'staging path to create in taxonomy %' , test_taxo[5];  
						--first create exisint hierarchy 
						--create taxon in taxonomy and keep id
						--update parent_ref and catalogue_ref

						--existing_longest_path_array= existing_longest_path;
						--existing_longest_path_staging_array= existing_longest_path_staging;
						staging_path_to_create_in_taxonomy_array=test_taxo->5;	
						--IF THIRD B	
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
						
						parent_updated_var:=false;
						--existing taxa
							--LOOP 3
							FOR i IN   1 .. ARRAY_LENGTH( existing_longest_path_array,1) LOOP
								--IF FOUR B
								IF LENGTH(TRIM(existing_longest_path_array[i]))>0 AND LENGTH(TRIM(existing_longest_path_staging_array[i]))>0 THEN
									--RAISE NOTICE 'IN IF';
									catalogue_ref_var:=existing_longest_path_array[i]::int;
									staging_ref:=existing_longest_path_staging_array[i]::int;
									--RAISE NOTICE 'catalogue_ref_var %', catalogue_ref_var;
									--RAISE NOTICE 'staging_ref %', staging_ref;
									--IF FIVE B
									IF parent_updated_var=false THEN
										--RAISE NOTICE 'UPDATE NO PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var
										WHERE id=staging_ref AND parent_updated=false AND parent_ref IS NULL;
									--ELSE FIVE B
									ELSE
										--RAISE NOTICE 'UPDATE  PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var,
										parent_ref=parent_ref_var, parent_updated=true
										WHERE id=staging_ref and parent_updated=false;
									--END IF FIVE B
									END IF;
									parent_updated_var:=true;
									parent_ref_var:=catalogue_ref_var;
									--update source in taxonomy
									--UPDATe taxonomy SET source=COALESCE(source||', '||source_text) WHERE id=catalogue_ref_var;
									--RAISE notice 'parent_ref_var %', parent_ref_var;
								--END IF FOUR B
								END IF;
							--END LOOP 3	
							END LOOP;
						--create new taxa
						--raise notice 'To create array %', staging_path_to_create_in_taxonomy_array; 
						--raise notice 'length array %' , ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1);
						--RAISE notice 'parent_ref_var between loops %', parent_ref_var;
							--LOOP 3 B
							FOR i IN  1..ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1) LOOP
							
								--RAISE NOTICE 'IN LOOP NEW TAXA';
								--IF FOUR C
								IF LENGTH(TRIM(staging_path_to_create_in_taxonomy_array[i]))>0 THEN

								--raise notice 'new taxa id %', staging_path_to_create_in_taxonomy_array[i];
									SELECT name , level_ref, parent_ref INTO tmp_name, tmp_level_ref, parent_ref_var_staging FROM staging_catalogue WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									SELECT catalogue_ref INTO parent_ref_var FROM staging_catalogue WHERe id=parent_ref_var_staging;
									--IF FIVE C
									IF parent_updated_var=false AND parent_ref_var IS NULL THEN 
										--raise notice 'tmp_name %', tmp_name;
										INSERT INTO taxonomy (id, name, level_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
										tmp_name, tmp_level_ref, var_metadata_ref, req_import_ref) 
										RETURNING id INTO last_id;
										UPDATE staging_catalogue SET catalogue_ref=last_id, imported=true
										FROM inserted WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										--raise notice 'last_id A %', last_id;
										 parent_ref_var:=last_id;
									--ELSIF FIVE C
									ELSIF parent_ref_var IS NOT NULL THEN
										--raise notice 'tmp_name %', tmp_name;
										--raise notice 'tmp_level_ref %', tmp_level_ref;
										--raise notice 'parent_ref_var %', parent_ref_var;
										--raise notice 'source_text %', source_text;
										INSERT INTO taxonomy (id, name, level_ref, parent_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
										tmp_name, tmp_level_ref, parent_ref_var,  var_metadata_ref, req_import_ref) RETURNING id INTO last_id;
										UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										--raise notice 'last_id B %', last_id;
										 parent_ref_var:=last_id; 
									--END IF FIVE C
									END IF;
								--END IF FOUR C	
								END IF;
							--END LOOP 3 B	
							END LOOP;
						--END IF THIRD B
						END IF;
					--END IF TWO 	
					END IF;
				--ELSE IF ONE	
				--ELSIF staging_catalogue_line.catalogue_ref IS NOT NULL AND staging_catalogue_line.parent_updated = FALSE THEN
				--partially updated
					--raise notice 'Catalogue_updated';
				--END IF ONE
				END IF;
		--END LOOP ONE
		END LOOP;
		--RAISE NOTICE 'exit';

		--FTHEETEN 2019 02 14
		UPDATE staging_catalogue SET import_exception='taxon_already_exists' FROM taxonomy WHERE staging_catalogue.import_ref=req_import_ref AND fulltoindex(staging_catalogue.name)=taxonomy.name_indexed AND taxonomy.metadata_ref=var_metadata_ref;
		RETURN TRUE;
	END;
	$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_json_mauvais(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1938 (class 1255 OID 5309281)
-- Name: fct_rmca_handle_non_reference_taxonomies_same_taxo(integer, integer, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_same_taxo(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
		staging_catalogue_line staging_catalogue;
		test_taxo  varchar[];
		higher_found_taxon varchar;
		existing_longest_path varchar;
		existing_longest_path_staging varchar;
		existing_longest_path_array varchar[];
		--marielle adam 2019 02 28
		existing_longest_path_array_no_null varchar[];
		existing_longest_path_staging_array varchar[];
		tmp_staging_id VARCHAR;
		tmp_taxonomy_id VARCHAR;
		is_parent boolean;
		i INTEGER;
		previous_staging_id_as_parent varchar;
		previous_taxonomy_id_as_parent varchar;
		staging_path_to_create_in_taxonomy varchar;
		staging_path_to_create_in_taxonomy_array varchar[];
		tmp_new_parent varchar;
		catalogue_ref_var integer;
		parent_ref_var integer; 
		staging_ref integer;
		parent_updated_var boolean;
		source_text varchar;
		tmp_name varchar;
		tmp_level_ref integer;
		last_id integer;
		parent_ref_var_staging integer;
		--ftheeten 2019 02 15
		staging_levels varchar;
		--ftheeten 2019 02 15
		taxonomy_levels varchar;
		--hierarchy_name varchar;
		 _c text;
		 kingdom_id integer;
		 --kingdom_name varchar;
		
		
	BEGIN
				--FTHEETEN 2019 02 14
		UPDATE staging_catalogue SET import_exception='taxon_already_exists_in_taxonomy' FROM taxonomy WHERE staging_catalogue.import_ref=req_import_ref AND fulltoindex(staging_catalogue.name)=taxonomy.name_indexed AND taxonomy.metadata_ref=var_metadata_ref;
		--raise notice 'enter handle';

		--create phylum beforehand if not exists
		i:=0;
		--ftheeten 2018 12 14
		FOR staging_catalogue_line IN SELECT staging_catalogue.* FROM staging_catalogue
			LEFT JOIN imports ON
			staging_catalogue.import_ref=imports.id
			LEFT JOIN taxonomy_metadata
			ON 
			imports.specimen_taxonomy_ref=taxonomy_metadata.id  
			WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE
			AND level_ref=4
			LOOP
				PERFORM id FROM taxonomy WHERE level_ref=4 AND fulltoindex(taxonomy.name)=fulltoindex(staging_catalogue_line.name) AND metadata_ref=var_metadata_ref;
				IF NOT FOUND THEN
					INSERT INTO taxonomy (name, level_ref, metadata_ref, import_ref, parent_ref) VALUES(staging_catalogue_line.name,4,var_metadata_ref, req_import_ref, (SELECT taxonomy_kingdom::integer FROM imports where id= req_import_ref));
				END IF;
			END LOOP;

                
		
		
		FOR staging_catalogue_line IN SELECT staging_catalogue.*, taxonomy_metadata.id as metadata_id FROM staging_catalogue 
		LEFT JOIN imports ON
		staging_catalogue.import_ref=imports.id
		LEFT JOIN taxonomy_metadata
		ON 
		imports.specimen_taxonomy_ref=taxonomy_metadata.id 
		WHERE staging_catalogue.import_ref= req_import_ref AND taxonomy_metadata.is_reference_taxonomy= FALSE ORDER BY staging_catalogue.level_ref DESC
		, fulltoindex(staging_catalogue.name) ASC
		--LOOP 1			
		LOOP
				raise notice 'in loop';
				raise notice '------------------------------%',(i::varchar);
				raise notice '------------------------------%',(staging_catalogue_line.id::varchar);
				--raise notice 'id %', staging_catalogue_line.id;
				--raise notice 'catalogue_ref %', staging_catalogue_line.catalogue_ref;
				raise notice 'name %', staging_catalogue_line.name;
				--take only not yet updated lines into considerations 
				--(attention this field can bbe updated from within the cursor) !

				--IF ONE
				IF staging_catalogue_line.catalogue_ref IS NULL AND staging_catalogue_line.parent_updated = FALSE THEN

					--FTHEETEN 2019 02 14
					/*PERFORM FROM taxonomy WHERE taxonomy.name_indexed=fulltoindex(name)
 AND taxonomy.level_ref=staging_catalogue.level_ref AND taxonomy.metadata_ref=metadata_id;
					IF FOUND THEN
						UPDATE staging_catalogue SET import_exception='taxon_already_exists' WHERE id=staging_catalogue_line.id;
					END IF;*/

					
 					--RAISE NOTICE 'try import';
					--raise notice 'line id=%',staging_catalogue_line.id ;
					--raise notice 'test %',staging_catalogue_line.id;
					SELECT fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy INTO test_taxo FROM fct_rmca_get_merge_catalogue_path_in_staging_existing_taxonomy(staging_catalogue_line.id
					--new 2019 02 26 stay in the same taxo
					,var_metadata_ref
					);
					existing_longest_path=test_taxo[1];
					existing_longest_path_staging=test_taxo[3];
					higher_found_taxon=test_taxo[4];
					staging_levels=test_taxo[6];
					taxonomy_levels=test_taxo[7];
					existing_longest_path_array=string_to_array( existing_longest_path, '/');
					existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');

					RAISE NOTICE 'Existing longest path %', existing_longest_path; 
					RAISE NOTICE 'Existing longest path staging %', existing_longest_path_staging;
					RAISE NOTICE 'Higher found taxon %', higher_found_taxon;
					RAISE NOTICE 'Staging level path %', staging_levels;
					RAISE NOTICE 'Taxonomy level path %', taxonomy_levels;
					--IF TWO 
					IF higher_found_taxon::varchar= staging_catalogue_line.id::varchar THEN
						RAISE notice 'taxon found !';
						--whole taxonomic path already in taxonomy
						--update parent_ref and catalogue_ref for the whole path
						--IF THIRD
						existing_longest_path_array_no_null:=array_remove(existing_longest_path_array,'');

						RAISE NOTICE 'taxonomy of taxon %',  array_remove(existing_longest_path_array,''); 
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
							is_parent:=TRUE;
							--LOOP 2
							FOR i IN  1..ARRAY_LENGTH(existing_longest_path_staging_array,1) LOOP
								tmp_taxonomy_id:=existing_longest_path_array[i];
								tmp_staging_id:=existing_longest_path_staging_array[i];
								--IF FOUR
								If LENGTH(TRIM(tmp_taxonomy_id))>0 AND LENGTH(trim(tmp_staging_id))>0 THEN
									--IF FIVE
									IF is_parent=TRUE THEN
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer WHERE id= staging_catalogue_line.id;								
									--ELSE FIVE	
									ELSE
										UPDATE staging_catalogue SET catalogue_ref=tmp_taxonomy_id::integer, parent_updated=true, parent_ref=previous_taxonomy_id_as_parent::integer WHERE id= staging_catalogue_line.id;
									--END IF FIVE		
									END IF;
									--MENTION source in the original taxonomy
									--UPDATE taxonomy SET source=TRIM(COALESCE(source,'')||'; '||staging_catalogue_line.source_taxonomy) WHERE id=tmp_taxonomy_id::integer;
									is_parent:=FALSE;
									previous_staging_id_as_parent:=staging_catalogue_line.id;
									previous_taxonomy_id_as_parent:=tmp_taxonomy_id;
								--END IF FOUR
								END IF;
							--END LOOP 2	
							END LOOP;
						
						END IF;
						--lowest taxon is not in taxonomy
					--END IF TWO
					ELSE
						RAISE notice 'taxon to be created %', staging_catalogue_line.name;
						--take part of path which is already in taxonomy
						--(longest prefix)
						--existing_longest_path=test_taxo[1];
						--existing_longest_path_staging=test_taxo[3];
						--higher_found_taxon=test_taxo[4];
						staging_path_to_create_in_taxonomy=test_taxo[5];
						--RAISE NOTICE 'staging path to create in taxonomy (all) %' , test_taxo;  
						--RAISE NOTICE 'staging path to create in taxonomy %' , test_taxo[5];  
						--first create exisint hierarchy 
						--create taxon in taxonomy and keep id
						--update parent_ref and catalogue_ref

						existing_longest_path_array=string_to_array( existing_longest_path, '/');
						existing_longest_path_staging_array=string_to_array( existing_longest_path_staging, '/');
						staging_path_to_create_in_taxonomy_array=string_to_array(staging_path_to_create_in_taxonomy, '/');	
						--IF THIRD B	
						IF(ARRAY_LENGTH(existing_longest_path_array,1)=ARRAY_LENGTH(existing_longest_path_staging_array,1)) THEN
						
						parent_updated_var:=false;
						--existing taxa
							--LOOP 3
							FOR i IN   1 .. ARRAY_LENGTH( existing_longest_path_array,1) LOOP
								--IF FOUR B
								IF LENGTH(TRIM(existing_longest_path_array[i]))>0 AND LENGTH(TRIM(existing_longest_path_staging_array[i]))>0 THEN
									--RAISE NOTICE 'IN IF';
									catalogue_ref_var:=existing_longest_path_array[i]::int;
									staging_ref:=existing_longest_path_staging_array[i]::int;
									--RAISE NOTICE 'catalogue_ref_var %', catalogue_ref_var;
									--RAISE NOTICE 'staging_ref %', staging_ref;
									--IF FIVE B
									IF parent_updated_var=false THEN
										--RAISE NOTICE 'UPDATE NO PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var
										WHERE id=staging_ref AND parent_updated=false AND parent_ref IS NULL;
									--ELSE FIVE B
									ELSE
										--RAISE NOTICE 'UPDATE  PARENT';
										UPDATE staging_catalogue SET catalogue_ref=catalogue_ref_var,
										parent_ref=parent_ref_var, parent_updated=true
										WHERE id=staging_ref and parent_updated=false;
									--END IF FIVE B
									END IF;
									parent_updated_var:=true;
									parent_ref_var:=catalogue_ref_var;
									--update source in taxonomy
									--UPDATe taxonomy SET source=COALESCE(source||', '||source_text) WHERE id=catalogue_ref_var;
									--RAISE notice 'parent_ref_var %', parent_ref_var;
								--END IF FOUR B
								END IF;
							--END LOOP 3	
							END LOOP;
						--create new taxa
						--raise notice 'To create array %', staging_path_to_create_in_taxonomy_array; 
						--raise notice 'length array %' , ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1);
						--RAISE notice 'parent_ref_var between loops %', parent_ref_var;
							--LOOP 3 B
							FOR i IN  1..ARRAY_LENGTH( staging_path_to_create_in_taxonomy_array,1) LOOP
							
								--RAISE NOTICE 'IN LOOP NEW TAXA';
								--IF FOUR C
								IF LENGTH(TRIM(staging_path_to_create_in_taxonomy_array[i]))>0 THEN

								--raise notice 'new taxa id %', staging_path_to_create_in_taxonomy_array[i];
									SELECT name , level_ref, parent_ref INTO tmp_name, tmp_level_ref, parent_ref_var_staging FROM staging_catalogue WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
									SELECT catalogue_ref INTO parent_ref_var FROM staging_catalogue WHERe id=parent_ref_var_staging;
									--IF FIVE C
									IF parent_updated_var=false AND parent_ref_var IS NULL THEN 
									BEGIN
										--raise notice 'tmp_name %', tmp_name;
										PERFORM FROM taxonomy WHERe name=tmp_name AND  level_ref=tmp_level_ref;
										IF NOT FOUND THEN

											INSERT INTO taxonomy (id, name, level_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
											tmp_name, tmp_level_ref, var_metadata_ref, req_import_ref) 
											RETURNING id INTO last_id;
											UPDATE staging_catalogue SET catalogue_ref=last_id, imported=true
											FROM inserted WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										--raise notice 'last_id A %', last_id;
											parent_ref_var:=last_id;
										ELSE
											RAISE NOTICE 'HIERARCHY EXISTS !!!!!!!!!!!!!!!!!!!!!';
											UPDATE staging_catalogue SET imported=FALSE,
											import_exception='path_already_exists (Hierarchy)'
											||(SELECT taxonomy_metadata.taxonomy_name FROM taxonomy_metadata WHERE taxonomy_metadata.id = (SELECT metadata_ref FROM taxonomy WHERE taxonomy.name=tmp_name AND  taxonomy.level_ref=tmp_level_ref ) LIMIT 1)||')' 
											WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
										END IF;
									EXCEPTION WHEN OTHERS THEN
										UPDATE staging_catalogue SET import_exception= SQLERRM WHERE staging_catalogue.id=staging_path_to_create_in_taxonomy_array[i]::int;
									END;
									--ELSIF FIVE C
									ELSIF parent_ref_var IS NOT NULL THEN
									BEGIN
										PERFORM FROM taxonomy WHERe name=tmp_name AND  level_ref=tmp_level_ref AND parent_ref=parent_ref_var AND metadata_ref=var_metadata_ref;
										IF NOT FOUND THEN
											--raise notice 'tmp_name %', tmp_name;
											--raise notice 'tmp_level_ref %', tmp_level_ref;
											--raise notice 'parent_ref_var %', parent_ref_var;
											--raise notice 'source_text %', source_text;
											INSERT INTO taxonomy (id, name, level_ref, parent_ref,  metadata_ref, import_ref) VALUES (DEFAULT,
											tmp_name, tmp_level_ref, parent_ref_var,  var_metadata_ref, req_import_ref) RETURNING id INTO last_id;
											/*IF staging_levels != taxonomy_levels THEN
												UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true , import_exception = 'taxon_already_exists_with_another_hierarchy' WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											ELSE
											
												UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											END IF;*/
											UPDATE staging_catalogue SET catalogue_ref=last_id, parent_ref=parent_ref_var, parent_updated=TRUE, imported=true , import_exception = 'taxon_imported' WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											--raise notice 'last_id B %', last_id;
											 parent_ref_var:=last_id; 
										ELSE
											UPDATE staging_catalogue SET imported=FALSE,
											import_exception='path_already_exists' WHERE id=staging_path_to_create_in_taxonomy_array[i]::int;
											--raise notice 'last_id B %', last_id;
											 
										END IF;
									--END IF FIVE C
									EXCEPTION WHEN OTHERS THEN
										UPDATE staging_catalogue SET import_exception= SQLERRM WHERE staging_catalogue.id=staging_path_to_create_in_taxonomy_array[i]::int;
									END;
									END IF;
								--END IF FOUR C	
								END IF;
							--END LOOP 3 B	
							END LOOP;
						--END IF THIRD B
						END IF;
					--END IF TWO 	
					END IF;
				--ELSE IF ONE	
				--ELSIF staging_catalogue_line.catalogue_ref IS NOT NULL AND staging_catalogue_line.parent_updated = FALSE THEN
				--partially updated
					--raise notice 'Catalogue_updated';
				--END IF ONE
				END IF;
		--END LOOP ONE
		i:=i+1;
		END LOOP;
		--RAISE NOTICE 'exit';

		UPDATE staging_catalogue
		SET import_exception='taxon_already_exists (check '||taxonomy_name||')'
			FROM taxonomy
			LEFT JOIN taxonomy_metadata
			ON taxonomy.metadata_ref=taxonomy_metadata.id
			 WHERE  
			staging_catalogue.catalogue_ref=taxonomy.id AND staging_catalogue.import_ref=req_import_ref AND imported=FALSE AND catalogue_ref IS NOT NULL;
		UPDATE staging_catalogue
		SET import_exception='could_not_link_taxon_check_upper_ranks'			
			WHERE staging_catalogue.import_ref=req_import_ref AND imported=FALSE AND import_exception IS NULL;
					
		RETURN TRUE;
	EXCEPTION WHEN OTHERS THEN
		RAISE NOTICE 'EXCEPTION';
		RAISE NOTICE '% %', SQLERRM, SQLSTATE;
	        GET STACKED DIAGNOSTICS _c = PG_EXCEPTION_CONTEXT;
		RAISE NOTICE 'context: >>%<<', _c;
		UPDATE imports SET state='error', errors_in_import=SQLERRM||' NAME ('||staging_catalogue_line.name||')'  WHERE id=req_import_ref;
		RETURN FALSE;
	END;
	$$;


ALTER FUNCTION darwin2.fct_rmca_handle_non_reference_taxonomies_same_taxo(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) OWNER TO darwin2;

--
-- TOC entry 1913 (class 1255 OID 5307731)
-- Name: fct_rmca_imp_checker_gtu_search_code(darwin2.staging, boolean); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, import boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	counter integer;
	gtu_ids integer[];
BEGIN
raise notice 'in function';
raise notice 'staging gtu code %', line.gtu_code;
  SELECT count(gtu.id), array_agg(gtu.id) INTO counter, gtu_ids FROM gtu WHERE TRIM(LOWER(gtu.code))=TRIM(LOWER(line.gtu_code));

  IF counter = 0 THEN
	UPDATE staging SET status = (status || hstore('gtu' , 'not_found')) where staging.id= line.id; 
  ELSEIF counter=1 THEN
	UPDATE staging SET gtu_ref=gtu_ids[1] where staging.id= line.id; 
  ELSEIF counter>1 THEN
	UPDATE staging SET status = (status || hstore('gtu' , 'too_much')) where staging.id= line.id; 
  END IF;

  

  RETURN true;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, import boolean) OWNER TO postgres;

--
-- TOC entry 1911 (class 1255 OID 5308233)
-- Name: fct_rmca_keep_staging_catalogue_parent(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_keep_staging_catalogue_parent() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP ='INSERT' THEN
    NEW.parent_ref_internal=NEW.parent_ref;
  
  ELSIF TG_OP ='UPDATE' AND NEW.parent_updated=FALSE  THEN
    NEW.parent_ref_internal=NEW.parent_ref;  
    
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_keep_staging_catalogue_parent() OWNER TO darwin2;

--
-- TOC entry 1910 (class 1255 OID 5307720)
-- Name: fct_rmca_people_array_to_name(integer[]); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_people_array_to_name(int_array integer[]) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE returned varchar;
BEGIN
returned = NULL;
If array_length(int_array,1) >=1 THEN

SELECT  formated_name into returned FROM people where id= int_array[1] limit 1;
end if;
return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_people_array_to_name(int_array integer[]) OWNER TO darwin2;

--
-- TOC entry 1930 (class 1255 OID 5309145)
-- Name: fct_rmca_redo_taxonomic_import(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_redo_taxonomic_import(req_import_ref integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	--2019 02 19
	returned boolean;
BEGIN
	returned=false;
	 UPDATE  darwin2.staging_catalogue set catalogue_ref=NULL ,parent_updated=FALSE where import_ref=req_import_Ref;
	UPDATE imports set state='loaded' wHERE id=req_import_Ref;
	--PERFORM fct_importer_catalogue(req_import_Ref, 'taxonomy', TRUE);
	returned:=true;
	return returned;
	
END
$$;


ALTER FUNCTION darwin2.fct_rmca_redo_taxonomic_import(req_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1814 (class 1255 OID 4816448)
-- Name: fct_rmca_retrieve_taxa_in_collection_fastly_array(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_retrieve_taxa_in_collection_fastly_array(integer) RETURNS SETOF integer[]
    LANGUAGE sql
    AS $_$
SELECT DISTINCT array_agg(id) FROM taxonomy 
                 INNER JOIN
                (
                       SELECT distinct unnest(string_to_array(taxon_path||'/'||taxon_ref::varchar, '/'))  as key_taxon from specimens where  collection_ref =$1 OR collection_path LIKE '%/'||$1||'/%'
                       
                      
                        AND taxon_path is not null 
                ) AS specimens
                        ON
                        taxonomy.id::text = specimens.key_taxon
                        $_$;


ALTER FUNCTION darwin2.fct_rmca_retrieve_taxa_in_collection_fastly_array(integer) OWNER TO darwin2;

--
-- TOC entry 1746 (class 1255 OID 4816449)
-- Name: fct_rmca_sort_taxon_get_parent_level(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_get_parent_level(id_taxon integer, id_level integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned int;
 arr varchar[];
 path_elem varchar;
 tmp_level int;
BEGIN
	returned:=-1;
	arr:= regexp_split_to_array((SELECt path FROM taxonomy where id=id_taxon),'/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		SELECT level_ref INTO tmp_level FROM taxonomy WHERE id= COALESCE(NULLIF(path_elem,''),'-1')::int;
		IF tmp_level=id_level THEN
			RETURN path_elem::int;
		END if;
      END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_get_parent_level(id_taxon integer, id_level integer) OWNER TO darwin2;

--
-- TOC entry 1818 (class 1255 OID 4816450)
-- Name: fct_rmca_sort_taxon_get_parent_level_text(integer, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_get_parent_level_text(id_taxon integer, id_level integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;
 arr varchar[];
 path_elem varchar;
 tmp_level int;
 tmp_name varchar;
BEGIN
	returned:=NULL;
	arr:= regexp_split_to_array((SELECt path FROM taxonomy where id=id_taxon),'/');
	--added if lower taxon known is family
	SELECT level_ref,name INTO tmp_level,tmp_name FROM taxonomy WHERE id= COALESCE(NULLIF(id_taxon::text,''),'-1')::int;
	IF tmp_level=id_level THEN
			RETURN tmp_name;
	END if;
	--end added
	FOR path_elem IN SELECT unnest(arr)
	LOOP
		SELECT level_ref,name INTO tmp_level,tmp_name FROM taxonomy WHERE id= COALESCE(NULLIF(path_elem,''),'-1')::int;
		IF tmp_level=id_level THEN
			RETURN tmp_name;
		END if;
	END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_get_parent_level_text(id_taxon integer, id_level integer) OWNER TO darwin2;

--
-- TOC entry 1819 (class 1255 OID 4816451)
-- Name: fct_rmca_sort_taxon_path_alphabetically(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically(path character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
BEGIN
	returned ='';
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			SELECT name_indexed INTO tmp FROM taxonomy where id=path_elem::int;
			returned=returned||'/'||tmp;
		END IF;
      END LOOP;

	return returned||'/';
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically(path character varying) OWNER TO darwin2;

--
-- TOC entry 1914 (class 1255 OID 5308258)
-- Name: fct_rmca_sort_taxon_path_alphabetically(character varying, integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically(path character varying, last_level integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
 level integer;
 name_rank varchar;
 full_name varchar;
BEGIN
	returned ='';
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			IF with_rank = FALSE THEN
				SELECT name_indexed, level_ref, name INTO tmp, level, full_name FROM taxonomy where taxonomy.id=path_elem::int;
				IF level>= last_level then
					IF is_indexed=FALSE THEN
						tmp:=full_name;
					END IF;
					returned=returned||'/'||tmp;
				END IF;
			ELSE
				SELECT name_indexed, level_ref, level_name, name INTO tmp, level, name_rank , full_name FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id where taxonomy.id=path_elem::int;
				IF level>= last_level then
					IF is_indexed=FALSE THEN
						tmp:=full_name;
					END IF;
					returned=returned||'/'||tmp||' ('||name_rank||')';
				END IF;
			END IF;
		END IF;
      END LOOP;

	return returned||'/';
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically(path character varying, last_level integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1820 (class 1255 OID 4816452)
-- Name: fct_rmca_sort_taxon_path_alphabetically_hstore(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore(path character varying) RETURNS public.hstore
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned hstore;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
 level integer;
 name_rank varchar;
 full_name varchar;
BEGIN
	returned =''::hstore;
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			
				SELECT name_indexed, level_ref, level_name, name INTO tmp, level, name_rank , full_name FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id where taxonomy.id=path_elem::int;
					
				returned:=returned||hstore(name_rank,full_name );
				
			
		END IF;
      END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore(path character varying) OWNER TO darwin2;

--
-- TOC entry 1821 (class 1255 OID 4816453)
-- Name: fct_rmca_sort_taxon_path_alphabetically_hstore_bck20180829(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore_bck20180829(path character varying) RETURNS public.hstore
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned hstore;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
 level integer;
 name_rank varchar;
 full_name varchar;
BEGIN
	returned =''::hstore;
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			
				SELECT name_indexed, level_ref, level_name, name INTO tmp, level, name_rank , full_name FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id where taxonomy.id=path_elem::int;

					raise notice '%s',full_name;
				returned=returned||hstore(name_rank,full_name) ;
				
			
		END IF;
      END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore_bck20180829(path character varying) OWNER TO darwin2;

--
-- TOC entry 1822 (class 1255 OID 4816454)
-- Name: fct_rmca_sort_taxon_path_alphabetically_hstore_key(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore_key(path character varying) RETURNS public.hstore
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned hstore;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
 level integer;
 name_rank varchar;
 full_name varchar;
BEGIN
	returned =''::hstore;
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			
				SELECT name_indexed, level_ref, level_name, name INTO tmp, level, name_rank , full_name FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id where taxonomy.id=path_elem::int;
					
				returned=returned||hstore(level::varchar ,full_name );
				
			
		END IF;
      END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore_key(path character varying) OWNER TO darwin2;

--
-- TOC entry 1823 (class 1255 OID 4816455)
-- Name: fct_rmca_sort_taxon_path_alphabetically_hstore_key_bck20180829(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore_key_bck20180829(path character varying) RETURNS public.hstore
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned hstore;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
 level integer;
 name_rank varchar;
 full_name varchar;
BEGIN
	returned =''::hstore;
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			
				SELECT name_indexed, level_ref, level_name, name INTO tmp, level, name_rank , full_name FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id where taxonomy.id=path_elem::int;
					
				returned=returned||hstore(level::varchar ,full_name );
				
			
		END IF;
      END LOOP;

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_hstore_key_bck20180829(path character varying) OWNER TO darwin2;

--
-- TOC entry 1824 (class 1255 OID 4816456)
-- Name: fct_rmca_sort_taxon_path_alphabetically_not_indexed(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_not_indexed(path character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;
 arr varchar[];
 path_elem varchar;
 tmp varchar;
BEGIN
	returned ='';
	--arr:=	 regexp_matches(trim(path), '([^/]+)' , 'g');
	arr:=regexp_split_to_array(path, '/');
      FOR path_elem IN SELECT unnest(arr)
      LOOP
		IF isnumeric(path_elem) THEN
			SELECT name INTO tmp FROM taxonomy where id=path_elem::int;
			returned=returned||'/'||tmp;
		END IF;
      END LOOP;

	return returned||'/';
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_not_indexed(path character varying) OWNER TO darwin2;

--
-- TOC entry 1916 (class 1255 OID 5308260)
-- Name: fct_rmca_sort_taxon_path_alphabetically_staging(integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging(taxon_id integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned varchar;

 tmp varchar;
 tmp_id integer;
 tmp_level integer;
 kingdom_given boolean;
 kingdom_id integer;
 kingdom_name varchar;

  domain_given boolean;
   domain_name varchar;
    name_rank varchar;
BEGIN
	returned ='';
	
	tmp_id:=taxon_id;
	kingdom_given :=FALSE;
	domain_given :=FALSE;
	while tmp_id is not null
	LOOP 
		SELECT name, parent_ref_internal, level_ref, level_name INTO tmp, tmp_id, tmp_level, name_rank FROM staging_catalogue 
			INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id
			WHERE staging_catalogue.id=tmp_id;
		IF tmp_level=2 THEN
			kingdom_given = true;
		END IF;
		IF tmp_level=1 THEN
			domain_given = true;
		END IF;
		--raise notice '%', returned;
		--raise notice '%', tmp_id;
		IF is_indexed=TRUE THEN
			tmp:=fulltoindex(tmp, false);
		END IF;
		IF with_rank = FALSE THEN
			returned := tmp||'/'||returned;
		ELSE
			returned := tmp||' ('||name_rank||')'||'/'||returned;
		END IF;
	END LOOP;
	IF kingdom_given = FALSE THEN
		-- 2019 02 19
		IF is_indexed =TRUE THEN
			SELECT fulltoindex(taxonomy.name, false), taxonomy.id INTO kingdom_name, kingdom_id FROM taxonomy INNER JOIN imports ON taxonomy.id=imports.taxonomy_kingdom::int INNER JOIN staging_catalogue ON imports.id=staging_catalogue.import_ref WHERE staging_catalogue.id=taxon_id;
		ELSE
			SELECT taxonomy.name, taxonomy.id INTO kingdom_name, kingdom_id FROM taxonomy INNER JOIN imports ON taxonomy.id=imports.taxonomy_kingdom::int INNER JOIN staging_catalogue ON imports.id=staging_catalogue.import_ref WHERE staging_catalogue.id=taxon_id;
		END IF;
		IF with_rank = TRUE THEN
			kingdom_name:= kingdom_name||' (kingdom)';
		END If;
		returned :=  kingdom_name||'/'||returned;
		
		IF domain_given = FALSE THEN
				-- 2019 02 19
			IF is_indexed =TRUE THEN
				SELECT fulltoindex(taxonomy.name, false) INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			ELSE
				SELECT taxonomy.name INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			END IF;
			IF with_rank = TRUE THEN
				domain_name:= domain_name||' (domain)';
			END If;
			returned :=  domain_name||'/'||returned;
		END IF;
	END IF;


	return '/'||returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging(taxon_id integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1933 (class 1255 OID 5309202)
-- Name: fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(integer, integer, boolean, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(taxon_id integer, req_import_ref integer, with_rank boolean DEFAULT true, is_indexed boolean DEFAULT false) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  --ftheeten 2019 02 21
 returned varchar;

 tmp varchar;
 tmp_id integer;
 tmp_level integer;
 kingdom_given boolean;
 kingdom_id integer;
 kingdom_name varchar;

  domain_given boolean;
  domain_name varchar;
  name_rank varchar;
  in_taxonomy boolean;
  taxonomy_id integer; 
  is_reference boolean; 
BEGIN

	in_taxonomy :=false;
	SELECT COALESCE(taxonomy_metadata.is_reference_taxonomy,FALSE) INTO is_reference FROM taxonomy_metadata LEFT JOIN imports ON taxonomy_metadata.id=imports.specimen_taxonomy_ref AND imports.id=req_import_ref LIMIT 1;
	returned ='';
	IF is_reference = FALSE THEN
		RAISE EXCEPTION 'Not a reference taxonomy';
	END IF ;
	tmp_id:=taxon_id;
	kingdom_given :=FALSE;
	domain_given :=FALSE;
	
	while tmp_id is not null
	LOOP 
		taxonomy_id := NULL;
		IF in_taxonomy THEN
			SELECT name, parent_ref, level_ref, level_name INTO tmp, tmp_id, tmp_level, name_rank  FROM taxonomy INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id
			WHERE taxonomy.id=tmp_id;
		ELSE
			SELECT name, parent_ref_internal, level_ref, level_name INTO tmp, tmp_id, tmp_level, name_rank FROM staging_catalogue 
			INNER JOIN catalogue_levels ON level_ref=catalogue_levels.id
			WHERE staging_catalogue.id=tmp_id;
		END IF;
		IF tmp_level=2 THEN
			kingdom_given = true;
		END IF;
		IF tmp_level=1 THEN
			domain_given = true;
		END IF;
		--raise notice '%', returned;
		--raise notice '%', tmp_id;
		IF is_indexed=TRUE THEN
			tmp:=fulltoindex(tmp, false);
		END IF;
		IF with_rank = FALSE THEN
			returned := tmp||'/'||returned;
		ELSE
			returned := tmp||' ('||name_rank||')'||'/'||returned;
		END IF;
		IF in_taxonomy = FALSE THEN
			SELECT taxonomy.parent_ref INTO taxonomy_id FROM taxonomy LEFT JOIN taxonomy_metadata ON taxonomy.metadata_ref= taxonomy_metadata.id WHERE taxonomy.level_ref=tmp_level AND taxonomy.name=tmp AND taxonomy_metadata.is_reference_taxonomy=TRUE;
			IF taxonomy_id IS NOT NULL THEN
				--merge
				tmp_id:=taxonomy_id;
				in_taxonomy:=TRUE;
			END IF;
		END IF;
	END LOOP;
	IF kingdom_given = FALSE THEN
		-- 2019 02 19
		IF is_indexed =TRUE THEN
			SELECT fulltoindex(taxonomy.name, false), taxonomy.id INTO kingdom_name, kingdom_id FROM taxonomy INNER JOIN imports ON taxonomy.id=imports.taxonomy_kingdom::int INNER JOIN staging_catalogue ON imports.id=staging_catalogue.import_ref WHERE staging_catalogue.id=taxon_id;
		ELSE
			SELECT taxonomy.name, taxonomy.id INTO kingdom_name, kingdom_id FROM taxonomy INNER JOIN imports ON taxonomy.id=imports.taxonomy_kingdom::int INNER JOIN staging_catalogue ON imports.id=staging_catalogue.import_ref WHERE staging_catalogue.id=taxon_id;
		END IF;
		IF with_rank = TRUE THEN
			kingdom_name:= kingdom_name||' (kingdom)';
		END If;
		returned :=  kingdom_name||'/'||returned;
		
		IF domain_given = FALSE THEN
				-- 2019 02 19
			IF is_indexed =TRUE THEN
				SELECT fulltoindex(taxonomy.name, false) INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			ELSE
				SELECT taxonomy.name INTO domain_name FROM taxonomy where id = (select parent_ref from taxonomy as b where b.id = kingdom_id);
			END IF;
			IF with_rank = TRUE THEN
				domain_name:= domain_name||' (domain)';
			END If;
			returned :=  domain_name||'/'||returned;
		END IF;
	END IF;


	return '/'||returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_alphabetically_staging_merge_reference(taxon_id integer, req_import_ref integer, with_rank boolean, is_indexed boolean) OWNER TO darwin2;

--
-- TOC entry 1915 (class 1255 OID 5308259)
-- Name: fct_rmca_sort_taxon_path_get_max_level_in_staging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_sort_taxon_path_get_max_level_in_staging(taxon_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
 returned integer;


 tmp_id integer;
BEGIN
	returned =NULL;
	
	tmp_id:=taxon_id;
	while tmp_id is not null
	LOOP 
		SELECT level_ref, parent_ref INTO returned, tmp_id FROM staging_catalogue where id=tmp_id;

		
	END LOOP;

     

	return returned;
END;

$$;


ALTER FUNCTION darwin2.fct_rmca_sort_taxon_path_get_max_level_in_staging(taxon_id integer) OWNER TO darwin2;

--
-- TOC entry 1826 (class 1255 OID 4816457)
-- Name: fct_rmca_taxonomy_split_name_author(character varying, integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_split_name_author(name character varying, rank_id integer) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$

DECLARE 
--tmp varchar[];
returned varchar[];
name_tmp varchar;
author_tmp varchar;
pos_author int;
BEGIN

	

	IF rank_id <= 41 THEN
		pos_author:=1;
	ELSEIF rank_id>41 and rank_id<=48 THEN
		pos_author:=2;
	ELSEIF rank_id >48 and rank_id <50 THEN
	        -- ftheeten 2018 11 22
		If rank_id=50 THEN
		name:=replace(name,' (L.) ', ' ');
		name:=replace(name,' L. ', ' ');
		name:=replace(name,' var. ', ' ');
		END IF;
		pos_author:=3;
	ELSEIF  rank_id =50 THEN
		returned[1]:=TRIM(regexp_replace(name, '(var\.\s\w+)(.*)', '\1'));
		returned[2]:=TRIM(replace(name, returned[1],''));
		return returned;
	ELSEIF  rank_id >50 THEN
		pos_author:=4;
	END IF;

	
	
	SELECT array_to_string((array_agg(elem))[1:pos_author], ' ') ,  array_to_string((array_agg(elem))[pos_author+1:500],' ') INTO name_tmp, author_tmp FROM 
(SELECT 1 as id, (regexp_matches(trim(name), '([^\s]+(\s\([^0-9]+\)){0,1})','g'))[1] as elem)
a group by id; 
	returned[1]:=name_tmp;
	returned[2]:= author_tmp;

RETURN returned;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_split_name_author(name character varying, rank_id integer) OWNER TO darwin2;

--
-- TOC entry 1827 (class 1255 OID 4816458)
-- Name: fct_rmca_taxonomy_try_to_isolate_from_author(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ /*SELECT 
regexp_replace(
trim(

regexp_replace(

	regexp_replace($1,'\([^\(]*\)$','')

,'(\s[A-Z]).*$','')),

E' (von|van|de|l\')$',''
)

;*/
DECLARE 
	returned varchar;
 BEGIN 
	IF LOWER(name) LIKE '% var. %' THEN
		returned:=TRIM(regexp_replace(name, '(var\.\s\w+)(.*)', '\1'));
	ELSE
		returned:=regexp_replace(
				trim(

				regexp_replace(

					regexp_replace(name,'\([^\(]*\)$','')

				,'(\s[A-Z]).*$','')),

				E' (von|van|de|l\')$',''
				)

				;
	END IF;
	 
	RETURN returned;
 END;

 $_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(name character varying) OWNER TO darwin2;

--
-- TOC entry 1828 (class 1255 OID 4816459)
-- Name: fct_rmca_taxonomy_try_to_isolate_from_author_old(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_taxonomy_try_to_isolate_from_author_old(character varying) RETURNS character varying
    LANGUAGE sql
    AS $_$ SELECT 
regexp_replace(
trim(

regexp_replace(

	regexp_replace($1,'\([^\(]*\)$','')

,'(\s[A-Z]).*$','')),

E' (von|van|de|l\')$',''
)

; $_$;


ALTER FUNCTION darwin2.fct_rmca_taxonomy_try_to_isolate_from_author_old(character varying) OWNER TO darwin2;

--
-- TOC entry 1829 (class 1255 OID 4816461)
-- Name: fct_rmca_update_child_of_taxon_protected(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_update_child_of_taxon_protected() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
	text_path varchar;
	text_to_replace varchar;
BEGIN
    IF TG_OP = 'UPDATE'  THEN

		IF NEW.sensitive_info_withheld <> OLD.sensitive_info_withheld THEN
			   
			UPDATE taxonomy SET sensitive_info_withheld=NEW.sensitive_info_withheld WHERE parent_ref=NEW.ID OR path LIKE '%/'||NEW.id::varchar||'/%' ;
		END IF;
        END IF;

 
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_update_child_of_taxon_protected() OWNER TO darwin2;

--
-- TOC entry 1830 (class 1255 OID 4816462)
-- Name: fct_rmca_update_reference_taxo(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_rmca_update_reference_taxo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN
--ftheeten 2017 07 03

     IF NEW.is_reference_taxonomy  != OLD.is_reference_taxonomy AND TG_OP = 'UPDATE' THEN
	UPDATE taxonomy SET is_reference_taxonomy= new.is_reference_taxonomy WHERE metadata_ref=NEW.id;
    END IF;
   	    
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_rmca_update_reference_taxo() OWNER TO darwin2;

--
-- TOC entry 1831 (class 1255 OID 4816463)
-- Name: fct_search_authorized_encoding_collections(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_search_authorized_encoding_collections(user_id integer) RETURNS SETOF integer
    LANGUAGE sql STABLE
    AS $_$
    select collection_ref from collections_rights where user_ref = $1 and db_user_type >= 2;
$_$;


ALTER FUNCTION darwin2.fct_search_authorized_encoding_collections(user_id integer) OWNER TO darwin2;

--
-- TOC entry 1832 (class 1255 OID 4816464)
-- Name: fct_search_authorized_view_collections(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_search_authorized_view_collections(user_id integer) RETURNS SETOF integer
    LANGUAGE sql STABLE
    AS $_$
    select collection_ref from collections_rights where user_ref = $1

    UNION

    select id as collection_ref from collections where is_public = true;
$_$;


ALTER FUNCTION darwin2.fct_search_authorized_view_collections(user_id integer) OWNER TO darwin2;

--
-- TOC entry 1833 (class 1255 OID 4816465)
-- Name: fct_search_methods(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_search_methods(str_ids character varying) RETURNS SETOF integer
    LANGUAGE sql STABLE
    AS $_$
    select distinct(specimen_ref) from specimen_collecting_methods where collecting_method_ref in (select X::int from regexp_split_to_table($1,',') as X);
$_$;


ALTER FUNCTION darwin2.fct_search_methods(str_ids character varying) OWNER TO darwin2;

--
-- TOC entry 1834 (class 1255 OID 4816466)
-- Name: fct_search_tools(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_search_tools(str_ids character varying) RETURNS SETOF integer
    LANGUAGE sql STABLE
    AS $_$
    select distinct(specimen_ref) from specimen_collecting_tools where collecting_tool_ref in (select X::int from regexp_split_to_table($1,',') as X);
$_$;


ALTER FUNCTION darwin2.fct_search_tools(str_ids character varying) OWNER TO darwin2;

--
-- TOC entry 1836 (class 1255 OID 4816467)
-- Name: fct_searchcodes(character varying[]); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_searchcodes(VARIADIC character varying[]) RETURNS SETOF integer
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
  sqlString varchar := E'select record_id from codes';
  sqlWhere varchar := '';
  code_part varchar;
  code_from varchar;
  code_to varchar;
  code_category varchar;
  relation varchar;
  word varchar;
BEGIN
  FOR i in 1 .. array_upper( $1, 1 ) BY 5 LOOP
    code_category := $1[i];
    code_part := $1[i+1];
    code_from := $1[i+2];
    code_to := $1[i+3];
    relation := $1[i+4] ;

    IF relation IS DISTINCT FROM '' AND i = 1 THEN
      sqlString := sqlString || ' where referenced_relation=' || quote_literal(relation) ;
    ELSIF i = 1 THEN
      sqlString := sqlString || E' where referenced_relation=\'specimens\''  ;
    END IF ;

    sqlWhere := sqlWhere || ' (code_category = ' || quote_literal(code_category) ;

    IF code_from ~ '^[0-9]+$' and code_to ~ '^[0-9]+$' THEN
      sqlWhere := sqlWhere || ' AND code_num BETWEEN ' || quote_literal(code_from) || ' AND ' || quote_literal(code_to) ;
    END IF;

    IF code_part != '' THEN
      sqlWhere := sqlWhere || ' AND (';
      FOR word IN (SELECT words FROM regexp_split_to_table(code_part, E'\\s+') as words) LOOP
        sqlWhere := sqlWhere || E' full_code_indexed like \'%\' || fullToIndex(' || quote_literal(word) || E') || \'%\' OR';
      END LOOP;
      sqlWhere := substr(sqlWhere,0,length(sqlWhere)-2) || ')';
    END IF;

    sqlWhere := sqlWhere || ') OR ';

  END LOOP;

  sqlString := sqlString || ' AND (' || substr(sqlWhere,0, length(sqlWhere)-2) || ')';
  RAISE INFO 'Sql : %',sqlString ;
  RETURN QUERY EXECUTE sqlString;
END;
$_$;


ALTER FUNCTION darwin2.fct_searchcodes(VARIADIC character varying[]) OWNER TO darwin2;

--
-- TOC entry 1837 (class 1255 OID 4816468)
-- Name: fct_set_user(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_set_user(userid integer) RETURNS void
    LANGUAGE sql
    AS $_$
  select set_config('darwin.userid', $1::varchar, false) ;
  select CASE WHEN get_setting('application_name') ~ ' uid:\d+'
    THEN set_config('application_name', regexp_replace(get_setting('application_name') ,'uid:\d+',  'uid:' || $1::varchar), false)
    ELSE set_config('application_name', get_setting('application_name')  || ' uid:' || $1::varchar, false)
    END;
  update users_login_infos set last_seen = now() where user_ref = $1  and login_type='local';
$_$;


ALTER FUNCTION darwin2.fct_set_user(userid integer) OWNER TO darwin2;

--
-- TOC entry 1838 (class 1255 OID 4816469)
-- Name: fct_trg_chk_possible_upper_level(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_trg_chk_possible_upper_level() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
   --ftheeten 2017 07 10
   IF TG_OP ='INSERT' OR (TG_OP ='UPDATE' AND (OLD.parent_ref !=NEW.parent_ref OR OLD.level_ref !=NEW.level_ref )) THEN		
	IF fct_chk_possible_upper_level(TG_TABLE_NAME::text, NEW.parent_ref, NEW.level_ref, NEW.id) = false THEN
	RAISE EXCEPTION 'This record does not follow the level hierarchy (NAME is %)', NEW.name;
	END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_trg_chk_possible_upper_level() OWNER TO darwin2;

--
-- TOC entry 1839 (class 1255 OID 4816470)
-- Name: fct_trk_log_table(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_trk_log_table() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  user_id integer;
  track_level integer;
  track_fields integer;
  trk_id bigint;
  tbl_row RECORD;
  new_val varchar;
  old_val varchar;
  returnedRow RECORD;
BEGIN
  IF TG_OP IN ('INSERT', 'UPDATE') THEN
    returnedRow := NEW;
  ELSE
    returnedRow := OLD;
  END IF;
  SELECT COALESCE(CASE WHEN get_setting('darwin.track_level') = '' THEN NULL ELSE get_setting('darwin.track_level') END,'10')::integer INTO track_level;
  IF track_level = 0 THEN --NO Tracking
    RETURN returnedRow;
  ELSIF track_level = 1 THEN -- Track Only Main tables
    IF TG_TABLE_NAME::text NOT IN ('specimens', 'taxonomy', 'chronostratigraphy', 'lithostratigraphy',
      'mineralogy', 'lithology', 'people', 'loans', 'loan_items') THEN
      RETURN returnedRow;
    END IF;
  END IF;

  SELECT COALESCE(CASE WHEN get_setting('darwin.userid') = '' THEN NULL ELSE get_setting('darwin.userid') END,'0')::integer INTO user_id;
  IF user_id = 0 OR  user_id = -1 THEN
    RETURN returnedRow;
  END IF;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO users_tracking (referenced_relation, record_id, user_ref, action, modification_date_time, new_value)
        VALUES (TG_TABLE_NAME::text, NEW.id, user_id, 'insert', now(), hstore(NEW)) RETURNING id into trk_id;
  ELSEIF TG_OP = 'UPDATE' THEN

    IF ROW(NEW.*) IS DISTINCT FROM ROW(OLD.*) THEN
    INSERT INTO users_tracking (referenced_relation, record_id, user_ref, action, modification_date_time, new_value, old_value)
        VALUES (TG_TABLE_NAME::text, NEW.id, user_id, 'update', now(), hstore(NEW), hstore(OLD)) RETURNING id into trk_id;
    ELSE
      RAISE info 'unnecessary update on table "%" and id "%"', TG_TABLE_NAME::text, NEW.id;
    END IF;

  ELSEIF TG_OP = 'DELETE' THEN
    INSERT INTO users_tracking (referenced_relation, record_id, user_ref, action, modification_date_time, old_value)
      VALUES (TG_TABLE_NAME::text, OLD.id, user_id, 'delete', now(), hstore(OLD));
  END IF;

  RETURN NULL;
END;
$$;


ALTER FUNCTION darwin2.fct_trk_log_table() OWNER TO darwin2;

--
-- TOC entry 1840 (class 1255 OID 4816471)
-- Name: fct_unpromotion_impact_prefs(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_unpromotion_impact_prefs() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  saved_search_row RECORD;
BEGIN
  IF NEW.db_user_type IS DISTINCT FROM OLD.db_user_type AND NEW.db_user_type = 1 THEN
    UPDATE preferences
    SET pref_value = subq.fields_available
    FROM (select array_to_string(array(select fields_list
                                       from regexp_split_to_table((SELECT pref_value
                                                                   FROM preferences
                                                                   WHERE user_ref = NEW.id
                                                                     AND pref_key = 'search_cols_specimen'
                                                                   LIMIT 1
                                                                  ), E'\\|') as fields_list
                                       where fields_list not in ('institution_ref', 'building', 'floor', 'room', 'row', 'shelf', 'col', 'container', 'container_type', 'container_storage', 'sub_container', 'sub_container_type', 'sub_container_storage')
                                      ),'|'
                                ) as fields_available
         ) subq
    WHERE user_ref = NEW.id
      AND pref_key = 'search_cols_specimen';
    FOR saved_search_row IN SELECT id, visible_fields_in_result FROM my_saved_searches WHERE user_ref = NEW.id LOOP
      UPDATE my_saved_searches
      SET visible_fields_in_result = subq.fields_available
      FROM (select array_to_string(array(select fields_list
                                         from regexp_split_to_table(saved_search_row.visible_fields_in_result, E'\\|') as fields_list
                                         where fields_list not in ('institution_ref','building', 'floor', 'room', 'row', 'shelf', 'col', 'container', 'container_type', 'container_storage', 'sub_container', 'sub_container_type', 'sub_container_storage')
                                        ),'|'
                                  ) as fields_available
          ) subq
      WHERE id = saved_search_row.id;
    END LOOP;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_unpromotion_impact_prefs() OWNER TO darwin2;

--
-- TOC entry 1825 (class 1255 OID 4816472)
-- Name: fct_upd_institution_staging_relationship(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_upd_institution_staging_relationship() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  import_id integer;
  line RECORD ;
BEGIN
 IF get_setting('darwin.upd_people_ref') is null OR  get_setting('darwin.upd_people_ref') = '' THEN
    PERFORM set_config('darwin.upd_people_ref', 'ok', true);
    select s.import_ref INTO import_id FROM staging s, staging_relationship sr WHERE sr.id=OLD.id AND sr.record_id = s.id ;
    UPDATE staging_relationship SET institution_ref = NEW.institution_ref WHERE id IN (
      SELECT sr.id from staging_relationship sr, staging s WHERE sr.institution_name = OLD.institution_name AND s.import_ref = import_id AND
      sr.record_id = s.id
    );
    FOR line IN SELECT s.* FROM staging s, staging_relationship sr WHERE s.id=sr.record_id AND sr.institution_ref = NEW.institution_ref
    LOOP
      UPDATE staging SET status = delete(status,'institution_relationship') where id=line.id;
    END LOOP ;
    PERFORM set_config('darwin.upd_imp_ref', NULL, true);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_upd_institution_staging_relationship() OWNER TO postgres;

--
-- TOC entry 1835 (class 1255 OID 4816473)
-- Name: fct_upd_people_in_flat(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_upd_people_in_flat() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  spec_row RECORD;
  ident RECORD;
  tmp_user text;
BEGIN
 SELECT COALESCE(get_setting('darwin.userid'),'0') INTO tmp_user;
  PERFORM set_config('darwin.userid', '-1', false) ;


  IF TG_OP = 'DELETE' THEN
    IF OLD.people_type = 'collector' THEN
      UPDATE specimens s SET spec_coll_ids = fct_remove_array_elem(spec_coll_ids,ARRAY[OLD.people_ref])
        WHERE id  = OLD.record_id;
    ELSIF OLD.people_type = 'donator' THEN
      UPDATE specimens s SET spec_don_sel_ids = fct_remove_array_elem(spec_don_sel_ids,ARRAY[OLD.people_ref])
        WHERE id  = OLD.record_id;
    ELSIF OLD.people_type = 'identifier' THEN
      SELECT * into ident FROM identifications where id = OLD.record_id;
      IF NOT FOUND Then
        PERFORM set_config('darwin.userid', tmp_user, false) ;
        RETURN OLD;
      END IF;

      UPDATE specimens s SET spec_ident_ids = fct_remove_array_elem(spec_ident_ids,ARRAY[OLD.people_ref])
        WHERE id  = ident.record_id
            AND NOT exists (
              SELECT true FROM catalogue_people cp INNER JOIN identifications i ON cp.record_id = i.id AND cp.referenced_relation = 'identifications'
                WHERE i.record_id = ident.id AND people_ref = OLD.people_ref AND i.referenced_relation = 'specimens'
            );
    END IF;

  ELSIF TG_OP = 'INSERT' THEN --- INSERT

    IF NEW.people_type = 'collector' THEN
      UPDATE specimens s SET spec_coll_ids = array_append(spec_coll_ids,NEW.people_ref)
        WHERE id  = NEW.record_id and NOT (spec_coll_ids && ARRAY[ NEW.people_ref::integer ]);
    ELSIF NEW.people_type = 'donator' THEN
      UPDATE specimens s SET spec_don_sel_ids = array_append(spec_don_sel_ids,NEW.people_ref)
        WHERE id  = NEW.record_id  and NOT (spec_don_sel_ids && ARRAY[ NEW.people_ref::integer ]);
    ELSIF NEW.people_type = 'identifier' THEN
      SELECT * into ident FROM identifications where id = NEW.record_id;

      UPDATE specimens s SET spec_ident_ids = array_append(spec_ident_ids,NEW.people_ref)
          WHERE id  = ident.record_id and NOT (spec_ident_ids && ARRAY[ NEW.people_ref::integer ]);
    END IF;

  ELSIF OLD.people_ref != NEW.people_ref THEN --UPDATE

    IF NEW.people_type = 'collector' THEN
      UPDATE specimens s SET spec_coll_ids = array_append(fct_remove_array_elem(spec_coll_ids ,ARRAY[OLD.people_ref]),NEW.people_ref::integer)
        WHERE id  = NEW.record_id;
    ELSIF NEW.people_type = 'donator' THEN
      UPDATE specimens s SET spec_don_sel_ids = array_append(fct_remove_array_elem(spec_don_sel_ids ,ARRAY[OLD.people_ref]),NEW.people_ref::integer)
        WHERE id  = NEW.record_id;

    ELSIF NEW.people_type = 'identifier' THEN
      SELECT * into ident FROM identifications where id = NEW.record_id;

        SELECT id, spec_ident_ids INTO spec_row FROM specimens WHERE id = ident.record_id;

        IF NOT exists (SELECT 1 from identifications i INNER JOIN catalogue_people c ON c.record_id = i.id AND c.referenced_relation = 'identifications'
          WHERE i.record_id = spec_row.id AND people_ref = OLD.people_ref AND i.referenced_relation = 'specimens' AND c.id != OLD.id
        ) THEN
          spec_row.spec_ident_ids := fct_remove_array_elem(spec_row.spec_ident_ids ,ARRAY[OLD.people_ref]);
        END IF;

        IF NOT spec_row.spec_ident_ids && ARRAY[ NEW.people_ref::integer ] THEN
          spec_row.spec_ident_ids := array_append(spec_row.spec_ident_ids ,NEW.people_ref);
        END IF;

        UPDATE specimens SET spec_ident_ids = spec_row.spec_ident_ids WHERE id = spec_row.id;
    END IF;
    --else  raise info 'ooh';
  END IF;

  PERFORM set_config('darwin.userid', tmp_user, false) ;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_upd_people_in_flat() OWNER TO darwin2;

--
-- TOC entry 1841 (class 1255 OID 4816474)
-- Name: fct_upd_people_staging_fields(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_upd_people_staging_fields() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  import_id integer;
BEGIN
 IF get_setting('darwin.upd_people_ref') is null OR  get_setting('darwin.upd_people_ref') = '' THEN
    PERFORM set_config('darwin.upd_people_ref', 'ok', true);
    IF OLD.referenced_relation = 'staging' THEN
      select s.import_ref INTO import_id FROM staging s, staging_people sp WHERE sp.id=OLD.id AND sp.record_id = s.id ;
    ELSEIF OLD.referenced_relation = 'identifications' THEN
      select s.import_ref INTO import_id FROM staging s, staging_people sp, identifications i WHERE sp.id=OLD.id
      AND sp.record_id = i.id AND i.record_id = s.id ;
    ELSE
      select s.import_ref INTO import_id FROM staging s, staging_people sp, collection_maintenance c WHERE sp.id=OLD.id
      AND sp.record_id = c.id AND c.record_id = s.id ;
    END IF;

    UPDATE staging_people SET people_ref = NEW.people_ref WHERE id IN (
      SELECT sp.id from staging_people sp, identifications i, staging s WHERE formated_name = OLD.formated_name AND s.import_ref = import_id
      AND i.record_id = s.id AND sp.referenced_relation = 'identifications' AND sp.record_id = i.id
      UNION
      SELECT sp.id from staging_people sp, staging s WHERE formated_name = OLD.formated_name AND s.import_ref = import_id AND
      sp.record_id = s.id AND sp.referenced_relation = 'staging'
      UNION
      SELECT sp.id from staging_people sp, collection_maintenance c, staging s WHERE formated_name = OLD.formated_name AND s.import_ref = import_id
      AND c.record_id = s.id AND sp.referenced_relation = 'collection_maintenance' AND sp.record_id = c.id
    );
    -- update status field, if all error people are corrected, statut 'people', 'operator' or 'identifiers' will be removed
    PERFORM fct_imp_checker_people(s.*) FROM staging s WHERE import_ref = import_id AND (status::hstore ? 'people' OR status::hstore ? 'identifiers'  OR status::hstore ? 'operator') ;
    PERFORM set_config('darwin.upd_imp_ref', NULL, true);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_upd_people_staging_fields() OWNER TO darwin2;

--
-- TOC entry 1842 (class 1255 OID 4816475)
-- Name: fct_upd_staging_fields(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_upd_staging_fields() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF get_setting('darwin.upd_imp_ref') is null OR  get_setting('darwin.upd_imp_ref') = '' THEN
    PERFORM set_config('darwin.upd_imp_ref', 'ok', true);
    IF OLD.taxon_ref IS DISTINCT FROM NEW.taxon_ref AND  NEW.taxon_ref is not null THEN
        SELECT t.id ,t.name, t.level_ref , cl.level_sys_name, t.status, t.extinct
        INTO NEW.taxon_ref,NEW.taxon_name, NEW.taxon_level_ref, NEW.taxon_level_name, NEW.taxon_status, NEW.taxon_extinct
        FROM taxonomy t, catalogue_levels cl
        WHERE cl.id=t.level_ref AND t.id = NEW.taxon_ref;

        UPDATE staging set taxon_ref=NEW.taxon_ref, taxon_name = new.taxon_name, taxon_level_ref=new.taxon_level_ref,
          taxon_level_name=new.taxon_level_name, taxon_status=new.taxon_status, taxon_extinct=new.taxon_extinct,
          status = delete(status,'taxon')

        WHERE
          taxon_name  IS NOT DISTINCT FROM  old.taxon_name AND  taxon_level_ref IS NOT DISTINCT FROM old.taxon_level_ref AND
          taxon_level_name IS NOT DISTINCT FROM old.taxon_level_name AND  taxon_status IS NOT DISTINCT FROM old.taxon_status
          AND  taxon_extinct IS NOT DISTINCT FROM old.taxon_extinct
          AND import_ref = NEW.import_ref;
        NEW.status = delete(NEW.status,'taxon');
    END IF;

    IF OLD.chrono_ref IS DISTINCT FROM NEW.chrono_ref  AND  NEW.chrono_ref is not null THEN
      SELECT c.id, c.name, c.level_ref, cl.level_name, c.status, c.local_naming, c.color, c.upper_bound, c.lower_bound
        INTO NEW.chrono_ref, NEW.chrono_name, NEW.chrono_level_ref, NEW.chrono_level_name, NEW.chrono_status, NEW.chrono_local, NEW.chrono_color, NEW.chrono_upper_bound, NEW.chrono_lower_bound
        FROM chronostratigraphy c, catalogue_levels cl
        WHERE cl.id=c.level_ref AND c.id = NEW.chrono_ref ;

        UPDATE staging set chrono_ref=NEW.chrono_ref, chrono_name = NEW.chrono_name, chrono_level_ref=NEW.chrono_level_ref, chrono_level_name=NEW.chrono_level_name, chrono_status=NEW.chrono_status,
        chrono_local=NEW.chrono_local, chrono_color=NEW.chrono_color, chrono_upper_bound=NEW.chrono_upper_bound, chrono_lower_bound=NEW.chrono_lower_bound,
        status = delete(status,'chrono')

        WHERE
        chrono_name  IS NOT DISTINCT FROM  OLD.chrono_name AND  chrono_level_ref IS NOT DISTINCT FROM OLD.chrono_level_ref AND
        chrono_level_name IS NOT DISTINCT FROM OLD.chrono_level_name AND  chrono_status IS NOT DISTINCT FROM OLD.chrono_status AND
        chrono_local IS NOT DISTINCT FROM OLD.chrono_local AND  chrono_color IS NOT DISTINCT FROM OLD.chrono_color AND
        chrono_upper_bound IS NOT DISTINCT FROM OLD.chrono_upper_bound AND  chrono_lower_bound IS NOT DISTINCT FROM OLD.chrono_lower_bound
        AND import_ref = NEW.import_ref;
        NEW.status = delete(NEW.status,'chrono');

    END IF;

    IF OLD.litho_ref IS DISTINCT FROM NEW.litho_ref  AND  NEW.litho_ref is not null  THEN
      SELECT l.id,l.name, l.level_ref, cl.level_name, l.status, l.local_naming, l.color
      INTO NEW.litho_ref, NEW.litho_name, NEW.litho_level_ref, NEW.litho_level_name, NEW.litho_status, NEW.litho_local, NEW.litho_color
      FROM lithostratigraphy l, catalogue_levels cl
      WHERE cl.id=l.level_ref AND l.id = NEW.litho_ref ;

      UPDATE staging set
        litho_ref=NEW.litho_ref, litho_name=NEW.litho_name, litho_level_ref=NEW.litho_level_ref, litho_level_name=NEW.litho_level_name,
        litho_status=NEW.litho_status, litho_local=NEW.litho_local, litho_color=NEW.litho_color,
        status = delete(status,'litho')

      WHERE
        litho_name IS NOT DISTINCT FROM  OLD.litho_name AND litho_level_ref IS NOT DISTINCT FROM  OLD.litho_level_ref AND
        litho_level_name IS NOT DISTINCT FROM  OLD.litho_level_name AND
        litho_status IS NOT DISTINCT FROM  OLD.litho_status AND litho_local IS NOT DISTINCT FROM  OLD.litho_local AND litho_color IS NOT DISTINCT FROM OLD.litho_color
        AND import_ref = NEW.import_ref;
        NEW.status = delete(NEW.status,'litho');

    END IF;


    IF OLD.lithology_ref IS DISTINCT FROM NEW.lithology_ref  AND  NEW.lithology_ref is not null THEN
      SELECT l.id, l.name, l.level_ref, cl.level_name, l.status, l.local_naming, l.color
      INTO NEW.lithology_ref, NEW.lithology_name, NEW.lithology_level_ref, NEW.lithology_level_name, NEW.lithology_status, NEW.lithology_local, NEW.lithology_color
      FROM lithology l, catalogue_levels cl
      WHERE cl.id=l.level_ref AND l.id = NEW.lithology_ref ;

      UPDATE staging set
        lithology_ref=NEW.lithology_ref, lithology_name=NEW.lithology_name, lithology_level_ref=NEW.lithology_level_ref,
        lithology_level_name=NEW.lithology_level_name, lithology_status=NEW.lithology_status, lithology_local=NEW.lithology_local,
        lithology_color=NEW.lithology_color,
        status = delete(status,'lithology')

      WHERE
        lithology_name IS NOT DISTINCT FROM OLD.lithology_name AND  lithology_level_ref IS NOT DISTINCT FROM OLD.lithology_level_ref AND
        lithology_level_name IS NOT DISTINCT FROM OLD.lithology_level_name AND  lithology_status IS NOT DISTINCT FROM OLD.lithology_status AND  lithology_local IS NOT DISTINCT FROM OLD.lithology_local AND
        lithology_color IS NOT DISTINCT FROM OLD.lithology_color
        AND import_ref = NEW.import_ref;
        NEW.status = delete(NEW.status,'lithology');

    END IF;


    IF OLD.mineral_ref IS DISTINCT FROM NEW.mineral_ref  AND  NEW.mineral_ref is not null THEN
      SELECT m.id, m.name, m.level_ref, cl.level_name, m.status, m.local_naming, m.color, m.path
      INTO NEW.mineral_ref, NEW.mineral_name, NEW.mineral_level_ref, NEW.mineral_level_name, NEW.mineral_status, NEW.mineral_local, NEW.mineral_color, NEW.mineral_path
      FROM mineralogy m, catalogue_levels cl
      WHERE cl.id=m.level_ref AND m.id = NEW.mineral_ref ;

      UPDATE staging set
        mineral_ref=NEW.mineral_ref, mineral_name=NEW.mineral_name, mineral_level_ref=NEW.mineral_level_ref,
        mineral_level_name=NEW.mineral_level_name, mineral_status=NEW.mineral_status, mineral_local=NEW.mineral_local,
        mineral_color=NEW.mineral_color, mineral_path=NEW.mineral_path,
        status = delete(status,'mineral')

      WHERE
        mineral_name IS NOT DISTINCT FROM OLD.mineral_name AND  mineral_level_ref IS NOT DISTINCT FROM OLD.mineral_level_ref AND
        mineral_level_name IS NOT DISTINCT FROM OLD.mineral_level_name AND  mineral_status IS NOT DISTINCT FROM OLD.mineral_status AND  mineral_local IS NOT DISTINCT FROM OLD.mineral_local AND
        mineral_color IS NOT DISTINCT FROM OLD.mineral_color AND  mineral_path IS NOT DISTINCT FROM OLD.mineral_path
        AND import_ref = NEW.import_ref;

        NEW.status = delete(NEW.status,'mineral');

    END IF;

    IF OLD.expedition_ref IS DISTINCT FROM NEW.expedition_ref  AND  NEW.expedition_ref is not null THEN
      SELECT id, "name", expedition_from_date, expedition_to_date, expedition_from_date_mask , expedition_to_date_mask
      INTO NEW.expedition_ref, NEW.expedition_name, NEW.expedition_from_date, NEW.expedition_to_date, NEW.expedition_from_date_mask , NEW.expedition_to_date_mask
      FROM expeditions
      WHERE id = NEW.expedition_ref ;

      UPDATE staging set
        expedition_ref=NEW.expedition_ref, expedition_name=NEW.expedition_name, expedition_from_date=NEW.expedition_from_date,
        expedition_to_date=NEW.expedition_to_date, expedition_from_date_mask=NEW.expedition_from_date_mask , expedition_to_date_mask=NEW.expedition_to_date_mask,
        status = delete(status,'expedition')
      WHERE
        expedition_name IS NOT DISTINCT FROM OLD.expedition_name AND  expedition_from_date IS NOT DISTINCT FROM OLD.expedition_from_date AND
        expedition_to_date IS NOT DISTINCT FROM OLD.expedition_to_date AND  expedition_from_date_mask IS NOT DISTINCT FROM OLD.expedition_from_date_mask  AND
        expedition_to_date_mask IS NOT DISTINCT FROM OLD.expedition_to_date_mask
        AND import_ref = NEW.import_ref;
  NEW.status = delete(NEW.status,'expedition');
    END IF;

    IF OLD.institution_ref IS DISTINCT FROM NEW.institution_ref  AND  NEW.institution_ref is not null THEN
      SELECT formated_name INTO NEW.institution_name FROM people WHERE id = NEW.institution_ref ;

      UPDATE staging set institution_ref = NEW.institution_ref, institution_name=NEW.institution_name,
        status = delete(status,'institution')
        WHERE
        institution_name IS NOT DISTINCT FROM OLD.institution_name
        AND import_ref = NEW.import_ref;

        NEW.status = delete(NEW.status,'institution');

    END IF;

    PERFORM set_config('darwin.upd_imp_ref', NULL, true);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_upd_staging_fields() OWNER TO darwin2;

--
-- TOC entry 1843 (class 1255 OID 4816478)
-- Name: fct_update_import(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.fct_update_import() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  if OLD.state IS DISTINCT FROM NEW.state THEN
  UPDATE imports set updated_at= now() where id=NEW.id ;
  END IF ;
  return new ;
END;
$$;


ALTER FUNCTION darwin2.fct_update_import() OWNER TO postgres;

--
-- TOC entry 1844 (class 1255 OID 4816479)
-- Name: fct_update_specimen_flat(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_update_specimen_flat() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  cnt integer;
  old_val specimens%ROWTYPE;
  new_val specimens%ROWTYPE;
BEGIN

    IF TG_OP = 'UPDATE' THEN
      old_val = OLD;
      new_val = NEW;
    ELSE --INSERT
      new_val = NEW;
    END IF;

    IF old_val.taxon_ref IS DISTINCT FROM new_val.taxon_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, path, parent_ref, extinct
        INTO NEW.taxon_name, NEW.taxon_name_indexed, NEW.taxon_level_ref, NEW.taxon_level_name, NEW.taxon_status,
          NEW.taxon_path, NEW.taxon_parent_ref, NEW.taxon_extinct
        FROM taxonomy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.taxon_ref;
    END IF;

    IF old_val.chrono_ref IS DISTINCT FROM new_val.chrono_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
      INTO NEW.chrono_name, NEW.chrono_name_indexed, NEW.chrono_level_ref, NEW.chrono_level_name, NEW.chrono_status,
          NEW.chrono_local, NEW.chrono_color, NEW.chrono_path, NEW.chrono_parent_ref
        FROM chronostratigraphy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.chrono_ref;
    END IF;

    IF old_val.litho_ref IS DISTINCT FROM new_val.litho_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
        INTO NEW.litho_name, NEW.litho_name_indexed, NEW.litho_level_ref, NEW.litho_level_name, NEW.litho_status,
          NEW.litho_local, NEW.litho_color, NEW.litho_path, NEW.litho_parent_ref
        FROM lithostratigraphy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.litho_ref;
    END IF;

    IF old_val.lithology_ref IS DISTINCT FROM new_val.lithology_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
        INTO NEW.lithology_name, NEW.lithology_name_indexed, NEW.lithology_level_ref, NEW.lithology_level_name, NEW.lithology_status,
          NEW.lithology_local, NEW.lithology_color, NEW.lithology_path, NEW.lithology_parent_ref
        FROM lithology c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.lithology_ref;
    END IF;

    IF old_val.mineral_ref IS DISTINCT FROM new_val.mineral_ref THEN
      SELECT  name, name_indexed, level_ref, level_name, status, local_naming, color, path, parent_ref
        INTO NEW.mineral_name, NEW.mineral_name_indexed, NEW.mineral_level_ref, NEW.mineral_level_name, NEW.mineral_status,
          NEW.mineral_local, NEW.mineral_color, NEW.mineral_path, NEW.mineral_parent_ref
        FROM mineralogy c
        INNER JOIN catalogue_levels l on c.level_ref = l.id
        WHERE c.id = new_val.mineral_ref;
    END IF;


    IF old_val.expedition_ref IS DISTINCT FROM new_val.expedition_ref THEN
      SELECT  name, name_indexed
        INTO NEW.expedition_name, NEW.expedition_name_indexed
        FROM expeditions c
        WHERE c.id = new_val.expedition_ref;
    END IF;

    IF old_val.collection_ref IS DISTINCT FROM new_val.collection_ref THEN
      SELECT collection_type, code, name, is_public, parent_ref, path
        INTO NEW.collection_type, NEW.collection_code, NEW.collection_name, NEW.collection_is_public,
          NEW.collection_parent_ref, NEW.collection_path
        FROM collections c
        WHERE c.id = new_val.collection_ref;
    END IF;

    IF old_val.ig_ref IS DISTINCT FROM new_val.ig_ref THEN
      SELECT  ig_num, ig_num_indexed, ig_date, ig_date_mask
        INTO NEW.ig_num, NEW.ig_num_indexed, NEW.ig_date, NEW.ig_date_mask
        FROM igs c
        WHERE c.id = new_val.ig_ref;
    END IF;

    IF old_val.gtu_ref IS DISTINCT FROM new_val.gtu_ref THEN
      SELECT  code,/* ftheeten 2018 11 30*/

       /*gtu_from_date, gtu_from_date_mask,
         gtu_to_date, gtu_to_date_mask,*/
         elevation, elevation_accuracy,
         tag_values_indexed, location,

         taggr_countries.tag_value, lineToTagArray(taggr_countries.tag_value),
         taggr_provinces.tag_value, lineToTagArray(taggr_provinces.tag_value),
         (select array_to_string(array(select tag from tags where gtu_ref = c.id and sub_group_type not in ('country', 'province')), ';')) as other_gtu_values,
         (select array(select distinct fullToIndex(tag) from tags where gtu_ref = c.id and sub_group_type not in ('country', 'province'))) as other_gtu_values_array

        INTO NEW.gtu_code,

         --NEW.gtu_from_date, NEW.gtu_from_date_mask, NEW.gtu_to_date, NEW.gtu_to_date_mask,
     
         NEW.gtu_elevation, NEW.gtu_elevation_accuracy, NEW.gtu_tag_values_indexed, NEW.gtu_location,
         NEW.gtu_country_tag_value, NEW.gtu_country_tag_indexed, NEW.gtu_province_tag_value,
         NEW.gtu_province_tag_indexed, NEW.gtu_others_tag_value, NEW.gtu_others_tag_indexed
        FROM gtu c
          LEFT JOIN tag_groups taggr_countries ON c.id = taggr_countries.gtu_ref AND taggr_countries.group_name_indexed = 'administrativearea' AND taggr_countries.sub_group_name_indexed = 'country'
          LEFT JOIN tag_groups taggr_provinces ON c.id = taggr_provinces.gtu_ref AND taggr_provinces.group_name_indexed = 'administrativearea' AND taggr_provinces.sub_group_name_indexed = 'province'
        WHERE c.id = new_val.gtu_ref;
    END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_update_specimen_flat() OWNER TO darwin2;

--
-- TOC entry 1845 (class 1255 OID 4816480)
-- Name: fct_update_specimens_flat_related(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fct_update_specimens_flat_related() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  indCount INTEGER := 0;
  indType BOOLEAN := false;
  tmp_user text;
BEGIN
 SELECT COALESCE(get_setting('darwin.userid'),'0') INTO tmp_user;
  PERFORM set_config('darwin.userid', '-1', false) ;

  IF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'expeditions' THEN
    IF NEW.name_indexed IS DISTINCT FROM OLD.name_indexed THEN
      UPDATE specimens
      SET (expedition_name, expedition_name_indexed) =
          (NEW.name, NEW.name_indexed)
      WHERE expedition_ref = NEW.id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'collections' THEN
    IF OLD.collection_type IS DISTINCT FROM NEW.collection_type
    OR OLD.code IS DISTINCT FROM NEW.code
    OR OLD.name IS DISTINCT FROM NEW.name
    OR OLD.is_public IS DISTINCT FROM NEW.is_public
    OR OLD.path IS DISTINCT FROM NEW.path
    THEN
      UPDATE specimens
      SET (collection_type, collection_code, collection_name, collection_is_public,
          collection_parent_ref, collection_path
          ) =
          (NEW.collection_type, NEW.code, NEW.name, NEW.is_public,
           NEW.parent_ref, NEW.path
          )
      WHERE collection_ref = NEW.id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'gtu' THEN
    UPDATE specimens
    SET (gtu_code, 
         /*
	 gtu_from_date, gtu_from_date_mask,
         gtu_to_date, gtu_to_date_mask,*/
         gtu_elevation, gtu_elevation_accuracy,
         gtu_tag_values_indexed, gtu_location
        ) =
        (NEW.code,
         -- ftheeten 2018 11 30 
         /*
         NEW.gtu_from_date, NEW.gtu_from_date_mask,
         NEW.gtu_to_date, NEW.gtu_to_date_mask,*/
         NEW.elevation, NEW.elevation_accuracy,
         NEW.tag_values_indexed, NEW.location
        )
    WHERE gtu_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'igs' THEN
    IF NEW.ig_num_indexed IS DISTINCT FROM OLD.ig_num_indexed OR NEW.ig_date IS DISTINCT FROM OLD.ig_date THEN
      UPDATE specimens
      SET (ig_num, ig_num_indexed, ig_date, ig_date_mask) =
          (NEW.ig_num, NEW.ig_num_indexed, NEW.ig_date, NEW.ig_date_mask)
      WHERE ig_ref = NEW.id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'taxonomy' THEN
    UPDATE specimens
    SET (taxon_name, taxon_name_indexed,
         taxon_level_ref, taxon_level_name,
         taxon_status, taxon_path, taxon_parent_ref, taxon_extinct
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status, NEW.path, NEW.parent_ref, NEW.extinct
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE taxon_ref = NEW.id;

  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'chronostratigraphy' THEN
    UPDATE specimens
    SET (chrono_name, chrono_name_indexed,
         chrono_level_ref, chrono_level_name,
         chrono_status,
         chrono_local, chrono_color,
         chrono_path, chrono_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE chrono_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'lithostratigraphy' THEN
    UPDATE specimens
    SET (litho_name, litho_name_indexed,
         litho_level_ref, litho_level_name,
         litho_status,
         litho_local, litho_color,
         litho_path, litho_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE litho_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'lithology' THEN
    UPDATE specimens
    SET (lithology_name, lithology_name_indexed,
         lithology_level_ref, lithology_level_name,
         lithology_status,
         lithology_local, lithology_color,
         lithology_path, lithology_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE lithology_ref = NEW.id;
  ELSIF TG_OP = 'UPDATE' AND TG_TABLE_NAME = 'mineralogy' THEN
    UPDATE specimens
    SET (mineral_name, mineral_name_indexed,
         mineral_level_ref, mineral_level_name,
         mineral_status,
         mineral_local, mineral_color,
         mineral_path, mineral_parent_ref
        ) =
        (NEW.name, NEW.name_indexed,
         NEW.level_ref, subq.level_name,
         NEW.status,
         NEW.local_naming, NEW.color,
         NEW.path, NEW.parent_ref
        )
        FROM
        (SELECT level_name
         FROM catalogue_levels
         WHERE id = NEW.level_ref
        ) subq
    WHERE mineral_ref = NEW.id;

  ELSIF TG_TABLE_NAME = 'tag_groups' THEN
    IF TG_OP = 'INSERT' THEN
      IF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_country_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_province_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF NEW.sub_group_name_indexed NOT IN ('country','province') THEN
      /*Trigger trg_cpy_gtutags_taggroups has already occured and values from tags table should be correct... but really need a check !*/
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag) from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
    ELSIF TG_OP = 'UPDATE' THEN
      IF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'country' AND NEW.sub_group_name_indexed != 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = NULL,
            gtu_country_tag_indexed = NULL
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'province' AND NEW.sub_group_name_indexed != 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = NULL,
            gtu_province_tag_indexed = NULL
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
      IF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_country_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END ||NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      ELSIF NEW.group_name_indexed = 'administrativearea' AND NEW.sub_group_name_indexed = 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value,
            gtu_province_tag_indexed = lineToTagArray(case when NEW.international_name != '' THEN NEW.international_name || ';' ELSE '' END || NEW.tag_value)
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
      IF NEW.sub_group_name_indexed NOT IN ('country','province') THEN
      /*Trigger trg_cpy_gtutags_taggroups has already occured and values from tags table should be correct... but really need a check !*/
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag) from tags where gtu_ref = NEW.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = NEW.gtu_ref;
      END IF;
    ELSIF TG_OP = 'DELETE' THEN
      IF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'country' THEN
        UPDATE specimens
        SET gtu_country_tag_value = NULL,
            gtu_country_tag_indexed = NULL
        WHERE gtu_ref = OLD.gtu_ref;
      ELSIF OLD.group_name_indexed = 'administrativearea' AND OLD.sub_group_name_indexed = 'province' THEN
        UPDATE specimens
        SET gtu_province_tag_value = NULL,
            gtu_province_tag_indexed = NULL
        WHERE gtu_ref = OLD.gtu_ref;
      ELSE
        /*Trigger trg_cpy_gtutags_taggroups has already occured and values from tags table should be correct... but really need a check !*/
        UPDATE specimens
        SET gtu_others_tag_value = (select array_to_string(array(select tag from tags where gtu_ref = OLD.gtu_ref and sub_group_type not in ('country', 'province')), ';')),
            gtu_others_tag_indexed = (select array(select distinct fullToIndex(tag) from tags where gtu_ref = OLD.gtu_ref and sub_group_type not in ('country', 'province')))
        WHERE gtu_ref = OLD.gtu_ref;
      END IF;
    END IF;
  END IF;
  PERFORM set_config('darwin.userid', tmp_user, false) ;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.fct_update_specimens_flat_related() OWNER TO darwin2;

--
-- TOC entry 1852 (class 1255 OID 4816483)
-- Name: fulltoindex(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fulltoindex(to_indexed character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
BEGIN
   return fulltoindex(to_indexed, false);
END;
$$;


ALTER FUNCTION darwin2.fulltoindex(to_indexed character varying) OWNER TO darwin2;

--
-- TOC entry 1909 (class 1255 OID 5307648)
-- Name: fulltoindex(character varying, boolean); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.fulltoindex(to_indexed character varying, keep_space boolean) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    temp_string varchar;
BEGIN
    -- Investigate https://launchpad.net/postgresql-unaccent
    temp_string := to_indexed;
    temp_string := translate(temp_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
    temp_string := translate(temp_string, 'èééêëēĕėęěĒĔĖĘĚ', 'eeeeeeeeeeeeeee');
    temp_string := translate(temp_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
    temp_string := translate(temp_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
    temp_string := translate(temp_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
    temp_string := REPLACE(temp_string, 'Œ', 'oe');
    temp_string := REPLACE(temp_string, 'Ӕ', 'ae');
    temp_string := REPLACE(temp_string, 'œ', 'oe');
    temp_string := REPLACE(temp_string, 'æ', 'ae');
    temp_string := REPLACE(temp_string, 'ë', 'e');
    temp_string := REPLACE(temp_string, 'ï', 'i');
    temp_string := REPLACE(temp_string, 'ö', 'o');
    temp_string := REPLACE(temp_string, 'ü', 'u');
--     temp_string := REPLACE(temp_string, E'\'', '');
--     temp_string := REPLACE(temp_string, '"', '');
    temp_string := REPLACE(temp_string, 'ñ', 'n');
    temp_string := REPLACE(temp_string,chr(946),'b');
    temp_string := TRANSLATE(temp_string,'Ð','d');
    temp_string := TRANSLATE(temp_string,'ó','o');
    temp_string := TRANSLATE(temp_string,'ę','e');
    temp_string := TRANSLATE(temp_string,'ā','a');
    temp_string := TRANSLATE(temp_string,'ē','e');
    temp_string := TRANSLATE(temp_string,'ī','i');
    temp_string := TRANSLATE(temp_string,'ō','o');
    temp_string := TRANSLATE(temp_string,'ū','u');
    temp_string := TRANSLATE(temp_string,'ş','s');
    temp_string := TRANSLATE(temp_string,'Ş','s');
--     temp_string := TRANSLATE(temp_string,'†','');
--     temp_string := TRANSLATE(temp_string,chr(52914),'');
--ftheeten 2015 02 15

--ftheeten 2017 01 22
temp_string := TRANSLATE(temp_string,'-',' ');
temp_string := TRANSLATE(temp_string,'''',' ');
    -- FROM 160 to 255 ASCII
    temp_string := TRANSLATE(temp_string, ' ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ',
      '  cL YS sCa  -R     Zu .z   EeY?AAAAAAACEEEEIIII NOOOOOxOUUUUYTBaaaaaaaceeeeiiii nooooo/ouuuuyty');
    --Remove ALL none alphanumerical char
    if keep_space= false then
    temp_string := lower(regexp_replace(temp_string,'[^[:alnum:]]','', 'g'));
    else
        temp_string := lower(regexp_replace(temp_string,'[^[:alnum:]\s]','', 'g'));
	temp_string :=regexp_replace(temp_string,'(\s{2,})',' ', 'g');
	
    end if;
    return temp_string;
END;
$$;


ALTER FUNCTION darwin2.fulltoindex(to_indexed character varying, keep_space boolean) OWNER TO darwin2;

--
-- TOC entry 1846 (class 1255 OID 4816484)
-- Name: get_import_row(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.get_import_row() RETURNS integer
    LANGUAGE sql SECURITY DEFINER
    AS $$

UPDATE imports SET state = 'aloaded' FROM (
  SELECT * FROM (
    SELECT  * FROM imports i1 WHERE i1.state = 'to_be_loaded' ORDER BY i1.created_at asc, id asc OFFSET 0 --thats important
  ) i2
  WHERE pg_try_advisory_lock('imports'::regclass::integer, i2.id)
  LIMIT 1
) i3
WHERE imports.id = i3.id RETURNING i3.id;
$$;


ALTER FUNCTION darwin2.get_import_row() OWNER TO darwin2;

--
-- TOC entry 1847 (class 1255 OID 4816485)
-- Name: get_setting(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.get_setting(param text, OUT value text) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$BEGIN
  SELECT current_setting(param) INTO value;
  EXCEPTION
  WHEN UNDEFINED_OBJECT THEN
    value := NULL;
END;$$;


ALTER FUNCTION darwin2.get_setting(param text, OUT value text) OWNER TO darwin2;

--
-- TOC entry 1848 (class 1255 OID 4816486)
-- Name: getspecificparentforlevel(character varying, character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.getspecificparentforlevel(referenced_relation character varying, path character varying, level_searched character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  response template_classifications.name%TYPE := '';
BEGIN
  EXECUTE
  'SELECT name ' ||
  ' FROM '
  || quote_ident(lower(referenced_relation)) || ' cat '
  ' INNER JOIN catalogue_levels ON cat.level_ref = catalogue_levels.id '
  ' WHERE level_name = '
  || quote_literal(lower(level_searched)) ||
  '   AND cat.id IN (SELECT i_id::integer FROM regexp_split_to_table(' || quote_literal(path) || E', E''\/'') as i_id WHERE i_id != '''')'
  INTO response;
  RETURN response;
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Error in getSpecificParentForLevel: %', SQLERRM;
    RETURN response;
END;
$$;


ALTER FUNCTION darwin2.getspecificparentforlevel(referenced_relation character varying, path character varying, level_searched character varying) OWNER TO darwin2;

--
-- TOC entry 1849 (class 1255 OID 4816487)
-- Name: gettagsindexedasarray(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.gettagsindexedasarray(taglist character varying) RETURNS character varying[]
    LANGUAGE sql IMMUTABLE
    AS $_$
  SELECT array_agg(tags) FROM (SELECT lineToTagRows($1) as tags) as subQuery;
$_$;


ALTER FUNCTION darwin2.gettagsindexedasarray(taglist character varying) OWNER TO darwin2;

--
-- TOC entry 1899 (class 1255 OID 4816488)
-- Name: is_property_unit_in_group(text, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.is_property_unit_in_group(searched_unit text, property_unit text) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$

  SELECT CASE
  WHEN $1 IN ('Kt', 'Beaufort', 'm/s')
    AND  $2  IN ('Kt', 'Beaufort', 'm/s')
    THEN TRUE
  WHEN $1 IN ( 'g', 'hg', 'kg', 'ton', 'dg', 'cg', 'mg', 'lb', 'lbs', 'pound' , 'ounce' , 'grain')
    AND  $2  IN ( 'g', 'hg', 'kg', 'ton', 'dg', 'cg', 'mg', 'lb', 'lbs', 'pound' , 'ounce' , 'grain')
    THEN TRUE

  WHEN $1 IN ('m³', 'l', 'cm³', 'ml', 'mm³' ,'µl' , 'µm³' , 'km³', 'Ml' , 'hl')
    AND  $2  IN ( 'g', 'hg', 'kg', 'ton', 'dg', 'cg', 'mg', 'lb', 'lbs', 'pound' , 'ounce' , 'grain')
    THEN TRUE

  WHEN $1 IN ('K', '°C', '°F', '°Ra', '°Re', '°r', '°N', '°Rø', '°De')
    AND  $2  IN ('K', '°C', '°F', '°Ra', '°Re', '°r', '°N', '°Rø', '°De')
    THEN TRUE

  WHEN $1 IN ('m', 'dm', 'cm', 'mm', 'µm', 'nm', 'pm', 'fm', 'am', 'zm', 'ym', 'am', 'dam', 'hm', 'km', 'Mm', 'Gm', 'Tm', 'Pm', 'Em', 'Zm', 'Ym', 'mam', 'mom', 'Å', 'ua', 'ch', 'fathom', 'fermi', 'ft', 'in', 'K', 'l.y.', 'ly', 'µ', 'mil', 'mi', 'nautical mi', 'pc', 'point', 'pt', 'pica', 'rd', 'yd', 'arp', 'lieue', 'league', 'cal', 'twp', 'p', 'P', 'fur', 'brasse', 'vadem', 'fms')
    AND  $2  IN ('m', 'dm', 'cm', 'mm', 'µm', 'nm', 'pm', 'fm', 'am', 'zm', 'ym', 'am', 'dam', 'hm', 'km', 'Mm', 'Gm', 'Tm', 'Pm', 'Em', 'Zm', 'Ym', 'mam', 'mom', 'Å', 'ua', 'ch', 'fathom', 'fermi', 'ft', 'in', 'K', 'l.y.', 'ly', 'µ', 'mil', 'mi', 'nautical mi', 'pc', 'point', 'pt', 'pica', 'rd', 'yd', 'arp', 'lieue', 'league', 'cal', 'twp', 'p', 'P', 'fur', 'brasse', 'vadem', 'fms')
    THEN TRUE
  ELSE FALSE END;
$_$;


ALTER FUNCTION darwin2.is_property_unit_in_group(searched_unit text, property_unit text) OWNER TO postgres;

--
-- TOC entry 1855 (class 1255 OID 4816489)
-- Name: isnumeric(text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.isnumeric(text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE x NUMERIC;
BEGIN
    x = $1::NUMERIC;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;
$_$;


ALTER FUNCTION darwin2.isnumeric(text) OWNER TO postgres;

--
-- TOC entry 1857 (class 1255 OID 4816490)
-- Name: labeling_code_for_indexation(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.labeling_code_for_indexation(part_ref integer) RETURNS character varying[]
    LANGUAGE sql IMMUTABLE
    AS $_$
select array_agg(coding)
from (select trim(coalesce(code_prefix, '') || coalesce(code_prefix_separator, '') || coalesce(code, '') || coalesce(code_suffix_separator, '') || coalesce(code_suffix, ''))::varchar as coding
      from codes
      where referenced_relation = 'specimens'
        and record_id = $1
        and code_category = 'main'
        and coalesce(upper(code_prefix),'') != 'RBINS'
     ) as x;
$_$;


ALTER FUNCTION darwin2.labeling_code_for_indexation(part_ref integer) OWNER TO darwin2;

--
-- TOC entry 1856 (class 1255 OID 4816491)
-- Name: labeling_individual_type_for_indexation(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.labeling_individual_type_for_indexation(individual_type character varying) RETURNS character varying[]
    LANGUAGE sql IMMUTABLE
    AS $_$
SELECT array[coalesce(fullToIndex($1),'-')];
$_$;


ALTER FUNCTION darwin2.labeling_individual_type_for_indexation(individual_type character varying) OWNER TO darwin2;

--
-- TOC entry 1858 (class 1255 OID 4816492)
-- Name: labeling_part_for_indexation(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.labeling_part_for_indexation(part character varying) RETURNS character varying[]
    LANGUAGE sql IMMUTABLE
    AS $_$
SELECT array[coalesce(fullToIndex($1),'-')];
$_$;


ALTER FUNCTION darwin2.labeling_part_for_indexation(part character varying) OWNER TO darwin2;

--
-- TOC entry 1850 (class 1255 OID 4816493)
-- Name: labeling_type_for_indexation(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.labeling_type_for_indexation(individual_type character varying) RETURNS character varying[]
    LANGUAGE sql IMMUTABLE
    AS $_$
SELECT array[coalesce(fullToIndex($1),'-')];
$_$;


ALTER FUNCTION darwin2.labeling_type_for_indexation(individual_type character varying) OWNER TO darwin2;

--
-- TOC entry 1853 (class 1255 OID 4816494)
-- Name: linetotagarray(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.linetotagarray(line text) RETURNS character varying[]
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
select array_agg(tags_list) FROM (SELECT lineToTagRows($1) AS tags_list ) as x;
$_$;


ALTER FUNCTION darwin2.linetotagarray(line text) OWNER TO darwin2;

--
-- TOC entry 1854 (class 1255 OID 4816495)
-- Name: linetotagrows(text); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.linetotagrows(line text) RETURNS SETOF character varying
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT distinct(fulltoIndex(tags)) FROM regexp_split_to_table($1, ';') as tags WHERE fulltoIndex(tags) != '' ;
$_$;


ALTER FUNCTION darwin2.linetotagrows(line text) OWNER TO darwin2;

--
-- TOC entry 1851 (class 1255 OID 4816496)
-- Name: point_equal(point, point); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.point_equal(point, point) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$SELECT
CASE WHEN $1[0] = $2[0] AND $1[1] = $2[1] THEN true
ELSE false END;$_$;


ALTER FUNCTION darwin2.point_equal(point, point) OWNER TO postgres;

--
-- TOC entry 1859 (class 1255 OID 4816497)
-- Name: rmca_cast_staging_gtu_date_to_mask(timestamp without time zone, time without time zone, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_cast_staging_gtu_date_to_mask(p_date timestamp without time zone, p_time time without time zone, date_resolution character varying) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
DECLARE
	date_returned timestamp;
	mask_returned varchar;
	returned varchar[];
BEGIN

	SELECT 
	CASE WHEN p_time is not null then 63
		WHEN LOWER(date_resolution)='day' THEN 56
		WHEN LOWER(date_resolution)='month' THEN 48
		WHEN LOWER(date_resolution)='year' THEN 32
		ELSE
		NULL
		END into mask_returned;
	
	SELECT CASE WHEN p_time is not null then  p_date+ p_time
		WHEN LOWER(date_resolution)='day' THEN p_date
		WHEN LOWER(date_resolution)='month' THEN date_trunc('month', p_date)
		WHEN LOWER(date_resolution)='year' THEN date_trunc('year', p_date)
		ELSE
		NULL
		END into date_returned
		;
			
	returned :=ARRAY[date_returned::varchar, mask_returned::varchar];
	return returned;
END;
$$;


ALTER FUNCTION darwin2.rmca_cast_staging_gtu_date_to_mask(p_date timestamp without time zone, p_time time without time zone, date_resolution character varying) OWNER TO darwin2;

--
-- TOC entry 1860 (class 1255 OID 4816498)
-- Name: rmca_create_missing_people_in_staging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_create_missing_people_in_staging(p_import_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	curs1 record;
	tmpid int;
	
BEGIN 
	DROP TABLE if EXISTs tmp_people_import_rmca;
	CREATE TEMPORARY TABLE tmp_people_import_rmca(pk int, name varchar);
	RAISE NOTICE 'Different peoples %', (SELECT COUNT(DISTINCT formated_name) from staging a
		--inner join codes b
		--on referenced_relation='staging'
		--and a.id=b.record_id
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging'
		where a.to_import='f' 
		and people_ref is null
		and import_ref=p_import_ref);
	RAISE NOTICE 'linked specimens to be imported %', (SELECT COUNT(formated_name) from staging a
		--inner join codes b
		--on referenced_relation='staging'
		--and a.id=b.record_id
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging'
		where a.to_import='f' 
		and people_ref is null
		and import_ref=p_import_ref);
	FOR curs1 IN SELECT DISTINCT formated_name from staging a
		--inner join codes b
		--on referenced_relation='staging'
		--and a.id=b.record_id
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging'
		where a.to_import='f' 
		and people_ref is null
		and import_ref=p_import_ref 
		/*UNION
		SELECT distinct formated_name from staging a
		inner join codes b
		on b.referenced_relation='staging'
		and a.id=b.record_id
		INNER JOIN identifications c
		ON c.record_id=a.id
		AND c.referenced_relation='staging'
		INNER JOIN
		staging_people d
		ON d.referenced_relation='identifications'
		AND c.id=d.record_id
		and people_ref is null
		where a.to_import='f' 

		and import_ref=p_import_ref
		*/
		

		LOOP
		
		RAISE NOTICE '%', curs1.formated_name;
		RAISE NOTICE 'people with this name %', (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) );
		RAISE NOTICE 'people split %',  (SELECT regexp_split_to_array(curs1.formated_name, ' '));
		IF  (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) )=0 THEN
            INSERT INTO people (family_name, import_ref) VALUES (curs1.formated_name, p_import_ref) RETURNING id INTO tmpid;
            INSERT INTO tmp_people_import_rmca (pk, name) VALUES(tmpid, curs1.formated_name);
		ELSE
           INSERT INTO tmp_people_import_rmca (pk, name) SELECT id, family_name FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) LIMIT 1;
        END IF;
		
	END LOOP;
	DELETE FROM tmp_people_import_rmca;

	RAISE NOTICE  'GO identifications';
	UPDATE staging_people SET people_ref=tmp_people_import_rmca.pk FROM (SELECT pk, name FROM tmp_people_import_rmca ) AS tmp_people_import_rmca WHERE staging_people.formated_name=tmp_people_import_rmca.name 
	and referenced_relation='staging'
		
		and people_ref is null
		and record_id IN (SELECT id FROM staging WHERE import_ref=p_import_ref AND to_import='f' )
		
		;




		FOR curs1 IN 
		SELECT distinct formated_name from staging a
		--inner join codes b
		--on b.referenced_relation='staging'
		--and a.id=b.record_id
		INNER JOIN identifications c
		ON c.record_id=a.id
		AND c.referenced_relation='staging'
		INNER JOIN
		staging_people d
		ON d.referenced_relation='identifications'
		AND c.id=d.record_id
		and people_ref is null
		where a.to_import='f' 

		and import_ref=p_import_ref
		
		

		LOOP
		
		RAISE NOTICE '%', curs1.formated_name;
		RAISE NOTICE 'people ident with this name %', (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) );
		RAISE NOTICE 'people ident split %',  (SELECT regexp_split_to_array(curs1.formated_name, ' '));
		IF  (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) )=0 THEN
            RAISE NOTICE 'INSERT %', curs1.formated_name;
                INSERT INTO people (family_name, import_ref) VALUES (curs1.formated_name, p_import_ref) RETURNING id INTO tmpid;
                INSERT INTO tmp_people_import_rmca (pk, name) VALUES(tmpid, curs1.formated_name);
		ELSE    
            INSERT INTO tmp_people_import_rmca (pk, name) SELECT id, family_name FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) LIMIT 1;
        END IF;
		
	END LOOP;
		UPDATE staging_people SET people_ref=tmp_people_import_rmca_alias.id FROM (SELECT id, family_name FROM people) AS tmp_people_import_rmca_alias 
		WHERE formated_name=tmp_people_import_rmca_alias.family_name 
		--and referenced_relation='identifications'
		
		and people_ref is null
		/*and record_id IN (SELECT c.id FROM identifications c 
			INNER join staging a ON 
			 c.referenced_relation='staging' AND c.record_id=a.id
			 WHERE import_ref=p_import_ref AND a.to_import='f' )
		*/	 
		
		;
	DROP TABLE  tmp_people_import_rmca;

	--clean staging status for identifications (2018 09 05)
		UPDATE staging SET status=status - 'identifiers'::varchar  WHERE id IN
		(
		SELECT identifications.record_id from staging_people 
		INNER JOIN
		identifications

		ON staging_people.referenced_relation='identifications' 
		AND staging_people.record_id = identifications.id
		WHERE identifications.referenced_relation='staging'
		AND identifications.record_id IN  (select id FROM staging WHERE import_ref=p_import_ref)
		AND staging_people.people_ref IS NOT NULL 

		)
		;
	-- clean staging status for other peoples (2018 09 05)
			UPDATE staging SET status=status - 'people'::varchar  WHERE id IN (SELECT record_id from staging_people WHERE referenced_relation='staging'  AND staging_people.people_ref IS NOT NULL AND record_id IN (SELECT id FROM staging WHERe import_ref = p_import_ref)
		);



	-- TO DO : clean staging status for operators


END;
$$;


ALTER FUNCTION darwin2.rmca_create_missing_people_in_staging(p_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1861 (class 1255 OID 4816499)
-- Name: rmca_delete_specimens_from_import_all(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_delete_specimens_from_import_all(p_import_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
 auto_increment BOOLEAN;
 last_value INTEGER;
 last_true_value INTEGER;
BEGIN 

DELETE FROM staging_people WHERE  referenced_relation ='identifications' AND record_id NOT IN (SELECT id FROM identifications)
;
DELETE FROM staging_people WHERE referenced_relation ='staging' AND record_id NOT IN (SELECT id FROM staging);

ALTER table properties disable trigger user; 
ALTER table comments disable trigger user; 
RAISE NOTICE 'before delete properties %', (SELECT count(*) FROM properties);
DELETE FROM properties WHERE record_id IN (SELECT id FROM specimens WHERE import_ref=p_import_ref) AND referenced_relation= 'specimens';
RAISE NOTICE 'after delete properties (specimens) %', (SELECT count(*) FROM properties);


RAISE NOTICE 'before delete comments %', (SELECT count(*) FROM comments);
DELETE FROM comments WHERE record_id IN (SELECT id FROM specimens WHERE import_ref=p_import_ref) AND referenced_relation='specimens';
RAISE NOTICE 'afet delete comments (specimens) %', (SELECT count(*) FROM comments);


RAISE NOTICE 'before delete properties %', (SELECT count(*) FROM properties);
DELETE FROM properties WHERE record_id IN (SELECT id FROM staging WHERE import_ref=p_import_ref) AND referenced_relation= 'staging';
RAISE NOTICE 'after delete properties (staging) %', (SELECT count(*) FROM properties);

RAISE NOTICE 'before delete comments %', (SELECT count(*) FROM comments);
DELETE FROM comments WHERE record_id IN (SELECT id FROM staging WHERE import_ref =p_import_ref) AND referenced_relation= 'staging';
RAISE NOTICE 'after delete comments (staging) %', (SELECT count(*) FROM comments);

RAISE NOTICE 'before delete properties %', (SELECT count(*) FROM comments);
DELETE
  FROM properties where referenced_relation ='staging_info' and record_id in (SELECT id FROM staging_info WHERE staging_ref IN (SELECT id FROM staging WHERE import_ref = p_import_ref) )  AND referenced_relation= 'staging_info';
RAISE NOTICE 'after delete properties (staging_info) %', (SELECT count(*) FROM properties);

RAISE NOTICE 'before delete comments %', (SELECT count(*) FROM comments);
DELETE
  FROM comments where referenced_relation ='staging_info' and record_id in (SELECT id FROM staging_info WHERE staging_ref IN (SELECT id FROM staging WHERE import_ref = p_import_ref) )  AND referenced_relation= 'staging_info';
RAISE NOTICE 'after  delete comments (staging_info) %', (SELECT count(*) FROM comments);

ALTER table properties enable trigger user; 
ALTER table comments enable trigger user; 

RAISE NOTICE 'before delete tags %', (SELECT count(*) FROM tags);
DELETE FROM tags WHERE gtu_ref IN (SELECT id FROM gtu WHERE id in (SELECT gtu_ref FROM specimens WHERE import_ref = p_import_ref) );
RAISE NOTICE 'after delete tags %', (SELECT count(*) FROM tags);


RAISE NOTICE 'before delete staging_info %', (SELECT count(*) FROM staging_info);
DELETE FROM staging_info WHERE staging_ref IN (SELECT distinct gtu_ref FROM staging   WHERE import_ref = p_import_ref);
RAISE NOTICE 'after delete staging_info %', (SELECT count(*) FROM staging_info);

ALTER TABLE identifications DISABLE TRIGGER user ;

RAISE NOTICE 'before delete identifications (specimens) %', (SELECT count(*) FROM identifications);
DELETE FROM identifications WHERE referenced_relation='specimens' AND record_id IN (SELECT id FROM specimens WHERE import_ref = p_import_ref);

RAISE NOTICE 'after delete identifications (specimens) %', (SELECT count(*) FROM identifications);

ALTER TABLE identifications ENABLE  TRIGGER user;

RAISE NOTICE 'before delete identifications (staging) %', (SELECT count(*) FROM identifications);



DELETE FROM identifications WHERE referenced_relation='staging' AND record_id IN (SELECT id FROM staging WHERE import_ref  = p_import_ref);
RAISE NOTICE 'atfer delete identifications (staging) %', (SELECT count(*) FROM identifications);



ALTER TABLE specimens DISABLE TRIGGER trg_chk_specimencollectionallowed;

RAISE NOTICE 'update specimens nullify FKs';
UPDATE specimens SET gtu_ref=NULL, taxon_ref=NULL, ig_ref=NULL WHERE import_ref=p_import_ref;

ALTER TABLE specimens ENABLE TRIGGER trg_chk_specimencollectionallowed;

RAISE NOTICE 'update staging nullify FKs';
UPDATE staging SET gtu_ref=NULL, taxon_ref=NULL, ig_ref=NULL WHERE id IN (SELECT id FROM staging WHERE import_ref = p_import_ref) ;


RAISE NOTICE 'before delete gtu %', (SELECT count(*) FROM gtu);
--DELETE FROM gtu WHERE id NOT in (SELECT gtu_ref FROM specimens) AND id NOT in (SELECT gtu_ref FROM staging);
RAISE NOTICE 'ater delete gtu %', (SELECT count(*) FROM gtu);


RAISE NOTICE 'before delete igs %', (SELECT count(*) FROM igs);

DELETE FROM igs WHERE id  in (SELECT ig_ref FROM specimens where import_ref=p_import_ref) AND id  in (SELECT ig_ref FROM staging where import_ref  =p_import_ref);

RAISE NOTICE 'after delete igs %', (SELECT count(*) FROM igs);

RAISE NOTICE 'before delete specimens_relationshipes %', (SELECT count(*) FROM specimens_relationships);
DELETE FROM specimens_relationships WHERE unit_type='specimens' AND (specimen_ref IN (SELECT id FROM specimens WHERE import_ref=p_import_ref) OR specimen_related_ref IN (SELECT id FROM specimens WHERE import_ref=p_import_ref));
RAISE NOTICE 'after delete specimens_relationshipes %', (SELECT count(*) FROM specimens_relationships);

RAISE NOTICE 'before delete staging %', (SELECT count(*) FROM staging);
DELETE FROM staging WHERE import_ref =p_import_ref;
RAISE NOTICE 'after  delete staging %', (SELECT count(*) FROM staging);


ALTER TABLE storage_parts DISABLE TRIGGER user;
RAISE NOTICE 'before delete storage_parts %', (SELECT count(*) FROM storage_parts);
DELETE FROM storage_parts where specimen_ref in (select id from specimens WHERE import_ref=p_import_ref);
RAISE NOTICE 'after delete storage_parts %', (SELECT count(*) FROM storage_parts);
--DELETE FROM collections WHERE id=p_coll_ref;
ALTER TABLE storage_parts ENABLE TRIGGER user;

ALTER TABLE specimens DISABLE TRIGGER user;
RAISE NOTICE 'before delete specimens %', (SELECT count(*) FROM specimens);
DELETE FROM specimens WHERE import_ref=p_import_ref;
RAISE NOTICE 'after delete specimens %', (SELECT count(*) FROM specimens);
--DELETE FROM collections WHERE id=p_coll_ref;
ALTER TABLE specimens ENABLE TRIGGER user;


END;
$$;


ALTER FUNCTION darwin2.rmca_delete_specimens_from_import_all(p_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1863 (class 1255 OID 4816500)
-- Name: rmca_dms_to_dd(character varying, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_dms_to_dd(coord_dms character varying, direction character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
	deg_path integer;
	decimal_part double precision;
	sign integer;
	returned double precision;
	go boolean;
	acc varchar[];
BEGIN

	returned:=fct_cast_to_real(coord_dms);
	coord_dms:=replace(coord_dms, ',','.');
	IF returned IS NOT NULL THEN
		RETURN returned;
	END IF;
	go:=false;
	acc :=regexp_matches(coord_dms, '[^\d]*(\d+)°');
	--raise notice '%', acc;
	if ARRAY_LENGTH(acc,1)>0 THEN
		go:=true;
		returned:=acc[1]::double precision;
		acc :=regexp_matches(coord_dms, '°\s*([\.\d]+)''');
		if ARRAY_LENGTH(acc,1)>0 THEN
			decimal_part=acc[1]::double precision/60;
			returned:=returned+decimal_part;
			acc :=regexp_matches(coord_dms, '''\s*([\.\d]+)"');
			if ARRAY_LENGTH(acc,1)>0 THEN
				decimal_part=acc[1]::double precision/3600;
				returned:=returned+decimal_part;
			END IF;
		END IF;
		IF LOWER(direction)='latitude' THEN
			IF POSITION('S' IN  UPPER(coord_dms))>0 THEN
				returned=returned*-1;
			END IF;
		ELSEIF LOWER(direction)='longitude' THEN
			IF POSITION('W' IN  UPPER(coord_dms))>0 THEN
				returned=returned*-1;
			END IF;
		END IF;
		
	END IF;
	
	
	return returned;
END;
$$;


ALTER FUNCTION darwin2.rmca_dms_to_dd(coord_dms character varying, direction character varying) OWNER TO darwin2;

--
-- TOC entry 1862 (class 1255 OID 4816501)
-- Name: rmca_dms_to_text(character varying, integer, double precision, double precision, integer, double precision, character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_dms_to_text(coordinates_format character varying, degrees integer, minutes double precision, seconds double precision, direction integer, coord_decimal double precision, lat_lon character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	returned varchar;
BEGIN
	returned='';
	IF LOWER(coordinates_format) = 'dms' THEN
		IF degrees is not null THEN
			returned:=returned||TRIM(degrees::varchar)||'° ';
			IF minutes is not null THEN
				returned:=returned||TRIM(minutes::varchar)||''' ';
				IF seconds is not null THEN
					returned:=returned||TRIM(seconds::varchar)||'" ';
				END IF;
			END IF;
			IF LOWER(lat_lon)='lat' THEN
				IF direction<0 THEN
					returned:=returned||'S';
				ELSE
					returned:=returned||'N';
				END IF;
			ELSIF LOWER(lat_lon)='lon' THEN
				IF direction<0 THEN
					returned:=returned||'W';
				ELSE
					returned:=returned||'E';
				END IF;
			END IF;
		END IF;
	ELSE 
		--implicitely DD
		IF LOWER(lat_lon)='lat' THEN
				IF direction<0 THEN
					returned:=coord_decimal::varchar||' S';
				ELSE
					returned:=coord_decimal::varchar||' N';
				END IF;
		ELSIF LOWER(lat_lon)='lon' THEN
				IF direction<0 THEN
					returned:=coord_decimal::varchar||' W';
				ELSE
					returned:=coord_decimal::varchar||' E';
				END IF;
			END IF;
	END IF;
	return TRIM(returned);
END;
$$;


ALTER FUNCTION darwin2.rmca_dms_to_text(coordinates_format character varying, degrees integer, minutes double precision, seconds double precision, direction integer, coord_decimal double precision, lat_lon character varying) OWNER TO darwin2;

--
-- TOC entry 1932 (class 1255 OID 5307855)
-- Name: rmca_dmscheck_syntax(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	acc varchar[];
       returned boolean;
BEGIN

        returned:=false;
        IF coord_dms IS NULL THEN
		RETURN NULL;
        END IF;
        coord_dms:=replace(coord_dms, ',','.');
	acc :=regexp_matches(coord_dms, '[^\d]*(\d+)°');
	
	if ARRAY_LENGTH(acc,1)>0 THEN
		returned:=true;
		acc :=regexp_matches(coord_dms, '°\s*([\.\d]+\s*)''');
		if ARRAY_LENGTH(acc,1)>0 THEN
			returned:=true;
			acc :=regexp_matches(coord_dms, '''\s*([\.\d]+\s*)"');
			if ARRAY_LENGTH(acc,1)>0 THEN
				returned:=true;
			ELSE
				acc :=regexp_matches(coord_dms, '''\s*([\.\d]+\s*)');
				IF ARRAY_LENGTH(acc,1)>0 THEN
					returned:=false;
				END IF;
			END IF;
		ELSE 
			acc :=regexp_matches(coord_dms, '°\s*([\.\d]+\s*)');
			IF ARRAY_LENGTH(acc,1)>0 THEN
			returned:=false;
			END IF;
		END IF;
		
	END IF;
	
	return returned;
END;
$$;


ALTER FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) OWNER TO darwin2;

--
-- TOC entry 1903 (class 1255 OID 5304957)
-- Name: rmca_fct_clear_gtu_date(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_fct_clear_gtu_date() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    DELETE FROM temporal_information where gtu_ref = OLD.id;
  END IF;
  RETURN OLD;
 END;
$$;


ALTER FUNCTION darwin2.rmca_fct_clear_gtu_date() OWNER TO darwin2;

--
-- TOC entry 1904 (class 1255 OID 5304961)
-- Name: rmca_fct_clear_specimen_date(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_fct_clear_specimen_date() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    DELETE FROM temporal_information where specimen_ref = OLD.id;
  END IF;
  RETURN NULL;
 END;
$$;


ALTER FUNCTION darwin2.rmca_fct_clear_specimen_date() OWNER TO darwin2;

--
-- TOC entry 1905 (class 1255 OID 5304959)
-- Name: rmca_fct_update_specimen_date(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_fct_update_specimen_date() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF NEW.gtu_from_date IS NOT NULL OR NEW.gtu_to_date IS NOT NULL THEN --added ftheeten 2019 01 16 to avoid call by updates on other tables
		PERFORM * FROM temporal_information WHERE specimen_ref=NEW.id;
		IF NOT FOUND THEN
			INSERT INTO temporal_information(gtu_ref, specimen_ref, from_date_mask, from_date, to_date_mask, 
		    to_date) VALUES(NEW.gtu_ref, NEW.id, NEW.gtu_from_date_mask, NEW.gtu_from_date, NEW.gtu_to_date_mask, 
		    NEW.gtu_to_date);
		ELSE
		
			UPDATE temporal_information 
				SET gtu_Ref=NEW.gtu_ref,
					from_date_mask=NEW.gtu_from_date_mask,
					from_date=NEW.gtu_from_date,
					to_date_mask=NEW.gtu_to_date_mask,
					to_date=NEW.gtu_to_date
			WHERE specimen_ref=NEW.id;
		END IF;
	ELSE 
		DELETE FROM temporal_information WHERE specimen_ref=NEW.id;
	END IF;	
  
  RETURN NEW;
 END;
$$;


ALTER FUNCTION darwin2.rmca_fct_update_specimen_date() OWNER TO darwin2;

--
-- TOC entry 1872 (class 1255 OID 4816502)
-- Name: rmca_import_gtu_create_missing_people_in_staging(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_import_gtu_create_missing_people_in_staging(p_import_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	curs1 record;
	tmpid int;
	
BEGIN 
	DROP TABLE if EXISTs tmp_people_import_rmca;
	CREATE TEMPORARY TABLE tmp_people_import_rmca(pk int, name varchar);
	RAISE NOTICE 'Different peoples %', (SELECT COUNT(DISTINCT formated_name) from staging_gtu a
		
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging_gtu'
		where-- a.to_import='f' 
		--and 
		people_ref is null
		and import_ref=p_import_ref);
	RAISE NOTICE 'linked specimens to be imported %', (SELECT COUNT(formated_name) from staging_gtu a
		
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging_gtu'
		where --a.to_import='f' 
		--and 
		people_ref is null
		and import_ref=p_import_ref);
	FOR curs1 IN SELECT DISTINCT formated_name from staging_gtu a
		
		inner join staging_people c
		ON
		c.record_id=a.id
		and c.referenced_relation='staging_gtu'
		where --a.to_import='f' 
		--and 
		people_ref is null
		and import_ref=p_import_ref 
		
		

		LOOP
		
		RAISE NOTICE '%', curs1.formated_name;
		RAISE NOTICE 'people with this name %', (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) );
		RAISE NOTICE 'people split %',  (SELECT regexp_split_to_array(curs1.formated_name, ' '));
		IF  (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) )=0 THEN
            INSERT INTO people (family_name) VALUES (curs1.formated_name) RETURNING id INTO tmpid;
            INSERT INTO tmp_people_import_rmca (pk, name) VALUES(tmpid, curs1.formated_name);
		ELSE
           INSERT INTO tmp_people_import_rmca (pk, name) SELECT id, family_name FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) LIMIT 1;
        END IF;
		
	END LOOP;
	DELETE FROM tmp_people_import_rmca;

	RAISE NOTICE  'GO identifications';
	UPDATE staging_people SET people_ref=tmp_people_import_rmca.pk FROM (SELECT pk, name FROM tmp_people_import_rmca ) AS tmp_people_import_rmca WHERE staging_people.formated_name=tmp_people_import_rmca.name 
	and referenced_relation='staging_gtu'
		
		and people_ref is null
		and record_id IN (SELECT id FROM staging_gtu WHERE import_ref=p_import_ref --AND to_import='f'
		 )
		
		;




		FOR curs1 IN 
		SELECT distinct formated_name from staging_gtu a
		--inner join codes b
		--on b.referenced_relation='staging'
		--and a.id=b.record_id
		INNER JOIN identifications c
		ON c.record_id=a.id
		AND c.referenced_relation='staging_gtu'
		INNER JOIN
		staging_people d
		ON d.referenced_relation='identifications'
		AND c.id=d.record_id
		and people_ref is null
		where --a.to_import='f' 

		--and 
		import_ref=p_import_ref
		
		

		LOOP
		
		RAISE NOTICE '%', curs1.formated_name;
		RAISE NOTICE 'people ident with this name %', (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) );
		RAISE NOTICE 'people ident split %',  (SELECT regexp_split_to_array(curs1.formated_name, ' '));
		IF  (sELECt count(*) FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) )=0 THEN
            RAISE NOTICE 'INSERT %', curs1.formated_name;
                INSERT INTO people (family_name) VALUES (curs1.formated_name) RETURNING id INTO tmpid;
                INSERT INTO tmp_people_import_rmca (pk, name) VALUES(tmpid, curs1.formated_name);
		ELSE    
            INSERT INTO tmp_people_import_rmca (pk, name) SELECT id, family_name FROM people WHERE people.formated_name_indexed LIKE fulltoindex(curs1.formated_name, true) LIMIT 1;
        END IF;
		
	END LOOP;
		UPDATE staging_people SET people_ref=tmp_people_import_rmca_alias.id FROM (SELECT id, family_name FROM people) AS tmp_people_import_rmca_alias 
		WHERE formated_name=tmp_people_import_rmca_alias.family_name 
		--and referenced_relation='identifications'
		
		and people_ref is null
		
		
		;
	DROP TABLE  tmp_people_import_rmca;

END;
$$;


ALTER FUNCTION darwin2.rmca_import_gtu_create_missing_people_in_staging(p_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1940 (class 1255 OID 5309972)
-- Name: rmca_import_gtu_force(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_import_gtu_force(p_staging_gtu_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
        curs record;
        expedition varchar;
        expedition_id integer;
        expedition_array integer[];
        gtu_id integer;
        collection_id integer;
	returned BOOLEAN;

BEGIN
	returned := false;
    FOR curs IN SELECT staging_gtu.* from staging_gtu WHERE id = p_staging_gtu_id		
    LOOP
    
        raise notice 'test %', curs.sampling_code;
		
					
		SELECT collection_ref INTO collection_id FROM darwin2.imports WHERE id=curs.import_ref;
                expedition :=NULL;
                expedition_id :=NULL;
                expedition_array := ARRAY[]::integer[];
                gtu_id :=NULL;

                raise notice 'go';                
               
                expedition:=curs.expeditions[1];
                raise notice 'expedition : %', expedition;
                expedition_id:=NULL;
                IF expedition IS NOT NULL THEN
                    SELECT id into expedition_id FROM expeditions WHERE LOWER(name)= LOWER(expedition) ;
                    IF NOT FOUND THEN
                        raise notice 'insert %', expedition;
                        INSERT INTO expeditions (name) VALUES (expedition) RETURNING id INTO expedition_id;
                    END IF;
                END IF;
                RAISE NOTICE 'exp_id %', expedition_id;
                expedition_array=expedition_array|| expedition_id;
                
                INSERT INTO gtu(
                    code,
                    
                    tag_values_indexed, 
                    latitude, 
                    longitude, --lat_long_accuracy, 
                    
                     elevation, import_ref, collection_ref,
                    expedition_refs,
                    collector_refs
                     )
                VALUES ( 
                curs.sampling_code, 
                
                (SELECT array_agg(tag_value) FROM staging_gtu_tag_groups WHERE staging_gtu_ref=curs.id),
                
                rmca_dms_to_dd(curs.latitude1, 'latitude'), 
                rmca_dms_to_dd(curs.longitude1, 'longitude'),
                
                curs.station_baseline_elevation, curs.import_ref, collection_id,
                expedition_array,
                (SELECT array_agg(people_ref) FROM staging_people WHERE referenced_relation='staging_gtu' AND record_id=curs.id)
                ) RETURNING id INTO gtu_id;

                IF curs.collectors IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'collectors', curs.collectors,'' );
                END IF;
                IF curs.expeditions IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'expeditions', curs.expeditions,'');
                END IF;
                IF curs.ig_num IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'ig_num', curs.ig_num,'' );
                END IF;
                IF curs.station_type IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'station_type', curs.station_type,'' );
                END IF;
                IF curs.sampling_field_number IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_field_number', curs.sampling_field_number,'' );
                END IF;
                IF curs.event_cluster_code IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'event_cluster_code', curs.event_cluster_code,'' );
                END IF;
                IF curs.event_order IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'event_order', curs.event_order,'' );
                END IF;
                IF curs.iso3166 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'iso3166', curs.iso3166,'' );
                END IF;
                IF curs.iso3166_subdivision IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'iso3166_subdivision', curs.iso3166_subdivision ,'');
                END IF;
                IF curs.locality_text IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'locality_text', curs.locality_text,'' );
                END IF;
                IF curs.ecology_text IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'ecology_text', curs.ecology_text ,'');
                END IF;
                IF curs.coordinates_format IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_format', curs.coordinates_format,'' );
                END IF;
                IF curs.latitude1 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'latitude1', curs.latitude1,'' );
                END IF;
                IF curs.longitude1 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'longitude1', curs.longitude1,'' );
                END IF;
                IF curs.latitude2 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'latitude2', curs.latitude2,'' );
                END IF;
                IF curs.longitude2 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'longitude2', curs.longitude2 ,'');
                END IF;
                IF curs.gis_type IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'gis_type', curs.gis_type,'' );
                END IF;
                IF curs.coordinates_datum IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_datum', curs.coordinates_datum ,'');
                END IF;
                IF curs.coordinates_original IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_original', curs.coordinates_original,'' );
                END IF;
                IF curs.coordinates_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_accuracy', curs.coordinates_accuracy,'' );
                END IF;
                IF curs.coordinates_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_accuracy', curs.coordinates_accuracy,'' );
                END IF;
                IF curs.station_baseline_elevation IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'station_baseline_elevation', curs.station_baseline_elevation,'' );
                END IF;
                IF curs.station_baseline_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'station_baseline_accuracy', curs.station_baseline_accuracy,'' );
                END IF;

                IF curs.sampling_elevation_start IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_elevation_start', curs.sampling_elevation_start,'' );
                END IF;

                IF curs.sampling_elevation_end IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_elevation_end', curs.sampling_elevation_end,'' );
                END IF;

                IF curs.sampling_elevation_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_elevation_accuracy', curs.sampling_elevation_accuracy,'' );
                END IF;

                IF curs.original_elevation_data IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'original_elevation_data', curs.original_elevation_data,'' );
                END IF;

                IF curs.sampling_depth_start IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_depth_start', curs.sampling_depth_start,'' );
                END IF;

                IF curs.sampling_depth_end IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_depth_end', curs.sampling_depth_end,'' );
                END IF;

                IF curs.sampling_depth_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_depth_accuracy', curs.sampling_depth_accuracy,'' );
                END IF;

                IF curs.original_depth_data IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'original_depth_data', curs.original_depth_data ,'');
                END IF;

                IF curs.sampling_method IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_method', curs.sampling_method,'' );
                END IF;

                IF curs.sampling_fixation IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_fixation', curs.sampling_fixation,'' );
                END IF;

                UPDATE properties SET referenced_relation='gtu', record_id=gtu_id WHERE referenced_relation='staging_gtu' AND record_id=curs.id;

                UPDATE comments SET referenced_relation='gtu', record_id=gtu_id WHERE referenced_relation='staging_gtu' AND record_id=curs.id;
		BEGIN
			INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value) SELECT DISTINCT gtu_id, staging_gtu_tag_groups.group_name, staging_gtu_tag_groups.sub_group_name, staging_gtu_tag_groups.tag_value FROM staging_gtu_tag_groups WHERE staging_gtu_ref=curs.id; 
		EXCEPTION WHEN unique_violation THEN
			-- Do nothing, and loop to try the UPDATE again.
		END; 	
                --ftheeten countries 2018 09 25
		BEGIN
			INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name,  tag_value) SELECT DISTINCT gtu_id, 'administrative', 'country', unnest(countries) FROM staging_gtu WHERE id=curs.id;
		EXCEPTION WHEN unique_violation THEN
			-- Do nothing, and loop to try the UPDATE again.
		END; 
                UPDATE staging_gtu SET imported=true, import_exception='imported' WHERE id=curs.id;            
        END LOOP;
        
	UPDATE staging_gtu SET imported=true, import_exception='imported' , gtu_ref=gtu_id WHERE id=p_staging_gtu_id;
           
	returned :=TRUE;
	RETURN returned;
END;
$$;


ALTER FUNCTION darwin2.rmca_import_gtu_force(p_staging_gtu_id integer) OWNER TO darwin2;

--
-- TOC entry 1868 (class 1255 OID 4816503)
-- Name: rmca_import_gtu_in_darwin_fast(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    curs record;
    expedition varchar;
    expedition_id integer;
    expedition_array integer[];
    gtu_id integer;
    collection_id integer;
        
BEGIN 

    UPDATE staging_gtu set status=''::public.hstore, import_exception=NULL WHERE import_ref = p_import_ref AND imported=FALSE;
    DROP TABLE if EXISTs tmp_codes;
    DROP TABLE if EXISTs tmp_coord_errors;
    CREATE TEMPORARY TABLE tmp_codes(
	code varchar
	);
    --ftheeten 2019 01 31
   CREATE TEMPORARY TABLE tmp_coord_errors(
	code varchar
	);
    SELECT collection_ref INTO collection_id FROM darwin2.imports WHERE id=p_import_ref;

       -- ftheeten 2019 01 31
       INSERT INTO tmp_coord_errors (code) SELECT staging_gtu.sampling_code FROM staging_gtu WHERE (darwin2.rmca_dmscheck_syntax(latitude1)=false OR darwin2.rmca_dmscheck_syntax(longitude1)=false
       OR darwin2.rmca_dmscheck_syntax(latitude2)=false OR darwin2.rmca_dmscheck_syntax(longitude2)=false) AND import_ref = p_import_ref;

       UPDATE staging_gtu SET status = status ||hstore('wrong_dms_coordinate_format' , 'check_long1_lat1_long2_lat2') ,
	import_exception=COALESCE(import_exception, 'wrong_dms_coordinate_format')   WHERE darwin2.rmca_dmscheck_syntax(latitude1)=false OR darwin2.rmca_dmscheck_syntax(longitude1)=false
       OR darwin2.rmca_dmscheck_syntax(latitude2)=false OR darwin2.rmca_dmscheck_syntax(longitude2)=false AND import_ref = p_import_ref ;
    
	FOR curs IN SELECT staging_gtu.* from staging_gtu 
		LEFT JOIN gtu
		ON 
			LOWER(staging_gtu.sampling_code)=LOWER(code)
			--ftheeten 2019 01 31 remove date in linking with gtu

		WHERE staging_gtu.import_ref = p_import_ref  
		AND gtu.id IS NULL
		AND staging_gtu.imported=FALSE 
    LOOP
    
        raise notice 'test %', curs.sampling_code;
        raise notice 'count %',  (SELECT COUNT(*) FROM (SELECT * FROM tmp_coord_errors WHERE 
			tmp_coord_errors.code=curs.sampling_code) a);
        PERFORM * FROM (SELECT * FROM tmp_codes WHERE 
			tmp_codes.code=curs.sampling_code UNION SELECT * FROM tmp_coord_errors WHERE 
			tmp_coord_errors.code=curs.sampling_code) a;
			
					
        IF NOT FOUND THEN
                   expedition :=NULL;
                   expedition_id :=NULL;
                   expedition_array := ARRAY[]::integer[];
                   gtu_id :=NULL;

                raise notice 'go';
                
                INSERT INTO tmp_codes(code) VALUES(curs.sampling_code);
                expedition:=curs.expeditions[1];
                raise notice 'expedition : %', expedition;
                expedition_id:=NULL;
                IF expedition IS NOT NULL THEN
                    SELECT id into expedition_id FROM expeditions WHERE LOWER(name)= LOWER(expedition) ;
                    IF NOT FOUND THEN
                        raise notice 'insert %', expedition;
                        INSERT INTO expeditions (name) VALUES (expedition) RETURNING id INTO expedition_id;
                    END IF;
                END IF;
                RAISE NOTICE 'exp_id %', expedition_id;
                expedition_array=expedition_array|| expedition_id;
                
                INSERT INTO gtu(
                    code,
                    
                    tag_values_indexed, 
                    latitude, 
                    longitude, --lat_long_accuracy, 
                    
                     elevation, import_ref, collection_ref,
                    expedition_refs,
                    collector_refs
                     )
                VALUES ( 
                curs.sampling_code, 
                
                (SELECT array_agg(tag_value) FROM staging_gtu_tag_groups WHERE staging_gtu_ref=curs.id),
                
                rmca_dms_to_dd(curs.latitude1, 'latitude'), 
                rmca_dms_to_dd(curs.longitude1, 'longitude'),
                
                curs.station_baseline_elevation, p_import_ref, collection_id,
                expedition_array,
                (SELECT array_agg(people_ref) FROM staging_people WHERE referenced_relation='staging_gtu' AND record_id=curs.id)
                ) RETURNING id INTO gtu_id;

                IF curs.collectors IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'collectors', curs.collectors,'' );
                END IF;
                IF curs.expeditions IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'expeditions', curs.expeditions,'');
                END IF;
                IF curs.ig_num IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'ig_num', curs.ig_num,'' );
                END IF;
                IF curs.station_type IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'station_type', curs.station_type,'' );
                END IF;
                IF curs.sampling_field_number IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_field_number', curs.sampling_field_number,'' );
                END IF;
                IF curs.event_cluster_code IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'event_cluster_code', curs.event_cluster_code,'' );
                END IF;
                IF curs.event_order IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'event_order', curs.event_order,'' );
                END IF;
                IF curs.iso3166 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'iso3166', curs.iso3166,'' );
                END IF;
                IF curs.iso3166_subdivision IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'iso3166_subdivision', curs.iso3166_subdivision ,'');
                END IF;
                IF curs.locality_text IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'locality_text', curs.locality_text,'' );
                END IF;
                IF curs.ecology_text IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'ecology_text', curs.ecology_text ,'');
                END IF;
                IF curs.coordinates_format IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_format', curs.coordinates_format,'' );
                END IF;
                IF curs.latitude1 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'latitude1', curs.latitude1,'' );
                END IF;
                IF curs.longitude1 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'longitude1', curs.longitude1,'' );
                END IF;
                IF curs.latitude2 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'latitude2', curs.latitude2,'' );
                END IF;
                IF curs.longitude2 IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'longitude2', curs.longitude2 ,'');
                END IF;
                IF curs.gis_type IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'gis_type', curs.gis_type,'' );
                END IF;
                IF curs.coordinates_datum IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_datum', curs.coordinates_datum ,'');
                END IF;
                IF curs.coordinates_original IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_original', curs.coordinates_original,'' );
                END IF;
                IF curs.coordinates_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_accuracy', curs.coordinates_accuracy,'' );
                END IF;
                IF curs.coordinates_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'coordinates_accuracy', curs.coordinates_accuracy,'' );
                END IF;
                IF curs.station_baseline_elevation IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'station_baseline_elevation', curs.station_baseline_elevation,'' );
                END IF;
                IF curs.station_baseline_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'station_baseline_accuracy', curs.station_baseline_accuracy,'' );
                END IF;

                IF curs.sampling_elevation_start IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_elevation_start', curs.sampling_elevation_start,'' );
                END IF;

                IF curs.sampling_elevation_end IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_elevation_end', curs.sampling_elevation_end,'' );
                END IF;

                IF curs.sampling_elevation_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_elevation_accuracy', curs.sampling_elevation_accuracy,'' );
                END IF;

                IF curs.original_elevation_data IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'original_elevation_data', curs.original_elevation_data,'' );
                END IF;

                IF curs.sampling_depth_start IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_depth_start', curs.sampling_depth_start,'' );
                END IF;

                IF curs.sampling_depth_end IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_depth_end', curs.sampling_depth_end,'' );
                END IF;

                IF curs.sampling_depth_accuracy IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_depth_accuracy', curs.sampling_depth_accuracy,'' );
                END IF;

                IF curs.original_depth_data IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'original_depth_data', curs.original_depth_data ,'');
                END IF;

                IF curs.sampling_method IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_method', curs.sampling_method,'' );
                END IF;

                IF curs.sampling_fixation IS NOT NULL THEN
                    INSERT INTO properties( referenced_relation, record_id, property_type, lower_value, upper_value) VALUES ('gtu', gtu_id, 'sampling_fixation', curs.sampling_fixation,'' );
                END IF;

                UPDATE properties SET referenced_relation='gtu', record_id=gtu_id WHERE referenced_relation='staging_gtu' AND record_id=curs.id;

                UPDATE comments SET referenced_relation='gtu', record_id=gtu_id WHERE referenced_relation='staging_gtu' AND record_id=curs.id;
		BEGIN
			INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name, tag_value) SELECT DISTINCT gtu_id, staging_gtu_tag_groups.group_name, staging_gtu_tag_groups.sub_group_name, staging_gtu_tag_groups.tag_value FROM staging_gtu_tag_groups WHERE staging_gtu_ref=curs.id; 
		EXCEPTION WHEN unique_violation THEN
			-- Do nothing, and loop to try the UPDATE again.
		END; 	
                --ftheeten countries 2018 09 25
		BEGIN
			INSERT INTO tag_groups (gtu_ref, group_name, sub_group_name,  tag_value) SELECT DISTINCT gtu_id, 'administrative', 'country', unnest(countries) FROM staging_gtu WHERE id=curs.id;
		EXCEPTION WHEN unique_violation THEN
			-- Do nothing, and loop to try the UPDATE again.
		END; 
                UPDATE staging_gtu SET imported=true, import_exception='imported', gtu_ref=gtu_id WHERE id=curs.id;
            ELSE
		PERFORM * FROM tmp_codes WHERE 	tmp_codes.code=curs.sampling_code ;
		IF FOUND THEN
			UPDATE staging_gtu SET status = status ||hstore('duplicate_code', 'duplicate_in_file') WHERE id=curs.id AND staging_gtu.sampling_code IN (SELECT code FROM tmp_codes);
		END IF;
	    END IF;
        END LOOP;

	
	FOR curs IN SELECT staging_gtu.*, string_agg(gtu.id::varchar,'; '::varchar ORDER BY gtu.id) as gtu_ids 

from staging_gtu 
	
		LEFT JOIN gtu
		ON 
			LOWER(staging_gtu.sampling_code)=LOWER(code)

		WHERE staging_gtu.import_ref = p_import_ref 
		AND gtu.id IS NOT NULL --NOT NULL as we are looking the duplicates in DB
		AND staging_gtu.imported=FALSE 
		GROUP BY

		staging_gtu.id, staging_gtu.import_ref, status, date_included, tags_merged, sensitive_information_withheld, 
		       gtu_ref, station_type, sampling_code, sampling_field_number, 
		       event_cluster_code, event_order, ig_num, ig_num_indexed, collections, 
		       collectors, expeditions, collection_refs, staging_gtu.collector_refs, staging_gtu.expedition_refs, 
		       iso3166, iso3166_subdivision, countries, tags, tags_indexed, 
		       locality_text, locality_text_indexed, ecology_text, ecology_text_indexed, 
		       coordinates_format, latitude1, longitude1, latitude2, longitude2, 
		       gis_type, coordinates_wkt, coordinates_datum, coordinates_proj_ref, 
		       coordinates_original, coordinates_accuracy, coordinates_accuracy_text, 
		       station_baseline_elevation, station_baseline_accuracy, sampling_elevation_start, 
		       sampling_elevation_end, sampling_elevation_accuracy, original_elevation_data, 
		       sampling_depth_start, sampling_depth_end, sampling_depth_accuracy, 
		       original_depth_data, collecting_date_begin, collecting_date_begin_mask, 
		       collecting_date_end, collecting_date_end_mask, collecting_time_begin, 
		       collecting_time_end, sampling_method, sampling_fixation, imported, 
		       pos_in_file, import_exception
	LOOP 
		UPDATE staging_gtu SET status = status ||hstore(ARRAY['duplicate_code', 'gtu_id']::varchar[], ARRAY['duplicate_with_database',curs.gtu_ids]::varchar[]), import_exception='duplicate_code' WHERE id=curs.id;
	END LOOP;

	--2019 02 28 
	UPDATE imports SET state='pending' WHERE id=p_import_ref;

	

END;
$$;


ALTER FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) OWNER TO darwin2;

--
-- TOC entry 1865 (class 1255 OID 4816506)
-- Name: rmca_reinit_statistical_view(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.rmca_reinit_statistical_view() RETURNS integer
    LANGUAGE sql
    AS $$

TRUNCATE tv_reporting_count_all_specimens_by_collection_year_ig;
TRUNCATE tv_reporting_count_all_specimens_type_by_collection_ref_year_ig;
TRUNCATE tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig;

INSERT INTO  tv_reporting_count_all_specimens_by_collection_year_ig SELECT * FROM v_reporting_count_all_specimens_by_collection_year_ig;
INSERT INTO  tv_reporting_count_all_specimens_type_by_collection_ref_year_ig SELECT * FROM v_reporting_count_all_specimens_type_by_collection_ref_year_ig;
INSERT INTO  tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig SELECT * FROM v_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig;


SELECT 0 as result;

$$;


ALTER FUNCTION darwin2.rmca_reinit_statistical_view() OWNER TO darwin2;

--
-- TOC entry 1866 (class 1255 OID 4816507)
-- Name: set_path(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.set_path() RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	SET search_path TO darwin2,darwin1,public;
	RETURN 1;
	EXCEPTION WHEN invalid_schema_name THEN
			SET search_path TO oracle,"$user",public;
	RETURN NULL;
END;
$_$;


ALTER FUNCTION darwin2.set_path() OWNER TO darwin2;

--
-- TOC entry 1867 (class 1255 OID 4816508)
-- Name: sha1(bytea); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.sha1(bytea) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
        RETURN ENCODE(DIGEST($1, 'sha1'), 'hex');
END;
$_$;


ALTER FUNCTION darwin2.sha1(bytea) OWNER TO darwin2;

--
-- TOC entry 1869 (class 1255 OID 4816509)
-- Name: stats_collections_encoding(integer, text, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.stats_collections_encoding(integer, text, text) RETURNS SETOF darwin2.stats_collections
    LANGUAGE sql IMMUTABLE
    AS $_$
select * from stats_collections_encoding($1, $2::timestamp, $3::timestamp);
$_$;


ALTER FUNCTION darwin2.stats_collections_encoding(integer, text, text) OWNER TO postgres;

--
-- TOC entry 5852 (class 0 OID 0)
-- Dependencies: 1869
-- Name: FUNCTION stats_collections_encoding(integer, text, text); Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON FUNCTION darwin2.stats_collections_encoding(integer, text, text) IS 'Gives, by collections, from a top collection given, the encoding stats';


--
-- TOC entry 1864 (class 1255 OID 4816510)
-- Name: stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone) RETURNS SETOF darwin2.stats_collections
    LANGUAGE sql IMMUTABLE
    AS $_$
WITH users_statistics AS
(
  WITH users_stats AS
  (
      SELECT DISTINCT
        collection_ref AS "Collection ID",
        (
          SELECT
        '/'
        ||
        array_to_string(
            array_agg(
                sc.name),
            '/')
        ||
        '/'
        ||
        collection_name
          FROM
            collections AS sc
            INNER JOIN
            (SELECT
               unnest(
                   string_to_array(
                       trim(
                           collection_path,
                           '/'),
                       '/')) :: BIGINT AS id) AS scc
              ON
                sc.id = scc.id
        ) AS "Collection Path",
        main_ut.action AS "Action",
        CASE WHEN
          main_s.type
          =
          'specimen'
          THEN 'non type'
        ELSE 'type' END AS "Type",
        main_s.id
      FROM users_tracking AS main_ut
        INNER JOIN specimens AS main_s
          ON main_ut.record_id = main_s.id
             AND main_ut.modification_date_time BETWEEN $2 :: TIMESTAMP AND $3 :: TIMESTAMP
             AND main_ut.referenced_relation = 'specimens'
      WHERE
        CASE
        WHEN 0 != $1
          THEN
            collection_ref IN (SELECT id
                               FROM collections
                               WHERE id = $1 OR path LIKE '%/' || $1 || '/%')
        ELSE
          TRUE
        END
        AND main_ut.action != 'delete'
      ORDER BY "Collection Path", "Action", "Type"
  )
  SELECT DISTINCT
    users_stats."Collection Path",
    users_stats."Action",
    users_stats."Type",
    coalesce(count(*) over (partition by "Collection ID", "Action"),0) as "Action Count",
    coalesce(count(*) over (partition by "Collection ID", "Action", "Type"),0) as "Type Count",
    coalesce(new_species."New species",0) as "New species"
  FROM users_stats
    LEFT JOIN
    (
      SELECT
        s.collection_ref,
        count(DISTINCT tax.id) AS "New species"
      FROM
        (users_tracking AS ut INNER JOIN taxonomy AS tax
            ON ut.referenced_relation = 'taxonomy'
               AND ut.action = 'insert'
               AND ut.record_id = tax.id
               AND tax.level_ref > 47
               AND ut.modification_date_time BETWEEN $2 :: TIMESTAMP AND $3 :: TIMESTAMP
          ) INNER JOIN
        (specimens AS s INNER JOIN users_tracking AS ust
            ON ust.referenced_relation = 'specimens'
               AND ust.action = 'insert'
               AND ust.record_id = s.id
               AND ust.modification_date_time BETWEEN $2 :: TIMESTAMP AND $3 :: TIMESTAMP
          ) ON s.taxon_ref = tax.id
      GROUP BY s.collection_ref
    ) AS new_species
      ON users_stats."Collection ID" = new_species.collection_ref
)
SELECT DISTINCT
  us."Collection Path",
  coalesce (
      (
        SELECT DISTINCT "Action Count"
        FROM users_statistics as sus
        WHERE sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'insert'
      ),
      0
  ) as "Insertion count",
  coalesce(
      (
        SELECT DISTINCT "Action Count"
        FROM users_statistics as sus
        WHERE sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'update'
      ),
      0
  ) as "Update count",
  coalesce(
      (
        SELECT DISTINCT "Type Count"
        FROM users_statistics as sus
        WHERE sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'insert'
              AND sus."Type" = 'type'
      ),
      0
  ) as "Inserted Type count",
  coalesce(
      (
        SELECT DISTINCT "Type Count"
        FROM users_statistics as sus
        WHERE sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'update'
              AND sus."Type" = 'type'
      ),
      0
  ) as "Updated Type count",
  coalesce(us."New species", 0) as "New species"
FROM users_statistics as us
ORDER BY us."Collection Path"
$_$;


ALTER FUNCTION darwin2.stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone) OWNER TO postgres;

--
-- TOC entry 5854 (class 0 OID 0)
-- Dependencies: 1864
-- Name: FUNCTION stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone); Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON FUNCTION darwin2.stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone) IS 'Gives, by collections, from a top collection given, the encoding stats';


--
-- TOC entry 1870 (class 1255 OID 4816511)
-- Name: stats_collections_encoding_optimistics(integer, text, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.stats_collections_encoding_optimistics(integer, text, text) RETURNS SETOF darwin2.stats_collections
    LANGUAGE sql IMMUTABLE
    AS $_$
select * from stats_collections_encoding_optimistics($1, $2::timestamp, $3::timestamp);
$_$;


ALTER FUNCTION darwin2.stats_collections_encoding_optimistics(integer, text, text) OWNER TO postgres;

--
-- TOC entry 5856 (class 0 OID 0)
-- Dependencies: 1870
-- Name: FUNCTION stats_collections_encoding_optimistics(integer, text, text); Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, text, text) IS 'Gives, by collections, from a top collection given, the encoding stats - this one counts all updates that occured even if several times for the same specimen';


--
-- TOC entry 1887 (class 1255 OID 4816512)
-- Name: stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone) RETURNS SETOF darwin2.stats_collections
    LANGUAGE sql IMMUTABLE
    AS $_$
WITH users_statistics AS
(
  WITH users_stats AS
  (
      SELECT DISTINCT
        collection_ref      AS "Collection ID",
        (
          SELECT
        '/'
        ||
        array_to_string(
            array_agg(
                sc.name),
            '/')
        ||
        '/'
        ||
        collection_name
          FROM
            collections AS sc
            INNER JOIN
            (SELECT
               unnest(
                   string_to_array(
                       trim(
                           collection_path,
                           '/'),
                       '/')) :: BIGINT AS id) AS scc
              ON
                sc.id = scc.id
        )                   AS "Collection Path",
        main_ut.action      AS "Action",
        CASE WHEN
          main_s.type
          =
          'specimen'
          THEN 'non type'
        ELSE 'type' END     AS "Type",
        count(*)
        OVER (
          PARTITION BY
            collection_ref,
            action
        )                   AS "Action Count",
        count(*)
        OVER (
          PARTITION BY
            collection_ref,
            action,
            CASE WHEN
              main_s.type = 'specimen'
              THEN 'non type'
            ELSE 'type' END
        )                   AS "Type Count"
      FROM users_tracking AS main_ut
        INNER JOIN specimens AS main_s
          ON main_ut.record_id = main_s.id
             AND main_ut.modification_date_time BETWEEN $2 :: TIMESTAMP AND $3 :: TIMESTAMP
             AND main_ut.referenced_relation = 'specimens'
      WHERE
        CASE
        WHEN 0 != $1
          THEN
            collection_ref IN (SELECT id
                               FROM collections
                               WHERE id = $1 OR path LIKE '%/' || $1 || '/%')
        ELSE
          TRUE
        END
        AND main_ut.action != 'delete'
      ORDER BY "Collection Path", "Action", "Type"
  )
  SELECT
    users_stats."Collection Path",
    users_stats."Action",
    users_stats."Type",
    users_stats."Action Count",
    users_stats."Type Count",
    new_species."New species"
  FROM users_stats
    LEFT JOIN
    (
      SELECT
        s.collection_ref,
        count(DISTINCT tax.id) AS "New species"
      FROM
        (users_tracking AS ut INNER JOIN taxonomy AS tax
            ON ut.referenced_relation = 'taxonomy'
               AND ut.action = 'insert'
               AND ut.record_id = tax.id
               AND tax.level_ref > 47
               AND ut.modification_date_time BETWEEN $2 :: TIMESTAMP AND $3 :: TIMESTAMP
          ) INNER JOIN
        (specimens AS s INNER JOIN users_tracking AS ust
            ON ust.referenced_relation = 'specimens'
               AND ust.action = 'insert'
               AND ust.record_id = s.id
               AND ust.modification_date_time BETWEEN $2 :: TIMESTAMP AND $3 :: TIMESTAMP
          ) ON s.taxon_ref = tax.id
      GROUP BY s.collection_ref
    ) AS new_species
      ON users_stats."Collection ID" = new_species.collection_ref
)
SELECT DISTINCT
  us."Collection Path",
  coalesce (
      (
        SELECT DISTINCT "Action Count"
        FROM users_statistics as sus
        WHERE sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'insert'
      ),
      0
  ) as "Insertion count",
  coalesce(
      (
        SELECT DISTINCT "Action Count"
        FROM users_statistics as sus
        WHERE sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'update'
      ),
      0
  ) as "Update count",
  coalesce(
      (
        SELECT DISTINCT "Type Count"
        FROM users_statistics as sus
        WHERE sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'insert'
              AND sus."Type" = 'type'
      ),
      0
  ) as "Inserted Type count",
  coalesce(
      (
        SELECT DISTINCT "Type Count"
        FROM users_statistics as sus
        WHERE sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'update'
              AND sus."Type" = 'type'
      ),
      0
  ) as "Updated Type count",
  coalesce(us."New species", 0) as "New species"
FROM users_statistics as us
ORDER BY us."Collection Path"
$_$;


ALTER FUNCTION darwin2.stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone) OWNER TO postgres;

--
-- TOC entry 5858 (class 0 OID 0)
-- Dependencies: 1887
-- Name: FUNCTION stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone); Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone) IS 'Gives, by collections, from a top collection given, the encoding stats - this one counts all updates that occured even if several times for the same specimen';


--
-- TOC entry 1871 (class 1255 OID 4816513)
-- Name: stats_encoders_encoding(integer, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text) RETURNS SETOF darwin2.encoders_stats_collections
    LANGUAGE sql
    AS $_$
SELECT * FROM stats_encoders_encoding ($1, $2, $3::timestamp, $4::timestamp);
$_$;


ALTER FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text) OWNER TO postgres;

--
-- TOC entry 5860 (class 0 OID 0)
-- Dependencies: 1871
-- Name: FUNCTION stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text); Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text) IS 'Gives, by collections (from a top collection given) and by users (from an array of users id passed), the encoding stats';


--
-- TOC entry 1900 (class 1255 OID 4816514)
-- Name: stats_encoders_encoding(integer, text, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) RETURNS SETOF darwin2.encoders_stats_collections
    LANGUAGE sql
    AS $_$
WITH users_statistics AS
(
  WITH users_stats AS
  (
      SELECT DISTINCT
        users.id            AS "User ID",
        users.formated_name AS "User",
        collection_ref      AS "Collection ID",
        (
          SELECT
        '/'
        ||
        array_to_string(
            array_agg(
                sc.name),
            '/')
        ||
        '/'
        ||
        collection_name
          FROM
            collections AS sc
            INNER JOIN
            (SELECT
               unnest(
                   string_to_array(
                       trim(
                           collection_path,
                           '/'),
                       '/')) :: BIGINT AS id) AS scc
              ON
                sc.id = scc.id
        )                   AS "Collection Path",
        main_ut.action      AS "Action",
        CASE WHEN
          main_s.type
          =
          'specimen'
          THEN 'non type'
        ELSE 'type' END     AS "Type",
        main_s.id
      FROM users
        INNER JOIN users_tracking AS main_ut
          ON users.id = main_ut.user_ref
             AND main_ut.modification_date_time BETWEEN $3 :: TIMESTAMP AND $4 :: TIMESTAMP
             AND main_ut.referenced_relation = 'specimens'
        INNER JOIN specimens AS main_s
          ON main_ut.record_id = main_s.id
      WHERE CASE
            WHEN '0' = ( select unnest(string_to_array(trim($2,'[]'), ', ')) limit 1 )
              THEN
                TRUE
            ELSE
              users.id::text IN ( select unnest(string_to_array(trim($2,'[]'), ', ')) )
            END
            AND
            CASE
            WHEN 0 != $1
              THEN
                collection_ref IN (SELECT id
                                   FROM collections
                                   WHERE id = $1 OR path LIKE '%/' || $1 || '/%')
            ELSE
              TRUE
            END
            AND main_ut.action != 'delete'
      ORDER BY "User", "Collection Path", "Action", "Type"
  )
  SELECT DISTINCT
    users_stats."User",
    users_stats."Collection Path",
    users_stats."Action",
    users_stats."Type",
    coalesce(count(*) over (partition by users_stats."User ID", "Collection ID", "Action"),0) as "Action Count",
    coalesce(count(*) over (partition by users_stats."User ID", "Collection ID", "Action", "Type"),0) as "Type Count",
    coalesce(new_species."New species encoded by the encoder used in this collection",0) as "New species encoded by the encoder used in this collection"
  FROM users_stats
    LEFT JOIN
    (
      SELECT
        s.collection_ref,
        ut.user_ref            AS "User ID",
        count(DISTINCT tax.id) AS "New species encoded by the encoder used in this collection"
      FROM
        (users_tracking AS ut INNER JOIN taxonomy AS tax
            ON ut.referenced_relation = 'taxonomy'
               AND ut.action = 'insert'
               AND ut.record_id = tax.id
               AND tax.level_ref > 47
               AND ut.modification_date_time BETWEEN $3 :: TIMESTAMP AND $4 :: TIMESTAMP
          ) INNER JOIN
        (specimens AS s INNER JOIN users_tracking AS ust
            ON ust.referenced_relation = 'specimens'
               AND ust.action = 'insert'
               AND ust.record_id = s.id
               AND ust.modification_date_time BETWEEN $3 :: TIMESTAMP AND $4 :: TIMESTAMP
          ) ON s.taxon_ref = tax.id
      GROUP BY s.collection_ref, ut.user_ref
    ) AS new_species
      ON users_stats."Collection ID" = new_species.collection_ref
         AND users_stats."User ID" = new_species."User ID"
)
SELECT DISTINCT
  us."User", us."Collection Path",
  coalesce (
      (
        SELECT DISTINCT "Action Count"
        FROM users_statistics as sus
        WHERE sus."User" = us."User"
              AND sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'insert'
      ),0
  ) as "Insertion count",
  coalesce (
      (
        SELECT DISTINCT "Action Count"
        FROM users_statistics as sus
        WHERE sus."User" = us."User"
              AND sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'update'
      ),0
  ) as "Update count",
  coalesce (
      (
        SELECT DISTINCT "Type Count"
        FROM users_statistics as sus
        WHERE sus."User" = us."User"
              AND sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'insert'
              AND sus."Type" = 'type'
      ),0
  ) as "Inserted Type count",
  coalesce (
      (
        SELECT DISTINCT "Type Count"
        FROM users_statistics as sus
        WHERE sus."User" = us."User"
              AND sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'update'
              AND sus."Type" = 'type'
      ),0
  ) as "Update Type count",
  coalesce(us."New species encoded by the encoder used in this collection",0) as "New species encoded by the encoder used in this collection"
FROM users_statistics as us
ORDER BY us."User", us."Collection Path"
$_$;


ALTER FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) OWNER TO postgres;

--
-- TOC entry 5862 (class 0 OID 0)
-- Dependencies: 1900
-- Name: FUNCTION stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone); Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) IS 'Gives, by collections (from a top collection given) and by users (from an array of users id passed), the encoding stats';


--
-- TOC entry 1875 (class 1255 OID 4816515)
-- Name: stats_encoders_encoding_optimistics(integer, text, text, text); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text) RETURNS SETOF darwin2.encoders_stats_collections
    LANGUAGE sql
    AS $_$
SELECT * FROM stats_encoders_encoding_optimistics ($1, $2, $3::timestamp, $4::timestamp);
$_$;


ALTER FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text) OWNER TO postgres;

--
-- TOC entry 5864 (class 0 OID 0)
-- Dependencies: 1875
-- Name: FUNCTION stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text); Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text) IS 'Gives, by collections (from a top collection given) and by users (from an array of users id passed), the encoding stats - this one counts all updates that occured even if several times for the same specimen';


--
-- TOC entry 1901 (class 1255 OID 4816516)
-- Name: stats_encoders_encoding_optimistics(integer, text, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) RETURNS SETOF darwin2.encoders_stats_collections
    LANGUAGE sql
    AS $_$
WITH users_statistics AS
(
  WITH users_stats AS
  (
      SELECT DISTINCT
        users.id            AS "User ID",
        users.formated_name AS "User",
        collection_ref      AS "Collection ID",
        (
          SELECT
        '/'
        ||
        array_to_string(
            array_agg(
                sc.name),
            '/')
        ||
        '/'
        ||
        collection_name
          FROM
            collections AS sc
            INNER JOIN
            (SELECT
               unnest(
                   string_to_array(
                       trim(
                           collection_path,
                           '/'),
                       '/')) :: BIGINT AS id) AS scc
              ON
                sc.id = scc.id
        )                   AS "Collection Path",
        main_ut.action      AS "Action",
        CASE WHEN
          main_s.type
          =
          'specimen'
          THEN 'non type'
        ELSE 'type' END     AS "Type",
        count(*)
        OVER (
          PARTITION BY
            users.id,
            collection_ref,
            action
        )                   AS "Action Count",
        count(*)
        OVER (
          PARTITION BY
            users.id,
            collection_ref,
            action,
            CASE WHEN
              main_s.type = 'specimen'
              THEN 'non type'
            ELSE 'type' END
        )                   AS "Type Count"
      FROM users
        INNER JOIN users_tracking AS main_ut
          ON users.id = main_ut.user_ref
             AND main_ut.modification_date_time BETWEEN $3 :: TIMESTAMP AND $4 :: TIMESTAMP
             AND main_ut.referenced_relation = 'specimens'
        INNER JOIN specimens AS main_s
          ON main_ut.record_id = main_s.id
      WHERE CASE
            WHEN '0' = ( select unnest(string_to_array(trim($2,'[]'), ', ')) limit 1 )
              THEN
                TRUE
            ELSE
              users.id::text IN ( select unnest(string_to_array(trim($2,'[]'), ', ')) )
            END
            AND
            CASE
            WHEN 0 != $1
              THEN
                collection_ref IN (SELECT id
                                   FROM collections
                                   WHERE id = $1 OR path LIKE '%/' || $1 || '/%')
            ELSE
              TRUE
            END
            AND main_ut.action != 'delete'
      ORDER BY "User", "Collection Path", "Action", "Type"
  )
  SELECT
    users_stats."User",
    users_stats."Collection Path",
    users_stats."Action",
    users_stats."Type",
    users_stats."Action Count",
    users_stats."Type Count",
    new_species."New species encoded by the encoder used in this collection"
  FROM users_stats
    LEFT JOIN
    (
      SELECT
        s.collection_ref,
        ut.user_ref            AS "User ID",
        count(DISTINCT tax.id) AS "New species encoded by the encoder used in this collection"
      FROM
        (users_tracking AS ut INNER JOIN taxonomy AS tax
            ON ut.referenced_relation = 'taxonomy'
               AND ut.action = 'insert'
               AND ut.record_id = tax.id
               AND tax.level_ref > 47
               AND ut.modification_date_time BETWEEN $3 :: TIMESTAMP AND $4 :: TIMESTAMP
          ) INNER JOIN
        (specimens AS s INNER JOIN users_tracking AS ust
            ON ust.referenced_relation = 'specimens'
               AND ust.action = 'insert'
               AND ust.record_id = s.id
               AND ust.modification_date_time BETWEEN $3 :: TIMESTAMP AND $4 :: TIMESTAMP
          ) ON s.taxon_ref = tax.id
      GROUP BY s.collection_ref, ut.user_ref
    ) AS new_species
      ON users_stats."Collection ID" = new_species.collection_ref
         AND users_stats."User ID" = new_species."User ID"
)
SELECT DISTINCT
  us."User", us."Collection Path",
  coalesce (
      (
        SELECT DISTINCT "Action Count"
        FROM users_statistics as sus
        WHERE sus."User" = us."User"
              AND sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'insert'
      ),0
  ) as "Insertion count",
  coalesce(
      (
        SELECT DISTINCT "Action Count"
        FROM users_statistics as sus
        WHERE sus."User" = us."User"
              AND sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'update'
      ),0
  ) as "Update count",
  coalesce (
      (
        SELECT DISTINCT "Type Count"
        FROM users_statistics as sus
        WHERE sus."User" = us."User"
              AND sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'insert'
              AND sus."Type" = 'type'
      ),0
  ) as "Inserted Type count",
  coalesce(
      (
        SELECT DISTINCT "Type Count"
        FROM users_statistics as sus
        WHERE sus."User" = us."User"
              AND sus."Collection Path" = us."Collection Path"
              AND sus."Action" = 'update'
              AND sus."Type" = 'type'
      ),0
  ) as "Update Type count",
  coalesce(us."New species encoded by the encoder used in this collection",0) as "New species encoded by the encoder used in this collection"
FROM users_statistics as us
ORDER BY us."User", us."Collection Path"
$_$;


ALTER FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) OWNER TO postgres;

--
-- TOC entry 5866 (class 0 OID 0)
-- Dependencies: 1901
-- Name: FUNCTION stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone); Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) IS 'Gives, by collections (from a top collection given) and by users (from an array of users id passed), the encoding stats - this one counts all updates that occured even if several times for the same specimen';


--
-- TOC entry 1873 (class 1255 OID 4816517)
-- Name: taxo_collections_count(integer); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.taxo_collections_count(integer) RETURNS TABLE(family character varying, family_cnt bigint, genus character varying, genus_cnt bigint, species character varying, species_cnt bigint)
    LANGUAGE plpgsql
    AS $_$
BEGIN
RETURN QUERY
SELECT DISTINCT r.family_name as family, cnt_fam.number_family as family_cnt, 
r.genus_name as genus, cnt_gen.number_genus as genus_cnt, 
r.species_name as species, cnt_spec.number_species as species_cnt 
FROM 
  (SELECT f.family_name, g.genus_name, s.species_name 
  FROM 
    (SELECT taxon_name, (taxon_path || taxon_ref || '/') as taxon_full_path
    FROM specimens s
    WHERE collection_ref = ANY((SELECT (array(SELECT c.id FROM collections c 
                WHERE c.id = $1
                OR c.path LIKE ('%/' || $1 || '/%'))) as collections)::int[])
    /*LIMIT 100*/) AS spec
    LEFT JOIN
      (SELECT id as id_family, name as family_name FROM taxonomy WHERE level_ref=34) AS f
      ON spec.taxon_full_path LIKE '%/' || f.id_family || '/%'
    LEFT JOIN
      (SELECT id as id_genus, name as genus_name FROM taxonomy WHERE level_ref=41) AS g
      ON spec.taxon_full_path LIKE '%/' || g.id_genus || '/%'
    LEFT JOIN
      (SELECT id as id_species, name as species_name FROM taxonomy WHERE level_ref=48) AS s
      ON spec.taxon_full_path LIKE '%/' || s.id_species || '/%') AS r
LEFT JOIN
        (SELECT count(family_name) as number_family, family_name
        FROM 
          (SELECT f.family_name, g.genus_name, s.species_name 
          FROM 
            (SELECT taxon_name, (taxon_path || taxon_ref || '/') as taxon_full_path
            FROM specimens s
            WHERE collection_ref = ANY((SELECT (array(SELECT c.id FROM collections c 
                WHERE c.id =$1
                OR c.path LIKE ('%/' || $1|| '/%'))) as collections)::int[])
            /*LIMIT 100*/) AS spec
          LEFT JOIN
            (SELECT id as id_family, name as family_name FROM taxonomy WHERE level_ref=34) AS f
          ON spec.taxon_full_path LIKE '%/' || f.id_family || '/%'
          LEFT JOIN
            (SELECT id as id_genus, name as genus_name FROM taxonomy WHERE level_ref=41) AS g
          ON spec.taxon_full_path LIKE '%/' || g.id_genus || '/%'
          LEFT JOIN
            (SELECT id as id_species, name as species_name FROM taxonomy WHERE level_ref=48) AS s
          ON spec.taxon_full_path LIKE '%/' || s.id_species || '/%') as r
        GROUP BY family_name) AS cnt_fam
ON cnt_fam.family_name = r.family_name
LEFT JOIN
        (SELECT count(genus_name) as number_genus, genus_name
        FROM 
          (SELECT f.family_name, g.genus_name, s.species_name 
          FROM 
            (SELECT taxon_name, (taxon_path || taxon_ref || '/') as taxon_full_path
            FROM specimens s
            WHERE collection_ref = ANY((SELECT (array(SELECT c.id FROM collections c 
                WHERE c.id = $1
                OR c.path LIKE ('%/' || $1 || '/%'))) as collections)::int[])
            /*LIMIT 100*/) AS spec
          LEFT JOIN
            (SELECT id as id_family, name as family_name FROM taxonomy WHERE level_ref=34) AS f
          ON spec.taxon_full_path LIKE '%/' || f.id_family || '/%'
          LEFT JOIN
            (SELECT id as id_genus, name as genus_name FROM taxonomy WHERE level_ref=41) AS g
          ON spec.taxon_full_path LIKE '%/' || g.id_genus || '/%'
          LEFT JOIN
            (SELECT id as id_species, name as species_name FROM taxonomy WHERE level_ref=48) AS s
          ON spec.taxon_full_path LIKE '%/' || s.id_species || '/%') as r
        GROUP BY genus_name) AS cnt_gen
ON cnt_gen.genus_name = r.genus_name
LEFT JOIN
        (SELECT count(species_name) as number_species, species_name
        FROM 
          (SELECT f.family_name, g.genus_name, s.species_name 
          FROM 
            (SELECT taxon_name, (taxon_path || taxon_ref || '/') as taxon_full_path
            FROM specimens s
            WHERE collection_ref = ANY((SELECT (array(SELECT c.id FROM collections c 
                WHERE c.id = $1
                OR c.path LIKE ('%/' || $1 || '/%'))) as collections)::int[])
            /*LIMIT 100*/) AS spec
          LEFT JOIN
            (SELECT id as id_family, name as family_name FROM taxonomy WHERE level_ref=34) AS f
          ON spec.taxon_full_path LIKE '%/' || f.id_family || '/%'
          LEFT JOIN
            (SELECT id as id_genus, name as genus_name FROM taxonomy WHERE level_ref=41) AS g
          ON spec.taxon_full_path LIKE '%/' || g.id_genus || '/%'
          LEFT JOIN
            (SELECT id as id_species, name as species_name FROM taxonomy WHERE level_ref=48) AS s
          ON spec.taxon_full_path LIKE '%/' || s.id_species || '/%') as r
        GROUP BY species_name) AS cnt_spec
ON cnt_spec.species_name = r.species_name
ORDER BY r.family_name, r.genus_name, r.species_name;
END
$_$;


ALTER FUNCTION darwin2.taxo_collections_count(integer) OWNER TO darwin2;

--
-- TOC entry 1874 (class 1255 OID 4816518)
-- Name: touniquestr(character varying); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.touniquestr(to_indexed character varying) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
    temp_string varchar;
BEGIN
    -- Investigate https://launchpad.net/postgresql-unaccent
    temp_string := to_indexed;
    temp_string := TRANSLATE(temp_string, E'  ¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿×&|@"\'#(§^!{})°$*][£µ`%+=~/.,?;:\\<>ł€¶ŧ←↓→«»¢“”_-','');
     --Remove ALL none alphanumerical char like # or '
    temp_string := lower(temp_string);
    return substring(temp_string from 0 for 40);
END;
$_$;


ALTER FUNCTION darwin2.touniquestr(to_indexed character varying) OWNER TO darwin2;

--
-- TOC entry 1876 (class 1255 OID 4816519)
-- Name: trg_del_dict(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_del_dict() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldfield RECORD;
  newfield RECORD;
BEGIN

    IF TG_OP = 'UPDATE' THEN
      oldfield = OLD;
      newfield = NEW;
    ELSE --DELETE
      oldfield = OLD;
      execute 'select * from ' || TG_TABLE_NAME::text || ' where id = -15 ' into newfield;
    END IF;
    IF TG_TABLE_NAME = 'codes' THEN
      PERFORM fct_del_in_dict('codes','code_prefix_separator', oldfield.code_prefix_separator, newfield.code_prefix_separator);
      PERFORM fct_del_in_dict('codes','code_suffix_separator', oldfield.code_suffix_separator, newfield.code_suffix_separator);
    ELSIF TG_TABLE_NAME = 'collection_maintenance' THEN
      PERFORM fct_del_in_dict('collection_maintenance','action_observation', oldfield.action_observation, newfield.action_observation);
    ELSIF TG_TABLE_NAME = 'identifications' THEN
      PERFORM fct_del_in_dict('identifications','determination_status', oldfield.determination_status, newfield.determination_status);
    ELSIF TG_TABLE_NAME = 'people' THEN
      PERFORM fct_del_in_dict('people','sub_type', oldfield.sub_type, newfield.sub_type);
      PERFORM fct_del_in_dict('people','title', oldfield.title, newfield.title);
    ELSIF TG_TABLE_NAME = 'people_addresses' THEN
      PERFORM fct_del_in_dict('people_addresses','country', oldfield.country, newfield.country);
    ELSIF TG_TABLE_NAME = 'insurances' THEN
      PERFORM fct_del_in_dict('insurances','insurance_currency', oldfield.insurance_currency, newfield.insurance_currency);
    ELSIF TG_TABLE_NAME = 'mineralogy' THEN
      PERFORM fct_del_in_dict('mineralogy','cristal_system', oldfield.cristal_system, newfield.cristal_system);
    ELSIF TG_TABLE_NAME = 'specimens' THEN
      PERFORM fct_del_in_dict('specimens','type', oldfield.type, newfield.type);
      PERFORM fct_del_in_dict('specimens','type_group', oldfield.type_group, newfield.type_group);
      PERFORM fct_del_in_dict('specimens','type_search', oldfield.type_search, newfield.type_search);
      PERFORM fct_del_in_dict('specimens','sex', oldfield.sex, newfield.sex);
      PERFORM fct_del_in_dict('specimens','state', oldfield.state, newfield.state);
      PERFORM fct_del_in_dict('specimens','stage', oldfield.stage, newfield.stage);
      PERFORM fct_del_in_dict('specimens','social_status', oldfield.social_status, newfield.social_status);
      PERFORM fct_del_in_dict('specimens','rock_form', oldfield.rock_form, newfield.rock_form);

      PERFORM fct_del_in_dict('specimens','container_type', oldfield.container_type, newfield.container_type);
      PERFORM fct_del_in_dict('specimens','sub_container_type', oldfield.sub_container_type, newfield.sub_container_type);
      PERFORM fct_del_in_dict('specimens','specimen_part', oldfield.specimen_part, newfield.specimen_part);
      PERFORM fct_del_in_dict('specimens','specimen_status', oldfield.specimen_status, newfield.specimen_status);

      PERFORM fct_del_in_dict('specimens','shelf', oldfield.shelf, newfield.shelf);
      PERFORM fct_del_in_dict('specimens','col', oldfield.col, newfield.col);
      PERFORM fct_del_in_dict('specimens','row', oldfield.row, newfield.row);
      PERFORM fct_del_in_dict('specimens','room', oldfield.room, newfield.room);
      PERFORM fct_del_in_dict('specimens','floor', oldfield.floor, newfield.floor);
      PERFORM fct_del_in_dict('specimens','building', oldfield.building, newfield.building);

      PERFORM fct_del_in_dict_dept('specimens','container_storage', oldfield.container_storage, newfield.container_storage,
        oldfield.container_type, newfield.container_type, 'container_type' );
      PERFORM fct_del_in_dict_dept('specimens','sub_container_storage', oldfield.sub_container_storage, newfield.sub_container_storage,
        oldfield.sub_container_type, newfield.sub_container_type, 'sub_container_type' );

    ELSIF TG_TABLE_NAME = 'specimens_relationships' THEN
      PERFORM fct_del_in_dict('specimens_relationships','relationship_type', oldfield.relationship_type, newfield.relationship_type);
    ELSIF TG_TABLE_NAME = 'users' THEN
      PERFORM fct_del_in_dict('users','title', oldfield.title, newfield.title);
      PERFORM fct_del_in_dict('users','sub_type', oldfield.sub_type, newfield.sub_type);
    ELSIF TG_TABLE_NAME = 'users_addresses' THEN
      PERFORM fct_del_in_dict('users_addresses','country', oldfield.country, newfield.country);

    ELSIF TG_TABLE_NAME = 'loan_status' THEN
      PERFORM fct_del_in_dict('loan_status','status', oldfield.status, newfield.status);

    ELSIF TG_TABLE_NAME = 'properties' THEN

      PERFORM fct_del_in_dict_dept('properties','property_type', oldfield.property_type, newfield.property_type,
        oldfield.referenced_relation, newfield.referenced_relation, 'referenced_relation' );
      PERFORM fct_del_in_dict_dept('properties','applies_to', oldfield.applies_to, newfield.applies_to,
        oldfield.property_type, newfield.property_type, 'property_type' );
      PERFORM fct_del_in_dict_dept('properties','property_unit', oldfield.property_unit, newfield.property_unit,
        oldfield.property_type, newfield.property_type, 'property_type' );

    ELSIF TG_TABLE_NAME = 'tag_groups' THEN
      PERFORM fct_del_in_dict_dept('tag_groups','sub_group_name', oldfield.sub_group_name, newfield.sub_group_name,
        oldfield.group_name, newfield.group_name, 'group_name' );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.trg_del_dict() OWNER TO darwin2;

--
-- TOC entry 1877 (class 1255 OID 4816520)
-- Name: trg_ins_update_dict(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_ins_update_dict() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  oldfield RECORD;
  newfield RECORD;
BEGIN

    IF TG_OP = 'UPDATE' THEN
      oldfield = OLD;
      newfield = NEW;
    ELSE --INSERT
      newfield = NEW;
      execute 'select * from ' || TG_TABLE_NAME::text || ' where id = -15 ' into oldfield;
    END IF;
    IF TG_TABLE_NAME = 'codes' THEN
      PERFORM fct_add_in_dict('codes','code_prefix_separator', oldfield.code_prefix_separator, newfield.code_prefix_separator);
      PERFORM fct_add_in_dict('codes','code_suffix_separator', oldfield.code_suffix_separator, newfield.code_suffix_separator);

      --ftheeten 2016 09 15
      IF newfield.referenced_relation='specimens' AND newfield.code_category='main' THEN
	UPDATE specimens SET main_code_indexed= fullToIndex(COALESCE(newfield.code_prefix,'') || COALESCE(newfield.code::text,'') || 		COALESCE(newfield.code_suffix,'') ) WHERE id=newfield.record_id;
      END IF;
    ELSIF TG_TABLE_NAME = 'collection_maintenance' THEN
      PERFORM fct_add_in_dict('collection_maintenance','action_observation', oldfield.action_observation, newfield.action_observation);
    ELSIF TG_TABLE_NAME = 'identifications' THEN
      PERFORM fct_add_in_dict('identifications','determination_status', oldfield.determination_status, newfield.determination_status);
    ELSIF TG_TABLE_NAME = 'people' THEN
      PERFORM fct_add_in_dict('people','sub_type', oldfield.sub_type, newfield.sub_type);
      PERFORM fct_add_in_dict('people','title', oldfield.title, newfield.title);
    ELSIF TG_TABLE_NAME = 'people_addresses' THEN
      PERFORM fct_add_in_dict('people_addresses','country', oldfield.country, newfield.country);
    ELSIF TG_TABLE_NAME = 'insurances' THEN
      PERFORM fct_add_in_dict('insurances','insurance_currency', oldfield.insurance_currency, newfield.insurance_currency);
    ELSIF TG_TABLE_NAME = 'mineralogy' THEN
      PERFORM fct_add_in_dict('mineralogy','cristal_system', oldfield.cristal_system, newfield.cristal_system);
    ELSIF TG_TABLE_NAME = 'specimens' THEN
      PERFORM fct_add_in_dict('specimens','type', oldfield.type, newfield.type);
      PERFORM fct_add_in_dict('specimens','type_group', oldfield.type_group, newfield.type_group);
      PERFORM fct_add_in_dict('specimens','type_search', oldfield.type_search, newfield.type_search);
      PERFORM fct_add_in_dict('specimens','sex', oldfield.sex, newfield.sex);
      PERFORM fct_add_in_dict('specimens','state', oldfield.state, newfield.state);
      PERFORM fct_add_in_dict('specimens','stage', oldfield.stage, newfield.stage);
      PERFORM fct_add_in_dict('specimens','social_status', oldfield.social_status, newfield.social_status);
      PERFORM fct_add_in_dict('specimens','rock_form', oldfield.rock_form, newfield.rock_form);

      PERFORM fct_add_in_dict('specimens','container_type', oldfield.container_type, newfield.container_type);
      PERFORM fct_add_in_dict('specimens','sub_container_type', oldfield.sub_container_type, newfield.sub_container_type);
      PERFORM fct_add_in_dict('specimens','specimen_part', oldfield.specimen_part, newfield.specimen_part);
      PERFORM fct_add_in_dict('specimens','specimen_status', oldfield.specimen_status, newfield.specimen_status);

      PERFORM fct_add_in_dict('specimens','shelf', oldfield.shelf, newfield.shelf);
      PERFORM fct_add_in_dict('specimens','col', oldfield.col, newfield.col);
      PERFORM fct_add_in_dict('specimens','row', oldfield.row, newfield.row);
      PERFORM fct_add_in_dict('specimens','room', oldfield.room, newfield.room);
      PERFORM fct_add_in_dict('specimens','floor', oldfield.floor, newfield.floor);
      PERFORM fct_add_in_dict('specimens','building', oldfield.building, newfield.building);

      PERFORM fct_add_in_dict_dept('specimens','container_storage', oldfield.container_storage, newfield.container_storage,
        oldfield.container_type, newfield.container_type);
      PERFORM fct_add_in_dict_dept('specimens','sub_container_storage', oldfield.sub_container_storage, newfield.sub_container_storage,
        oldfield.sub_container_type, newfield.sub_container_type);

    ELSIF TG_TABLE_NAME = 'specimens_relationships' THEN
      PERFORM fct_add_in_dict('specimens_relationships','relationship_type', oldfield.relationship_type, newfield.relationship_type);
    ELSIF TG_TABLE_NAME = 'users' THEN
      PERFORM fct_add_in_dict('users','title', oldfield.title, newfield.title);
      PERFORM fct_add_in_dict('users','sub_type', oldfield.sub_type, newfield.sub_type);
    ELSIF TG_TABLE_NAME = 'users_addresses' THEN
      PERFORM fct_add_in_dict('users_addresses','country', oldfield.country, newfield.country);

    ELSIF TG_TABLE_NAME = 'loan_status' THEN
      PERFORM fct_add_in_dict('loan_status','status', oldfield.status, newfield.status);

    ELSIF TG_TABLE_NAME = 'properties' THEN

      PERFORM fct_add_in_dict_dept('properties','property_type', oldfield.property_type, newfield.property_type,
        oldfield.referenced_relation, newfield.referenced_relation);
      PERFORM fct_add_in_dict_dept('properties','applies_to', oldfield.applies_to, newfield.applies_to,
        oldfield.property_type, newfield.property_type);
      PERFORM fct_add_in_dict_dept('properties','property_unit', oldfield.property_unit, newfield.property_unit,
        oldfield.property_type, newfield.property_type);

    ELSIF TG_TABLE_NAME = 'tag_groups' THEN
      PERFORM fct_add_in_dict_dept('tag_groups','sub_group_name', oldfield.sub_group_name, newfield.sub_group_name,
        oldfield.group_name, newfield.group_name);

    END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.trg_ins_update_dict() OWNER TO darwin2;

--
-- TOC entry 1878 (class 1255 OID 4816521)
-- Name: trg_rmca_del_import_related(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_rmca_del_import_related() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN

 IF TG_OP='DELETE' OR (TG_OP='UPDATE' AND NEW.state='deleted' ) THEN
	DELETE FROM properties WHERE referenced_relation='staging_gtu' AND record_id IN (SELECT id FROM staging_gtu WHERE import_ref= OLD.id ) ;
	DELETE FROM comments WHERE referenced_relation='staging_gtu' AND record_id IN (SELECT id FROM staging_gtu WHERE import_ref= OLD.id ) ;
	DELETE FROM staging_people WHERE referenced_relation='staging_gtu' AND record_id IN (SELECT id FROM staging_gtu WHERE import_ref= OLD.id ) ;
	DELETE FROM staging_gtu_tag_groups WHERE staging_gtu_ref IN (SELECT id FROM staging_gtu WHERE import_ref= OLD.id ) ;
	DELETE FROM staging_gtu WHERE import_ref=OLD.id;
	PERFORM setval('darwin2.staging_gtu_id_seq', (SELECT MAX(id)+1 FROM staging_gtu) , false);
  
 END IF;
 IF TG_OP='DELETE' THEN
  RETURN OLD;
 ELSEIF TG_OP='UPDATE' THEN
  RETURN NEW;
 END IF;
 RETURN OLD;
END;
$$;


ALTER FUNCTION darwin2.trg_rmca_del_import_related() OWNER TO darwin2;

--
-- TOC entry 1879 (class 1255 OID 4816522)
-- Name: trg_rmca_import_taxonomy_history(); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.trg_rmca_import_taxonomy_history() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN
IF TG_OP='INSERT' THEN
	NEW.history_taxonomy =hstore(NEW.specimen_taxonomy_ref::varchar ,now()::varchar);
ELSIF TG_OP='UPDATE' THEN
	IF OLD.history_taxonomy IS NULL THEN
		NEW.history_taxonomy =hstore(NEW.specimen_taxonomy_ref::varchar ,now()::varchar);
	ELSE 
		IF NEW.specimen_taxonomy_ref!= OLD.specimen_taxonomy_ref  THEN
			NEW.history_taxonomy =OLD.history_taxonomy||hstore(NEW.specimen_taxonomy_ref::varchar ,now()::varchar);
			UPDATE staging SET specimen_taxonomy_ref=NEW.specimen_taxonomy_ref WHERE taxon_ref IS NULL AND import_ref=NEW.id;
		END IF;
	END IF ;
 END IF;
 
 RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.trg_rmca_import_taxonomy_history() OWNER TO darwin2;

--
-- TOC entry 1880 (class 1255 OID 4816523)
-- Name: update_collections_code_last_val(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.update_collections_code_last_val() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE collections 
  SET code_last_value = (SELECT max(code_num) 
                         FROM codes 
                         INNER JOIN specimens 
                           ON codes.referenced_relation = 'specimens' 
                           AND codes.record_id = specimens.id
                           AND codes.code_category = 'main'
                         WHERE specimens.collection_ref = NEW.collection_ref
                           AND codes.code_num IS NOT NULL
                        )
  WHERE id = NEW.collection_ref
    AND EXISTS (SELECT 1
                FROM codes inner join specimens
                  ON codes.referenced_relation = 'specimens'
                  AND codes.record_id = specimens.id
                WHERE codes.code_category = 'main'
                  AND specimens.collection_ref = NEW.collection_ref
                  AND codes.code_num IS NOT NULL
                LIMIT 1
               );
  UPDATE collections 
  SET code_last_value = (SELECT max(code_num) 
                         FROM codes 
                         INNER JOIN specimens 
                           ON codes.referenced_relation = 'specimens' 
                           AND codes.record_id = specimens.id
                           AND codes.code_category = 'main'
                         WHERE specimens.collection_ref = OLD.collection_ref
                           AND codes.code_num IS NOT NULL
                        )
  WHERE id = OLD.collection_ref
    AND EXISTS (SELECT 1
                FROM codes inner join specimens
                  ON codes.referenced_relation = 'specimens'
                  AND codes.record_id = specimens.id
                WHERE codes.code_category = 'main'
                  AND specimens.collection_ref = OLD.collection_ref
                  AND codes.code_num IS NOT NULL
                LIMIT 1
               );
  IF NOT FOUND THEN
    UPDATE collections
    SET code_last_value = DEFAULT
    WHERE id = OLD.collection_ref;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION darwin2.update_collections_code_last_val() OWNER TO postgres;

--
-- TOC entry 1902 (class 1255 OID 4816524)
-- Name: update_collections_code_last_val_after_spec_del(); Type: FUNCTION; Schema: darwin2; Owner: postgres
--

CREATE FUNCTION darwin2.update_collections_code_last_val_after_spec_del() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE collections 
  SET code_last_value = (SELECT max(code_num) 
                         FROM codes 
                         INNER JOIN specimens 
                           ON codes.referenced_relation = 'specimens' 
                           AND codes.record_id = specimens.id
                           AND codes.code_category = 'main'
                         WHERE specimens.collection_ref = OLD.collection_ref
                           AND specimens.id != OLD.id
                           AND codes.code_num IS NOT NULL
                        )
  WHERE id = OLD.collection_ref
    AND EXISTS (SELECT 1
                FROM codes inner join specimens
                  ON codes.referenced_relation = 'specimens'
                  AND codes.record_id = specimens.id
                WHERE codes.code_category = 'main'
                  AND specimens.collection_ref = OLD.collection_ref
                  AND specimens.id != OLD.id
                  AND codes.code_num IS NOT NULL
                LIMIT 1
               );
  IF NOT FOUND THEN
    UPDATE collections
    SET code_last_value = DEFAULT
    WHERE id = OLD.collection_ref;
  END IF;
  RETURN NULL;
END;
$$;


ALTER FUNCTION darwin2.update_collections_code_last_val_after_spec_del() OWNER TO postgres;

--
-- TOC entry 1881 (class 1255 OID 4816525)
-- Name: upsert(character varying, public.hstore); Type: FUNCTION; Schema: darwin2; Owner: darwin2
--

CREATE FUNCTION darwin2.upsert(tablename character varying, keyvalues public.hstore) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  insert_stmt varchar := 'insert into ' || quote_ident(tableName) || ' (';
  update_stmt varchar := 'update ' || quote_ident(tableName) || ' SET (';
  where_stmt varchar := ' WHERE ';
  iloop integer := 0;
  recUnqFields RECORD;
  newhst RECORD;
  lowerKeyValues hstore;
begin
  for newhst in (select * from each(keyValues)) loop
    if iloop = 0 then
      lowerKeyValues := hstore(lower(newhst.key), newhst.value);
    else
      lowerKeyValues := lowerKeyValues || hstore(lower(newhst.key), newhst.value);
    end if;
    iloop := iloop +1;
  end loop;
  iloop := 0;
  insert_stmt := insert_stmt || array_to_string(akeys(lowerKeyValues), ',') || ') VALUES (' || chr(39) || array_to_string(avals(lowerKeyValues), (chr(39) || ',' || chr(39))::text) || chr(39) ||')';
  begin
    execute insert_stmt;
  exception
    when unique_violation then
      begin
        for recUnqFields IN (select x.vals as field, column_default as defaultVal 
                             from (select regexp_split_to_table(trim(substr(indexdef,strpos(indexdef, '(')+1),')'),', ') as vals 
                                   from pg_indexes 
                                   where tablename = tableName 
                                     and strpos(indexdef, 'UNIQUE') > 0 
                                     and indexname = (select conname 
                                                      from pg_class inner join pg_constraint on pg_class.oid = pg_constraint.conrelid and relname = tableName and contype = 'p'
                                                     )
                                  ) as x 
                             inner join 
                             information_schema.columns on x.vals = column_name and table_name = tableName) loop
          if iloop > 0 then
            where_stmt := where_stmt || ' AND ';
          end if;
          iloop := iloop + 1;
          if lowerKeyValues ? recUnqFields.field then
            where_stmt := where_stmt || quote_ident(recUnqFields.field) || ' = ' || quote_literal(lowerKeyValues -> recUnqFields.field);
          else
            where_stmt := where_stmt || quote_ident(recUnqFields.field) || ' = ' || quote_literal(coalesce(recUnqFields.defaultVal,''));
          end if;
        end loop;
        update_stmt := update_stmt || array_to_string(akeys(lowerKeyValues), ',') || ') = (' || chr(39) || array_to_string(avals(lowerKeyValues), (chr(39) || ',' || chr(39))::text) || chr(39) ||')' || where_stmt;
        execute update_stmt;
        return 'updated';
      exception
        when others then
          return 'SQL error is: '::text || SQLERRM;
      end;
      return 'SQL error is: '::text || SQLERRM;
  end;
  return 'inserted';
end;
$$;


ALTER FUNCTION darwin2.upsert(tablename character varying, keyvalues public.hstore) OWNER TO darwin2;

--
-- TOC entry 1882 (class 1255 OID 4816526)
-- Name: addgeometrycolumn(character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.addgeometrycolumn(character varying, character varying, integer, character varying, integer) OWNER TO postgres;

--
-- TOC entry 1883 (class 1255 OID 4816527)
-- Name: addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;


ALTER FUNCTION public.addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) OWNER TO postgres;

--
-- TOC entry 1884 (class 1255 OID 4816528)
-- Name: addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	catalog_name alias for $1;
	schema_name alias for $2;
	table_name alias for $3;
	column_name alias for $4;
	new_srid alias for $5;
	new_type alias for $6;
	new_dim alias for $7;
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;

BEGIN

	-- Verify geometry type
	IF ( NOT ( (new_type = 'GEOMETRY') OR
			   (new_type = 'GEOMETRYCOLLECTION') OR
			   (new_type = 'POINT') OR
			   (new_type = 'MULTIPOINT') OR
			   (new_type = 'POLYGON') OR
			   (new_type = 'MULTIPOLYGON') OR
			   (new_type = 'LINESTRING') OR
			   (new_type = 'MULTILINESTRING') OR
			   (new_type = 'GEOMETRYCOLLECTIONM') OR
			   (new_type = 'POINTM') OR
			   (new_type = 'MULTIPOINTM') OR
			   (new_type = 'POLYGONM') OR
			   (new_type = 'MULTIPOLYGONM') OR
			   (new_type = 'LINESTRINGM') OR
			   (new_type = 'MULTILINESTRINGM') OR
			   (new_type = 'CIRCULARSTRING') OR
			   (new_type = 'CIRCULARSTRINGM') OR
			   (new_type = 'COMPOUNDCURVE') OR
			   (new_type = 'COMPOUNDCURVEM') OR
			   (new_type = 'CURVEPOLYGON') OR
			   (new_type = 'CURVEPOLYGONM') OR
			   (new_type = 'MULTICURVE') OR
			   (new_type = 'MULTICURVEM') OR
			   (new_type = 'MULTISURFACE') OR
			   (new_type = 'MULTISURFACEM')) )
	THEN
		RAISE EXCEPTION 'Invalid type name - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM,
	or GEOMETRYCOLLECTIONM';
		RETURN 'fail';
	END IF;


	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <0) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;


	-- Verify SRID
	IF ( new_srid != -1 ) THEN
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumns() - invalid SRID';
			RETURN 'fail';
		END IF;
	END IF;


	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;


	-- Add geometry column to table
	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD COLUMN ' || quote_ident(column_name) ||
		' geometry ';
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Delete stale record in geometry_columns (if any)
	sql := 'DELETE FROM geometry_columns WHERE
		f_table_catalog = ' || quote_literal('') ||
		' AND f_table_schema = ' ||
		quote_literal(real_schema) ||
		' AND f_table_name = ' || quote_literal(table_name) ||
		' AND f_geometry_column = ' || quote_literal(column_name);
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Add record in geometry_columns
	sql := 'INSERT INTO geometry_columns (f_table_catalog,f_table_schema,f_table_name,' ||
										  'f_geometry_column,coord_dimension,srid,type)' ||
		' VALUES (' ||
		quote_literal('') || ',' ||
		quote_literal(real_schema) || ',' ||
		quote_literal(table_name) || ',' ||
		quote_literal(column_name) || ',' ||
		new_dim::text || ',' ||
		new_srid::text || ',' ||
		quote_literal(new_type) || ')';
	RAISE DEBUG '%', sql;
	EXECUTE sql;


	-- Add table CHECKs
	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD CONSTRAINT '
		|| quote_ident('enforce_srid_' || column_name)
		|| ' CHECK (ST_SRID(' || quote_ident(column_name) ||
		') = ' || new_srid::text || ')' ;
	RAISE DEBUG '%', sql;
	EXECUTE sql;

	sql := 'ALTER TABLE ' ||
		quote_ident(real_schema) || '.' || quote_ident(table_name)
		|| ' ADD CONSTRAINT '
		|| quote_ident('enforce_dims_' || column_name)
		|| ' CHECK (ST_NDims(' || quote_ident(column_name) ||
		') = ' || new_dim::text || ')' ;
	RAISE DEBUG '%', sql;
	EXECUTE sql;

	IF ( NOT (new_type = 'GEOMETRY')) THEN
		sql := 'ALTER TABLE ' ||
			quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
			quote_ident('enforce_geotype_' || column_name) ||
			' CHECK (GeometryType(' ||
			quote_ident(column_name) || ')=' ||
			quote_literal(new_type) || ' OR (' ||
			quote_ident(column_name) || ') is null)';
		RAISE DEBUG '%', sql;
		EXECUTE sql;
	END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
$_$;


ALTER FUNCTION public.addgeometrycolumn(character varying, character varying, character varying, character varying, integer, character varying, integer) OWNER TO postgres;

--
-- TOC entry 1885 (class 1255 OID 4816529)
-- Name: fix_geometry_columns(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.fix_geometry_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	mislinked record;
	result text;
	linked integer;
	deleted integer;
	foundschema integer;
BEGIN

	-- Since 7.3 schema support has been added.
	-- Previous postgis versions used to put the database name in
	-- the schema column. This needs to be fixed, so we try to
	-- set the correct schema for each geometry_colums record
	-- looking at table, column, type and srid.
	UPDATE geometry_columns SET f_table_schema = n.nspname
		FROM pg_namespace n, pg_class c, pg_attribute a,
			pg_constraint sridcheck, pg_constraint typecheck
			WHERE ( f_table_schema is NULL
		OR f_table_schema = ''
			OR f_table_schema NOT IN (
					SELECT nspname::varchar
					FROM pg_namespace nn, pg_class cc, pg_attribute aa
					WHERE cc.relnamespace = nn.oid
					AND cc.relname = f_table_name::name
					AND aa.attrelid = cc.oid
					AND aa.attname = f_geometry_column::name))
			AND f_table_name::name = c.relname
			AND c.oid = a.attrelid
			AND c.relnamespace = n.oid
			AND f_geometry_column::name = a.attname

			AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(srid(% = %)'
			AND sridcheck.consrc ~ textcat(' = ', srid::text)

			AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype(%) = ''%''::text) OR (% IS NULL))'
			AND typecheck.consrc ~ textcat(' = ''', type::text)

			AND NOT EXISTS (
					SELECT oid FROM geometry_columns gc
					WHERE c.relname::varchar = gc.f_table_name
					AND n.nspname::varchar = gc.f_table_schema
					AND a.attname::varchar = gc.f_geometry_column
			);

	GET DIAGNOSTICS foundschema = ROW_COUNT;

	-- no linkage to system table needed
	return 'fixed:'||foundschema::text;

END;
$$;


ALTER FUNCTION public.fix_geometry_columns() OWNER TO postgres;

--
-- TOC entry 1888 (class 1255 OID 4816530)
-- Name: fulltoindex(character varying, boolean); Type: FUNCTION; Schema: public; Owner: darwin2
--

CREATE FUNCTION public.fulltoindex(to_indexed character varying, keep_space boolean) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    temp_string varchar;
BEGIN
    -- Investigate https://launchpad.net/postgresql-unaccent
    temp_string := to_indexed;
    temp_string := translate(temp_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
    temp_string := translate(temp_string, 'èééêëēĕėęěĒĔĖĘĚ', 'eeeeeeeeeeeeeee');
    temp_string := translate(temp_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
    temp_string := translate(temp_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
    temp_string := translate(temp_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
    temp_string := REPLACE(temp_string, 'Œ', 'oe');
    temp_string := REPLACE(temp_string, 'Ӕ', 'ae');
    temp_string := REPLACE(temp_string, 'œ', 'oe');
    temp_string := REPLACE(temp_string, 'æ', 'ae');
    temp_string := REPLACE(temp_string, 'ë', 'e');
    temp_string := REPLACE(temp_string, 'ï', 'i');
    temp_string := REPLACE(temp_string, 'ö', 'o');
    temp_string := REPLACE(temp_string, 'ü', 'u');
--     temp_string := REPLACE(temp_string, E'\'', '');
--     temp_string := REPLACE(temp_string, '"', '');
    temp_string := REPLACE(temp_string, 'ñ', 'n');
    temp_string := REPLACE(temp_string,chr(946),'b');
    temp_string := TRANSLATE(temp_string,'Ð','d');
    temp_string := TRANSLATE(temp_string,'ó','o');
    temp_string := TRANSLATE(temp_string,'ę','e');
    temp_string := TRANSLATE(temp_string,'ā','a');
    temp_string := TRANSLATE(temp_string,'ē','e');
    temp_string := TRANSLATE(temp_string,'ī','i');
    temp_string := TRANSLATE(temp_string,'ō','o');
    temp_string := TRANSLATE(temp_string,'ū','u');
    temp_string := TRANSLATE(temp_string,'ş','s');
    temp_string := TRANSLATE(temp_string,'Ş','s');
--     temp_string := TRANSLATE(temp_string,'†','');
--     temp_string := TRANSLATE(temp_string,chr(52914),'');
--ftheeten 2015 02 15

--ftheeten 2017 01 22
temp_string := TRANSLATE(temp_string,'-',' ');
temp_string := TRANSLATE(temp_string,'''',' ');
    -- FROM 160 to 255 ASCII
    temp_string := TRANSLATE(temp_string, ' ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ',
      '  cL YS sCa  -R     Zu .z   EeY?AAAAAAACEEEEIIII NOOOOOxOUUUUYTBaaaaaaaceeeeiiii nooooo/ouuuuyty');
    --Remove ALL none alphanumerical char
    if keep_space= false then
    temp_string := lower(regexp_replace(temp_string,'[^[:alnum:]]','', 'g'));
    else
        temp_string := lower(regexp_replace(temp_string,'[^[:alnum:]\s]','', 'g'));
	temp_string :=regexp_replace(temp_string,'(\s{2,})',' ', 'g');
	
    end if;
    return temp_string;
END;
$$;


ALTER FUNCTION public.fulltoindex(to_indexed character varying, keep_space boolean) OWNER TO darwin2;

--
-- TOC entry 1889 (class 1255 OID 4816531)
-- Name: populate_geometry_columns(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.populate_geometry_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	inserted    integer;
	oldcount    integer;
	probed      integer;
	stale       integer;
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;

BEGIN
	SELECT count(*) INTO oldcount FROM geometry_columns;
	inserted := 0;

	EXECUTE 'TRUNCATE geometry_columns';

	-- Count the number of geometry columns in all tables and views
	SELECT count(DISTINCT c.oid) INTO probed
	FROM pg_class c,
		 pg_attribute a,
		 pg_type t,
		 pg_namespace n
	WHERE (c.relkind = 'r' OR c.relkind = 'v')
	AND t.typname = 'geometry'
	AND a.attisdropped = false
	AND a.atttypid = t.oid
	AND a.attrelid = c.oid
	AND c.relnamespace = n.oid
	AND n.nspname NOT ILIKE 'pg_temp%';

	-- Iterate through all non-dropped geometry columns
	RAISE DEBUG 'Processing Tables.....';

	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
	LOOP

	inserted := inserted + populate_geometry_columns(gcs.oid);
	END LOOP;

	-- Add views to geometry columns table
	RAISE DEBUG 'Processing Views.....';
	FOR gcs IN
	SELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'v'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
	LOOP

	inserted := inserted + populate_geometry_columns(gcs.oid);
	END LOOP;

	IF oldcount > inserted THEN
	stale = oldcount-inserted;
	ELSE
	stale = 0;
	END IF;

	RETURN 'probed:' ||probed|| ' inserted:'||inserted|| ' conflicts:'||probed-inserted|| ' deleted:'||stale;
END

$$;


ALTER FUNCTION public.populate_geometry_columns() OWNER TO postgres;

--
-- TOC entry 1890 (class 1255 OID 4816532)
-- Name: populate_geometry_columns(oid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.populate_geometry_columns(tbl_oid oid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	gcs         RECORD;
	gc          RECORD;
	gsrid       integer;
	gndims      integer;
	gtype       text;
	query       text;
	gc_is_valid boolean;
	inserted    integer;

BEGIN
	inserted := 0;

	-- Iterate through all geometry columns in this table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'r'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP

	RAISE DEBUG 'Processing table %.%.%', gcs.nspname, gcs.relname, gcs.attname;

	DELETE FROM geometry_columns
	  WHERE f_table_schema = gcs.nspname
	  AND f_table_name = gcs.relname
	  AND f_geometry_column = gcs.attname;

	gc_is_valid := true;

	-- Try to find srid check from system tables (pg_constraint)
	gsrid :=
		(SELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%srid(% = %');
	IF (gsrid IS NULL) THEN
		-- Try to find srid from the geometry itself
		EXECUTE 'SELECT srid(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gsrid := gc.srid;

		-- Try to apply srid check to column
		IF (gsrid IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
						 ADD CONSTRAINT ' || quote_ident('enforce_srid_' || gcs.attname) || '
						 CHECK (srid(' || quote_ident(gcs.attname) || ') = ' || gsrid || ')';
			EXCEPTION
				WHEN check_violation THEN
					RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (srid(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gsrid;
					gc_is_valid := false;
			END;
		END IF;
	END IF;

	-- Try to find ndims check from system tables (pg_constraint)
	gndims :=
		(SELECT replace(split_part(s.consrc, ' = ', 2), ')', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%ndims(% = %');
	IF (gndims IS NULL) THEN
		-- Try to find ndims from the geometry itself
		EXECUTE 'SELECT ndims(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gndims := gc.ndims;

		-- Try to apply ndims check to column
		IF (gndims IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
						 ADD CONSTRAINT ' || quote_ident('enforce_dims_' || gcs.attname) || '
						 CHECK (ndims(' || quote_ident(gcs.attname) || ') = '||gndims||')';
			EXCEPTION
				WHEN check_violation THEN
					RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (ndims(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gndims;
					gc_is_valid := false;
			END;
		END IF;
	END IF;

	-- Try to find geotype check from system tables (pg_constraint)
	gtype :=
		(SELECT replace(split_part(s.consrc, '''', 2), ')', '')
		 FROM pg_class c, pg_namespace n, pg_attribute a, pg_constraint s
		 WHERE n.nspname = gcs.nspname
		 AND c.relname = gcs.relname
		 AND a.attname = gcs.attname
		 AND a.attrelid = c.oid
		 AND s.connamespace = n.oid
		 AND s.conrelid = c.oid
		 AND a.attnum = ANY (s.conkey)
		 AND s.consrc LIKE '%geometrytype(% = %');
	IF (gtype IS NULL) THEN
		-- Try to find geotype from the geometry itself
		EXECUTE 'SELECT geometrytype(' || quote_ident(gcs.attname) || ')
				 FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gtype := gc.geometrytype;
		--IF (gtype IS NULL) THEN
		--    gtype := 'GEOMETRY';
		--END IF;

		-- Try to apply geometrytype check to column
		IF (gtype IS NOT NULL) THEN
			BEGIN
				EXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				ADD CONSTRAINT ' || quote_ident('enforce_geotype_' || gcs.attname) || '
				CHECK ((geometrytype(' || quote_ident(gcs.attname) || ') = ' || quote_literal(gtype) || ') OR (' || quote_ident(gcs.attname) || ' IS NULL))';
			EXCEPTION
				WHEN check_violation THEN
					-- No geometry check can be applied. This column contains a number of geometry types.
					RAISE WARNING 'Could not add geometry type check (%) to table column: %.%.%', gtype, quote_ident(gcs.nspname),quote_ident(gcs.relname),quote_ident(gcs.attname);
			END;
		END IF;
	END IF;

	IF (gsrid IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the srid', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSIF (gndims IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the number of dimensions', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSIF (gtype IS NULL) THEN
		RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine the geometry type', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
	ELSE
		-- Only insert into geometry_columns if table constraints could be applied.
		IF (gc_is_valid) THEN
			INSERT INTO geometry_columns (f_table_catalog,f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type)
			VALUES ('', gcs.nspname, gcs.relname, gcs.attname, gndims, gsrid, gtype);
			inserted := inserted + 1;
		END IF;
	END IF;
	END LOOP;

	-- Add views to geometry columns table
	FOR gcs IN
	SELECT n.nspname, c.relname, a.attname
		FROM pg_class c,
			 pg_attribute a,
			 pg_type t,
			 pg_namespace n
		WHERE c.relkind = 'v'
		AND t.typname = 'geometry'
		AND a.attisdropped = false
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND n.nspname NOT ILIKE 'pg_temp%'
		AND c.oid = tbl_oid
	LOOP
		RAISE DEBUG 'Processing view %.%.%', gcs.nspname, gcs.relname, gcs.attname;

	DELETE FROM geometry_columns
	  WHERE f_table_schema = gcs.nspname
	  AND f_table_name = gcs.relname
	  AND f_geometry_column = gcs.attname;
	  
		EXECUTE 'SELECT ndims(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gndims := gc.ndims;

		EXECUTE 'SELECT srid(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gsrid := gc.srid;

		EXECUTE 'SELECT geometrytype(' || quote_ident(gcs.attname) || ')
				 FROM ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '
				 WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1'
			INTO gc;
		gtype := gc.geometrytype;

		IF (gndims IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine ndims', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSIF (gsrid IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine srid', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSIF (gtype IS NULL) THEN
			RAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not determine gtype', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname);
		ELSE
			query := 'INSERT INTO geometry_columns (f_table_catalog,f_table_schema, f_table_name, f_geometry_column, coord_dimension, srid, type) ' ||
					 'VALUES ('''', ' || quote_literal(gcs.nspname) || ',' || quote_literal(gcs.relname) || ',' || quote_literal(gcs.attname) || ',' || gndims || ',' || gsrid || ',' || quote_literal(gtype) || ')';
			EXECUTE query;
			inserted := inserted + 1;
		END IF;
	END LOOP;

	RETURN inserted;
END

$$;


ALTER FUNCTION public.populate_geometry_columns(tbl_oid oid) OWNER TO postgres;

--
-- TOC entry 1891 (class 1255 OID 4816534)
-- Name: probe_geometry_columns(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.probe_geometry_columns() RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	inserted integer;
	oldcount integer;
	probed integer;
	stale integer;
BEGIN

	SELECT count(*) INTO oldcount FROM geometry_columns;

	SELECT count(*) INTO probed
		FROM pg_class c, pg_attribute a, pg_type t,
			pg_namespace n,
			pg_constraint sridcheck, pg_constraint typecheck

		WHERE t.typname = 'geometry'
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND sridcheck.connamespace = n.oid
		AND typecheck.connamespace = n.oid
		AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(srid('||a.attname||') = %)'
		AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype('||a.attname||') = ''%''::text) OR (% IS NULL))'
		;

	INSERT INTO geometry_columns SELECT
		''::varchar as f_table_catalogue,
		n.nspname::varchar as f_table_schema,
		c.relname::varchar as f_table_name,
		a.attname::varchar as f_geometry_column,
		2 as coord_dimension,
		trim(both  ' =)' from
			replace(replace(split_part(
				sridcheck.consrc, ' = ', 2), ')', ''), '(', ''))::integer AS srid,
		trim(both ' =)''' from substr(typecheck.consrc,
			strpos(typecheck.consrc, '='),
			strpos(typecheck.consrc, '::')-
			strpos(typecheck.consrc, '=')
			))::varchar as type
		FROM pg_class c, pg_attribute a, pg_type t,
			pg_namespace n,
			pg_constraint sridcheck, pg_constraint typecheck
		WHERE t.typname = 'geometry'
		AND a.atttypid = t.oid
		AND a.attrelid = c.oid
		AND c.relnamespace = n.oid
		AND sridcheck.connamespace = n.oid
		AND typecheck.connamespace = n.oid
		AND sridcheck.conrelid = c.oid
		AND sridcheck.consrc LIKE '(st_srid('||a.attname||') = %)'
		AND typecheck.conrelid = c.oid
		AND typecheck.consrc LIKE
		'((geometrytype('||a.attname||') = ''%''::text) OR (% IS NULL))'

			AND NOT EXISTS (
					SELECT oid FROM geometry_columns gc
					WHERE c.relname::varchar = gc.f_table_name
					AND n.nspname::varchar = gc.f_table_schema
					AND a.attname::varchar = gc.f_geometry_column
			);

	GET DIAGNOSTICS inserted = ROW_COUNT;

	IF oldcount > probed THEN
		stale = oldcount-probed;
	ELSE
		stale = 0;
	END IF;

	RETURN 'probed:'||probed::text||
		' inserted:'||inserted::text||
		' conflicts:'||(probed-inserted)::text||
		' stale:'||stale::text;
END

$$;


ALTER FUNCTION public.probe_geometry_columns() OWNER TO postgres;

--
-- TOC entry 1892 (class 1255 OID 4816535)
-- Name: rename_geometry_table_constraints(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.rename_geometry_table_constraints() RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $$
SELECT 'rename_geometry_table_constraint() is obsoleted'::text
$$;


ALTER FUNCTION public.rename_geometry_table_constraints() OWNER TO postgres;

--
-- TOC entry 1893 (class 1255 OID 4816536)
-- Name: st_asbinary(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.st_asbinary(text) RETURNS bytea
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$ SELECT ST_AsBinary($1::geometry);  $_$;


ALTER FUNCTION public.st_asbinary(text) OWNER TO postgres;

--
-- TOC entry 3849 (class 2617 OID 4816537)
-- Name: =; Type: OPERATOR; Schema: darwin2; Owner: postgres
--

CREATE OPERATOR darwin2.= (
    FUNCTION = darwin2.point_equal,
    LEFTARG = point,
    RIGHTARG = point
);


ALTER OPERATOR darwin2.= (point, point) OWNER TO postgres;

--
-- TOC entry 4143 (class 2753 OID 4816538)
-- Name: gist_geometry_ops; Type: OPERATOR FAMILY; Schema: public; Owner: postgres
--

CREATE OPERATOR FAMILY public.gist_geometry_ops USING gist;


ALTER OPERATOR FAMILY public.gist_geometry_ops USING gist OWNER TO postgres;

--
-- TOC entry 4183 (class 1417 OID 4816539)
-- Name: file_server; Type: SERVER; Schema: -; Owner: postgres
--

CREATE SERVER file_server FOREIGN DATA WRAPPER file_fdw;


ALTER SERVER file_server OWNER TO postgres;

--
-- TOC entry 435 (class 1259 OID 5308564)
-- Name: authority_domain; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.authority_domain (
    id integer NOT NULL,
    name character varying NOT NULL,
    website_url character varying,
    webservice_root character varying,
    webservice_format character varying
);


ALTER TABLE darwin2.authority_domain OWNER TO darwin2;

--
-- TOC entry 5870 (class 0 OID 0)
-- Dependencies: 435
-- Name: TABLE authority_domain; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.authority_domain IS 'List of all authority domains that contributed to a mapping';


--
-- TOC entry 5871 (class 0 OID 0)
-- Dependencies: 435
-- Name: COLUMN authority_domain.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.authority_domain.id IS 'Unique identifier of a authority domain.';


--
-- TOC entry 5872 (class 0 OID 0)
-- Dependencies: 435
-- Name: COLUMN authority_domain.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.authority_domain.name IS 'Name of the authority domain';


--
-- TOC entry 5873 (class 0 OID 0)
-- Dependencies: 435
-- Name: COLUMN authority_domain.website_url; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.authority_domain.website_url IS 'Front-end URL of the authority domain';


--
-- TOC entry 5874 (class 0 OID 0)
-- Dependencies: 435
-- Name: COLUMN authority_domain.webservice_root; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.authority_domain.webservice_root IS 'Webservice endpoint of the authority domain.';


--
-- TOC entry 5875 (class 0 OID 0)
-- Dependencies: 435
-- Name: COLUMN authority_domain.webservice_format; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.authority_domain.webservice_format IS 'Main returned format of the authority domain. Might be multiple.';


--
-- TOC entry 434 (class 1259 OID 5308562)
-- Name: authority_domain_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.authority_domain_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.authority_domain_id_seq OWNER TO darwin2;

--
-- TOC entry 5877 (class 0 OID 0)
-- Dependencies: 434
-- Name: authority_domain_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.authority_domain_id_seq OWNED BY darwin2.authority_domain.id;


--
-- TOC entry 237 (class 1259 OID 4816540)
-- Name: bibliography; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.bibliography (
    id integer NOT NULL,
    title character varying NOT NULL,
    title_indexed character varying NOT NULL,
    type character varying NOT NULL,
    abstract character varying DEFAULT ''::character varying NOT NULL,
    year integer
);


ALTER TABLE darwin2.bibliography OWNER TO darwin2;

--
-- TOC entry 5879 (class 0 OID 0)
-- Dependencies: 237
-- Name: TABLE bibliography; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.bibliography IS 'List of expeditions made to collect specimens';


--
-- TOC entry 5880 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN bibliography.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.id IS 'Unique identifier';


--
-- TOC entry 5881 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN bibliography.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.title IS 'bibliography title';


--
-- TOC entry 5882 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN bibliography.title_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.title_indexed IS 'Indexed form of title';


--
-- TOC entry 5883 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN bibliography.type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.type IS 'bibliography type : article, book, booklet';


--
-- TOC entry 5884 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN bibliography.abstract; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.abstract IS 'optional abstract of the bibliography';


--
-- TOC entry 5885 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN bibliography.year; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.bibliography.year IS 'The year of publication (or, if unpublished, the year of creation)';


--
-- TOC entry 238 (class 1259 OID 4816547)
-- Name: bibliography_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.bibliography_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.bibliography_id_seq OWNER TO darwin2;

--
-- TOC entry 5887 (class 0 OID 0)
-- Dependencies: 238
-- Name: bibliography_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.bibliography_id_seq OWNED BY darwin2.bibliography.id;


--
-- TOC entry 239 (class 1259 OID 4816549)
-- Name: template_table_record_ref; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_table_record_ref (
    referenced_relation character varying NOT NULL,
    record_id integer NOT NULL
);


ALTER TABLE darwin2.template_table_record_ref OWNER TO darwin2;

--
-- TOC entry 5888 (class 0 OID 0)
-- Dependencies: 239
-- Name: TABLE template_table_record_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_table_record_ref IS 'Template called to add referenced_relation and record_id fields';


--
-- TOC entry 5889 (class 0 OID 0)
-- Dependencies: 239
-- Name: COLUMN template_table_record_ref.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_table_record_ref.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 5890 (class 0 OID 0)
-- Dependencies: 239
-- Name: COLUMN template_table_record_ref.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_table_record_ref.record_id IS 'Id of record concerned';


--
-- TOC entry 240 (class 1259 OID 4816555)
-- Name: catalogue_bibliography; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.catalogue_bibliography (
    id integer NOT NULL,
    bibliography_ref integer NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.catalogue_bibliography OWNER TO darwin2;

--
-- TOC entry 5892 (class 0 OID 0)
-- Dependencies: 240
-- Name: TABLE catalogue_bibliography; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.catalogue_bibliography IS 'List of people of catalogues units - Taxonomy, Chronostratigraphy,...';


--
-- TOC entry 5893 (class 0 OID 0)
-- Dependencies: 240
-- Name: COLUMN catalogue_bibliography.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_bibliography.referenced_relation IS 'Identifier-Name of table the units come from';


--
-- TOC entry 5894 (class 0 OID 0)
-- Dependencies: 240
-- Name: COLUMN catalogue_bibliography.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_bibliography.record_id IS 'Identifier of record concerned in table concerned';


--
-- TOC entry 5895 (class 0 OID 0)
-- Dependencies: 240
-- Name: COLUMN catalogue_bibliography.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_bibliography.id IS 'Unique identifier of record';


--
-- TOC entry 5896 (class 0 OID 0)
-- Dependencies: 240
-- Name: COLUMN catalogue_bibliography.bibliography_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_bibliography.bibliography_ref IS 'Reference of the biblio concerned - id field of people table';


--
-- TOC entry 241 (class 1259 OID 4816561)
-- Name: catalogue_bibliography_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.catalogue_bibliography_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.catalogue_bibliography_id_seq OWNER TO darwin2;

--
-- TOC entry 5898 (class 0 OID 0)
-- Dependencies: 241
-- Name: catalogue_bibliography_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.catalogue_bibliography_id_seq OWNED BY darwin2.catalogue_bibliography.id;


--
-- TOC entry 242 (class 1259 OID 4816563)
-- Name: catalogue_levels_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.catalogue_levels_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.catalogue_levels_id_seq OWNER TO darwin2;

--
-- TOC entry 243 (class 1259 OID 4816565)
-- Name: catalogue_levels; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.catalogue_levels (
    id integer DEFAULT nextval('darwin2.catalogue_levels_id_seq'::regclass) NOT NULL,
    level_type character varying NOT NULL,
    level_name character varying NOT NULL,
    level_sys_name character varying NOT NULL,
    optional_level boolean DEFAULT false NOT NULL,
    level_order integer DEFAULT 999 NOT NULL
);


ALTER TABLE darwin2.catalogue_levels OWNER TO darwin2;

--
-- TOC entry 5899 (class 0 OID 0)
-- Dependencies: 243
-- Name: TABLE catalogue_levels; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.catalogue_levels IS 'List of hierarchical units levels - organized by type of unit: taxonomy, chroostratigraphy,...';


--
-- TOC entry 5900 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN catalogue_levels.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.id IS 'Unique identifier of a hierarchical unit level';


--
-- TOC entry 5901 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN catalogue_levels.level_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.level_type IS 'Type of unit the levels is applicable to - contained in a predifined list: taxonomy, chronostratigraphy,...';


--
-- TOC entry 5902 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN catalogue_levels.level_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.level_name IS 'Name given to level concerned';


--
-- TOC entry 5903 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN catalogue_levels.level_sys_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.level_sys_name IS 'Name given to level concerned in the system. i.e.: cohort zoology will be writen in system as cohort_zoology';


--
-- TOC entry 5904 (class 0 OID 0)
-- Dependencies: 243
-- Name: COLUMN catalogue_levels.optional_level; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_levels.optional_level IS 'Tells if the level is optional';


--
-- TOC entry 244 (class 1259 OID 4816574)
-- Name: catalogue_people_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.catalogue_people_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.catalogue_people_id_seq OWNER TO darwin2;

--
-- TOC entry 245 (class 1259 OID 4816576)
-- Name: catalogue_people; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.catalogue_people (
    id integer DEFAULT nextval('darwin2.catalogue_people_id_seq'::regclass) NOT NULL,
    people_type character varying DEFAULT 'author'::character varying NOT NULL,
    people_sub_type character varying DEFAULT ''::character varying NOT NULL,
    order_by integer DEFAULT 1 NOT NULL,
    people_ref integer NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.catalogue_people OWNER TO darwin2;

--
-- TOC entry 5906 (class 0 OID 0)
-- Dependencies: 245
-- Name: TABLE catalogue_people; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.catalogue_people IS 'List of people of catalogues units - Taxonomy, Chronostratigraphy,...';


--
-- TOC entry 5907 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN catalogue_people.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.referenced_relation IS 'Identifier-Name of table the units come from';


--
-- TOC entry 5908 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN catalogue_people.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.record_id IS 'Identifier of record concerned in table concerned';


--
-- TOC entry 5909 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN catalogue_people.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.id IS 'Unique identifier of record';


--
-- TOC entry 5910 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN catalogue_people.people_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.people_type IS 'Type of "people" associated to the catalogue unit: authors, collectors, defined,  ...';


--
-- TOC entry 5911 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN catalogue_people.people_sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.people_sub_type IS 'Type of "people" associated to the catalogue unit: Main author, corrector, taking the sense from,...';


--
-- TOC entry 5912 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN catalogue_people.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.order_by IS 'Integer used to order the persons in a list';


--
-- TOC entry 5913 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN catalogue_people.people_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_people.people_ref IS 'Reference of person concerned - id field of people table';


--
-- TOC entry 246 (class 1259 OID 4816586)
-- Name: catalogue_properties_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.catalogue_properties_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.catalogue_properties_id_seq OWNER TO darwin2;

--
-- TOC entry 247 (class 1259 OID 4816588)
-- Name: catalogue_relationships_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.catalogue_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.catalogue_relationships_id_seq OWNER TO darwin2;

--
-- TOC entry 248 (class 1259 OID 4816590)
-- Name: catalogue_relationships; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.catalogue_relationships (
    id integer DEFAULT nextval('darwin2.catalogue_relationships_id_seq'::regclass) NOT NULL,
    referenced_relation character varying NOT NULL,
    record_id_1 integer NOT NULL,
    record_id_2 integer NOT NULL,
    relationship_type character varying DEFAULT 'recombined from'::character varying NOT NULL,
    CONSTRAINT chk_not_related_to_self CHECK ((record_id_1 <> record_id_2))
);


ALTER TABLE darwin2.catalogue_relationships OWNER TO darwin2;

--
-- TOC entry 5915 (class 0 OID 0)
-- Dependencies: 248
-- Name: TABLE catalogue_relationships; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.catalogue_relationships IS 'Stores the relationships between records of a table - current name, original combination, ...';


--
-- TOC entry 5916 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN catalogue_relationships.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_relationships.referenced_relation IS 'Reference of the table a relationship is defined for';


--
-- TOC entry 5917 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN catalogue_relationships.record_id_1; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_relationships.record_id_1 IS 'Identifier of record in relation with an other one (record_id_2)';


--
-- TOC entry 5918 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN catalogue_relationships.record_id_2; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_relationships.record_id_2 IS 'Identifier of record in relation with an other one (record_id_1)';


--
-- TOC entry 5919 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN catalogue_relationships.relationship_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.catalogue_relationships.relationship_type IS 'Type of relation between record 1 and record 2 - current name, original combination, ...';


--
-- TOC entry 249 (class 1259 OID 4816599)
-- Name: chronostratigraphy_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.chronostratigraphy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.chronostratigraphy_id_seq OWNER TO darwin2;

--
-- TOC entry 250 (class 1259 OID 4816601)
-- Name: template_classifications; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_classifications (
    name character varying NOT NULL,
    name_indexed character varying,
    level_ref integer NOT NULL,
    status character varying DEFAULT 'valid'::character varying NOT NULL,
    local_naming boolean DEFAULT false NOT NULL,
    color character varying,
    path character varying DEFAULT '/'::character varying NOT NULL,
    parent_ref integer
);


ALTER TABLE darwin2.template_classifications OWNER TO darwin2;

--
-- TOC entry 5921 (class 0 OID 0)
-- Dependencies: 250
-- Name: TABLE template_classifications; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_classifications IS 'Template table used to construct every common data in each classifications tables (taxonomy, chronostratigraphy, lithostratigraphy,...)';


--
-- TOC entry 5922 (class 0 OID 0)
-- Dependencies: 250
-- Name: COLUMN template_classifications.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.name IS 'Classification unit name';


--
-- TOC entry 5923 (class 0 OID 0)
-- Dependencies: 250
-- Name: COLUMN template_classifications.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.name_indexed IS 'Indexed form of name field for ordering';


--
-- TOC entry 5924 (class 0 OID 0)
-- Dependencies: 250
-- Name: COLUMN template_classifications.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 5925 (class 0 OID 0)
-- Dependencies: 250
-- Name: COLUMN template_classifications.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 5926 (class 0 OID 0)
-- Dependencies: 250
-- Name: COLUMN template_classifications.local_naming; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.local_naming IS 'Flag telling the appelation is local or internationally recognized';


--
-- TOC entry 5927 (class 0 OID 0)
-- Dependencies: 250
-- Name: COLUMN template_classifications.color; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.color IS 'Hexadecimal value of color associated to the unit';


--
-- TOC entry 5928 (class 0 OID 0)
-- Dependencies: 250
-- Name: COLUMN template_classifications.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 5929 (class 0 OID 0)
-- Dependencies: 250
-- Name: COLUMN template_classifications.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_classifications.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 251 (class 1259 OID 4816610)
-- Name: chronostratigraphy; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.chronostratigraphy (
    id integer DEFAULT nextval('darwin2.chronostratigraphy_id_seq'::regclass) NOT NULL,
    lower_bound numeric(10,3),
    upper_bound numeric(10,3),
    CONSTRAINT fct_chk_onceinpath_chronostratigraphy CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.chronostratigraphy OWNER TO darwin2;

--
-- TOC entry 5931 (class 0 OID 0)
-- Dependencies: 251
-- Name: TABLE chronostratigraphy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.chronostratigraphy IS 'List of chronostratigraphic units';


--
-- TOC entry 5932 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN chronostratigraphy.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.name IS 'Classification unit name';


--
-- TOC entry 5933 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN chronostratigraphy.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 5934 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN chronostratigraphy.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 5935 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN chronostratigraphy.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 5936 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN chronostratigraphy.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 5937 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN chronostratigraphy.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 5938 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN chronostratigraphy.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 5939 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN chronostratigraphy.lower_bound; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.lower_bound IS 'Lower age boundary in years';


--
-- TOC entry 5940 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN chronostratigraphy.upper_bound; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.chronostratigraphy.upper_bound IS 'Upper age boundary in years';


--
-- TOC entry 252 (class 1259 OID 4816621)
-- Name: class_vernacular_names_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.class_vernacular_names_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.class_vernacular_names_id_seq OWNER TO darwin2;

--
-- TOC entry 253 (class 1259 OID 4816623)
-- Name: classification_keywords_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.classification_keywords_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.classification_keywords_id_seq OWNER TO darwin2;

--
-- TOC entry 254 (class 1259 OID 4816625)
-- Name: classification_keywords; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.classification_keywords (
    id integer DEFAULT nextval('darwin2.classification_keywords_id_seq'::regclass) NOT NULL,
    keyword_type character varying DEFAULT 'name'::character varying NOT NULL,
    keyword character varying NOT NULL,
    keyword_indexed character varying NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.classification_keywords OWNER TO darwin2;

--
-- TOC entry 5942 (class 0 OID 0)
-- Dependencies: 254
-- Name: TABLE classification_keywords; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.classification_keywords IS 'Help user to tag-label each part of full name in classifications';


--
-- TOC entry 5943 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN classification_keywords.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_keywords.referenced_relation IS 'Name of classifification table: taxonomy, lithology,...';


--
-- TOC entry 5944 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN classification_keywords.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_keywords.record_id IS 'Id of record concerned';


--
-- TOC entry 5945 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN classification_keywords.keyword_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_keywords.keyword_type IS 'Keyword type: name, year, authoritative keyword,...';


--
-- TOC entry 5946 (class 0 OID 0)
-- Dependencies: 254
-- Name: COLUMN classification_keywords.keyword; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_keywords.keyword IS 'Keyword';


--
-- TOC entry 255 (class 1259 OID 4816633)
-- Name: classification_synonymies_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.classification_synonymies_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.classification_synonymies_id_seq OWNER TO darwin2;

--
-- TOC entry 256 (class 1259 OID 4816635)
-- Name: classification_synonymies; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.classification_synonymies (
    id integer DEFAULT nextval('darwin2.classification_synonymies_id_seq'::regclass) NOT NULL,
    group_id integer NOT NULL,
    group_name character varying NOT NULL,
    is_basionym boolean DEFAULT false,
    order_by integer DEFAULT 0 NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.classification_synonymies OWNER TO darwin2;

--
-- TOC entry 5948 (class 0 OID 0)
-- Dependencies: 256
-- Name: TABLE classification_synonymies; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.classification_synonymies IS 'Table containing classification synonymies';


--
-- TOC entry 5949 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN classification_synonymies.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.referenced_relation IS 'Classification table concerned';


--
-- TOC entry 5950 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN classification_synonymies.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.record_id IS 'Id of record placed in group as a synonym';


--
-- TOC entry 5951 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN classification_synonymies.group_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.group_id IS 'Id given to group';


--
-- TOC entry 5952 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN classification_synonymies.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.group_name IS 'Name of group under which synonyms are placed';


--
-- TOC entry 5953 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN classification_synonymies.is_basionym; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.is_basionym IS 'If record is a basionym';


--
-- TOC entry 5954 (class 0 OID 0)
-- Dependencies: 256
-- Name: COLUMN classification_synonymies.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.classification_synonymies.order_by IS 'Order by used to qualify order amongst synonyms - used mainly for senio and junior synonyms';


--
-- TOC entry 257 (class 1259 OID 4816644)
-- Name: classification_synonymies_group_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.classification_synonymies_group_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.classification_synonymies_group_id_seq OWNER TO darwin2;

--
-- TOC entry 258 (class 1259 OID 4816646)
-- Name: codes_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.codes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.codes_id_seq OWNER TO darwin2;

--
-- TOC entry 259 (class 1259 OID 4816648)
-- Name: codes; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.codes (
    id integer DEFAULT nextval('darwin2.codes_id_seq'::regclass) NOT NULL,
    code_category character varying DEFAULT 'main'::character varying NOT NULL,
    code_prefix character varying,
    code_prefix_separator character varying,
    code character varying,
    code_suffix character varying,
    code_suffix_separator character varying,
    full_code_indexed character varying NOT NULL,
    code_date timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone NOT NULL,
    code_date_mask integer DEFAULT 0 NOT NULL,
    code_num bigint DEFAULT 0
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.codes OWNER TO darwin2;

--
-- TOC entry 5956 (class 0 OID 0)
-- Dependencies: 259
-- Name: TABLE codes; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.codes IS 'Template used to construct the specimen codes tables';


--
-- TOC entry 5957 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.referenced_relation IS 'Reference name of table concerned';


--
-- TOC entry 5958 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.record_id IS 'Identifier of record concerned';


--
-- TOC entry 5959 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.id IS 'Unique identifier of a code';


--
-- TOC entry 5960 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.code_category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_category IS 'Category of code: main, secondary, temporary,...';


--
-- TOC entry 5961 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.code_prefix; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_prefix IS 'Code prefix - entire code if all alpha, begining character part if code is made of characters and numeric parts';


--
-- TOC entry 5962 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.code_prefix_separator; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_prefix_separator IS 'Separtor used between code core and code prefix';


--
-- TOC entry 5963 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code IS 'Numerical part of code - but not forced: if users want to use it as alphanumerical code - possible too';


--
-- TOC entry 5964 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.code_suffix; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_suffix IS 'For codes made of characters and numerical parts, this field stores the last alpha part of code';


--
-- TOC entry 5965 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.code_suffix_separator; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_suffix_separator IS 'Separtor used between code core and code suffix';


--
-- TOC entry 5966 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.full_code_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.full_code_indexed IS 'Full code composition by code_prefix, code and code suffix concatenation and indexed for unique check purpose';


--
-- TOC entry 5967 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.code_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_date IS 'Date of code creation (fuzzy date)';


--
-- TOC entry 5968 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN codes.code_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.codes.code_date_mask IS 'Mask used for code date';


--
-- TOC entry 260 (class 1259 OID 4816659)
-- Name: collecting_methods_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collecting_methods_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collecting_methods_id_seq OWNER TO darwin2;

--
-- TOC entry 261 (class 1259 OID 4816661)
-- Name: collecting_methods; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collecting_methods (
    id integer DEFAULT nextval('darwin2.collecting_methods_id_seq'::regclass) NOT NULL,
    method character varying NOT NULL,
    method_indexed character varying NOT NULL,
    CONSTRAINT chk_collecting_methods_method CHECK (((method)::text <> ''::text))
);


ALTER TABLE darwin2.collecting_methods OWNER TO darwin2;

--
-- TOC entry 5970 (class 0 OID 0)
-- Dependencies: 261
-- Name: TABLE collecting_methods; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collecting_methods IS 'List of all available collecting methods';


--
-- TOC entry 5971 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN collecting_methods.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_methods.id IS 'Unique identifier of a collecting method';


--
-- TOC entry 5972 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN collecting_methods.method; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_methods.method IS 'Method used';


--
-- TOC entry 5973 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN collecting_methods.method_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_methods.method_indexed IS 'Indexed form of method used - for ordering and filtering purposes';


--
-- TOC entry 262 (class 1259 OID 4816669)
-- Name: collecting_tools_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collecting_tools_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collecting_tools_id_seq OWNER TO darwin2;

--
-- TOC entry 263 (class 1259 OID 4816671)
-- Name: collecting_tools; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collecting_tools (
    id integer DEFAULT nextval('darwin2.collecting_tools_id_seq'::regclass) NOT NULL,
    tool character varying NOT NULL,
    tool_indexed character varying NOT NULL,
    CONSTRAINT chk_collecting_tools_tool CHECK (((tool)::text <> ''::text))
);


ALTER TABLE darwin2.collecting_tools OWNER TO darwin2;

--
-- TOC entry 5975 (class 0 OID 0)
-- Dependencies: 263
-- Name: TABLE collecting_tools; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collecting_tools IS 'List of all available collecting tools';


--
-- TOC entry 5976 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN collecting_tools.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_tools.id IS 'Unique identifier of a collecting tool';


--
-- TOC entry 5977 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN collecting_tools.tool; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_tools.tool IS 'Tool used';


--
-- TOC entry 5978 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN collecting_tools.tool_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collecting_tools.tool_indexed IS 'Indexed form of tool used - for ordering and filtering purposes';


--
-- TOC entry 264 (class 1259 OID 4816679)
-- Name: collection_maintenance_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collection_maintenance_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collection_maintenance_id_seq OWNER TO darwin2;

--
-- TOC entry 265 (class 1259 OID 4816681)
-- Name: collection_maintenance; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collection_maintenance (
    id integer DEFAULT nextval('darwin2.collection_maintenance_id_seq'::regclass) NOT NULL,
    people_ref integer,
    category character varying DEFAULT 'action'::character varying NOT NULL,
    action_observation character varying NOT NULL,
    description character varying,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    modification_date_mask integer DEFAULT 0 NOT NULL,
    description_indexed text
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.collection_maintenance OWNER TO darwin2;

--
-- TOC entry 5980 (class 0 OID 0)
-- Dependencies: 265
-- Name: TABLE collection_maintenance; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collection_maintenance IS 'History of specimen maintenance';


--
-- TOC entry 5981 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN collection_maintenance.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.referenced_relation IS 'Reference of table a maintenance entry has been created for';


--
-- TOC entry 5982 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN collection_maintenance.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.record_id IS 'ID of record a maintenance entry has been created for';


--
-- TOC entry 5983 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN collection_maintenance.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.id IS 'Unique identifier of a specimen maintenance';


--
-- TOC entry 5984 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN collection_maintenance.people_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.people_ref IS 'Reference of person having done an action or an observation';


--
-- TOC entry 5985 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN collection_maintenance.category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.category IS 'Action or Observation';


--
-- TOC entry 5986 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN collection_maintenance.action_observation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.action_observation IS 'Action or observation done';


--
-- TOC entry 5987 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN collection_maintenance.description; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.description IS 'Complementary description';


--
-- TOC entry 5988 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN collection_maintenance.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.modification_date_time IS 'Last update date/time';


--
-- TOC entry 5989 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN collection_maintenance.description_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collection_maintenance.description_indexed IS 'indexed form of description field';


--
-- TOC entry 266 (class 1259 OID 4816691)
-- Name: collections_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collections_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collections_id_seq OWNER TO darwin2;

--
-- TOC entry 267 (class 1259 OID 4816693)
-- Name: collections; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collections (
    id integer DEFAULT nextval('darwin2.collections_id_seq'::regclass) NOT NULL,
    collection_type character varying DEFAULT 'mix'::character varying NOT NULL,
    code character varying NOT NULL,
    name character varying NOT NULL,
    name_indexed character varying NOT NULL,
    institution_ref integer NOT NULL,
    main_manager_ref integer NOT NULL,
    parent_ref integer,
    path character varying NOT NULL,
    code_auto_increment boolean DEFAULT false NOT NULL,
    code_last_value bigint DEFAULT 0 NOT NULL,
    code_prefix character varying,
    code_prefix_separator character varying,
    code_suffix character varying,
    code_suffix_separator character varying,
    is_public boolean DEFAULT true NOT NULL,
    code_specimen_duplicate boolean DEFAULT false NOT NULL,
    staff_ref integer,
    code_auto_increment_for_insert_only boolean DEFAULT true NOT NULL,
    code_mask character varying,
    allow_duplicates boolean DEFAULT false,
    publish_to_gbif boolean,
    profile text[],
    title_en text,
    title_nl text,
    title_fr text,
    CONSTRAINT chk_main_manager_ref CHECK ((main_manager_ref > 0)),
    CONSTRAINT fct_chk_onceinpath_collections CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
);


ALTER TABLE darwin2.collections OWNER TO darwin2;

--
-- TOC entry 5991 (class 0 OID 0)
-- Dependencies: 267
-- Name: TABLE collections; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collections IS 'List of all collections encoded in DaRWIN 2';


--
-- TOC entry 5992 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.id IS 'Unique identifier of a collection';


--
-- TOC entry 5993 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.collection_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.collection_type IS 'Type of collection: physical for a collection of only physical objects, observations for a collection of only observations, mix for any kind of entry catalogued in collection';


--
-- TOC entry 5994 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code IS 'Code given to collection';


--
-- TOC entry 5995 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.name IS 'Collection name';


--
-- TOC entry 5996 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.name_indexed IS 'Collection name indexed';


--
-- TOC entry 5997 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.institution_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.institution_ref IS 'Reference of institution current collection belongs to - id field of people table';


--
-- TOC entry 5998 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.main_manager_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.main_manager_ref IS 'Reference of collection main manager - id field of users table';


--
-- TOC entry 5999 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.parent_ref IS 'Recursive reference to collection table itself to represent collection parenty/hierarchy';


--
-- TOC entry 6000 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.path IS 'Descriptive path for collection hierarchy, each level separated by a /';


--
-- TOC entry 6001 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code_auto_increment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_auto_increment IS 'Flag telling if the numerical part of a code has to be incremented or not';


--
-- TOC entry 6002 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code_last_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_last_value IS 'Value of the last numeric code given in this collection when auto increment is/was activated';


--
-- TOC entry 6003 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code_prefix; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_prefix IS 'Default code prefix to be used for specimens encoded in this collection';


--
-- TOC entry 6004 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code_prefix_separator; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_prefix_separator IS 'Character chain used to separate code prefix from code core';


--
-- TOC entry 6005 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code_suffix; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_suffix IS 'Default code suffix to be used for specimens encoded in this collection';


--
-- TOC entry 6006 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code_suffix_separator; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_suffix_separator IS 'Character chain used to separate code suffix from code core';


--
-- TOC entry 6007 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.is_public; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.is_public IS 'Flag telling if the collection can be found in the public search';


--
-- TOC entry 6008 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code_specimen_duplicate; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_specimen_duplicate IS 'Flag telling if the whole specimen code has to be copied when you do a duplicate';


--
-- TOC entry 6009 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.staff_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.staff_ref IS 'Reference of staff member, scientist responsible - id field of users table';


--
-- TOC entry 6010 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code_auto_increment_for_insert_only; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_auto_increment_for_insert_only IS 'Flag telling if the autoincremented code insertion has to be done only after insertion of specimens or also after updates of specimens';


--
-- TOC entry 6011 (class 0 OID 0)
-- Dependencies: 267
-- Name: COLUMN collections.code_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections.code_mask IS 'A mask that should be applied to help encode following a specific structured way';


--
-- TOC entry 268 (class 1259 OID 4816709)
-- Name: collections_rights_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.collections_rights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.collections_rights_id_seq OWNER TO darwin2;

--
-- TOC entry 269 (class 1259 OID 4816711)
-- Name: collections_rights; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.collections_rights (
    collection_ref integer DEFAULT 0 NOT NULL,
    user_ref integer DEFAULT 0 NOT NULL,
    id integer DEFAULT nextval('darwin2.collections_rights_id_seq'::regclass) NOT NULL,
    db_user_type smallint DEFAULT 1 NOT NULL
);


ALTER TABLE darwin2.collections_rights OWNER TO darwin2;

--
-- TOC entry 6013 (class 0 OID 0)
-- Dependencies: 269
-- Name: TABLE collections_rights; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.collections_rights IS 'List of rights of given users on given collections';


--
-- TOC entry 6014 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN collections_rights.collection_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections_rights.collection_ref IS 'Reference of collection concerned - id field of collections table';


--
-- TOC entry 6015 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN collections_rights.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections_rights.user_ref IS 'Reference of user - id field of users table';


--
-- TOC entry 6016 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN collections_rights.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections_rights.id IS 'Unique identifier for collection rights';


--
-- TOC entry 6017 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN collections_rights.db_user_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.collections_rights.db_user_type IS 'Integer is representing a role: 1 for registered user, 2 for encoder, 4 for collection manager, 8 for system admin,...';


--
-- TOC entry 270 (class 1259 OID 4816718)
-- Name: comments_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.comments_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.comments_id_seq OWNER TO darwin2;

--
-- TOC entry 271 (class 1259 OID 4816720)
-- Name: comments; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.comments (
    id integer DEFAULT nextval('darwin2.comments_id_seq'::regclass) NOT NULL,
    notion_concerned character varying NOT NULL,
    comment text NOT NULL,
    comment_indexed text NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.comments OWNER TO darwin2;

--
-- TOC entry 6019 (class 0 OID 0)
-- Dependencies: 271
-- Name: TABLE comments; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.comments IS 'Comments associated to a record of a given table (and maybe a given field) on a given subject';


--
-- TOC entry 6020 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN comments.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.referenced_relation IS 'Reference-Name of table a comment is posted for';


--
-- TOC entry 6021 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN comments.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.record_id IS 'Identifier of the record concerned';


--
-- TOC entry 6022 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN comments.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.id IS 'Unique identifier of a comment';


--
-- TOC entry 6023 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN comments.notion_concerned; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.notion_concerned IS 'Notion concerned by comment';


--
-- TOC entry 6024 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN comments.comment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.comment IS 'Comment';


--
-- TOC entry 6025 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN comments.comment_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.comments.comment_indexed IS 'indexed form of comment field';


--
-- TOC entry 272 (class 1259 OID 4816727)
-- Name: darwin_flat_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.darwin_flat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.darwin_flat_id_seq OWNER TO darwin2;

--
-- TOC entry 273 (class 1259 OID 4816729)
-- Name: db_version; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.db_version (
    id integer NOT NULL,
    update_at timestamp without time zone DEFAULT now()
);


ALTER TABLE darwin2.db_version OWNER TO darwin2;

--
-- TOC entry 6027 (class 0 OID 0)
-- Dependencies: 273
-- Name: TABLE db_version; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.db_version IS 'Table holding the database version and update date';


--
-- TOC entry 274 (class 1259 OID 4816733)
-- Name: properties; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.properties (
    id integer NOT NULL,
    property_type character varying NOT NULL,
    applies_to character varying DEFAULT ''::character varying NOT NULL,
    applies_to_indexed character varying NOT NULL,
    date_from_mask integer DEFAULT 0 NOT NULL,
    date_from timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone NOT NULL,
    date_to_mask integer DEFAULT 0 NOT NULL,
    date_to timestamp without time zone DEFAULT '2038-12-31 00:00:00'::timestamp without time zone NOT NULL,
    is_quantitative boolean DEFAULT false NOT NULL,
    property_unit character varying DEFAULT ''::character varying NOT NULL,
    method character varying,
    method_indexed character varying NOT NULL,
    lower_value character varying NOT NULL,
    lower_value_unified double precision,
    upper_value character varying NOT NULL,
    upper_value_unified double precision,
    property_accuracy character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.properties OWNER TO darwin2;

--
-- TOC entry 6028 (class 0 OID 0)
-- Dependencies: 274
-- Name: TABLE properties; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.properties IS 'All properties or all measurements describing an object in darwin are stored in this table';


--
-- TOC entry 6029 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.referenced_relation IS 'Identifier-Name of the table a property is defined for';


--
-- TOC entry 6030 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.record_id IS 'Identifier of record a property is defined for';


--
-- TOC entry 6031 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.property_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.property_type IS 'Type-Category of property - Latitude, Longitude, Ph, Height, Weight, Color, Temperature, Wind direction,...';


--
-- TOC entry 6032 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.applies_to; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.applies_to IS 'Depending on the use of the type, this can further specify the actual part measured. For example, a measurement of temperature may be a surface, air or sub-surface measurement.';


--
-- TOC entry 6033 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.applies_to_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.applies_to_indexed IS 'Indexed form of Sub type of property - if subtype is null, takes a generic replacement value';


--
-- TOC entry 6034 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.date_from_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.date_from_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6035 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.date_from; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.date_from IS 'For a range of measurements, give the measurement start - if null, takes a generic replacement value';


--
-- TOC entry 6036 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.date_to_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.date_to_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6037 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.date_to; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.date_to IS 'For a range of measurements, give the measurement stop date/time - if null, takes a generic replacement value';


--
-- TOC entry 6038 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.property_unit; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.property_unit IS 'Unit used for property value introduced';


--
-- TOC entry 6039 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.method; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.method IS 'Method used to collect property value';


--
-- TOC entry 6040 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.method_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.method_indexed IS 'Indexed version of property_method field - if null, takes a generic replacement value';


--
-- TOC entry 6041 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.lower_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.lower_value IS 'Lower value of Single Value';


--
-- TOC entry 6042 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.lower_value_unified; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.lower_value_unified IS 'unified version of the value for comparison with other units';


--
-- TOC entry 6043 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.upper_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.upper_value IS 'upper value if in bound';


--
-- TOC entry 6044 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.upper_value_unified; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.upper_value_unified IS 'unified version of the value for comparison with other units';


--
-- TOC entry 6045 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN properties.property_accuracy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.properties.property_accuracy IS 'Accuracy of the values';


--
-- TOC entry 275 (class 1259 OID 4816747)
-- Name: doctrine_gtu_comments; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.doctrine_gtu_comments AS
 SELECT c.record_id AS id,
    c.record_id,
    string_agg(btrim((((COALESCE(c.notion_concerned, ''::character varying))::text || ' : '::text) || COALESCE(c.comment))), '|'::text ORDER BY c.id) AS comments
   FROM darwin2.comments c
  WHERE ((c.referenced_relation)::text = 'gtu'::text)
  GROUP BY c.record_id
UNION
 SELECT DISTINCT properties.record_id AS id,
    properties.record_id,
    string_agg(btrim((((COALESCE((((properties.property_type)::text || COALESCE((' - '::text || (properties.applies_to)::text), ''::text)) || ' : '::text), ''::text) || (COALESCE(properties.lower_value, ''::character varying))::text) || COALESCE(('-'::text || (properties.upper_value)::text), ''::text)) || COALESCE((' '::text || (properties.property_unit)::text), ''::text))), '|'::text ORDER BY properties.id) AS comments
   FROM darwin2.properties
  WHERE ((properties.referenced_relation)::text = 'gtu'::text)
  GROUP BY properties.record_id;


ALTER TABLE darwin2.doctrine_gtu_comments OWNER TO darwin2;

--
-- TOC entry 276 (class 1259 OID 4816752)
-- Name: identifications_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.identifications_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.identifications_id_seq OWNER TO darwin2;

--
-- TOC entry 277 (class 1259 OID 4816754)
-- Name: identifications; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.identifications (
    id integer DEFAULT nextval('darwin2.identifications_id_seq'::regclass) NOT NULL,
    notion_concerned character varying NOT NULL,
    notion_date timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone NOT NULL,
    notion_date_mask integer DEFAULT 0 NOT NULL,
    value_defined character varying,
    value_defined_indexed character varying NOT NULL,
    determination_status character varying,
    order_by integer DEFAULT 1 NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.identifications OWNER TO darwin2;

--
-- TOC entry 6047 (class 0 OID 0)
-- Dependencies: 277
-- Name: TABLE identifications; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.identifications IS 'History of identifications';


--
-- TOC entry 6048 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.referenced_relation IS 'Reference of table an identification is introduced for';


--
-- TOC entry 6049 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.record_id IS 'Id of record concerned by an identification entry';


--
-- TOC entry 6050 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.id IS 'Unique identifier of an identification';


--
-- TOC entry 6051 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.notion_concerned; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.notion_concerned IS 'Type of entry: Identification on a specific concern';


--
-- TOC entry 6052 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.notion_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.notion_date IS 'Date of identification or preparation';


--
-- TOC entry 6053 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.notion_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.notion_date_mask IS 'Date/Time mask used for identification date fuzzyness';


--
-- TOC entry 6054 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.value_defined; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.value_defined IS 'When making identification, stores the value resulting of this identification';


--
-- TOC entry 6055 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.value_defined_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.value_defined_indexed IS 'Indexed form of value_defined field';


--
-- TOC entry 6056 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.determination_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.determination_status IS 'Status of identification - can either be a percentage of certainty or a code describing the identification step in the process';


--
-- TOC entry 6057 (class 0 OID 0)
-- Dependencies: 277
-- Name: COLUMN identifications.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.identifications.order_by IS 'Integer used to order the identifications when no date entered';


--
-- TOC entry 278 (class 1259 OID 4816764)
-- Name: doctrine_taxonomic_identifications; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.doctrine_taxonomic_identifications AS
 SELECT i.record_id AS id,
    i.record_id,
    string_agg(btrim((((COALESCE(i.value_defined, ''::character varying))::text || ' '::text) || COALESCE(darwin2.fct_mask_date(i.notion_date, i.notion_date_mask), ''::text))), '|'::text ORDER BY i.notion_date DESC) AS taxonomic_identification
   FROM darwin2.identifications i
  WHERE ((i.referenced_relation)::text = 'specimens'::text)
  GROUP BY i.record_id;


ALTER TABLE darwin2.doctrine_taxonomic_identifications OWNER TO darwin2;

--
-- TOC entry 285 (class 1259 OID 4816801)
-- Name: gtu_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.gtu_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.gtu_id_seq OWNER TO darwin2;

--
-- TOC entry 286 (class 1259 OID 4816803)
-- Name: gtu; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.gtu (
    id integer DEFAULT nextval('darwin2.gtu_id_seq'::regclass) NOT NULL,
    code character varying DEFAULT ''::character varying NOT NULL,
    gtu_from_date_mask integer DEFAULT 0 NOT NULL,
    gtu_from_date timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone NOT NULL,
    gtu_to_date_mask integer DEFAULT 0 NOT NULL,
    gtu_to_date timestamp without time zone DEFAULT '2038-12-31 00:00:00'::timestamp without time zone NOT NULL,
    tag_values_indexed character varying[],
    latitude double precision,
    longitude double precision,
    lat_long_accuracy double precision,
    elevation double precision,
    elevation_accuracy double precision,
    location point,
    gtu_creation_date timestamp without time zone DEFAULT now(),
    import_ref integer,
    collector_refs integer[],
    expedition_refs integer[],
    collection_ref integer,
    latitude_dms_degree integer,
    latitude_dms_minutes double precision,
    latitude_dms_seconds double precision,
    latitude_dms_direction integer,
    longitude_dms_degree integer,
    longitude_dms_minutes double precision,
    longitude_dms_seconds double precision,
    longitude_dms_direction integer,
    latitude_utm double precision,
    longitude_utm double precision,
    utm_zone character varying,
    coordinates_source character varying
);


ALTER TABLE darwin2.gtu OWNER TO darwin2;

--
-- TOC entry 6059 (class 0 OID 0)
-- Dependencies: 286
-- Name: TABLE gtu; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.gtu IS 'Location or sampling units - GeoTemporalUnits';


--
-- TOC entry 6060 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.id IS 'Unique identifier of a location or sampling unit';


--
-- TOC entry 6061 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.code IS 'Code given - for sampling units - takes id if none defined';


--
-- TOC entry 6062 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.gtu_from_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.gtu_from_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6063 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.gtu_from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.gtu_from_date IS 'composed from date of the GTU';


--
-- TOC entry 6064 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.gtu_to_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.gtu_to_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6065 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.gtu_to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.gtu_to_date IS 'composed to date of the GTU';


--
-- TOC entry 6066 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.tag_values_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.tag_values_indexed IS 'Array of all tags associated to gtu (indexed form)';


--
-- TOC entry 6067 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.latitude; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.latitude IS 'Latitude of the gtu';


--
-- TOC entry 6068 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.longitude; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.longitude IS 'longitude of the gtu';


--
-- TOC entry 6069 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.lat_long_accuracy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.lat_long_accuracy IS 'Accuracy in meter of both lat & long';


--
-- TOC entry 6070 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.elevation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.elevation IS 'Elevation from the level of the sea in meter';


--
-- TOC entry 6071 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN gtu.elevation_accuracy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.gtu.elevation_accuracy IS 'Accuracy in meter of the elevation';


--
-- TOC entry 427 (class 1259 OID 5304935)
-- Name: temporal_information; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.temporal_information (
    id integer NOT NULL,
    gtu_ref integer,
    specimen_ref integer,
    from_date_mask integer DEFAULT 0 NOT NULL,
    from_date timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone NOT NULL,
    to_date_mask integer DEFAULT 0 NOT NULL,
    to_date timestamp without time zone DEFAULT '2038-12-31 00:00:00'::timestamp without time zone NOT NULL
);


ALTER TABLE darwin2.temporal_information OWNER TO darwin2;

--
-- TOC entry 6073 (class 0 OID 0)
-- Dependencies: 427
-- Name: COLUMN temporal_information.from_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.temporal_information.from_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6074 (class 0 OID 0)
-- Dependencies: 427
-- Name: COLUMN temporal_information.from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.temporal_information.from_date IS 'composed from date of the GTU';


--
-- TOC entry 6075 (class 0 OID 0)
-- Dependencies: 427
-- Name: COLUMN temporal_information.to_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.temporal_information.to_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6076 (class 0 OID 0)
-- Dependencies: 427
-- Name: COLUMN temporal_information.to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.temporal_information.to_date IS 'composed to date of the GTU';


--
-- TOC entry 430 (class 1259 OID 5307583)
-- Name: doctrine_temporal_information_gtu_group; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.doctrine_temporal_information_gtu_group AS
 SELECT DISTINCT gtu.id,
    gtu.code,
    gtu.gtu_from_date_mask,
    gtu.gtu_from_date,
    gtu.gtu_to_date_mask,
    gtu.gtu_to_date,
    gtu.tag_values_indexed,
    gtu.latitude,
    gtu.longitude,
    gtu.lat_long_accuracy,
    gtu.elevation,
    gtu.elevation_accuracy,
    (gtu.location)::character varying AS location,
    gtu.gtu_creation_date,
    gtu.import_ref,
    gtu.collector_refs,
    gtu.expedition_refs,
    gtu.collection_ref,
    gtu.latitude_dms_degree,
    gtu.latitude_dms_minutes,
    gtu.latitude_dms_seconds,
    gtu.latitude_dms_direction,
    gtu.longitude_dms_degree,
    gtu.longitude_dms_minutes,
    gtu.longitude_dms_seconds,
    gtu.longitude_dms_direction,
    gtu.latitude_utm,
    gtu.longitude_utm,
    gtu.utm_zone,
    gtu.coordinates_source,
    array_agg(temporal_information.from_date_mask ORDER BY temporal_information.from_date DESC) AS array_from_date_mask,
    array_agg(temporal_information.from_date ORDER BY temporal_information.from_date DESC) AS array_from_date,
    array_agg(temporal_information.to_date_mask ORDER BY temporal_information.from_date DESC) AS array_to_date_mask,
    array_agg(temporal_information.to_date ORDER BY temporal_information.from_date DESC) AS array_to_date,
    string_agg(DISTINCT btrim((((COALESCE(c.notion_concerned, ''::character varying))::text || ' : '::text) || COALESCE(c.comment))), '|'::text ORDER BY (btrim((((COALESCE(c.notion_concerned, ''::character varying))::text || ' : '::text) || COALESCE(c.comment)))), '|'::text) AS comments,
    string_agg(DISTINCT btrim((((COALESCE((((properties.property_type)::text || COALESCE((' - '::text || (properties.applies_to)::text), ''::text)) || ' : '::text), ''::text) || (COALESCE(properties.lower_value, ''::character varying))::text) || COALESCE(('-'::text || (properties.upper_value)::text), ''::text)) || COALESCE((' '::text || (properties.property_unit)::text), ''::text))), '|'::text ORDER BY (btrim((((COALESCE((((properties.property_type)::text || COALESCE((' - '::text || (properties.applies_to)::text), ''::text)) || ' : '::text), ''::text) || (COALESCE(properties.lower_value, ''::character varying))::text) || COALESCE(('-'::text || (properties.upper_value)::text), ''::text)) || COALESCE((' '::text || (properties.property_unit)::text), ''::text)))), '|'::text) AS properties
   FROM (((darwin2.gtu
     LEFT JOIN darwin2.temporal_information ON ((gtu.id = temporal_information.gtu_ref)))
     LEFT JOIN darwin2.comments c ON (((gtu.id = c.record_id) AND ((c.referenced_relation)::text = 'gtu'::text))))
     LEFT JOIN darwin2.properties ON (((gtu.id = properties.id) AND ((properties.referenced_relation)::text = 'gtu'::text))))
  GROUP BY gtu.id, gtu.code, gtu.gtu_from_date_mask, gtu.gtu_from_date, gtu.gtu_to_date_mask, gtu.gtu_to_date, gtu.tag_values_indexed, gtu.latitude, gtu.longitude, gtu.lat_long_accuracy, gtu.elevation, gtu.elevation_accuracy, (gtu.location)::character varying, gtu.gtu_creation_date, gtu.import_ref, gtu.collector_refs, gtu.expedition_refs, gtu.collection_ref, gtu.latitude_dms_degree, gtu.latitude_dms_minutes, gtu.latitude_dms_seconds, gtu.latitude_dms_direction, gtu.longitude_dms_degree, gtu.longitude_dms_minutes, gtu.longitude_dms_seconds, gtu.longitude_dms_direction, gtu.latitude_utm, gtu.longitude_utm, gtu.utm_zone, gtu.coordinates_source;


ALTER TABLE darwin2.doctrine_temporal_information_gtu_group OWNER TO darwin2;

--
-- TOC entry 279 (class 1259 OID 4816768)
-- Name: expeditions_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.expeditions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.expeditions_id_seq OWNER TO darwin2;

--
-- TOC entry 280 (class 1259 OID 4816770)
-- Name: expeditions; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.expeditions (
    id integer DEFAULT nextval('darwin2.expeditions_id_seq'::regclass) NOT NULL,
    name character varying NOT NULL,
    name_indexed character varying NOT NULL,
    expedition_from_date_mask integer DEFAULT 0 NOT NULL,
    expedition_from_date date DEFAULT '0001-01-01'::date NOT NULL,
    expedition_to_date_mask integer DEFAULT 0 NOT NULL,
    expedition_to_date date DEFAULT '2038-12-31'::date NOT NULL
);


ALTER TABLE darwin2.expeditions OWNER TO darwin2;

--
-- TOC entry 6078 (class 0 OID 0)
-- Dependencies: 280
-- Name: TABLE expeditions; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.expeditions IS 'List of expeditions made to collect specimens';


--
-- TOC entry 6079 (class 0 OID 0)
-- Dependencies: 280
-- Name: COLUMN expeditions.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.id IS 'Unique identifier of an expedition';


--
-- TOC entry 6080 (class 0 OID 0)
-- Dependencies: 280
-- Name: COLUMN expeditions.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.name IS 'Expedition name';


--
-- TOC entry 6081 (class 0 OID 0)
-- Dependencies: 280
-- Name: COLUMN expeditions.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.name_indexed IS 'Indexed form of expedition name';


--
-- TOC entry 6082 (class 0 OID 0)
-- Dependencies: 280
-- Name: COLUMN expeditions.expedition_from_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.expedition_from_date_mask IS 'Contains the Mask flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6083 (class 0 OID 0)
-- Dependencies: 280
-- Name: COLUMN expeditions.expedition_from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.expedition_from_date IS 'Start date of the expedition';


--
-- TOC entry 6084 (class 0 OID 0)
-- Dependencies: 280
-- Name: COLUMN expeditions.expedition_to_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.expedition_to_date_mask IS 'Contains the Mask flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6085 (class 0 OID 0)
-- Dependencies: 280
-- Name: COLUMN expeditions.expedition_to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.expeditions.expedition_to_date IS 'End date of the expedition';


--
-- TOC entry 281 (class 1259 OID 4816781)
-- Name: ext_links_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.ext_links_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.ext_links_id_seq OWNER TO darwin2;

--
-- TOC entry 282 (class 1259 OID 4816783)
-- Name: ext_links; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.ext_links (
    id integer DEFAULT nextval('darwin2.ext_links_id_seq'::regclass) NOT NULL,
    url character varying NOT NULL,
    comment text NOT NULL,
    comment_indexed text NOT NULL,
    type text DEFAULT 'ext'::text NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.ext_links OWNER TO darwin2;

--
-- TOC entry 6087 (class 0 OID 0)
-- Dependencies: 282
-- Name: TABLE ext_links; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.ext_links IS 'External link possibly refereced for a specific relation';


--
-- TOC entry 6088 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN ext_links.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.referenced_relation IS 'Reference-Name of table a comment is posted for';


--
-- TOC entry 6089 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN ext_links.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.record_id IS 'Identifier of the record concerned';


--
-- TOC entry 6090 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN ext_links.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.id IS 'Unique identifier of a comment';


--
-- TOC entry 6091 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN ext_links.url; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.url IS 'External URL';


--
-- TOC entry 6092 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN ext_links.comment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.comment IS 'Comment';


--
-- TOC entry 6093 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN ext_links.comment_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.comment_indexed IS 'indexed form of comment field';


--
-- TOC entry 6094 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN ext_links.type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.ext_links.type IS 'Sort of external link given';


--
-- TOC entry 283 (class 1259 OID 4816791)
-- Name: flat_dict_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.flat_dict_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.flat_dict_id_seq OWNER TO darwin2;

--
-- TOC entry 284 (class 1259 OID 4816793)
-- Name: flat_dict; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.flat_dict (
    id integer DEFAULT nextval('darwin2.flat_dict_id_seq'::regclass) NOT NULL,
    referenced_relation character varying NOT NULL,
    dict_field character varying NOT NULL,
    dict_value character varying NOT NULL,
    dict_depend character varying DEFAULT ''::character varying NOT NULL
);


ALTER TABLE darwin2.flat_dict OWNER TO darwin2;

--
-- TOC entry 6096 (class 0 OID 0)
-- Dependencies: 284
-- Name: TABLE flat_dict; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.flat_dict IS 'Flat table compiling all small distinct values for a faster search like types, code prefixes ,...';


--
-- TOC entry 6097 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN flat_dict.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.flat_dict.referenced_relation IS 'The table where the value come from';


--
-- TOC entry 6098 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN flat_dict.dict_field; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.flat_dict.dict_field IS 'the field name of where the value come from';


--
-- TOC entry 6099 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN flat_dict.dict_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.flat_dict.dict_value IS 'the distinct value';


--
-- TOC entry 287 (class 1259 OID 4816816)
-- Name: gtu_analyse_normalisation_20181127; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.gtu_analyse_normalisation_20181127 (
    formated_name character varying,
    id integer,
    gtu_id integer[]
);


ALTER TABLE darwin2.gtu_analyse_normalisation_20181127 OWNER TO darwin2;

--
-- TOC entry 288 (class 1259 OID 4816822)
-- Name: gtu_bck20181123; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.gtu_bck20181123 (
    id integer NOT NULL,
    code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    tag_values_indexed character varying[],
    latitude double precision,
    longitude double precision,
    lat_long_accuracy double precision,
    elevation double precision,
    elevation_accuracy double precision,
    location point,
    gtu_creation_date timestamp without time zone,
    import_ref integer,
    collector_refs integer[],
    expedition_refs integer[],
    collection_ref integer,
    latitude_dms_degree integer,
    latitude_dms_minutes double precision,
    latitude_dms_seconds double precision,
    latitude_dms_direction integer,
    longitude_dms_degree integer,
    longitude_dms_minutes double precision,
    longitude_dms_seconds double precision,
    longitude_dms_direction integer,
    latitude_utm double precision,
    longitude_utm double precision,
    utm_zone character varying,
    coordinates_source character varying
);


ALTER TABLE darwin2.gtu_bck20181123 OWNER TO darwin2;

--
-- TOC entry 289 (class 1259 OID 4816828)
-- Name: gtu_bck20181130; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.gtu_bck20181130 (
    id integer,
    code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    tag_values_indexed character varying[],
    latitude double precision,
    longitude double precision,
    lat_long_accuracy double precision,
    elevation double precision,
    elevation_accuracy double precision,
    location point,
    gtu_creation_date timestamp without time zone,
    import_ref integer,
    collector_refs integer[],
    expedition_refs integer[],
    collection_ref integer,
    latitude_dms_degree integer,
    latitude_dms_minutes double precision,
    latitude_dms_seconds double precision,
    latitude_dms_direction integer,
    longitude_dms_degree integer,
    longitude_dms_minutes double precision,
    longitude_dms_seconds double precision,
    longitude_dms_direction integer,
    latitude_utm double precision,
    longitude_utm double precision,
    utm_zone character varying,
    coordinates_source character varying
);


ALTER TABLE darwin2.gtu_bck20181130 OWNER TO darwin2;

--
-- TOC entry 429 (class 1259 OID 5305093)
-- Name: gtu_bck20181213; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.gtu_bck20181213 (
    id integer,
    code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    tag_values_indexed character varying[],
    latitude double precision,
    longitude double precision,
    lat_long_accuracy double precision,
    elevation double precision,
    elevation_accuracy double precision,
    location point,
    gtu_creation_date timestamp without time zone,
    import_ref integer,
    collector_refs integer[],
    expedition_refs integer[],
    collection_ref integer,
    latitude_dms_degree integer,
    latitude_dms_minutes double precision,
    latitude_dms_seconds double precision,
    latitude_dms_direction integer,
    longitude_dms_degree integer,
    longitude_dms_minutes double precision,
    longitude_dms_seconds double precision,
    longitude_dms_direction integer,
    latitude_utm double precision,
    longitude_utm double precision,
    utm_zone character varying,
    coordinates_source character varying
);


ALTER TABLE darwin2.gtu_bck20181213 OWNER TO darwin2;

--
-- TOC entry 290 (class 1259 OID 4816834)
-- Name: igs_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.igs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.igs_id_seq OWNER TO darwin2;

--
-- TOC entry 291 (class 1259 OID 4816836)
-- Name: igs; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.igs (
    id integer DEFAULT nextval('darwin2.igs_id_seq'::regclass) NOT NULL,
    ig_num character varying NOT NULL,
    ig_num_indexed character varying NOT NULL,
    ig_date_mask integer DEFAULT 0 NOT NULL,
    ig_date date DEFAULT '0001-01-01'::date NOT NULL
);


ALTER TABLE darwin2.igs OWNER TO darwin2;

--
-- TOC entry 6101 (class 0 OID 0)
-- Dependencies: 291
-- Name: TABLE igs; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.igs IS 'Inventory table - register all ig (inventory general) numbers given in RBINS';


--
-- TOC entry 6102 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN igs.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.igs.id IS 'Unique identifier of an ig reference';


--
-- TOC entry 6103 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN igs.ig_num; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.igs.ig_num IS 'IG number';


--
-- TOC entry 6104 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN igs.ig_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.igs.ig_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6105 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN igs.ig_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.igs.ig_date IS 'Date of ig number creation';


--
-- TOC entry 292 (class 1259 OID 4816845)
-- Name: imports_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.imports_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.imports_id_seq OWNER TO darwin2;

--
-- TOC entry 293 (class 1259 OID 4816847)
-- Name: imports; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.imports (
    id integer DEFAULT nextval('darwin2.imports_id_seq'::regclass) NOT NULL,
    user_ref integer NOT NULL,
    format character varying NOT NULL,
    collection_ref integer,
    filename character varying NOT NULL,
    state character varying DEFAULT ''::character varying NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now(),
    initial_count integer DEFAULT 0 NOT NULL,
    is_finished boolean DEFAULT false NOT NULL,
    errors_in_import text,
    template_version text,
    exclude_invalid_entries boolean DEFAULT false NOT NULL,
    creation_date date,
    creation_date_mask integer,
    working boolean,
    mime_type character varying,
    gtu_include_date boolean DEFAULT false,
    gtu_tags_in_merge boolean DEFAULT false,
    source_database character varying,
    sensitive_information_withheld boolean,
    taxonomy_kingdom character varying,
    history_taxonomy public.hstore,
    specimen_taxonomy_ref integer,
    taxonomy_name character varying,
    definition_taxonomy text,
    is_reference_taxonomy boolean,
    source_taxonomy character varying,
    url_website_taxonomy character varying,
    url_webservice_taxonomy character varying
);


ALTER TABLE darwin2.imports OWNER TO darwin2;

--
-- TOC entry 6107 (class 0 OID 0)
-- Dependencies: 293
-- Name: TABLE imports; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.imports IS 'Table used to check the state of the date coming from an uploaded file';


--
-- TOC entry 6108 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.user_ref IS 'The referenced user id';


--
-- TOC entry 6109 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.format; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.format IS 'The import template to use for the imported file';


--
-- TOC entry 6110 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.collection_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.collection_ref IS 'The collection associated';


--
-- TOC entry 6111 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.filename; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.filename IS 'The filename of the file to proceed';


--
-- TOC entry 6112 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.state; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.state IS 'the state of the processing the file';


--
-- TOC entry 6113 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.created_at; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.created_at IS 'Creation of the file';


--
-- TOC entry 6114 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.updated_at; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.updated_at IS 'When the data has been modified lately';


--
-- TOC entry 6115 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.initial_count; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.initial_count IS 'Number of rows of staging when the import was created';


--
-- TOC entry 6116 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.is_finished; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.is_finished IS 'Boolean to mark if the import is finished or still need some operations';


--
-- TOC entry 6117 (class 0 OID 0)
-- Dependencies: 293
-- Name: COLUMN imports.exclude_invalid_entries; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.imports.exclude_invalid_entries IS 'Tell if, for this import, match should exclude the invalid units';


--
-- TOC entry 294 (class 1259 OID 4816862)
-- Name: informative_workflow_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.informative_workflow_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.informative_workflow_id_seq OWNER TO darwin2;

--
-- TOC entry 295 (class 1259 OID 4816864)
-- Name: informative_workflow; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.informative_workflow (
    id integer DEFAULT nextval('darwin2.informative_workflow_id_seq'::regclass) NOT NULL,
    user_ref integer,
    status character varying DEFAULT 'suggestion'::character varying NOT NULL,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    comment character varying,
    formated_name character varying DEFAULT 'anonymous'::character varying NOT NULL,
    is_last boolean DEFAULT true NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.informative_workflow OWNER TO darwin2;

--
-- TOC entry 6119 (class 0 OID 0)
-- Dependencies: 295
-- Name: TABLE informative_workflow; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.informative_workflow IS 'Workflow information for each record encoded';


--
-- TOC entry 6120 (class 0 OID 0)
-- Dependencies: 295
-- Name: COLUMN informative_workflow.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 6121 (class 0 OID 0)
-- Dependencies: 295
-- Name: COLUMN informative_workflow.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.record_id IS 'ID of record a workflow is defined for';


--
-- TOC entry 6122 (class 0 OID 0)
-- Dependencies: 295
-- Name: COLUMN informative_workflow.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.user_ref IS 'Reference of user - id field of users table';


--
-- TOC entry 6123 (class 0 OID 0)
-- Dependencies: 295
-- Name: COLUMN informative_workflow.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.status IS 'Record status: to correct, to be corrected or published';


--
-- TOC entry 6124 (class 0 OID 0)
-- Dependencies: 295
-- Name: COLUMN informative_workflow.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.modification_date_time IS 'Date and time of status change - last date/time is used as actual status, but helps also to keep an history of status change';


--
-- TOC entry 6125 (class 0 OID 0)
-- Dependencies: 295
-- Name: COLUMN informative_workflow.comment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.comment IS 'Complementary comments';


--
-- TOC entry 6126 (class 0 OID 0)
-- Dependencies: 295
-- Name: COLUMN informative_workflow.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.formated_name IS 'used to allow non registered user to add a workflow';


--
-- TOC entry 6127 (class 0 OID 0)
-- Dependencies: 295
-- Name: COLUMN informative_workflow.is_last; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.informative_workflow.is_last IS 'a flag witch allow us to know if the workflow for this referenced_relation/record id is the latest';


--
-- TOC entry 296 (class 1259 OID 4816875)
-- Name: insurances_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.insurances_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.insurances_id_seq OWNER TO darwin2;

--
-- TOC entry 297 (class 1259 OID 4816877)
-- Name: insurances; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.insurances (
    id integer DEFAULT nextval('darwin2.insurances_id_seq'::regclass) NOT NULL,
    insurance_value numeric(16,2) NOT NULL,
    insurance_currency character varying DEFAULT '€'::character varying NOT NULL,
    insurer_ref integer,
    date_from_mask integer DEFAULT 0 NOT NULL,
    date_from date DEFAULT '0001-01-01'::date NOT NULL,
    date_to_mask integer DEFAULT 0 NOT NULL,
    date_to date DEFAULT '2038-12-31'::date NOT NULL,
    contact_ref integer,
    CONSTRAINT chk_chk_specimen_parts_insurances CHECK ((insurance_value > (0)::numeric))
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.insurances OWNER TO darwin2;

--
-- TOC entry 6129 (class 0 OID 0)
-- Dependencies: 297
-- Name: TABLE insurances; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.insurances IS 'List of insurances values for given specimen parts/individuals';


--
-- TOC entry 6130 (class 0 OID 0)
-- Dependencies: 297
-- Name: COLUMN insurances.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 6131 (class 0 OID 0)
-- Dependencies: 297
-- Name: COLUMN insurances.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.record_id IS 'Identifier of record concerned';


--
-- TOC entry 6132 (class 0 OID 0)
-- Dependencies: 297
-- Name: COLUMN insurances.insurance_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.insurance_value IS 'Insurance value';


--
-- TOC entry 6133 (class 0 OID 0)
-- Dependencies: 297
-- Name: COLUMN insurances.insurance_currency; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.insurance_currency IS 'Currency used with insurance value';


--
-- TOC entry 6134 (class 0 OID 0)
-- Dependencies: 297
-- Name: COLUMN insurances.insurer_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.insurances.insurer_ref IS 'Reference of the insurance firm an insurance have been subscripted at';


--
-- TOC entry 298 (class 1259 OID 4816890)
-- Name: lithology_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.lithology_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.lithology_id_seq OWNER TO darwin2;

--
-- TOC entry 299 (class 1259 OID 4816892)
-- Name: lithology; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.lithology (
    id integer DEFAULT nextval('darwin2.lithology_id_seq'::regclass) NOT NULL,
    CONSTRAINT fct_chk_onceinpath_lithology CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.lithology OWNER TO darwin2;

--
-- TOC entry 6136 (class 0 OID 0)
-- Dependencies: 299
-- Name: TABLE lithology; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.lithology IS 'List of lithologic units';


--
-- TOC entry 6137 (class 0 OID 0)
-- Dependencies: 299
-- Name: COLUMN lithology.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.name IS 'Classification unit name';


--
-- TOC entry 6138 (class 0 OID 0)
-- Dependencies: 299
-- Name: COLUMN lithology.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 6139 (class 0 OID 0)
-- Dependencies: 299
-- Name: COLUMN lithology.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 6140 (class 0 OID 0)
-- Dependencies: 299
-- Name: COLUMN lithology.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 6141 (class 0 OID 0)
-- Dependencies: 299
-- Name: COLUMN lithology.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 6142 (class 0 OID 0)
-- Dependencies: 299
-- Name: COLUMN lithology.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 6143 (class 0 OID 0)
-- Dependencies: 299
-- Name: COLUMN lithology.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithology.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 300 (class 1259 OID 4816903)
-- Name: lithostratigraphy_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.lithostratigraphy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.lithostratigraphy_id_seq OWNER TO darwin2;

--
-- TOC entry 301 (class 1259 OID 4816905)
-- Name: lithostratigraphy; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.lithostratigraphy (
    id integer DEFAULT nextval('darwin2.lithostratigraphy_id_seq'::regclass) NOT NULL,
    CONSTRAINT fct_chk_onceinpath_lithostratigraphy CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.lithostratigraphy OWNER TO darwin2;

--
-- TOC entry 6145 (class 0 OID 0)
-- Dependencies: 301
-- Name: TABLE lithostratigraphy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.lithostratigraphy IS 'List of lithostratigraphic units';


--
-- TOC entry 6146 (class 0 OID 0)
-- Dependencies: 301
-- Name: COLUMN lithostratigraphy.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.name IS 'Classification unit name';


--
-- TOC entry 6147 (class 0 OID 0)
-- Dependencies: 301
-- Name: COLUMN lithostratigraphy.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 6148 (class 0 OID 0)
-- Dependencies: 301
-- Name: COLUMN lithostratigraphy.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 6149 (class 0 OID 0)
-- Dependencies: 301
-- Name: COLUMN lithostratigraphy.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 6150 (class 0 OID 0)
-- Dependencies: 301
-- Name: COLUMN lithostratigraphy.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 6151 (class 0 OID 0)
-- Dependencies: 301
-- Name: COLUMN lithostratigraphy.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 6152 (class 0 OID 0)
-- Dependencies: 301
-- Name: COLUMN lithostratigraphy.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.lithostratigraphy.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 302 (class 1259 OID 4816916)
-- Name: loan_history; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loan_history (
    id integer NOT NULL,
    loan_ref integer NOT NULL,
    referenced_table text NOT NULL,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    record_line public.hstore
);


ALTER TABLE darwin2.loan_history OWNER TO darwin2;

--
-- TOC entry 6154 (class 0 OID 0)
-- Dependencies: 302
-- Name: TABLE loan_history; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loan_history IS 'Table is a snapshot of an entire loan and related informations at a certain time';


--
-- TOC entry 6155 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN loan_history.loan_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_history.loan_ref IS 'Mandatory Reference to a loan';


--
-- TOC entry 6156 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN loan_history.referenced_table; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_history.referenced_table IS 'Mandatory Reference to the table refereced';


--
-- TOC entry 6157 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN loan_history.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_history.modification_date_time IS 'date of the modification';


--
-- TOC entry 6158 (class 0 OID 0)
-- Dependencies: 302
-- Name: COLUMN loan_history.record_line; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_history.record_line IS 'hstore containing the whole line of referenced_table';


--
-- TOC entry 303 (class 1259 OID 4816923)
-- Name: loan_history_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loan_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loan_history_id_seq OWNER TO darwin2;

--
-- TOC entry 6160 (class 0 OID 0)
-- Dependencies: 303
-- Name: loan_history_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.loan_history_id_seq OWNED BY darwin2.loan_history.id;


--
-- TOC entry 304 (class 1259 OID 4816925)
-- Name: loan_items_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loan_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loan_items_id_seq OWNER TO darwin2;

--
-- TOC entry 305 (class 1259 OID 4816927)
-- Name: loan_items; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loan_items (
    id integer DEFAULT nextval('darwin2.loan_items_id_seq'::regclass) NOT NULL,
    loan_ref integer NOT NULL,
    ig_ref integer,
    from_date date,
    to_date date,
    specimen_ref integer,
    details character varying DEFAULT ''::character varying
);


ALTER TABLE darwin2.loan_items OWNER TO darwin2;

--
-- TOC entry 6163 (class 0 OID 0)
-- Dependencies: 305
-- Name: TABLE loan_items; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loan_items IS 'Table holding an item of a loan. It may be a part from darwin or only an generic item';


--
-- TOC entry 6164 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN loan_items.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.id IS 'Unique identifier of record';


--
-- TOC entry 6165 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN loan_items.loan_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.loan_ref IS 'Mandatory Reference to a loan';


--
-- TOC entry 6166 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN loan_items.ig_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.ig_ref IS 'Optional ref to an IG stored in the igs table';


--
-- TOC entry 6167 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN loan_items.from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.from_date IS 'Date when the item was sended';


--
-- TOC entry 6168 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN loan_items.to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.to_date IS 'Date when the item was recieved back';


--
-- TOC entry 6169 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN loan_items.specimen_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.specimen_ref IS 'Optional reference to a Darwin Part';


--
-- TOC entry 6170 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN loan_items.details; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_items.details IS 'Textual details describing the item';


--
-- TOC entry 306 (class 1259 OID 4816935)
-- Name: loan_rights_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loan_rights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loan_rights_id_seq OWNER TO darwin2;

--
-- TOC entry 307 (class 1259 OID 4816937)
-- Name: loan_rights; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loan_rights (
    id integer DEFAULT nextval('darwin2.loan_rights_id_seq'::regclass) NOT NULL,
    loan_ref integer NOT NULL,
    user_ref integer NOT NULL,
    has_encoding_right boolean DEFAULT false NOT NULL
);


ALTER TABLE darwin2.loan_rights OWNER TO darwin2;

--
-- TOC entry 6173 (class 0 OID 0)
-- Dependencies: 307
-- Name: TABLE loan_rights; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loan_rights IS 'Table describing rights into an entire loan (if user is in the table he has at least viewing rights)';


--
-- TOC entry 6174 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN loan_rights.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_rights.id IS 'Unique identifier of record';


--
-- TOC entry 6175 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN loan_rights.loan_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_rights.loan_ref IS 'Mandatory Reference to a loan';


--
-- TOC entry 6176 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN loan_rights.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_rights.user_ref IS 'Mandatory Reference to a user';


--
-- TOC entry 6177 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN loan_rights.has_encoding_right; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_rights.has_encoding_right IS 'Bool saying if the user can edit a loan';


--
-- TOC entry 308 (class 1259 OID 4816942)
-- Name: loan_status_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loan_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loan_status_id_seq OWNER TO darwin2;

--
-- TOC entry 309 (class 1259 OID 4816944)
-- Name: loan_status; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loan_status (
    id integer DEFAULT nextval('darwin2.loan_status_id_seq'::regclass) NOT NULL,
    loan_ref integer NOT NULL,
    user_ref integer NOT NULL,
    status character varying DEFAULT 'new'::character varying NOT NULL,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    comment character varying DEFAULT ''::character varying NOT NULL,
    is_last boolean DEFAULT true NOT NULL
);


ALTER TABLE darwin2.loan_status OWNER TO darwin2;

--
-- TOC entry 6180 (class 0 OID 0)
-- Dependencies: 309
-- Name: TABLE loan_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loan_status IS 'Table describing various states of a loan';


--
-- TOC entry 6181 (class 0 OID 0)
-- Dependencies: 309
-- Name: COLUMN loan_status.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.id IS 'Unique identifier of record';


--
-- TOC entry 6182 (class 0 OID 0)
-- Dependencies: 309
-- Name: COLUMN loan_status.loan_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.loan_ref IS 'Mandatory Reference to a loan';


--
-- TOC entry 6183 (class 0 OID 0)
-- Dependencies: 309
-- Name: COLUMN loan_status.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.user_ref IS 'Mandatory Reference to a user';


--
-- TOC entry 6184 (class 0 OID 0)
-- Dependencies: 309
-- Name: COLUMN loan_status.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.status IS 'Current status of the loan in a list (new, closed, running, ...)';


--
-- TOC entry 6185 (class 0 OID 0)
-- Dependencies: 309
-- Name: COLUMN loan_status.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.modification_date_time IS 'date of the modification';


--
-- TOC entry 6186 (class 0 OID 0)
-- Dependencies: 309
-- Name: COLUMN loan_status.comment; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.comment IS 'comment of the status modification';


--
-- TOC entry 6187 (class 0 OID 0)
-- Dependencies: 309
-- Name: COLUMN loan_status.is_last; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loan_status.is_last IS 'flag telling which line is the current line';


--
-- TOC entry 310 (class 1259 OID 4816955)
-- Name: loans_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.loans_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.loans_id_seq OWNER TO darwin2;

--
-- TOC entry 311 (class 1259 OID 4816957)
-- Name: loans; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.loans (
    id integer DEFAULT nextval('darwin2.loans_id_seq'::regclass) NOT NULL,
    name character varying DEFAULT ''::character varying NOT NULL,
    description character varying DEFAULT ''::character varying NOT NULL,
    from_date date,
    to_date date,
    extended_to_date date,
    search_indexed text NOT NULL
);


ALTER TABLE darwin2.loans OWNER TO darwin2;

--
-- TOC entry 6190 (class 0 OID 0)
-- Dependencies: 311
-- Name: TABLE loans; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.loans IS 'Table holding an entire loan made of multiple loan items may also be linked to other table as comment, properties , ...';


--
-- TOC entry 6191 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN loans.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.id IS 'Unique identifier of record';


--
-- TOC entry 6192 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN loans.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.name IS 'Global name of the loan. May be a sort of code of other naming scheme';


--
-- TOC entry 6193 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN loans.description; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.description IS 'Description of the meaning of the loan';


--
-- TOC entry 6194 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN loans.from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.from_date IS 'Date of the start of the loan';


--
-- TOC entry 6195 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN loans.to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.to_date IS 'Planned date of the end of the loan';


--
-- TOC entry 6196 (class 0 OID 0)
-- Dependencies: 311
-- Name: COLUMN loans.search_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.loans.search_indexed IS 'indexed getting Description and title of the loan';


--
-- TOC entry 312 (class 1259 OID 4816966)
-- Name: mineralogy_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.mineralogy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.mineralogy_id_seq OWNER TO darwin2;

--
-- TOC entry 313 (class 1259 OID 4816968)
-- Name: mineralogy; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.mineralogy (
    id integer DEFAULT nextval('darwin2.mineralogy_id_seq'::regclass) NOT NULL,
    code character varying NOT NULL,
    classification character varying DEFAULT 'strunz'::character varying NOT NULL,
    formule character varying,
    formule_indexed character varying,
    cristal_system character varying,
    CONSTRAINT fct_chk_onceinpath_mineralogy CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.mineralogy OWNER TO darwin2;

--
-- TOC entry 6198 (class 0 OID 0)
-- Dependencies: 313
-- Name: TABLE mineralogy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.mineralogy IS 'List of mineralogic units';


--
-- TOC entry 6199 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.name IS 'Classification unit name';


--
-- TOC entry 6200 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 6201 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 6202 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 6203 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 6204 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 6205 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 6206 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.code IS 'Classification code given to mineral - in classification chosen - Strunz by default';


--
-- TOC entry 6207 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.classification; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.classification IS 'Classification system used to describe mineral: strunz, dana,...';


--
-- TOC entry 6208 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.formule; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.formule IS 'Chemical formulation';


--
-- TOC entry 6209 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.formule_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.formule_indexed IS 'Indexed form of foumule field';


--
-- TOC entry 6210 (class 0 OID 0)
-- Dependencies: 313
-- Name: COLUMN mineralogy.cristal_system; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.mineralogy.cristal_system IS 'Cristal system defining the mineral structure: isometric, hexagonal,...';


--
-- TOC entry 314 (class 1259 OID 4816980)
-- Name: multimedia_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.multimedia_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.multimedia_id_seq OWNER TO darwin2;

--
-- TOC entry 315 (class 1259 OID 4816982)
-- Name: multimedia; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.multimedia (
    id integer DEFAULT nextval('darwin2.multimedia_id_seq'::regclass) NOT NULL,
    is_digital boolean DEFAULT true NOT NULL,
    type character varying DEFAULT 'image'::character varying NOT NULL,
    sub_type character varying,
    title character varying NOT NULL,
    description character varying DEFAULT ''::character varying NOT NULL,
    uri character varying,
    filename character varying,
    creation_date date DEFAULT '0001-01-01'::date NOT NULL,
    creation_date_mask integer DEFAULT 0 NOT NULL,
    mime_type character varying NOT NULL,
    visible boolean DEFAULT true NOT NULL,
    publishable boolean DEFAULT true NOT NULL,
    search_indexed text NOT NULL,
    extracted_info text
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.multimedia OWNER TO darwin2;

--
-- TOC entry 6213 (class 0 OID 0)
-- Dependencies: 315
-- Name: TABLE multimedia; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.multimedia IS 'Stores all multimedia objects encoded in DaRWIN 2.0';


--
-- TOC entry 6214 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 6215 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.record_id IS 'Identifier of record concerned';


--
-- TOC entry 6216 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.id IS 'Unique identifier of a multimedia object';


--
-- TOC entry 6217 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.is_digital; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.is_digital IS 'Flag telling if the object is digital (true) or physical (false)';


--
-- TOC entry 6218 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.type IS 'Main multimedia object type: image, sound, video,...';


--
-- TOC entry 6219 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.sub_type IS 'Characterization of object type: article, publication in serie, book, glass plate,...';


--
-- TOC entry 6220 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.title IS 'Title of the multimedia object';


--
-- TOC entry 6221 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.description; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.description IS 'Description of the current object';


--
-- TOC entry 6222 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.uri; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.uri IS 'URI of object if digital';


--
-- TOC entry 6223 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.filename; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.filename IS 'The original name of the saved file';


--
-- TOC entry 6224 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.creation_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.creation_date IS 'Object creation date';


--
-- TOC entry 6225 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.creation_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.creation_date_mask IS 'Mask used for object creation date display';


--
-- TOC entry 6226 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.mime_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.mime_type IS 'Mime/Type of the linked digital object';


--
-- TOC entry 6227 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.visible; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.visible IS 'Flag telling if the related file has been chosen to be publically visible or not';


--
-- TOC entry 6228 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.publishable; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.publishable IS 'Flag telling if the related file has been chosen as a prefered item for publication - Would be for example used for preselection of media published for Open Up project';


--
-- TOC entry 6229 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN multimedia.search_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia.search_indexed IS 'indexed form of title and description fields together';


--
-- TOC entry 316 (class 1259 OID 4816996)
-- Name: multimedia_todelete; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.multimedia_todelete (
    id integer NOT NULL,
    uri text
);


ALTER TABLE darwin2.multimedia_todelete OWNER TO darwin2;

--
-- TOC entry 6231 (class 0 OID 0)
-- Dependencies: 316
-- Name: TABLE multimedia_todelete; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.multimedia_todelete IS 'Table here to save deleted multimedia files waiting for a deletion on the disk';


--
-- TOC entry 6232 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN multimedia_todelete.uri; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.multimedia_todelete.uri IS 'URI of the file to delete';


--
-- TOC entry 317 (class 1259 OID 4817002)
-- Name: multimedia_todelete_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.multimedia_todelete_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.multimedia_todelete_id_seq OWNER TO darwin2;

--
-- TOC entry 6234 (class 0 OID 0)
-- Dependencies: 317
-- Name: multimedia_todelete_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.multimedia_todelete_id_seq OWNED BY darwin2.multimedia_todelete.id;


--
-- TOC entry 437 (class 1259 OID 5308577)
-- Name: tag_authority; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tag_authority (
    id integer NOT NULL,
    domain_ref bigint NOT NULL,
    source character varying,
    url character varying NOT NULL,
    urn character varying,
    code character varying,
    type text[],
    pref_label character varying(255) NOT NULL,
    definition character varying,
    synonyms text[],
    language_variants public.hstore,
    alternative_representations public.hstore,
    tag_group_distinct_ref integer
);


ALTER TABLE darwin2.tag_authority OWNER TO darwin2;

--
-- TOC entry 6236 (class 0 OID 0)
-- Dependencies: 437
-- Name: TABLE tag_authority; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.tag_authority IS 'Formal representations of tags used in DarWIN as they appear in vocabularies or gazetteers. All mapped entries must have a resolvable url and a preferred label.';


--
-- TOC entry 6237 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.id IS 'Primary key of the authoritative representation of a tag.';


--
-- TOC entry 6238 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.domain_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.domain_ref IS 'Reference to the domain that authored the authoritative representation.';


--
-- TOC entry 6239 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.source; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.source IS 'A gazetter might have aggregated a matching entry from other sources. This source can be considered a subdomain if it is only aggregated by one (this) domain.';


--
-- TOC entry 6240 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.url; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.url IS 'The url of the authority entry. Mandatory.';


--
-- TOC entry 6241 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.urn; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.urn IS 'The urn or pseudo-urn of the authority entry.';


--
-- TOC entry 6242 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.code IS 'The internal identifier used in the domain (for example the GeoNames number).';


--
-- TOC entry 6243 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.type IS 'An array of the most specific types that a gazetteer has attached to this entry. Example:';


--
-- TOC entry 6244 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.pref_label; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.pref_label IS 'The principal name used for the term by the authority or gazetteer. Mandatory.';


--
-- TOC entry 6245 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.definition; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.definition IS 'The definition of the term used by the authority or gazetteer.';


--
-- TOC entry 6246 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.synonyms; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.synonyms IS 'A flat array containing synonyms. NOT intended as a reference towards other entries in the same authority, should contain only information gathered from the entry itself. Example: "Montana","The Buckeye State"';


--
-- TOC entry 6247 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.language_variants; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.language_variants IS 'An associative array containing key-value pairs for language variants. NOT intended as a reference towards other entries in the same authority, should contain only information gathered from the entry itself. Example: "@de": "Bayern"; "@nl":"Beieren"';


--
-- TOC entry 6248 (class 0 OID 0)
-- Dependencies: 437
-- Name: COLUMN tag_authority.alternative_representations; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_authority.alternative_representations IS 'An associative array containing key-value pairs for alternative representations. NOT intended as a reference towards other entries in the same authority, should contain only information gathered from the entry itself. Example: "ISO 3166-2": "DE"; "ISO 3166-3":"DEU"';


--
-- TOC entry 433 (class 1259 OID 5308546)
-- Name: tag_group_distinct; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tag_group_distinct (
    id integer NOT NULL,
    sub_group_name_indexed character varying NOT NULL,
    group_name_indexed character varying NOT NULL,
    tag_value character varying NOT NULL
);


ALTER TABLE darwin2.tag_group_distinct OWNER TO darwin2;

--
-- TOC entry 6250 (class 0 OID 0)
-- Dependencies: 433
-- Name: TABLE tag_group_distinct; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.tag_group_distinct IS 'List of all distinct tags';


--
-- TOC entry 6251 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tag_group_distinct.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_group_distinct.id IS 'Unique identifier of a tag value/group name/sub group name combination';


--
-- TOC entry 6252 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tag_group_distinct.sub_group_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_group_distinct.sub_group_name_indexed IS 'Reference to the sub_group_name';


--
-- TOC entry 6253 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tag_group_distinct.group_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_group_distinct.group_name_indexed IS 'Reference to the group_name';


--
-- TOC entry 6254 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tag_group_distinct.tag_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_group_distinct.tag_value IS 'Textual value of the tag.';


--
-- TOC entry 375 (class 1259 OID 4817347)
-- Name: tag_groups_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.tag_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.tag_groups_id_seq OWNER TO darwin2;

--
-- TOC entry 376 (class 1259 OID 4817349)
-- Name: tag_groups; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tag_groups (
    id bigint DEFAULT nextval('darwin2.tag_groups_id_seq'::regclass) NOT NULL,
    gtu_ref integer NOT NULL,
    group_name character varying NOT NULL,
    group_name_indexed character varying NOT NULL,
    sub_group_name character varying NOT NULL,
    sub_group_name_indexed character varying NOT NULL,
    color character varying DEFAULT '#FFFFFF'::character varying NOT NULL,
    tag_value character varying NOT NULL,
    international_name text DEFAULT ''::text NOT NULL,
    tag_group_distinct_ref bigint
);


ALTER TABLE darwin2.tag_groups OWNER TO darwin2;

--
-- TOC entry 6256 (class 0 OID 0)
-- Dependencies: 376
-- Name: TABLE tag_groups; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.tag_groups IS 'List of grouped tags';


--
-- TOC entry 6257 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tag_groups.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.id IS 'Unique identifier of a grouped tag';


--
-- TOC entry 6258 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tag_groups.gtu_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.gtu_ref IS 'Reference to a Gtu';


--
-- TOC entry 6259 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tag_groups.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.group_name IS 'Group name under which the tag is grouped: Administrative area, Topographic structure,...';


--
-- TOC entry 6260 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tag_groups.group_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.group_name_indexed IS 'Indexed form of a group name';


--
-- TOC entry 6261 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tag_groups.sub_group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.sub_group_name IS 'Sub-Group name under which the tag is grouped: Country, River, Mountain,...';


--
-- TOC entry 6262 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tag_groups.sub_group_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.sub_group_name_indexed IS 'Indexed form of a sub-group name';


--
-- TOC entry 6263 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tag_groups.color; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.color IS 'Color associated to the group concerned';


--
-- TOC entry 6264 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tag_groups.tag_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.tag_value IS 'Ensemble of Tags';


--
-- TOC entry 6265 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tag_groups.international_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tag_groups.international_name IS 'The international(english) name of the place / ocean / country';


--
-- TOC entry 438 (class 1259 OID 5308593)
-- Name: tag_tag_authority; Type: TABLE; Schema: darwin2; Owner: postgres
--

CREATE TABLE darwin2.tag_tag_authority (
    tag_authority_ref bigint NOT NULL,
    tag_group_distinct_ref bigint NOT NULL,
    tag_authority_match_predicate text NOT NULL,
    CONSTRAINT chk_predicate_onto CHECK (((tag_authority_match_predicate ~~ '%skos:%'::text) OR (tag_authority_match_predicate ~~ '%owl:%'::text)))
);


ALTER TABLE darwin2.tag_tag_authority OWNER TO postgres;

--
-- TOC entry 6267 (class 0 OID 0)
-- Dependencies: 438
-- Name: TABLE tag_tag_authority; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON TABLE darwin2.tag_tag_authority IS 'The coupling table between vocabulary entries and tags.';


--
-- TOC entry 6268 (class 0 OID 0)
-- Dependencies: 438
-- Name: COLUMN tag_tag_authority.tag_authority_ref; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.tag_tag_authority.tag_authority_ref IS 'Reference to the authoritative vocabulary entry.';


--
-- TOC entry 6269 (class 0 OID 0)
-- Dependencies: 438
-- Name: COLUMN tag_tag_authority.tag_group_distinct_ref; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.tag_tag_authority.tag_group_distinct_ref IS 'Reference to the distinct grouped tag as used in DarWIN.';


--
-- TOC entry 6270 (class 0 OID 0)
-- Dependencies: 438
-- Name: COLUMN tag_tag_authority.tag_authority_match_predicate; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.tag_tag_authority.tag_authority_match_predicate IS 'Predicate that indicates how close the match between the tag and the authoritative url is: must use a predicate from an existing ontology, i.e. skos:broader, skos:narrower, owl:sameAs.';


--
-- TOC entry 439 (class 1259 OID 5308612)
-- Name: mv_tag_to_country; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: postgres
--

CREATE MATERIALIZED VIEW darwin2.mv_tag_to_country AS
 SELECT DISTINCT gtu.id AS gtu_ref,
    t1.id AS tag_group_distinct_ref,
    t1.tag_value,
    ta.code,
    ta.url,
    ta.pref_label,
    (ta.alternative_representations OPERATOR(public.->) 'ISO 3166-2'::text) AS country_iso
   FROM (((((darwin2.gtu
     LEFT JOIN darwin2.tag_groups t1 ON ((gtu.id = t1.gtu_ref)))
     RIGHT JOIN darwin2.tag_groups t ON ((gtu.id = t.gtu_ref)))
     RIGHT JOIN darwin2.tag_group_distinct td ON ((((t.tag_value)::text = (td.tag_value)::text) AND ((td.sub_group_name_indexed)::text = (t.sub_group_name_indexed)::text) AND ((td.group_name_indexed)::text = (t.group_name_indexed)::text) AND ((td.sub_group_name_indexed)::text = 'country'::text))))
     LEFT JOIN darwin2.tag_tag_authority tta ON ((tta.tag_group_distinct_ref = td.id)))
     LEFT JOIN darwin2.tag_authority ta ON ((tta.tag_authority_ref = ta.id)))
  WHERE (((td.sub_group_name_indexed)::text = 'country'::text) AND (ta.id IS NOT NULL) AND ((t1.sub_group_name_indexed)::text <> 'country'::text) AND (t1.id IS NOT NULL))
  WITH NO DATA;


ALTER TABLE darwin2.mv_tag_to_country OWNER TO postgres;

--
-- TOC entry 351 (class 1259 OID 4817202)
-- Name: specimens; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimens (
    id integer NOT NULL,
    category character varying DEFAULT 'physical'::character varying NOT NULL,
    collection_ref integer NOT NULL,
    expedition_ref integer,
    gtu_ref integer,
    taxon_ref integer,
    litho_ref integer,
    chrono_ref integer,
    lithology_ref integer,
    mineral_ref integer,
    acquisition_category character varying DEFAULT ''::character varying NOT NULL,
    acquisition_date_mask integer DEFAULT 0 NOT NULL,
    acquisition_date date DEFAULT '0001-01-01'::date NOT NULL,
    station_visible boolean DEFAULT true NOT NULL,
    ig_ref integer,
    type character varying DEFAULT 'specimen'::character varying NOT NULL,
    type_group character varying DEFAULT 'specimen'::character varying NOT NULL,
    type_search character varying DEFAULT 'specimen'::character varying NOT NULL,
    sex character varying DEFAULT 'undefined'::character varying NOT NULL,
    stage character varying DEFAULT 'undefined'::character varying NOT NULL,
    state character varying DEFAULT 'not applicable'::character varying NOT NULL,
    social_status character varying DEFAULT 'not applicable'::character varying NOT NULL,
    rock_form character varying DEFAULT 'not applicable'::character varying NOT NULL,
    specimen_part character varying DEFAULT 'specimen'::character varying NOT NULL,
    complete boolean DEFAULT true NOT NULL,
    institution_ref integer,
    building character varying,
    floor character varying,
    room character varying,
    "row" character varying,
    shelf character varying,
    container character varying,
    sub_container character varying,
    container_type character varying DEFAULT 'container'::character varying NOT NULL,
    sub_container_type character varying DEFAULT 'container'::character varying NOT NULL,
    container_storage character varying DEFAULT 'dry'::character varying NOT NULL,
    sub_container_storage character varying DEFAULT 'dry'::character varying NOT NULL,
    surnumerary boolean DEFAULT false NOT NULL,
    specimen_status character varying DEFAULT 'good state'::character varying NOT NULL,
    specimen_count_min integer DEFAULT 1 NOT NULL,
    specimen_count_max integer DEFAULT 1 NOT NULL,
    object_name text,
    object_name_indexed text DEFAULT ''::text NOT NULL,
    spec_ident_ids integer[] DEFAULT '{}'::integer[] NOT NULL,
    spec_coll_ids integer[] DEFAULT '{}'::integer[] NOT NULL,
    spec_don_sel_ids integer[] DEFAULT '{}'::integer[] NOT NULL,
    collection_type character varying,
    collection_code character varying,
    collection_name character varying,
    collection_is_public boolean,
    collection_parent_ref integer,
    collection_path character varying,
    expedition_name character varying,
    expedition_name_indexed character varying,
    gtu_code character varying,
    gtu_from_date_mask integer DEFAULT 0,
    gtu_from_date timestamp without time zone DEFAULT '0001-01-01 00:00:00'::timestamp without time zone,
    gtu_to_date_mask integer DEFAULT 0,
    gtu_to_date timestamp without time zone DEFAULT '2038-12-31 00:00:00'::timestamp without time zone,
    gtu_tag_values_indexed character varying[],
    gtu_country_tag_value character varying,
    gtu_country_tag_indexed character varying[],
    gtu_province_tag_value character varying,
    gtu_province_tag_indexed character varying[],
    gtu_others_tag_value character varying,
    gtu_others_tag_indexed character varying[],
    gtu_elevation double precision,
    gtu_elevation_accuracy double precision,
    taxon_name character varying,
    taxon_name_indexed character varying,
    taxon_level_ref integer,
    taxon_level_name character varying,
    taxon_status character varying,
    taxon_path character varying,
    taxon_parent_ref integer,
    taxon_extinct boolean,
    litho_name character varying,
    litho_name_indexed character varying,
    litho_level_ref integer,
    litho_level_name character varying,
    litho_status character varying,
    litho_local boolean,
    litho_color character varying,
    litho_path character varying,
    litho_parent_ref integer,
    chrono_name character varying,
    chrono_name_indexed character varying,
    chrono_level_ref integer,
    chrono_level_name character varying,
    chrono_status character varying,
    chrono_local boolean,
    chrono_color character varying,
    chrono_path character varying,
    chrono_parent_ref integer,
    lithology_name character varying,
    lithology_name_indexed character varying,
    lithology_level_ref integer,
    lithology_level_name character varying,
    lithology_status character varying,
    lithology_local boolean,
    lithology_color character varying,
    lithology_path character varying,
    lithology_parent_ref integer,
    mineral_name character varying,
    mineral_name_indexed character varying,
    mineral_level_ref integer,
    mineral_level_name character varying,
    mineral_status character varying,
    mineral_local boolean,
    mineral_color character varying,
    mineral_path character varying,
    mineral_parent_ref integer,
    ig_num character varying,
    ig_num_indexed character varying,
    ig_date_mask integer,
    ig_date date,
    col text,
    gtu_location point,
    specimen_creation_date timestamp without time zone DEFAULT now(),
    import_ref integer,
    main_code_indexed character varying,
    CONSTRAINT chk_chk_specimens_min CHECK ((specimen_count_min >= 0)),
    CONSTRAINT chk_chk_specimens_minmax CHECK ((specimen_count_min <= specimen_count_max))
);


ALTER TABLE darwin2.specimens OWNER TO darwin2;

--
-- TOC entry 6273 (class 0 OID 0)
-- Dependencies: 351
-- Name: TABLE specimens; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.specimens IS 'Specimens or batch of specimens stored in collection';


--
-- TOC entry 6274 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.id IS 'Unique identifier of a specimen or batch of specimens';


--
-- TOC entry 6275 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.category IS 'Type of specimen encoded: a physical object stored in collections, an observation, a figurate specimen,...';


--
-- TOC entry 6276 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.collection_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.collection_ref IS 'Reference of collection the specimen is grouped under - id field of collections table';


--
-- TOC entry 6277 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.expedition_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.expedition_ref IS 'When acquisition category is expedition, contains the reference of the expedition having conducted to the current specimen capture - id field of expeditions table';


--
-- TOC entry 6278 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.gtu_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_ref IS 'Reference of the sampling location the specimen is coming from - id field of gtu table';


--
-- TOC entry 6279 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.taxon_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.taxon_ref IS 'When encoding a ''living'' specimen, contains the reference of the taxon unit defining the specimen - id field of taxonomy table';


--
-- TOC entry 6280 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.litho_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.litho_ref IS 'When encoding a rock, mineral or paleontologic specimen, contains the reference of lithostratigraphic unit the specimen have been found into - id field of lithostratigraphy table';


--
-- TOC entry 6281 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.chrono_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.chrono_ref IS 'When encoding a rock, mineral or paleontologic specimen, contains the reference of chronostratigraphic unit the specimen have been found into - id field of chronostratigraphy table';


--
-- TOC entry 6282 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.lithology_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.lithology_ref IS 'Reference of a rock classification unit associated to the specimen encoded - id field of lithology table';


--
-- TOC entry 6283 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.mineral_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.mineral_ref IS 'Reference of a mineral classification unit associated to the specimen encoded - id field of mineralogy table';


--
-- TOC entry 6284 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.acquisition_category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.acquisition_category IS 'Describe how the specimen was collected: expedition, donation,...';


--
-- TOC entry 6285 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.acquisition_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.acquisition_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6286 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.acquisition_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.acquisition_date IS 'Date Composed (if possible) of the acquisition';


--
-- TOC entry 6287 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.station_visible; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.station_visible IS 'Flag telling if the sampling location can be visible or must be hidden for the specimen encoded';


--
-- TOC entry 6288 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.ig_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.ig_ref IS 'Reference of ig number this specimen has been associated to';


--
-- TOC entry 6289 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.type IS 'Flag indicating if the taxa has been improted into Darwin (2019 02 11)';


--
-- TOC entry 6290 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.type_group; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.type_group IS 'For some special status, a common appelation is used - ie: topotype and cotype are joined into a common appelation of syntype';


--
-- TOC entry 6291 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.type_search; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.type_search IS 'On the interface, the separation in all special status is not suggested for non official appelations. For instance, an unified grouping name is provided: type for non official appelation,...';


--
-- TOC entry 6292 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.sex; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.sex IS 'sex: male , female,...';


--
-- TOC entry 6293 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.stage; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.stage IS 'stage: adult, juvenile,...';


--
-- TOC entry 6294 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.state; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.state IS 'state - a sex complement: ovigerous, pregnant,...';


--
-- TOC entry 6295 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.social_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.social_status IS 'For social specimens, give the social status/role of the specimen in colony';


--
-- TOC entry 6296 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.rock_form; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.rock_form IS 'For rock specimens, a descriptive form can be given: polygonous,...';


--
-- TOC entry 6297 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.specimen_part; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.specimen_part IS 'Description of the part stored in conservatory: the whole specimen or a given precise part such as skelleton, head, fur,...';


--
-- TOC entry 6298 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.complete; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.complete IS 'Flag telling if specimen is complete or not';


--
-- TOC entry 6299 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.building; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.building IS 'Building the specimen is stored in';


--
-- TOC entry 6300 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.floor; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.floor IS 'Floor the specimen is stored in';


--
-- TOC entry 6301 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.room; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.room IS 'Room the specimen is stored in';


--
-- TOC entry 6302 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens."row"; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens."row" IS 'Row the specimen is stored in';


--
-- TOC entry 6303 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.shelf; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.shelf IS 'Shelf the specimen is stored in';


--
-- TOC entry 6304 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.container; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.container IS 'Container the specimen is stored in';


--
-- TOC entry 6305 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.sub_container; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.sub_container IS 'Sub-Container the specimen is stored in';


--
-- TOC entry 6306 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.container_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.container_type IS 'Type of container: box, plateau-caisse,...';


--
-- TOC entry 6307 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.sub_container_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.sub_container_type IS 'Type of sub-container: slide, needle,...';


--
-- TOC entry 6308 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.container_storage; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.container_storage IS 'Conservative medium used: formol, alcohool, dry,...';


--
-- TOC entry 6309 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.sub_container_storage; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.sub_container_storage IS 'Conservative medium used: formol, alcohool, dry,...';


--
-- TOC entry 6310 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.surnumerary; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.surnumerary IS 'Tells if this specimen has been added after first inventory';


--
-- TOC entry 6311 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.specimen_status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.specimen_status IS 'Specimen status: good state, lost, damaged,...';


--
-- TOC entry 6312 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.specimen_count_min; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.specimen_count_min IS 'Minimum number of specimens';


--
-- TOC entry 6313 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.specimen_count_max; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.specimen_count_max IS 'Maximum number of specimens';


--
-- TOC entry 6314 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.gtu_from_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_from_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6315 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.gtu_from_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_from_date IS 'composed from date of the GTU';


--
-- TOC entry 6316 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.gtu_to_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_to_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day, 4 for hour, 2 for minutes, 1 for seconds';


--
-- TOC entry 6317 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN specimens.gtu_to_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens.gtu_to_date IS 'composed to date of the GTU';


--
-- TOC entry 324 (class 1259 OID 4817057)
-- Name: template_people; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_people (
    is_physical boolean DEFAULT true NOT NULL,
    sub_type character varying,
    formated_name character varying NOT NULL,
    formated_name_indexed character varying NOT NULL,
    formated_name_unique character varying NOT NULL,
    title character varying DEFAULT ''::character varying NOT NULL,
    family_name character varying NOT NULL,
    given_name character varying,
    additional_names character varying,
    birth_date_mask integer DEFAULT 0 NOT NULL,
    birth_date date DEFAULT '0001-01-01'::date NOT NULL,
    gender character(1),
    CONSTRAINT genders_chk CHECK ((gender = ANY (ARRAY['M'::bpchar, 'F'::bpchar])))
);


ALTER TABLE darwin2.template_people OWNER TO darwin2;

--
-- TOC entry 6319 (class 0 OID 0)
-- Dependencies: 324
-- Name: TABLE template_people; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_people IS 'Template table used to describe user/people tables';


--
-- TOC entry 6320 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.is_physical; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.is_physical IS 'Type of user/person: physical or moral - true is physical, false is moral';


--
-- TOC entry 6321 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.sub_type IS 'Used for moral user/persons: precise nature - public institution, asbl, sprl, sa,...';


--
-- TOC entry 6322 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.formated_name IS 'Complete user/person formated name (with honorific mention, prefixes, suffixes,...) - By default composed with family_name and given_name fields, but can be modified by hand';


--
-- TOC entry 6323 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.formated_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.formated_name_indexed IS 'Indexed form of formated_name field';


--
-- TOC entry 6324 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.formated_name_unique; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.formated_name_unique IS 'Indexed form of formated_name field (for unique index purpose)';


--
-- TOC entry 6325 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.title IS 'Title of a physical user/person like Mr or Mrs or phd,...';


--
-- TOC entry 6326 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.family_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.family_name IS 'Family name for physical user/persons and Organisation name for moral user/persons';


--
-- TOC entry 6327 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.given_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.given_name IS 'User/person''s given name - usually first name';


--
-- TOC entry 6328 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.additional_names; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.additional_names IS 'Any additional names given to user/person';


--
-- TOC entry 6329 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.birth_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.birth_date_mask IS 'Contains the Mask flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6330 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.birth_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.birth_date IS 'Birth/Creation date composed';


--
-- TOC entry 6331 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN template_people.gender; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people.gender IS 'For physical user/persons give the gender: M or F';


--
-- TOC entry 328 (class 1259 OID 4817096)
-- Name: template_people_users_comm_common; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_people_users_comm_common (
    person_user_ref integer NOT NULL,
    entry character varying NOT NULL
);


ALTER TABLE darwin2.template_people_users_comm_common OWNER TO darwin2;

--
-- TOC entry 6333 (class 0 OID 0)
-- Dependencies: 328
-- Name: TABLE template_people_users_comm_common; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_people_users_comm_common IS 'Template table used to construct people communication tables (tel and e-mail)';


--
-- TOC entry 6334 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN template_people_users_comm_common.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_comm_common.person_user_ref IS 'Reference of person/user - id field of people/users table';


--
-- TOC entry 6335 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN template_people_users_comm_common.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_comm_common.entry IS 'Communication entry';


--
-- TOC entry 387 (class 1259 OID 4817414)
-- Name: users_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_id_seq OWNER TO darwin2;

--
-- TOC entry 388 (class 1259 OID 4817416)
-- Name: users; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users (
    id integer DEFAULT nextval('darwin2.users_id_seq'::regclass) NOT NULL,
    db_user_type smallint DEFAULT 1 NOT NULL,
    people_id integer,
    created_at timestamp without time zone DEFAULT now(),
    selected_lang character varying DEFAULT 'en'::character varying NOT NULL
)
INHERITS (darwin2.template_people);


ALTER TABLE darwin2.users OWNER TO darwin2;

--
-- TOC entry 6338 (class 0 OID 0)
-- Dependencies: 388
-- Name: TABLE users; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users IS 'List all application users';


--
-- TOC entry 6339 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.is_physical; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.is_physical IS 'Type of user: physical or moral - true is physical, false is moral';


--
-- TOC entry 6340 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.sub_type IS 'Used for moral users: precise nature - public institution, asbl, sprl, sa,...';


--
-- TOC entry 6341 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.formated_name IS 'Complete user formated name (with honorific mention, prefixes, suffixes,...) - By default composed with family_name and given_name fields, but can be modified by hand';


--
-- TOC entry 6342 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.formated_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.formated_name_indexed IS 'Indexed form of formated_name field';


--
-- TOC entry 6343 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.formated_name_unique; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.formated_name_unique IS 'Indexed form of formated_name field (for unique index use)';


--
-- TOC entry 6344 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.title IS 'Title of a physical user/person like Mr or Mrs or phd,...';


--
-- TOC entry 6345 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.family_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.family_name IS 'Family name for physical users and Organisation name for moral users';


--
-- TOC entry 6346 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.given_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.given_name IS 'User/user''s given name - usually first name';


--
-- TOC entry 6347 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.additional_names; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.additional_names IS 'Any additional names given to user';


--
-- TOC entry 6348 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.birth_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.birth_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6349 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.birth_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.birth_date IS 'Birth/Creation date composed';


--
-- TOC entry 6350 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.gender; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.gender IS 'For physical users give the gender: M or F';


--
-- TOC entry 6351 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.id IS 'Unique identifier of a user';


--
-- TOC entry 6352 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.db_user_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.db_user_type IS 'Integer is representing a role: 1 for registered user, 2 for encoder, 4 for collection manager, 8 for system admin,...';


--
-- TOC entry 6353 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.people_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.people_id IS 'Reference to a people if this user is also known as a people';


--
-- TOC entry 6354 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN users.selected_lang; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users.selected_lang IS 'Lang of the interface for the user en,fr,nl ,....';


--
-- TOC entry 391 (class 1259 OID 4817441)
-- Name: users_comm_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_comm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_comm_id_seq OWNER TO darwin2;

--
-- TOC entry 392 (class 1259 OID 4817443)
-- Name: users_comm; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users_comm (
    id integer DEFAULT nextval('darwin2.users_comm_id_seq'::regclass) NOT NULL,
    comm_type character varying DEFAULT 'phone/fax'::character varying NOT NULL,
    tag character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_people_users_comm_common);


ALTER TABLE darwin2.users_comm OWNER TO darwin2;

--
-- TOC entry 6357 (class 0 OID 0)
-- Dependencies: 392
-- Name: TABLE users_comm; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users_comm IS 'Users phones and e-mails';


--
-- TOC entry 6358 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN users_comm.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.person_user_ref IS 'Reference of user - id field of user table';


--
-- TOC entry 6359 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN users_comm.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.entry IS 'Communication entry';


--
-- TOC entry 6360 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN users_comm.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.id IS 'Unique identifier of a users communication mean entry';


--
-- TOC entry 6361 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN users_comm.comm_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.comm_type IS 'Type of communication table concerned: address, phone or e-mail';


--
-- TOC entry 6362 (class 0 OID 0)
-- Dependencies: 392
-- Name: COLUMN users_comm.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_comm.tag IS 'List of descriptive tags: internet, tel, fax, pager, public, private,...';


--
-- TOC entry 441 (class 1259 OID 5308663)
-- Name: mv_eml; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: postgres
--

CREATE MATERIALIZED VIEW darwin2.mv_eml AS
 WITH children_geographic_coverage AS (
         SELECT c_1.id,
            string_agg(DISTINCT (countries.pref_label)::text, ', '::text ORDER BY (countries.pref_label)::text) AS geographic_coverage,
            min(s.gtu_location[0]) AS min_lat,
            min(s.gtu_location[1]) AS min_lon,
            max(s.gtu_location[0]) AS max_lat,
            max(s.gtu_location[1]) AS max_lon
           FROM ((darwin2.specimens s
             JOIN darwin2.collections c_1 ON ((((((s.collection_path)::text || '/'::text) || s.collection_ref) || '/'::text) ~~ (('%/'::text || c_1.id) || '/%'::text))))
             JOIN darwin2.mv_tag_to_country countries ON ((countries.gtu_ref = s.gtu_ref)))
          WHERE (c_1.publish_to_gbif = true)
          GROUP BY c_1.id
        ), specimen_info AS (
         SELECT c_1.id,
            count(s.*) AS nb_spec,
            array_agg(DISTINCT s.ig_num ORDER BY s.ig_num) AS ig_num
           FROM (darwin2.specimens s
             JOIN darwin2.collections c_1 ON ((((((s.collection_path)::text || '/'::text) || s.collection_ref) || '/'::text) ~~ (('%/'::text || c_1.id) || '/%'::text))))
          WHERE (c_1.publish_to_gbif = true)
          GROUP BY c_1.id
        ), children_temporal_coverage AS (
         SELECT c_1.id,
            min(
                CASE
                    WHEN (s.gtu_from_date_mask = 0) THEN darwin2.fct_mask_date(s.gtu_to_date, s.gtu_to_date_mask)
                    ELSE darwin2.fct_mask_date(s.gtu_from_date, s.gtu_from_date_mask)
                END) AS date_from,
            replace(max(replace(
                CASE
                    WHEN (s.gtu_to_date_mask = 0) THEN darwin2.fct_mask_date(s.gtu_from_date, s.gtu_from_date_mask)
                    ELSE darwin2.fct_mask_date(s.gtu_to_date, s.gtu_to_date_mask)
                END, 'xxxx-xx-xx'::text, '0000-00-00'::text)), '0000-00-00'::text, 'xxxx-xx-xx'::text) AS date_to
           FROM (darwin2.specimens s
             JOIN darwin2.collections c_1 ON (((((((s.collection_path)::text || '/'::text) || s.collection_ref) || '/'::text) ~~ (('%/'::text || c_1.id) || '/%'::text)) AND (c_1.publish_to_gbif = true))))
          GROUP BY c_1.id, c_1.name
          ORDER BY c_1.id
        ), species_coverage AS (
         SELECT c_1.id,
            count(DISTINCT s.taxon_path) AS nb_species
           FROM (darwin2.specimens s
             JOIN darwin2.collections c_1 ON (((((((s.collection_path)::text || '/'::text) || s.collection_ref) || '/'::text) ~~ (('%/'::text || c_1.id) || '/%'::text)) AND (c_1.publish_to_gbif = true))))
          GROUP BY c_1.id
        ), classes_orders_coverage AS (
         SELECT c_1.id,
            f.level_ref,
            string_agg(DISTINCT f.name, ', '::text) AS names
           FROM ((darwin2.specimens s
             JOIN LATERAL darwin2.fct_get_tax_hierarchy(s.taxon_ref, ARRAY[12, 28]) f(r_start_id, id, name, level_ref, parent_ref) ON ((f.r_start_id = s.taxon_ref)))
             JOIN darwin2.collections c_1 ON (((((((s.collection_path)::text || '/'::text) || s.collection_ref) || '/'::text) ~~ (('%/'::text || c_1.id) || '/%'::text)) AND (c_1.publish_to_gbif = true))))
          GROUP BY c_1.id, f.level_ref
        ), classes_orders_coverage2 AS (
         SELECT classes.id,
            classes.names AS class_taxonomic_coverage,
            orders.names AS order_taxonomic_coverage
           FROM (classes_orders_coverage classes
             LEFT JOIN classes_orders_coverage orders ON ((orders.id = classes.id)))
          WHERE ((classes.level_ref = 12) AND (orders.level_ref = 28))
        )
 SELECT (((((((('The '::text || c.title_en) || ' contains '::text) || si.nb_spec) || ' digitised specimens over '::text) || sc.nb_species) || ' taxa (mostly species). The following classes are included: '::text) || coc.class_taxonomic_coverage) || '.'::text) AS abstract,
    'collection' AS scope,
    si.nb_spec,
    sc.nb_species,
    si.ig_num,
    c.code AS existing_code,
    c.id,
    c.name,
    c.name_indexed AS code,
    c.title_en,
    c.title_nl,
    c.title_fr,
    c.profile,
    gc.geographic_coverage,
    gc.min_lon,
    gc.max_lon,
    gc.min_lat,
    gc.max_lat,
        CASE
            WHEN (tc.date_from = 'xxxx-xx-xx'::text) THEN NULL::text
            ELSE tc.date_from
        END AS start_date,
        CASE
            WHEN (tc.date_to = 'xxxx-xx-xx'::text) THEN NULL::text
            ELSE tc.date_to
        END AS end_date,
    coc.class_taxonomic_coverage,
    coc.order_taxonomic_coverage,
    ('natural history collection, RBINS, DaRWIN, '::text || (c.name)::text) AS keywords,
    'Royal Belgian Institute for Natural Sciences' AS institute_name,
    'Department of ' AS institute_dept_abbrev,
    (((curator.given_name)::text || ' '::text) || (curator.family_name)::text) AS boss,
    uc1.entry AS boss_email,
    'curator' AS boss_role,
    (((staff.given_name)::text || ' '::text) || (staff.family_name)::text) AS subboss,
    uc2.entry AS subboss_email,
    'Collection manager' AS subboss_role
   FROM (((((((((darwin2.collections c
     LEFT JOIN specimen_info si ON ((c.id = si.id)))
     LEFT JOIN darwin2.users curator ON ((c.main_manager_ref = curator.id)))
     LEFT JOIN darwin2.users_comm uc1 ON (((uc1.person_user_ref = curator.id) AND ((uc1.comm_type)::text = 'e-mail'::text))))
     LEFT JOIN darwin2.users staff ON ((c.staff_ref = staff.id)))
     LEFT JOIN darwin2.users_comm uc2 ON (((uc2.person_user_ref = staff.id) AND ((uc2.comm_type)::text = 'e-mail'::text))))
     LEFT JOIN children_geographic_coverage gc ON ((gc.id = c.id)))
     LEFT JOIN children_temporal_coverage tc ON ((tc.id = c.id)))
     LEFT JOIN classes_orders_coverage2 coc ON ((coc.id = c.id)))
     LEFT JOIN species_coverage sc ON ((sc.id = c.id)))
  WHERE (c.publish_to_gbif = true)
  WITH NO DATA;


ALTER TABLE darwin2.mv_eml OWNER TO postgres;

--
-- TOC entry 442 (class 1259 OID 5308682)
-- Name: mv_eml_marine; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.mv_eml_marine AS
 SELECT replace(mv_eml.abstract, '(mostly species).'::text, '(mostly species). This dataset only contains the marine species of the collection.'::text) AS replace,
    mv_eml.scope,
    mv_eml.nb_spec,
    mv_eml.nb_species,
    mv_eml.ig_num,
    mv_eml.id,
    mv_eml.name,
    mv_eml.existing_code,
    mv_eml.code,
    mv_eml.title_en,
    mv_eml.title_nl,
    mv_eml.title_fr,
    mv_eml.profile,
    mv_eml.geographic_coverage,
    mv_eml.min_lon,
    mv_eml.max_lon,
    mv_eml.min_lat,
    mv_eml.max_lat,
    mv_eml.end_date,
    mv_eml.class_taxonomic_coverage,
    mv_eml.order_taxonomic_coverage,
    mv_eml.keywords,
    mv_eml.institute_name,
    mv_eml.institute_dept_abbrev,
    mv_eml.boss,
    mv_eml.boss_email,
    mv_eml.boss_role,
    mv_eml.subboss,
    mv_eml.subboss_email,
    mv_eml.subboss_role
   FROM darwin2.mv_eml
  WHERE (mv_eml.profile @> ARRAY['isMarine'::text])
  WITH NO DATA;


ALTER TABLE darwin2.mv_eml_marine OWNER TO darwin2;

--
-- TOC entry 443 (class 1259 OID 5308700)
-- Name: mv_spatial; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.mv_spatial AS
 WITH cte AS (
         SELECT properties.record_id,
            properties.property_type,
            properties.lower_value
           FROM darwin2.properties
          WHERE (((properties.referenced_relation)::text = 'gtu'::text) AND ((properties.property_type)::text = ANY (ARRAY[('datum'::character varying)::text, ('latitude'::character varying)::text, ('longitude'::character varying)::text])) AND (properties.record_id IN ( SELECT properties_1.record_id
                   FROM darwin2.properties properties_1
                  WHERE (((properties_1.referenced_relation)::text = 'gtu'::text) AND ((properties_1.property_type)::text = ANY (ARRAY[('latitude'::character varying)::text, ('longitude'::character varying)::text, ('datum'::character varying)::text])))
                  GROUP BY properties_1.record_id
                 HAVING (count(*) = 3))))
          ORDER BY properties.record_id, properties.property_type
        )
 SELECT cte.record_id,
        CASE cte.lower_value
            WHEN 'WGS84'::text THEN 4258
            WHEN 'ED50'::text THEN 4230
            ELSE NULL::integer
        END AS datum,
    cte2.lower_value AS prop_longitude,
    cte3.lower_value AS prop_latitude,
    public.st_transform(public.st_setsrid(public.st_makepoint(((cte2.lower_value)::numeric)::double precision, ((cte3.lower_value)::numeric)::double precision),
        CASE cte.lower_value
            WHEN 'WGS84'::text THEN 4258
            WHEN 'ED50'::text THEN 4230
            ELSE NULL::integer
        END), 4258) AS geometry,
    gtu.id,
    gtu.code,
    gtu.gtu_from_date_mask,
    gtu.gtu_from_date,
    gtu.gtu_to_date_mask,
    gtu.gtu_to_date,
    gtu.tag_values_indexed,
    gtu.latitude,
    gtu.longitude,
    gtu.lat_long_accuracy,
    gtu.elevation,
    gtu.elevation_accuracy,
    gtu.location
   FROM (((cte
     JOIN cte cte2 ON ((cte.record_id = cte2.record_id)))
     JOIN cte cte3 ON ((cte.record_id = cte3.record_id)))
     LEFT JOIN darwin2.gtu ON ((gtu.id = cte.record_id)))
  WHERE (((cte.property_type)::text = 'datum'::text) AND ((cte2.property_type)::text = 'longitude'::text) AND ((cte3.property_type)::text = 'latitude'::text))
  WITH NO DATA;


ALTER TABLE darwin2.mv_spatial OWNER TO darwin2;

--
-- TOC entry 440 (class 1259 OID 5308620)
-- Name: mv_tag_to_locations; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: postgres
--

CREATE MATERIALIZED VIEW darwin2.mv_tag_to_locations AS
 SELECT DISTINCT t.tag_value AS original_location,
    t.group_name_indexed AS original_type,
    t.sub_group_name_indexed AS original_sub_type,
        CASE t.sub_group_name_indexed
            WHEN 'abandonnedpopulatedplace'::text THEN 'PPLQ'::text
            WHEN 'abbey'::text THEN 'CTRR'::text
            WHEN 'abby'::text THEN 'CTRR'::text
            WHEN 'administrativedivision'::text THEN 'ADMD'::text
            WHEN 'administrativeregion'::text THEN 'ADMD'::text
            WHEN 'affluentzijriviertributary'::text THEN 'STM'::text
            WHEN 'airfield'::text THEN 'AIRF'::text
            WHEN 'airport'::text THEN 'AIRP'::text
            WHEN 'allotment'::text THEN ''::text
            WHEN 'altwasseropstuwingbackwater'::text THEN ''::text
            WHEN 'americanarmybase'::text THEN 'MILB'::text
            WHEN 'amphitheater'::text THEN 'AMTH'::text
            WHEN 'anabranch'::text THEN 'STMA'::text
            WHEN 'anchialinepool'::text THEN ''::text
            WHEN 'anchorage'::text THEN 'ANCH'::text
            WHEN 'anciennecarriereoudesteengroevequarry'::text THEN 'MNQR'::text
            WHEN 'ancientroad'::text THEN 'RDA'::text
            WHEN 'ancientsite'::text THEN 'ANS'::text
            WHEN 'appletreeappelboom'::text THEN 'TREE'::text
            WHEN 'aquarium'::text THEN ''::text
            WHEN 'aqueducsouterrainundergroundaqueduct'::text THEN 'CNLSB'::text
            WHEN 'aqueduct'::text THEN 'CNLA'::text
            WHEN 'arboretum'::text THEN 'GDN'::text
            WHEN 'archaeologicalsite'::text THEN 'ANS'::text
            WHEN 'arch'::text THEN 'ARCH'::text
            WHEN 'area'::text THEN 'AREA'::text
            WHEN 'arrondissement'::text THEN 'ADMD'::text
            WHEN 'autonomouscity'::text THEN 'PPL'::text
            WHEN 'autonomouscommunity'::text THEN 'PPL'::text
            WHEN 'autonomousconstituentcountry'::text THEN 'PCLI'::text
            WHEN 'autonomouscountry'::text THEN 'PCLI'::text
            WHEN 'autonomousprefecture'::text THEN 'ADMD'::text
            WHEN 'autonomousregion'::text THEN 'ADMD'::text
            WHEN 'badeseerecreatieplasbathinglakelacdebaignade'::text THEN ''::text
            WHEN 'basin'::text THEN 'BSNU'::text
            WHEN 'bassindechassespuikom'::text THEN ''::text
            WHEN 'bassindechasse'::text THEN ''::text
            WHEN 'bassinlocalappelation'::text THEN ''::text
            WHEN 'beacon'::text THEN 'BCN'::text
            WHEN 'beekbrook'::text THEN 'STM'::text
            WHEN 'beekjepetitruisseausmallstream'::text THEN 'STM'::text
            WHEN 'betweenislands'::text THEN ''::text
            WHEN 'billabong'::text THEN 'LKO'::text
            WHEN 'biogeografie'::text THEN ''::text
            WHEN 'biogeographicrealmecozone'::text THEN ''::text
            WHEN 'borough'::text THEN 'PPLX'::text
            WHEN 'bosdomein'::text THEN 'FRST'::text
            WHEN 'botanicalgarden'::text THEN 'GDN'::text
            WHEN 'branch'::text THEN ''::text
            WHEN 'brewery'::text THEN 'MFGB'::text
            WHEN 'bridge'::text THEN 'BDG'::text
            WHEN 'britishcentralafricaprotectorate'::text THEN 'PCLD'::text
            WHEN 'britishcrowndependency'::text THEN 'PCLD'::text
            WHEN 'britishoverseasterritories'::text THEN 'PCLD'::text
            WHEN 'buildings'::text THEN 'BLDG'::text
            WHEN 'bundeslanddeelstaatstate'::text THEN 'ADMD'::text
            WHEN 'bushes'::text THEN 'BUSH'::text
            WHEN 'caldera'::text THEN 'CLDA'::text
            WHEN 'camping'::text THEN ''::text
            WHEN 'camps'::text THEN 'CMP'::text
            WHEN 'canals'::text THEN 'CNL'::text
            WHEN 'canal'::text THEN 'CNL'::text
            WHEN 'canton'::text THEN 'ADMD'::text
            WHEN 'canyonlocalappelation'::text THEN 'CNYN'::text
            WHEN 'canyon'::text THEN 'CNYN'::text
            WHEN 'capital'::text THEN 'PPLC'::text
            WHEN 'career'::text THEN ''::text
            WHEN 'carrieregroeve'::text THEN ''::text
            WHEN 'castle'::text THEN 'CSTL'::text
            WHEN 'cattlestation'::text THEN 'AGRF'::text
            WHEN 'caves'::text THEN 'CAVE'::text
            WHEN 'cave'::text THEN 'CAVE'::text
            WHEN 'cayzandbankbancdesable'::text THEN 'BNKU'::text
            WHEN 'cenotelimestonesinkholes'::text THEN 'SINK'::text
            WHEN 'censusarea'::text THEN 'ADMD'::text
            WHEN 'censusdesignatedplace'::text THEN 'PPL'::text
            WHEN 'center'::text THEN 'PPLX'::text
            WHEN 'chapel'::text THEN 'CTRR'::text
            WHEN 'chateau'::text THEN 'CSTL'::text
            WHEN 'church'::text THEN 'CH'::text
            WHEN 'cirque'::text THEN 'CRQ'::text
            WHEN 'citadel'::text THEN ''::text
            WHEN 'citystate'::text THEN ''::text
            WHEN 'city'::text THEN 'PPL'::text
            WHEN 'civilparish'::text THEN 'PRSH'::text
            WHEN 'clearing'::text THEN 'CLG'::text
            WHEN 'cliffdwelling'::text THEN ''::text
            WHEN 'cloudforestedmountain'::text THEN ''::text
            WHEN 'coalmine'::text THEN 'MN'::text
            WHEN 'coastallakes'::text THEN ''::text
            WHEN 'college'::text THEN 'SCHC'::text
            WHEN 'colonialfederationkolonialefederatiefederationcoloniale'::text THEN ''::text
            WHEN 'colonykolonie'::text THEN 'PCLD'::text
            WHEN 'col'::text THEN 'PASS'::text
            WHEN 'commonwealthrealm'::text THEN ''::text
            WHEN 'commonwealth'::text THEN ''::text
            WHEN 'communeafacilitesfaciliteitengemeente'::text THEN ''::text
            WHEN 'commune'::text THEN 'PPL'::text
            WHEN 'community'::text THEN 'PPL'::text
            WHEN 'complexvolcanocompoundvolcano'::text THEN 'VLC'::text
            WHEN 'condominium'::text THEN ''::text
            WHEN 'cones'::text THEN 'CONE'::text
            WHEN 'confluence'::text THEN 'CNFL'::text
            WHEN 'constituentcountry'::text THEN 'PCLI'::text
            WHEN 'continent'::text THEN 'CONT'::text
            WHEN 'cordilleracordillere'::text THEN 'CDAU'::text
            WHEN 'cornichecornice'::text THEN ''::text
            WHEN 'councilarea'::text THEN ''::text
            WHEN 'countryhouse'::text THEN 'HSEC'::text
            WHEN 'country'::text THEN 'PCLI'::text
            WHEN 'county'::text THEN 'ADMD'::text
            WHEN 'crag'::text THEN 'BUTE'::text
            WHEN 'craterlake'::text THEN 'LKC'::text
            WHEN 'craters'::text THEN 'CRTR'::text
            WHEN 'creek'::text THEN 'STM'::text
            WHEN 'crevassespleet'::text THEN ''::text
            WHEN 'crowncolony'::text THEN 'PCLD'::text
            WHEN 'culvertsiphon'::text THEN ''::text
            WHEN 'dam'::text THEN 'DAM'::text
            WHEN 'delta'::text THEN 'DLTA'::text
            WHEN 'departement'::text THEN 'ADMD'::text
            WHEN 'departmentdepartement'::text THEN 'ADMD'::text
            WHEN 'department'::text THEN 'ADMD'::text
            WHEN 'dependentpoliticalentity'::text THEN 'PCLD'::text
            WHEN 'depressions'::text THEN 'DPR'::text
            WHEN 'desert'::text THEN 'DSRT'::text
            WHEN 'destroyedpopulatedplace'::text THEN 'PPLW'::text
            WHEN 'distributaryies'::text THEN 'STMD'::text
            WHEN 'district'::text THEN 'PPLX'::text
            WHEN 'ditch'::text THEN 'DTCH'::text
            WHEN 'divesite'::text THEN ''::text
            WHEN 'division'::text THEN 'PPLX'::text
            WHEN 'domaineprovincial'::text THEN 'PRK'::text
            WHEN 'domaniaalnatuurreservaatreservenaturelledomanialestatenaturereserve'::text THEN 'RES'::text
            WHEN 'domein'::text THEN ''::text
            WHEN 'dorpvillage'::text THEN 'PPL'::text
            WHEN 'drainagebassin'::text THEN 'BSND'::text
            WHEN 'drainagecanal'::text THEN 'CNLD'::text
            WHEN 'drainageditch'::text THEN 'DTCHD'::text
            WHEN 'drain'::text THEN ''::text
            WHEN 'dreefdreve'::text THEN 'RD'::text
            WHEN 'drystreambed'::text THEN 'SBED'::text
            WHEN 'duchy'::text THEN 'ADMD'::text
            WHEN 'duinen'::text THEN 'DUNE'::text
            WHEN 'dunes'::text THEN 'DUNE'::text
            WHEN 'dutchempire'::text THEN 'PCLH'::text
            WHEN 'ecology'::text THEN ''::text
            WHEN 'ecoregion'::text THEN ''::text
            WHEN 'elevation'::text THEN ''::text
            WHEN 'elfinforest'::text THEN 'FRST'::text
            WHEN 'enterprise'::text THEN ''::text
            WHEN 'escarpment'::text THEN 'SCRP'::text
            WHEN 'estates'::text THEN 'EST'::text
            WHEN 'etangdepechevisvijverfishingpond'::text THEN 'PNDSF'::text
            WHEN 'etangenassec'::text THEN 'PND'::text
            WHEN 'etangvijverpond'::text THEN 'PND'::text
            WHEN 'exlave'::text THEN ''::text
            WHEN 'exsurgence'::text THEN 'STMSB'::text
            WHEN 'falls'::text THEN 'FLLS'::text
            WHEN 'farmstead'::text THEN 'FRMT'::text
            WHEN 'farms'::text THEN 'FRMS'::text
            WHEN 'farm'::text THEN 'FRM'::text
            WHEN 'federaldistrict'::text THEN 'ADMD'::text
            WHEN 'federalsubject'::text THEN ''::text
            WHEN 'federatestate'::text THEN 'PCLI'::text
            WHEN 'fields'::text THEN 'FLD'::text
            WHEN 'firstorderadministrativedivision'::text THEN 'ADM1'::text
            WHEN 'fischerdorfvissersdorp'::text THEN 'PPL'::text
            WHEN 'fischteichvisvijvervivierfishpond'::text THEN 'PNDSF'::text
            WHEN 'fishery'::text THEN 'FISH'::text
            WHEN 'fishfarm'::text THEN 'AQC'::text
            WHEN 'fishingarea'::text THEN 'FISH'::text
            WHEN 'fishingvillage'::text THEN 'PPL'::text
            WHEN 'fishpond'::text THEN 'PNDSF'::text
            WHEN 'flachmoorboglaagveentourbiereombrotrophe'::text THEN 'BOG'::text
            WHEN 'floodedquarrycarriereinondee'::text THEN 'MNQ'::text
            WHEN 'floodplainoverstromingsvlaktelit'::text THEN ''::text
            WHEN 'flow'::text THEN ''::text
            WHEN 'ford'::text THEN 'FORD'::text
            WHEN 'forestbeltceinturedeforetbosgordel'::text THEN 'FRST'::text
            WHEN 'forestforetbos'::text THEN 'FRST'::text
            WHEN 'forestlitterbosstrooisellitiereforestiere'::text THEN ''::text
            WHEN 'forestreserve'::text THEN 'RESF'::text
            WHEN 'forest'::text THEN 'FRST'::text
            WHEN 'foretwoudforest'::text THEN 'FRST'::text
            WHEN 'formersugarmill'::text THEN 'MLSGQ'::text
            WHEN 'fortress'::text THEN 'FT'::text
            WHEN 'fort'::text THEN 'FT'::text
            WHEN 'fosse'::text THEN 'DTCH'::text
            WHEN 'fourthorderadministrativedivision'::text THEN 'ADM4'::text
            WHEN 'frazione'::text THEN 'PPLX'::text
            WHEN 'frenchcolony'::text THEN 'PCLD'::text
            WHEN 'frenchprotectorate'::text THEN 'PCLD'::text
            WHEN 'gap'::text THEN 'GAP'::text
            WHEN 'gardens'::text THEN 'GDN'::text
            WHEN 'garden'::text THEN 'GDN'::text
            WHEN 'gebouw'::text THEN 'BLDG'::text
            WHEN 'gehuchthameauhamlet'::text THEN 'PPLL'::text
            WHEN 'gemeentecommune'::text THEN 'PPLA4'::text
            WHEN 'gemeindegemeenschapmunicipalitycommunaute'::text THEN 'PPLA4'::text
            WHEN 'gemeindemunicipality'::text THEN 'PPLA4'::text
            WHEN 'geologicformation'::text THEN ''::text
            WHEN 'germancolonialempiredeutscheskolonialreich'::text THEN 'PCLD'::text
            WHEN 'gewestcommunauteregion'::text THEN 'ADMD'::text
            WHEN 'geyser'::text THEN 'GYSR'::text
            WHEN 'ghosttown'::text THEN 'PPLQ'::text
            WHEN 'glaciallake'::text THEN 'LK'::text
            WHEN 'glacier'::text THEN 'GLCR'::text
            WHEN 'goldminingtown'::text THEN 'PPL'::text
            WHEN 'golftresort'::text THEN 'RECG'::text
            WHEN 'gorges'::text THEN 'GRGE'::text
            WHEN 'governorate'::text THEN 'ADMD'::text
            WHEN 'gracht'::text THEN 'DTCH'::text
            WHEN 'grassland'::text THEN 'GRSLD'::text
            WHEN 'grazingarea'::text THEN 'GRAZ'::text
            WHEN 'greenhouseserre'::text THEN ''::text
            WHEN 'groevecarrierequarry'::text THEN 'MNQR'::text
            WHEN 'grotgrottecave'::text THEN 'CAVE'::text
            WHEN 'groundwatereauxsouterrainesgrondwater'::text THEN ''::text
            WHEN 'guesthouse'::text THEN ''::text
            WHEN 'gully'::text THEN 'GLYU'::text
            WHEN 'hacienda'::text THEN 'FRMT'::text
            WHEN 'hameau'::text THEN 'PPLL'::text
            WHEN 'hamlethameau'::text THEN 'PPLL'::text
            WHEN 'hamlet'::text THEN 'PPLL'::text
            WHEN 'harbour'::text THEN 'HBR'::text
            WHEN 'head'::text THEN 'HDLD'::text
            WHEN 'heath'::text THEN 'HTH'::text
            WHEN 'highprairiehautesprairieshogeweide'::text THEN ''::text
            WHEN 'highway'::text THEN 'RD'::text
            WHEN 'hillresort'::text THEN 'RSRT'::text
            WHEN 'hillstation'::text THEN ''::text
            WHEN 'hills'::text THEN 'HLLS'::text
            WHEN 'hill'::text THEN 'HLL'::text
            WHEN 'hippodroomhippodrome'::text THEN 'RECR'::text
            WHEN 'historicalcountry'::text THEN 'PCLH'::text
            WHEN 'historicalregion'::text THEN 'RGNH'::text
            WHEN 'historicstate'::text THEN 'PCLH'::text
            WHEN 'hole'::text THEN 'HOLU'::text
            WHEN 'holleweg'::text THEN 'RD'::text
            WHEN 'homestead'::text THEN 'HMSD'::text
            WHEN 'hoofdstedelijkgewest'::text THEN 'ADMD'::text
            WHEN 'hoogvlaktehighlandmassifmontagneux'::text THEN 'PLAT'::text
            WHEN 'hotel'::text THEN 'HTL'::text
            WHEN 'hotsprings'::text THEN 'SPNT'::text
            WHEN 'houses'::text THEN 'HSE'::text
            WHEN 'hut'::text THEN 'HUT'::text
            WHEN 'hyporheiczone'::text THEN ''::text
            WHEN 'iceshelves'::text THEN ''::text
            WHEN 'independentpoliticalentity'::text THEN 'PCLI'::text
            WHEN 'indianreservation'::text THEN 'RESV'::text
            WHEN 'institute'::text THEN 'FCL'::text
            WHEN 'intermittentlake'::text THEN 'LKI'::text
            WHEN 'intermittentstream'::text THEN 'STMI'::text
            WHEN 'intersectionroad'::text THEN 'RD'::text
            WHEN 'interstitialwater'::text THEN ''::text
            WHEN 'intertidalzone'::text THEN ''::text
            WHEN 'irrigationcanal'::text THEN 'CNLI'::text
            WHEN 'islandcountry'::text THEN 'ISL'::text
            WHEN 'islandstation'::text THEN ''::text
            WHEN 'islands'::text THEN 'ISLS'::text
            WHEN 'island'::text THEN 'ISL'::text
            WHEN 'isle'::text THEN 'ISL'::text
            WHEN 'islet'::text THEN 'ISLET'::text
            WHEN 'jettysteigerjetee'::text THEN 'JTY'::text
            WHEN 'jeugdverblijf'::text THEN ''::text
            WHEN 'kanaalcanalchannel'::text THEN 'CHN'::text
            WHEN 'kanton'::text THEN 'ADMD'::text
            WHEN 'karstique'::text THEN 'KRST'::text
            WHEN 'keizerrijk'::text THEN 'PCLH'::text
            WHEN 'kerncentralenuclearpowerplant'::text THEN 'PS'::text
            WHEN 'kettleholetoteisseedoodijsgat'::text THEN ''::text
            WHEN 'kingdom'::text THEN 'PCLI'::text
            WHEN 'kloof'::text THEN 'CNYN'::text
            WHEN 'kolk'::text THEN ''::text
            WHEN 'koolmijncoalmineminedecharbon'::text THEN 'MN'::text
            WHEN 'kreisdistrictarrondissement'::text THEN 'ADMD'::text
            WHEN 'kreisfreiestadt'::text THEN 'PPL'::text
            WHEN 'lakechannels'::text THEN 'CHNL'::text
            WHEN 'lakes'::text THEN 'LKS'::text
            WHEN 'lake'::text THEN 'LK'::text
            WHEN 'landing'::text THEN 'LDNG'::text
            WHEN 'landkreisprovinciedistrictcomte'::text THEN 'ADMD'::text
            WHEN 'leaflitterbladafvallitiere'::text THEN ''::text
            WHEN 'legaldistrict'::text THEN 'PPLX'::text
            WHEN 'leveedijkdigue'::text THEN 'LEV'::text
            WHEN 'lieuditlocalityplaats'::text THEN 'LCTY'::text
            WHEN 'lieudit'::text THEN 'LCTY'::text
            WHEN 'lieudittopografie'::text THEN 'LCTY'::text
            WHEN 'lieutenancyarea'::text THEN ''::text
            WHEN 'lighthouse'::text THEN 'LTHSE'::text
            WHEN 'limestoneplateaus'::text THEN 'KRST'::text
            WHEN 'littoralvegetation'::text THEN ''::text
            WHEN 'littoralzone'::text THEN ''::text
            WHEN 'localgovernmentarea'::text THEN 'ADMD'::text
            WHEN 'localgovernment'::text THEN 'ADMD'::text
            WHEN 'locality'::text THEN 'LCTY'::text
            WHEN 'location'::text THEN 'LCTY'::text
            WHEN 'locksluisecluse'::text THEN 'SLCE'::text
            WHEN 'longdistancefootpaths'::text THEN 'TRL'::text
            WHEN 'lowlandslaagte'::text THEN ''::text
            WHEN 'maison'::text THEN 'HSE'::text
            WHEN 'mandatmandaat'::text THEN ''::text
            WHEN 'marineandcoastalprotectedarea'::text THEN 'RES'::text
            WHEN 'market'::text THEN 'MKT'::text
            WHEN 'markettown'::text THEN 'PPL'::text
            WHEN 'marshes'::text THEN 'MRSH'::text
            WHEN 'marshmoeras'::text THEN 'MRSH'::text
            WHEN 'massif'::text THEN 'MTS'::text
            WHEN 'massive'::text THEN ''::text
            WHEN 'mausoleum'::text THEN 'TMB'::text
            WHEN 'memorialpark'::text THEN 'PRK'::text
            WHEN 'mesas'::text THEN 'MESA'::text
            WHEN 'mesoregio'::text THEN ''::text
            WHEN 'meteorologicalstation'::text THEN 'STNM'::text
            WHEN 'metropolitanarea'::text THEN 'PPLX'::text
            WHEN 'metropolitanborough'::text THEN 'PPLX'::text
            WHEN 'microregio'::text THEN ''::text
            WHEN 'militaryairbase'::text THEN 'MILB'::text
            WHEN 'militarybase'::text THEN 'MILB'::text
            WHEN 'mills'::text THEN 'ML'::text
            WHEN 'mines'::text THEN 'MN'::text
            WHEN 'mirador'::text THEN ''::text
            WHEN 'missionaryoutpost'::text THEN 'MSSN'::text
            WHEN 'mission'::text THEN 'MSSN'::text
            WHEN 'moat'::text THEN 'MOTU'::text
            WHEN 'moerasmaraismarches'::text THEN 'MRSH'::text
            WHEN 'monastery'::text THEN 'MSTY'::text
            WHEN 'monts'::text THEN 'MTS'::text
            WHEN 'mosquee'::text THEN 'MSQE'::text
            WHEN 'moss'::text THEN ''::text
            WHEN 'mounds'::text THEN 'MND'::text
            WHEN 'mountainforest'::text THEN 'FRST'::text
            WHEN 'mountainpass'::text THEN 'PASS'::text
            WHEN 'mountainpeak'::text THEN 'PK'::text
            WHEN 'mountainrange'::text THEN 'MTS'::text
            WHEN 'mountains'::text THEN 'MTS'::text
            WHEN 'mountain'::text THEN 'MT'::text
            WHEN 'mountainvillage'::text THEN 'PPL'::text
            WHEN 'mounts'::text THEN 'MTS'::text
            WHEN 'municipality'::text THEN 'PPLA4'::text
            WHEN 'municipalunit'::text THEN 'PPLA4'::text
            WHEN 'museum'::text THEN 'MUS'::text
            WHEN 'musselbeds'::text THEN ''::text
            WHEN 'narrows'::text THEN 'NRWS'::text
            WHEN 'nationaalparkparcnational'::text THEN 'RES'::text
            WHEN 'nationalforest'::text THEN ''::text
            WHEN 'nationalpark'::text THEN 'RES'::text
            WHEN 'nationalreserve'::text THEN ''::text
            WHEN 'naturalarchnaturalbridge'::text THEN ''::text
            WHEN 'naturallandscape'::text THEN ''::text
            WHEN 'naturalregion'::text THEN 'RES'::text
            WHEN 'naturalsite'::text THEN 'RES'::text
            WHEN 'naturepark'::text THEN ''::text
            WHEN 'naturereservenaturalreservebioreserve'::text THEN ''::text
            WHEN 'naturereserve'::text THEN 'RESN'::text
            WHEN 'naturschutzgebietnatuurreservaatnaturereservereservenaturelle'::text THEN 'RES'::text
            WHEN 'natuurgebied'::text THEN 'RES'::text
            WHEN 'necropole'::text THEN 'TMB'::text
            WHEN 'neighbourhood'::text THEN 'PPLX'::text
            WHEN 'nile'::text THEN ''::text
            WHEN 'oasiscity'::text THEN ''::text
            WHEN 'oasises'::text THEN 'OAS'::text
            WHEN 'oasis'::text THEN 'OAS'::text
            WHEN 'oblast'::text THEN 'ADM2'::text
            WHEN 'observatory'::text THEN 'OBS'::text
            WHEN 'occupiedterritory'::text THEN ''::text
            WHEN 'ocean'::text THEN 'OCN'::text
            WHEN 'oeverbank'::text THEN ''::text
            WHEN 'oilfield'::text THEN 'OILF'::text
            WHEN 'oilrefinery'::text THEN 'OILR'::text
            WHEN 'ortsteilwijkdistrictquartier'::text THEN ''::text
            WHEN 'oued'::text THEN 'WAD'::text
            WHEN 'outflow'::text THEN ''::text
            WHEN 'overseascollectivity'::text THEN ''::text
            WHEN 'overseasdepartmentsandterritoriesoffrance'::text THEN 'ADMD'::text
            WHEN 'overseasregion'::text THEN 'ADMD'::text
            WHEN 'overseasterritory'::text THEN 'ADMD'::text
            WHEN 'paalweringpileresistance'::text THEN ''::text
            WHEN 'paddyswamp'::text THEN ''::text
            WHEN 'palace'::text THEN 'PAL'::text
            WHEN 'pan'::text THEN 'PAN'::text
            WHEN 'parish'::text THEN 'PRSH'::text
            WHEN 'parkparc'::text THEN 'PRK'::text
            WHEN 'park'::text THEN 'PRK'::text
            WHEN 'paroisseparochieparish'::text THEN 'PRSH'::text
            WHEN 'part'::text THEN 'PPLX'::text
            WHEN 'passage'::text THEN ''::text
            WHEN 'pass'::text THEN 'PASS'::text
            WHEN 'path'::text THEN 'TRL'::text
            WHEN 'payslocalappelation'::text THEN 'PCLI'::text
            WHEN 'peak'::text THEN 'PK'::text
            WHEN 'peninsula'::text THEN 'PEN'::text
            WHEN 'periphery'::text THEN 'PPLX'::text
            WHEN 'petitaffluent'::text THEN ''::text
            WHEN 'petitecommunedeelgemeente'::text THEN 'PPLA4'::text
            WHEN 'phreaticzone'::text THEN ''::text
            WHEN 'pitcavegouffreondergrondsekalksteenkoepel'::text THEN ''::text
            WHEN 'place'::text THEN 'LCTY'::text
            WHEN 'plains'::text THEN 'PLN'::text
            WHEN 'plantation'::text THEN 'AGRC'::text
            WHEN 'plantentuinbotanicalgardenjardinbotanique'::text THEN 'GDN'::text
            WHEN 'plant'::text THEN ''::text
            WHEN 'plateau'::text THEN 'PLAT'::text
            WHEN 'point'::text THEN 'PT'::text
            WHEN 'polarresearchstation'::text THEN 'STNB'::text
            WHEN 'polder'::text THEN 'PLDR'::text
            WHEN 'politicalentity'::text THEN 'PCL'::text
            WHEN 'ponds'::text THEN 'PNDS'::text
            WHEN 'pond'::text THEN 'PND'::text
            WHEN 'pontbrugbridge'::text THEN 'BDG'::text
            WHEN 'pools'::text THEN 'POOL'::text
            WHEN 'populatedlocality'::text THEN 'PPLL'::text
            WHEN 'populatedplaces'::text THEN 'PPLS'::text
            WHEN 'populatedplace'::text THEN 'PPL'::text
            WHEN 'poste'::text THEN ''::text
            WHEN 'powerstation'::text THEN 'PS'::text
            WHEN 'prefecturallevelcity'::text THEN 'PPLG'::text
            WHEN 'prefecture'::text THEN 'ADMD'::text
            WHEN 'prehistoricsite'::text THEN 'ANS'::text
            WHEN 'presquile'::text THEN 'PEN'::text
            WHEN 'principalityprincedom'::text THEN 'PCLI'::text
            WHEN 'principaute'::text THEN 'PCLI'::text
            WHEN 'priory'::text THEN 'CTRR'::text
            WHEN 'prison'::text THEN 'PRN'::text
            WHEN 'promontoryies'::text THEN 'PROM'::text
            WHEN 'protectedarea'::text THEN 'PCLD'::text
            WHEN 'protectorate'::text THEN 'PCLD'::text
            WHEN 'province'::text THEN 'ADMD'::text
            WHEN 'provinciaaldomeinprovincialdomain'::text THEN 'PRK'::text
            WHEN 'provinciaaldomein'::text THEN 'PRK'::text
            WHEN 'provincialcapital'::text THEN 'PPLG'::text
            WHEN 'provincialdomain'::text THEN 'PRK'::text
            WHEN 'pub'::text THEN 'REST'::text
            WHEN 'puddles'::text THEN ''::text
            WHEN 'puntapuentepointe'::text THEN 'PT'::text
            WHEN 'quarrycarrieresteengroeve'::text THEN 'MNQR'::text
            WHEN 'quarry'::text THEN 'MNQR'::text
            WHEN 'quartier'::text THEN 'PPLX'::text
            WHEN 'racetrack'::text THEN 'RECR'::text
            WHEN 'railroadsiding'::text THEN 'RSD'::text
            WHEN 'railroadstation'::text THEN 'RSTN'::text
            WHEN 'railroadstop'::text THEN 'RSTP'::text
            WHEN 'railroad'::text THEN 'RR'::text
            WHEN 'rainforestforetombrophileregenwoud'::text THEN ''::text
            WHEN 'rainforest'::text THEN 'FRST'::text
            WHEN 'ranches'::text THEN 'RNCH'::text
            WHEN 'rangelocalappelation'::text THEN 'MTS'::text
            WHEN 'rapids'::text THEN 'RPDS'::text
            WHEN 'ravines'::text THEN 'RVN'::text
            WHEN 'ravine'::text THEN 'CNYU'::text
            WHEN 'reach'::text THEN 'RCH'::text
            WHEN 'recreatiedomein'::text THEN 'PRK'::text
            WHEN 'recreationparc'::text THEN 'PRK'::text
            WHEN 'recyclingcenter'::text THEN 'LNDF'::text
            WHEN 'refstockmans'::text THEN ''::text
            WHEN 'refuge'::text THEN ''::text
            WHEN 'regency'::text THEN ''::text
            WHEN 'regionalunit'::text THEN 'ADMD'::text
            WHEN 'regionordistrict'::text THEN 'ADMD'::text
            WHEN 'region'::text THEN 'RGN'::text
            WHEN 'religioussite'::text THEN 'RLG'::text
            WHEN 'republic'::text THEN 'PCLI'::text
            WHEN 'researchinstitute'::text THEN 'ITTR'::text
            WHEN 'researchstation'::text THEN ''::text
            WHEN 'reservaatreservation'::text THEN 'RES'::text
            WHEN 'reserve'::text THEN 'RES'::text
            WHEN 'reservoirs'::text THEN 'RSV'::text
            WHEN 'residentialarea'::text THEN 'PPLX'::text
            WHEN 'resort'::text THEN 'RSRT'::text
            WHEN 'ressort'::text THEN 'RSRT'::text
            WHEN 'restaurant'::text THEN 'REST'::text
            WHEN 'resurgence'::text THEN 'STMSB'::text
            WHEN 'ridges'::text THEN 'RDGE'::text
            WHEN 'rim'::text THEN 'SCRP'::text
            WHEN 'rio'::text THEN 'STM'::text
            WHEN 'river'::text THEN 'STM'::text
            WHEN 'rivulet'::text THEN 'STM'::text
            WHEN 'roadhouse'::text THEN ''::text
            WHEN 'roadjunction'::text THEN 'RDJCT'::text
            WHEN 'roadsted'::text THEN 'RDST'::text
            WHEN 'road'::text THEN 'RD'::text
            WHEN 'rocks'::text THEN 'RKS'::text
            WHEN 'rock'::text THEN 'RK'::text
            WHEN 'route'::text THEN 'RD'::text
            WHEN 'ruins'::text THEN 'RUIN'::text
            WHEN 'saltarea'::text THEN 'SALT'::text
            WHEN 'saltlake'::text THEN 'LKN'::text
            WHEN 'saltmarsh'::text THEN 'MRSHN'::text
            WHEN 'sanctuary'::text THEN 'CTRR'::text
            WHEN 'sandmeerergduinmassiefmassifdedunes'::text THEN 'DUNE'::text
            WHEN 'sand'::text THEN ''::text
            WHEN 'saturatedkarst'::text THEN 'KRST'::text
            WHEN 'school'::text THEN 'SCH'::text
            WHEN 'scientificresearchbase'::text THEN 'STNB'::text
            WHEN 'sealoch'::text THEN 'FJD'::text
            WHEN 'seamarknavigationmark'::text THEN ''::text
            WHEN 'seamount'::text THEN 'SMU'::text
            WHEN 'seaplanelandingarea'::text THEN 'AIRS'::text
            WHEN 'seasidesuburb'::text THEN 'PPLX'::text
            WHEN 'seatofafirstorderadministrativedivision'::text THEN 'PPLA'::text
            WHEN 'seatofasecondorderadministrativedivision'::text THEN 'PPLA2'::text
            WHEN 'seatofathirdorderadministrativedivision'::text THEN 'PPLA3'::text
            WHEN 'secondorderadministrativedivision'::text THEN 'ADM2'::text
            WHEN 'sectionofpopulatedplace'::text THEN 'PPLX'::text
            WHEN 'sectionofrussianempire'::text THEN 'ADMDH'::text
            WHEN 'sectionofstream'::text THEN 'STMX'::text
            WHEN 'section'::text THEN 'PPLX'::text
            WHEN 'sector'::text THEN 'PPLX'::text
            WHEN 'seep'::text THEN ''::text
            WHEN 'semiautonomousregion'::text THEN 'ADMD'::text
            WHEN 'settlement'::text THEN 'PPLL'::text
            WHEN 'sherpavillage'::text THEN 'PPLL'::text
            WHEN 'shore'::text THEN 'SHOR'::text
            WHEN 'shrine'::text THEN 'SHRN'::text
            WHEN 'shrubbeltceinturearbustivestruikgordel'::text THEN ''::text
            WHEN 'siedlungsbereichenwoongebied'::text THEN ''::text
            WHEN 'sierra'::text THEN 'MTS'::text
            WHEN 'sinkholezinkgatdoline'::text THEN 'SINK'::text
            WHEN 'site'::text THEN 'LCTY'::text
            WHEN 'slootditchwassergrabenfosse'::text THEN 'DTCH'::text
            WHEN 'slope'::text THEN 'SLPU'::text
            WHEN 'sluissas'::text THEN 'SLCE'::text
            WHEN 'smallisland'::text THEN 'ISLET'::text
            WHEN 'smallwaterfallkleinewatervalcascatelle'::text THEN 'FLLS'::text
            WHEN 'sound'::text THEN 'SD'::text
            WHEN 'source'::text THEN 'SPNG'::text
            WHEN 'sovereigncitystate'::text THEN 'ADMD'::text
            WHEN 'sovereignstate'::text THEN 'PCLI'::text
            WHEN 'spa'::text THEN 'SPA'::text
            WHEN 'specializedmunicipality'::text THEN 'ADM4'::text
            WHEN 'spillway'::text THEN 'SPLY'::text
            WHEN 'sportcomplex'::text THEN 'ATHF'::text
            WHEN 'springs'::text THEN 'SPNG'::text
            WHEN 'stadion'::text THEN 'ATHF'::text
            WHEN 'stadtteilebuurtneighborhoodsquartiers'::text THEN 'PPLX'::text
            WHEN 'stadvilletown'::text THEN 'PPL'::text
            WHEN 'stagnantwater'::text THEN ''::text
            WHEN 'stateforest'::text THEN 'RES'::text
            WHEN 'stateorprovince'::text THEN 'ADMD'::text
            WHEN 'stateorterritory'::text THEN 'ADMD'::text
            WHEN 'statepark'::text THEN 'RES'::text
            WHEN 'state'::text THEN 'ADMD'::text
            WHEN 'stationbalneaire'::text THEN 'SPA'::text
            WHEN 'stationdepurationafvalwaterzuiveringsinstallatiewastewatertreatmentplant'::text THEN 'SWT'::text
            WHEN 'station'::text THEN 'LCTY'::text
            WHEN 'stationzoologique'::text THEN ''::text
            WHEN 'stauseereservoir'::text THEN 'RSV'::text
            WHEN 'steppe'::text THEN ''::text
            WHEN 'steps'::text THEN 'STPS'::text
            WHEN 'store'::text THEN 'RET'::text
            WHEN 'straatruestreet'::text THEN 'RD'::text
            WHEN 'strait'::text THEN 'STRT'::text
            WHEN 'stratovolcano'::text THEN 'VLC'::text
            WHEN 'streampool'::text THEN ''::text
            WHEN 'streams'::text THEN 'STMS'::text
            WHEN 'stream'::text THEN 'STM'::text
            WHEN 'street'::text THEN 'RD'::text
            WHEN 'stretch'::text THEN ''::text
            WHEN 'subcontinenet'::text THEN 'CONT'::text
            WHEN 'subcountyconstituency'::text THEN 'ADMD'::text
            WHEN 'subdistrict'::text THEN 'PPLX'::text
            WHEN 'subdivisionadministrative'::text THEN 'ADMD'::text
            WHEN 'subdivision'::text THEN 'ADMD'::text
            WHEN 'subprefecturessousprefectures'::text THEN 'ADMD'::text
            WHEN 'subprefecture'::text THEN 'ADMD'::text
            WHEN 'subregion'::text THEN 'ADMD'::text
            WHEN 'suburbanarea'::text THEN 'PPLX'::text
            WHEN 'suburb'::text THEN 'PPLX'::text
            WHEN 'summitoftheislandsommetdelile'::text THEN 'PK'::text
            WHEN 'swamp'::text THEN 'SWMP'::text
            WHEN 'tabletopmountain'::text THEN 'MESA'::text
            WHEN 'temples'::text THEN 'TMPL'::text
            WHEN 'temple'::text THEN 'TMPL'::text
            WHEN 'terrasse'::text THEN ''::text
            WHEN 'territory'::text THEN 'TERR'::text
            WHEN 'thirdorderadministrativedivision'::text THEN 'ADM3'::text
            WHEN 'tidalcreek'::text THEN 'CRKT'::text
            WHEN 'torfsumpfpeatswampturfmoerasmaraistourbeux'::text THEN 'BOG'::text
            WHEN 'tower'::text THEN 'TOWR'::text
            WHEN 'township'::text THEN 'PPL'::text
            WHEN 'town'::text THEN 'PPL'::text
            WHEN 'trail'::text THEN 'TRL'::text
            WHEN 'trainstation'::text THEN 'RSTN'::text
            WHEN 'transbordeurpontferry'::text THEN ''::text
            WHEN 'trawl'::text THEN ''::text
            WHEN 'trees'::text THEN 'TREE'::text
            WHEN 'tribalarea'::text THEN 'TRB'::text
            WHEN 'tuinjardingarden'::text THEN 'GDN'::text
            WHEN 'tunnel'::text THEN 'TNL'::text
            WHEN 'undefined'::text THEN NULL::text
            WHEN 'undergroundlake'::text THEN 'LKSB'::text
            WHEN 'undergroundriver'::text THEN 'STMSB'::text
            WHEN 'underseaplateau'::text THEN 'PLTU'::text
            WHEN 'unescoworldheritagesite'::text THEN ''::text
            WHEN 'unincorporatedarea'::text THEN ''::text
            WHEN 'unincorporatedcommunity'::text THEN 'PPL'::text
            WHEN 'unitaryauthority'::text THEN ''::text
            WHEN 'unitesstates'::text THEN ''::text
            WHEN 'university'::text THEN 'UNIV'::text
            WHEN 'unknown'::text THEN 'll'::text
            WHEN 'upland'::text THEN 'UPLD'::text
            WHEN 'urbanforest'::text THEN 'FRST'::text
            WHEN 'urbantypesettlement'::text THEN 'PPL'::text
            WHEN 'vaartchannel'::text THEN 'CHN'::text
            WHEN 'vadose'::text THEN ''::text
            WHEN 'valleys'::text THEN 'VALS'::text
            WHEN 'valley'::text THEN 'VAL'::text
            WHEN 'vennenfagnesfens'::text THEN 'MOOR'::text
            WHEN 'view'::text THEN ''::text
            WHEN 'vijveretangpond'::text THEN 'PND'::text
            WHEN 'villagedevelopmentcommittee'::text THEN ''::text
            WHEN 'village'::text THEN 'PPL'::text
            WHEN 'villemetropolitaine'::text THEN 'PPL'::text
            WHEN 'vishandel'::text THEN ''::text
            WHEN 'viskwekerijpisciculturehatchery'::text THEN 'AQC'::text
            WHEN 'vlasrootput'::text THEN ''::text
            WHEN 'vlei'::text THEN ''::text
            WHEN 'volcanicarchipelago'::text THEN 'ISLS'::text
            WHEN 'volcaniccavegrottevolcanique'::text THEN 'CAVE'::text
            WHEN 'volcanicisland'::text THEN 'ISL'::text
            WHEN 'volcano'::text THEN 'VLC'::text
            WHEN 'wadi'::text THEN 'WAD'::text
            WHEN 'ward'::text THEN 'PPLX'::text
            WHEN 'watercourse'::text THEN 'WTRC'::text
            WHEN 'waterfalls'::text THEN 'FLLS'::text
            WHEN 'waterfall'::text THEN 'FLLS'::text
            WHEN 'waterholes'::text THEN 'WTRH'::text
            WHEN 'wateringwatermeadow'::text THEN ''::text
            WHEN 'waterketelboilerchaudiere'::text THEN ''::text
            WHEN 'watermolen'::text THEN 'MLWTR'::text
            WHEN 'waterpits'::text THEN 'WLL'::text
            WHEN 'waterplas'::text THEN ''::text
            WHEN 'waterspring'::text THEN 'SPNG'::text
            WHEN 'watertube'::text THEN ''::text
            WHEN 'watervoorzieningarriveedeauwatersupply'::text THEN ''::text
            WHEN 'waterwaywaterloop'::text THEN 'WTRC'::text
            WHEN 'weatherstation'::text THEN 'STNM'::text
            WHEN 'weg'::text THEN 'RD'::text
            WHEN 'wells'::text THEN 'WLLS'::text
            WHEN 'well'::text THEN 'WLL'::text
            WHEN 'wetland'::text THEN 'WTLD'::text
            WHEN 'wheelrutsspoorvormingornierage'::text THEN ''::text
            WHEN 'wijkquarterquartier'::text THEN 'PPLX'::text
            WHEN 'wijnboerderij'::text THEN ''::text
            WHEN 'wildlifereserve'::text THEN 'RESW'::text
            WHEN 'windmill'::text THEN 'MLWND'::text
            WHEN 'wolfsgrubewolfskuiltrappingpit'::text THEN ''::text
            WHEN 'woodboisbos'::text THEN 'FRST'::text
            WHEN 'woodlandregionarboreebosgebied'::text THEN 'FRST'::text
            WHEN 'wood'::text THEN 'FRST'::text
            WHEN 'zeczonedexploitationcontrolee'::text THEN ''::text
            WHEN 'zonemontagneuse'::text THEN 'MTS'::text
            WHEN 'zonesource'::text THEN 'SPNG'::text
            WHEN 'zone'::text THEN 'ZN'::text
            WHEN 'zoo'::text THEN 'ZOO'::text
            WHEN 'archipel'::text THEN 'ISLS'::text
            WHEN 'archipelago'::text THEN 'ISLS'::text
            WHEN 'atol'::text THEN 'ATOL'::text
            WHEN 'atoll'::text THEN 'ATOL'::text
            WHEN 'banc'::text THEN 'BNKU'::text
            WHEN 'banks'::text THEN 'BNKU'::text
            WHEN 'bar'::text THEN 'BAR'::text
            WHEN 'bay'::text THEN 'BAY'::text
            WHEN 'beach'::text THEN 'BCH'::text
            WHEN 'bights'::text THEN 'BGHT'::text
            WHEN 'bluehole'::text THEN 'HOLU'::text
            WHEN 'boat'::text THEN 'WRCK'::text
            WHEN 'cape'::text THEN 'CAPE'::text
            WHEN 'cay'::text THEN 'BNKU'::text
            WHEN 'channel'::text THEN 'CHN'::text
            WHEN 'cliff'::text THEN 'CLF'::text
            WHEN 'cliffs'::text THEN 'CLF'::text
            WHEN 'coastkustcote'::text THEN 'CST'::text
            WHEN 'coast'::text THEN 'CST'::text
            WHEN 'coralreef'::text THEN 'RFU'::text
            WHEN 'coves'::text THEN 'COVE'::text
            WHEN 'deep'::text THEN 'DEPU'::text
            WHEN 'docks'::text THEN 'DCK'::text
            WHEN 'estuary'::text THEN 'ESTY'::text
            WHEN 'fjord'::text THEN 'FJD'::text
            WHEN 'gulf'::text THEN 'GULF'::text
            WHEN 'harbors'::text THEN 'HBR'::text
            WHEN 'headlands'::text THEN 'HDLD'::text
            WHEN 'inlet'::text THEN 'INLT'::text
            WHEN 'isthmus'::text THEN 'ISTH'::text
            WHEN 'lagoon'::text THEN 'LGN'::text
            WHEN 'lagoons'::text THEN 'LGN'::text
            WHEN 'laguna'::text THEN 'LGN'::text
            WHEN 'mangroveswamp'::text THEN 'MGV'::text
            WHEN 'mangrove'::text THEN 'MGV'::text
            WHEN 'marina'::text THEN 'HBR'::text
            WHEN 'marinechannel'::text THEN 'CHN'::text
            WHEN 'marineregion'::text THEN 'RGN'::text
            WHEN 'oceancurrent'::text THEN 'CRNT'::text
            WHEN 'ocean'::text THEN 'OCN'::text
            WHEN 'pier'::text THEN 'DCK'::text
            WHEN 'port'::text THEN 'HBR'::text
            WHEN 'reefunit'::text THEN 'RFU'::text
            WHEN 'reef'::text THEN 'RFU'::text
            WHEN 'sandbank'::text THEN 'BNKU'::text
            WHEN 'seaarea'::text THEN 'SEA'::text
            WHEN 'seavalley'::text THEN 'VALU'::text
            WHEN 'sea'::text THEN 'SEA'::text
            WHEN 'seaport'::text THEN 'HBR'::text
            WHEN 'seasideresort'::text THEN 'RSRT'::text
            WHEN 'sectionofharbor'::text THEN 'HBR'::text
            WHEN 'sectionofreef'::text THEN 'RFU'::text
            WHEN 'shipwreck'::text THEN 'WRCK'::text
            WHEN 'shoals'::text THEN 'SHLU'::text
            WHEN 'streammouths'::text THEN 'STMM'::text
            WHEN 'subamrinecanyon'::text THEN 'CNYU'::text
            WHEN 'submarinevolcano'::text THEN 'VLC'::text
            WHEN 'tidalcreeks'::text THEN 'CRKT'::text
            WHEN 'tidalflats'::text THEN 'FLTM'::text
            WHEN 'trench'::text THEN 'TRNU'::text
            WHEN 'underseavalley'::text THEN 'VALU'::text
            WHEN 'wharf'::text THEN 'WHRF'::text
            WHEN 'wreck'::text THEN 'WRCK'::text
            ELSE NULL::text
        END AS gazetteer_type_mapped,
        CASE t.sub_group_name_indexed
            WHEN 'archipel'::text THEN 'Archipelago'::text
            WHEN 'archipelago'::text THEN 'Archipelago'::text
            WHEN 'archipelago'::text THEN 'Archipelago'::text
            WHEN 'atol'::text THEN 'Atoll'::text
            WHEN 'atoll'::text THEN 'Atoll'::text
            WHEN 'banc'::text THEN 'Bank'::text
            WHEN 'banks'::text THEN 'Bank'::text
            WHEN 'bar'::text THEN 'Bar'::text
            WHEN 'bay'::text THEN 'Bay'::text
            WHEN 'bay'::text THEN 'Bay'::text
            WHEN 'beach'::text THEN 'Beach'::text
            WHEN 'beach'::text THEN 'Beach'::text
            WHEN 'bights'::text THEN 'Bight'::text
            WHEN 'bluehole'::text THEN 'Hole'::text
            WHEN 'boat'::text THEN 'Wreck'::text
            WHEN 'cape'::text THEN 'Cape'::text
            WHEN 'cape'::text THEN 'Cape'::text
            WHEN 'cay'::text THEN 'Bank'::text
            WHEN 'cay'::text THEN 'Bank'::text
            WHEN 'channel'::text THEN 'Channel'::text
            WHEN 'channel'::text THEN 'Channel'::text
            WHEN 'channel'::text THEN 'Channel'::text
            WHEN 'cliff'::text THEN 'Cliffs'::text
            WHEN 'cliffs'::text THEN 'Cliffs'::text
            WHEN 'coastkustcote'::text THEN 'Coast'::text
            WHEN 'coast'::text THEN 'Coast'::text
            WHEN 'coast'::text THEN 'Coast'::text
            WHEN 'coast'::text THEN 'Coast'::text
            WHEN 'coralreef'::text THEN 'Reef'::text
            WHEN 'coves'::text THEN 'Cove'::text
            WHEN 'deep'::text THEN 'Deep'::text
            WHEN 'docks'::text THEN 'Dock'::text
            WHEN 'estuary'::text THEN 'Estuary'::text
            WHEN 'fjord'::text THEN 'Fjord'::text
            WHEN 'gulf'::text THEN 'Gulf'::text
            WHEN 'harbors'::text THEN 'Harbour'::text
            WHEN 'headlands'::text THEN 'Headland'::text
            WHEN 'inlet'::text THEN 'Inlet'::text
            WHEN 'isthmus'::text THEN 'Isthmus'::text
            WHEN 'lagoon'::text THEN 'Lagoon'::text
            WHEN 'lagoons'::text THEN 'Lagoon'::text
            WHEN 'laguna'::text THEN 'Lagoon'::text
            WHEN 'mangroveswamp'::text THEN 'Mangrove'::text
            WHEN 'mangrove'::text THEN 'Mangrove'::text
            WHEN 'marina'::text THEN 'Harbour'::text
            WHEN 'marinechannel'::text THEN 'Channel'::text
            WHEN 'marineregion'::text THEN 'Marine Region'::text
            WHEN 'oceancurrent'::text THEN 'Current'::text
            WHEN 'ocean'::text THEN 'Ocean'::text
            WHEN 'ocean'::text THEN 'Ocean'::text
            WHEN 'ocean'::text THEN 'Ocean'::text
            WHEN 'pier'::text THEN 'Dock'::text
            WHEN 'pier'::text THEN 'Dock'::text
            WHEN 'port'::text THEN 'Harbour'::text
            WHEN 'port'::text THEN 'Harbour'::text
            WHEN 'port'::text THEN 'Harbour'::text
            WHEN 'reefunit'::text THEN 'Reef'::text
            WHEN 'reef'::text THEN 'Reef'::text
            WHEN 'reef'::text THEN 'Reef'::text
            WHEN 'sandbank'::text THEN 'Sandbank'::text
            WHEN 'seaarea'::text THEN 'Sea'::text
            WHEN 'seavalley'::text THEN 'Valley'::text
            WHEN 'sea'::text THEN 'Sea'::text
            WHEN 'sea'::text THEN 'Sea'::text
            WHEN 'sea'::text THEN 'Sea'::text
            WHEN 'seaport'::text THEN 'Harbour'::text
            WHEN 'seasideresort'::text THEN 'Resort'::text
            WHEN 'seasideresort'::text THEN 'Resort'::text
            WHEN 'sectionofharbor'::text THEN 'Harbour'::text
            WHEN 'sectionofreef'::text THEN 'Reef'::text
            WHEN 'shipwreck'::text THEN 'Wreck'::text
            WHEN 'shoals'::text THEN 'Shoal'::text
            WHEN 'streammouths'::text THEN 'River Outlet'::text
            WHEN 'subamrinecanyon'::text THEN 'Canyon'::text
            WHEN 'submarinevolcano'::text THEN 'Volcano'::text
            WHEN 'tidalcreeks'::text THEN 'Creek'::text
            WHEN 'tidalflats'::text THEN 'Mud flat'::text
            WHEN 'trench'::text THEN 'Trench'::text
            WHEN 'underseavalley'::text THEN 'Submarine valley(s)'::text
            WHEN 'wharf'::text THEN 'Wharf'::text
            WHEN 'wreck'::text THEN 'Wreck'::text
            ELSE NULL::text
        END AS marineregions_type_mapped,
    ta.code AS gazetteer_code,
    ta.url AS gazetteer_url,
    ta.pref_label AS gazetteer_pref_label,
    countries.country_iso
   FROM (((((darwin2.gtu
     RIGHT JOIN darwin2.tag_groups t ON ((gtu.id = t.gtu_ref)))
     RIGHT JOIN darwin2.tag_group_distinct td ON ((((t.tag_value)::text = (td.tag_value)::text) AND ((td.sub_group_name_indexed)::text = (t.sub_group_name_indexed)::text) AND ((td.group_name_indexed)::text = (t.group_name_indexed)::text) AND ((td.sub_group_name_indexed)::text <> 'country'::text))))
     LEFT JOIN darwin2.tag_tag_authority tta ON ((tta.tag_group_distinct_ref = td.id)))
     LEFT JOIN darwin2.tag_authority ta ON ((tta.tag_authority_ref = ta.id)))
     LEFT JOIN ( SELECT DISTINCT mv_tag_to_country.tag_group_distinct_ref,
            mv_tag_to_country.country_iso
           FROM darwin2.mv_tag_to_country) countries ON ((countries.tag_group_distinct_ref = td.id)))
  WITH NO DATA;


ALTER TABLE darwin2.mv_tag_to_locations OWNER TO postgres;

--
-- TOC entry 318 (class 1259 OID 4817004)
-- Name: my_saved_searches_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.my_saved_searches_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.my_saved_searches_id_seq OWNER TO darwin2;

--
-- TOC entry 319 (class 1259 OID 4817006)
-- Name: my_saved_searches; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.my_saved_searches (
    id integer DEFAULT nextval('darwin2.my_saved_searches_id_seq'::regclass) NOT NULL,
    user_ref integer NOT NULL,
    name character varying DEFAULT 'default'::character varying NOT NULL,
    search_criterias character varying NOT NULL,
    favorite boolean DEFAULT false NOT NULL,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL,
    visible_fields_in_result character varying NOT NULL,
    is_only_id boolean DEFAULT false NOT NULL,
    subject character varying DEFAULT 'specimen'::character varying NOT NULL,
    query_where character varying,
    query_parameters character varying
);


ALTER TABLE darwin2.my_saved_searches OWNER TO darwin2;

--
-- TOC entry 6368 (class 0 OID 0)
-- Dependencies: 319
-- Name: TABLE my_saved_searches; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.my_saved_searches IS 'Stores user''s saved searches but also (by default) the last search done';


--
-- TOC entry 6369 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN my_saved_searches.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.user_ref IS 'Reference of user having saved a search';


--
-- TOC entry 6370 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN my_saved_searches.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.name IS 'Name given by user to his/her saved search';


--
-- TOC entry 6371 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN my_saved_searches.search_criterias; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.search_criterias IS 'String field containing the serialization of search criterias';


--
-- TOC entry 6372 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN my_saved_searches.favorite; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.favorite IS 'Flag telling if saved search concerned is one of the favorites or not';


--
-- TOC entry 6373 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN my_saved_searches.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.modification_date_time IS 'Last modification or entry date and time';


--
-- TOC entry 6374 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN my_saved_searches.visible_fields_in_result; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.visible_fields_in_result IS 'Array of fields that were set visible in the result table at the time the search was saved';


--
-- TOC entry 6375 (class 0 OID 0)
-- Dependencies: 319
-- Name: COLUMN my_saved_searches.is_only_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_saved_searches.is_only_id IS 'Tell if the search only contains saved specimen (ids) or it is a normal saved search';


--
-- TOC entry 320 (class 1259 OID 4817018)
-- Name: my_widgets_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.my_widgets_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.my_widgets_id_seq OWNER TO darwin2;

--
-- TOC entry 321 (class 1259 OID 4817020)
-- Name: my_widgets; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.my_widgets (
    id integer DEFAULT nextval('darwin2.my_widgets_id_seq'::regclass) NOT NULL,
    user_ref integer NOT NULL,
    category character varying DEFAULT 'board_widget'::character varying NOT NULL,
    group_name character varying NOT NULL,
    order_by smallint DEFAULT 1 NOT NULL,
    col_num smallint DEFAULT 1 NOT NULL,
    mandatory boolean DEFAULT false NOT NULL,
    visible boolean DEFAULT true NOT NULL,
    opened boolean DEFAULT true NOT NULL,
    color character varying DEFAULT '#5BAABD'::character varying NOT NULL,
    is_available boolean DEFAULT false NOT NULL,
    icon_ref integer,
    title_perso character varying(32),
    collections character varying DEFAULT ','::character varying NOT NULL,
    all_public boolean DEFAULT false NOT NULL
);


ALTER TABLE darwin2.my_widgets OWNER TO darwin2;

--
-- TOC entry 6378 (class 0 OID 0)
-- Dependencies: 321
-- Name: TABLE my_widgets; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.my_widgets IS 'Stores user''s preferences for customizable page elements - widgets mainly';


--
-- TOC entry 6379 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.user_ref IS 'Reference of user concerned - id field of users table';


--
-- TOC entry 6380 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.category; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.category IS 'Customizable page element category: board widget, encoding widget,...';


--
-- TOC entry 6381 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.group_name IS 'Customizable page element name';


--
-- TOC entry 6382 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.order_by IS 'Absolute order by between page element name';


--
-- TOC entry 6383 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.col_num; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.col_num IS 'Column number - tells in which column the page element concerned is';


--
-- TOC entry 6384 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.mandatory; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.mandatory IS 'Flag telling if the page element can be closed or not';


--
-- TOC entry 6385 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.visible; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.visible IS 'Flag telling if the page element is on the board or in the widget chooser';


--
-- TOC entry 6386 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.opened; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.opened IS 'Flag telling if the page element is opened by default or not';


--
-- TOC entry 6387 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.color; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.color IS 'Color given to page element by user';


--
-- TOC entry 6388 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.is_available; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.is_available IS 'Flag telling if the widget can be used or not';


--
-- TOC entry 6389 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.icon_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.icon_ref IS 'Reference of multimedia icon to be used before page element title';


--
-- TOC entry 6390 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.title_perso; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.title_perso IS 'Page element title given by user';


--
-- TOC entry 6391 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.collections; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.collections IS 'list of collections whitch user_ref has rights to see';


--
-- TOC entry 6392 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN my_widgets.all_public; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.my_widgets.all_public IS 'Set to determine if the widget is public by default or not';


--
-- TOC entry 322 (class 1259 OID 4817037)
-- Name: old_multimedia; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.old_multimedia (
    id integer NOT NULL,
    is_digital boolean DEFAULT true NOT NULL,
    type character varying DEFAULT 'image'::character varying NOT NULL,
    sub_type character varying,
    title character varying NOT NULL,
    title_indexed character varying NOT NULL,
    subject character varying DEFAULT '/'::character varying NOT NULL,
    coverage darwin2.coverages DEFAULT 'temporal'::darwin2.coverages NOT NULL,
    apercu_path character varying,
    copyright character varying,
    license character varying,
    uri character varying,
    descriptive_ts tsvector NOT NULL,
    descriptive_language_full_text darwin2.full_text_language,
    creation_date date DEFAULT '0001-01-01'::date NOT NULL,
    creation_date_mask integer DEFAULT 0 NOT NULL,
    publication_date_from date DEFAULT '0001-01-01'::date NOT NULL,
    publication_date_from_mask integer DEFAULT 0 NOT NULL,
    publication_date_to date DEFAULT '2038-12-31'::date NOT NULL,
    publication_date_to_mask integer DEFAULT 0 NOT NULL,
    parent_ref integer,
    path character varying DEFAULT '/'::character varying NOT NULL,
    mime_type character varying,
    CONSTRAINT fct_chk_onceinpath_multimedia CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
);


ALTER TABLE darwin2.old_multimedia OWNER TO darwin2;

--
-- TOC entry 6394 (class 0 OID 0)
-- Dependencies: 322
-- Name: TABLE old_multimedia; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.old_multimedia IS 'Stores all multimedia objects encoded in DaRWIN 2.0';


--
-- TOC entry 6395 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.id IS 'Unique identifier of a multimedia object';


--
-- TOC entry 6396 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.is_digital; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.is_digital IS 'Flag telling if the object is digital (true) or physical (false)';


--
-- TOC entry 6397 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.type IS 'Main multimedia object type: image, sound, video,...';


--
-- TOC entry 6398 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.sub_type IS 'Characterization of object type: article, publication in serie, book, glass plate,...';


--
-- TOC entry 6399 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.title IS 'Object title';


--
-- TOC entry 6400 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.title_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.title_indexed IS 'Indexed form of title field';


--
-- TOC entry 6401 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.subject; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.subject IS 'Multimedia object subject (as required by Dublin Core...)';


--
-- TOC entry 6402 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.coverage; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.coverage IS 'Coverage of multimedia object: spatial or temporal (as required by Dublin Core...)';


--
-- TOC entry 6403 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.apercu_path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.apercu_path IS 'URI path to the thumbnail illustrating the object';


--
-- TOC entry 6404 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.copyright; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.copyright IS 'Copyright notice';


--
-- TOC entry 6405 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.license; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.license IS 'License notice';


--
-- TOC entry 6406 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.uri; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.uri IS 'URI of object if digital';


--
-- TOC entry 6407 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.descriptive_ts; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.descriptive_ts IS 'tsvector form of title and subject fields together';


--
-- TOC entry 6408 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.descriptive_language_full_text; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.descriptive_language_full_text IS 'Language used for descriptive_ts tsvector field composition';


--
-- TOC entry 6409 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.creation_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.creation_date IS 'Object creation date';


--
-- TOC entry 6410 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.creation_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.creation_date_mask IS 'Mask used for object creation date display';


--
-- TOC entry 6411 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.publication_date_from; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.publication_date_from IS 'Object publication date from';


--
-- TOC entry 6412 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.publication_date_from_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.publication_date_from_mask IS 'Mask used for object publication begining date display';


--
-- TOC entry 6413 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.publication_date_to; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.publication_date_to IS 'Object publication date to';


--
-- TOC entry 6414 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.publication_date_to_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.publication_date_to_mask IS 'Mask used for object publication end date display';


--
-- TOC entry 6415 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.parent_ref IS 'Reference of a parent multimedia. Such as an Article of a publication';


--
-- TOC entry 6416 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.path IS 'Path of parent of the object (automaticaly filled)';


--
-- TOC entry 6417 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN old_multimedia.mime_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.old_multimedia.mime_type IS 'Mime/Type of the linked digital object';


--
-- TOC entry 323 (class 1259 OID 4817055)
-- Name: people_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_id_seq OWNER TO darwin2;

--
-- TOC entry 325 (class 1259 OID 4817068)
-- Name: people; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people (
    id integer DEFAULT nextval('darwin2.people_id_seq'::regclass) NOT NULL,
    db_people_type integer DEFAULT 1 NOT NULL,
    end_date_mask integer DEFAULT 0 NOT NULL,
    end_date date DEFAULT '2038-12-31'::date NOT NULL,
    activity_date_from_mask integer DEFAULT 0 NOT NULL,
    activity_date_from date DEFAULT '0001-01-01'::date NOT NULL,
    activity_date_to_mask integer DEFAULT 0 NOT NULL,
    activity_date_to date DEFAULT '2038-12-31'::date NOT NULL,
    name_formated_indexed text DEFAULT ''::text NOT NULL,
    import_ref integer
)
INHERITS (darwin2.template_people);


ALTER TABLE darwin2.people OWNER TO darwin2;

--
-- TOC entry 6419 (class 0 OID 0)
-- Dependencies: 325
-- Name: TABLE people; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people IS 'All physical and moral persons used in the application are here stored';


--
-- TOC entry 6420 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.is_physical; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.is_physical IS 'Type of person: physical or moral - true is physical, false is moral';


--
-- TOC entry 6421 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.sub_type IS 'Used for moral persons: precise nature - public institution, asbl, sprl, sa,...';


--
-- TOC entry 6422 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.formated_name IS 'Complete person formated name (with honorific mention, prefixes, suffixes,...) - By default composed with family_name and given_name fields, but can be modified by hand';


--
-- TOC entry 6423 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.formated_name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.formated_name_indexed IS 'Indexed form of formated_name field';


--
-- TOC entry 6424 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.title; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.title IS 'Title of a physical user/person like Mr or Mrs or phd,...';


--
-- TOC entry 6425 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.family_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.family_name IS 'Family name for physical persons and Organisation name for moral persons';


--
-- TOC entry 6426 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.given_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.given_name IS 'User/person''s given name - usually first name';


--
-- TOC entry 6427 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.additional_names; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.additional_names IS 'Any additional names given to person';


--
-- TOC entry 6428 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.birth_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.birth_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6429 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.birth_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.birth_date IS 'Day of birth/creation';


--
-- TOC entry 6430 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.gender; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.gender IS 'For physical persons give the gender: M or F';


--
-- TOC entry 6431 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.id IS 'Unique identifier of a person';


--
-- TOC entry 6432 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.db_people_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.db_people_type IS 'Sum of numbers in an arithmetic suite (1,2,4,8,...) that gives a unique number identifying people roles - each roles represented by one of the number in the arithmetic suite: 1 is contact, 2 is author, 4 is identifier, 8 is expert, 16 is collector, 32 preparator, 64 photographer...';


--
-- TOC entry 6433 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.end_date_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.end_date_mask IS 'Mask Flag to know wich part of the date is effectively known: 32 for year, 16 for month and 8 for day';


--
-- TOC entry 6434 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.end_date; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.end_date IS 'End date';


--
-- TOC entry 6435 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.activity_date_from_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.activity_date_from_mask IS 'person general activity period or person activity period in the organization referenced date from mask';


--
-- TOC entry 6436 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.activity_date_from; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.activity_date_from IS 'person general activity period or person activity period in the organization referenced date from';


--
-- TOC entry 6437 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.activity_date_to_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.activity_date_to_mask IS 'person general activity period or person activity period in the organization referenced date to mask';


--
-- TOC entry 6438 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN people.activity_date_to; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people.activity_date_to IS 'person general activity period or person activity period in the organization referenced date to';


--
-- TOC entry 326 (class 1259 OID 4817088)
-- Name: people_addresses_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_addresses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_addresses_id_seq OWNER TO darwin2;

--
-- TOC entry 327 (class 1259 OID 4817090)
-- Name: template_people_users_addr_common; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.template_people_users_addr_common (
    po_box character varying,
    extended_address character varying,
    locality character varying NOT NULL,
    region character varying,
    zip_code character varying,
    country character varying NOT NULL
);


ALTER TABLE darwin2.template_people_users_addr_common OWNER TO darwin2;

--
-- TOC entry 6440 (class 0 OID 0)
-- Dependencies: 327
-- Name: TABLE template_people_users_addr_common; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.template_people_users_addr_common IS 'Template table used to construct addresses tables for people/users';


--
-- TOC entry 6441 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN template_people_users_addr_common.po_box; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.po_box IS 'PO Box';


--
-- TOC entry 6442 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN template_people_users_addr_common.extended_address; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.extended_address IS 'Address extension: State, Special post zip code characters,...';


--
-- TOC entry 6443 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN template_people_users_addr_common.locality; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.locality IS 'Locality';


--
-- TOC entry 6444 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN template_people_users_addr_common.region; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.region IS 'Region';


--
-- TOC entry 6445 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN template_people_users_addr_common.zip_code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.zip_code IS 'zip code';


--
-- TOC entry 6446 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN template_people_users_addr_common.country; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.template_people_users_addr_common.country IS 'Country';


--
-- TOC entry 329 (class 1259 OID 4817102)
-- Name: people_addresses; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people_addresses (
    id integer DEFAULT nextval('darwin2.people_addresses_id_seq'::regclass) NOT NULL,
    tag character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_people_users_comm_common, darwin2.template_people_users_addr_common);


ALTER TABLE darwin2.people_addresses OWNER TO darwin2;

--
-- TOC entry 6448 (class 0 OID 0)
-- Dependencies: 329
-- Name: TABLE people_addresses; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people_addresses IS 'People addresses';


--
-- TOC entry 6449 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.person_user_ref IS 'Reference of the person concerned - id field of people table';


--
-- TOC entry 6450 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.entry IS 'Street address';


--
-- TOC entry 6451 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.po_box; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.po_box IS 'PO Box';


--
-- TOC entry 6452 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.extended_address; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.extended_address IS 'Address extension: State, zip code suffix,...';


--
-- TOC entry 6453 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.locality; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.locality IS 'Locality';


--
-- TOC entry 6454 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.region; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.region IS 'Region';


--
-- TOC entry 6455 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.zip_code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.zip_code IS 'Zip code';


--
-- TOC entry 6456 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.country; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.country IS 'Country';


--
-- TOC entry 6457 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.id IS 'Unique identifier of a person address';


--
-- TOC entry 6458 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN people_addresses.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_addresses.tag IS 'List of descriptive tags: home, work,...';


--
-- TOC entry 330 (class 1259 OID 4817110)
-- Name: people_comm_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_comm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_comm_id_seq OWNER TO darwin2;

--
-- TOC entry 331 (class 1259 OID 4817112)
-- Name: people_comm; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people_comm (
    id integer DEFAULT nextval('darwin2.people_comm_id_seq'::regclass) NOT NULL,
    comm_type character varying DEFAULT 'phone/fax'::character varying NOT NULL,
    tag character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_people_users_comm_common);


ALTER TABLE darwin2.people_comm OWNER TO darwin2;

--
-- TOC entry 6460 (class 0 OID 0)
-- Dependencies: 331
-- Name: TABLE people_comm; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people_comm IS 'People phones and e-mails';


--
-- TOC entry 6461 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN people_comm.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.person_user_ref IS 'Reference of person - id field of people table';


--
-- TOC entry 6462 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN people_comm.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.entry IS 'Communication entry';


--
-- TOC entry 6463 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN people_comm.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.id IS 'Unique identifier of a person communication mean entry';


--
-- TOC entry 6464 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN people_comm.comm_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.comm_type IS 'Type of communication table concerned: address, phone or e-mail';


--
-- TOC entry 6465 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN people_comm.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_comm.tag IS 'List of descriptive tags separated by , : internet, tel, fax, pager, public, private,...';


--
-- TOC entry 332 (class 1259 OID 4817121)
-- Name: people_languages_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_languages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_languages_id_seq OWNER TO darwin2;

--
-- TOC entry 333 (class 1259 OID 4817123)
-- Name: people_languages; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people_languages (
    language_country character varying DEFAULT 'en'::character varying NOT NULL,
    mother boolean DEFAULT true NOT NULL,
    preferred_language boolean DEFAULT false NOT NULL,
    id integer DEFAULT nextval('darwin2.people_languages_id_seq'::regclass) NOT NULL,
    people_ref integer NOT NULL
);


ALTER TABLE darwin2.people_languages OWNER TO darwin2;

--
-- TOC entry 6467 (class 0 OID 0)
-- Dependencies: 333
-- Name: TABLE people_languages; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people_languages IS 'Languages spoken by a given person';


--
-- TOC entry 6468 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN people_languages.language_country; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_languages.language_country IS 'Reference of Language - language_country field of languages_countries table';


--
-- TOC entry 6469 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN people_languages.mother; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_languages.mother IS 'Flag telling if its mother language or not';


--
-- TOC entry 6470 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN people_languages.preferred_language; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_languages.preferred_language IS 'Flag telling which language is preferred in communications';


--
-- TOC entry 6471 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN people_languages.people_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_languages.people_ref IS 'Reference of person - id field of people table';


--
-- TOC entry 334 (class 1259 OID 4817133)
-- Name: people_relationships_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.people_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.people_relationships_id_seq OWNER TO darwin2;

--
-- TOC entry 335 (class 1259 OID 4817135)
-- Name: people_relationships; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.people_relationships (
    person_user_role character varying,
    id integer DEFAULT nextval('darwin2.people_relationships_id_seq'::regclass) NOT NULL,
    relationship_type character varying DEFAULT 'belongs to'::character varying NOT NULL,
    person_1_ref integer NOT NULL,
    person_2_ref integer NOT NULL,
    path character varying,
    activity_date_from_mask integer DEFAULT 0 NOT NULL,
    activity_date_from date DEFAULT '0001-01-01'::date NOT NULL,
    activity_date_to_mask integer DEFAULT 0 NOT NULL,
    activity_date_to date DEFAULT '2038-12-31'::date NOT NULL
);


ALTER TABLE darwin2.people_relationships OWNER TO darwin2;

--
-- TOC entry 6473 (class 0 OID 0)
-- Dependencies: 335
-- Name: TABLE people_relationships; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.people_relationships IS 'Relationships between people - mainly between physical person and moral person: relationship of dependancy';


--
-- TOC entry 6474 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN people_relationships.person_user_role; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.person_user_role IS 'Person role in the organization referenced';


--
-- TOC entry 6475 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN people_relationships.relationship_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.relationship_type IS 'Type of relationship between two persons: belongs to, is department of, is section of, works for,...';


--
-- TOC entry 6476 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN people_relationships.person_1_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.person_1_ref IS 'Reference of person to be puted in relationship with an other - id field of people table';


--
-- TOC entry 6477 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN people_relationships.person_2_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.person_2_ref IS 'Reference of person puted the person puted in relationship with is dependant of - id field of people table';


--
-- TOC entry 6478 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN people_relationships.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.path IS 'Hierarchical path of the organization structure';


--
-- TOC entry 6479 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN people_relationships.activity_date_from_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.activity_date_from_mask IS 'person activity period or person activity period in the organization referenced date from mask';


--
-- TOC entry 6480 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN people_relationships.activity_date_from; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.activity_date_from IS 'person activity period or person activity period in the organization referenced date from';


--
-- TOC entry 6481 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN people_relationships.activity_date_to_mask; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.activity_date_to_mask IS 'person activity period or person activity period in the organization referenced date to mask';


--
-- TOC entry 6482 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN people_relationships.activity_date_to; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.people_relationships.activity_date_to IS 'person activity period or person activity period in the organization referenced date to';


--
-- TOC entry 336 (class 1259 OID 4817147)
-- Name: possible_upper_levels; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.possible_upper_levels (
    level_ref integer NOT NULL,
    level_upper_ref integer
);


ALTER TABLE darwin2.possible_upper_levels OWNER TO darwin2;

--
-- TOC entry 6484 (class 0 OID 0)
-- Dependencies: 336
-- Name: TABLE possible_upper_levels; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.possible_upper_levels IS 'For each level, list all the availble parent levels';


--
-- TOC entry 6485 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN possible_upper_levels.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.possible_upper_levels.level_ref IS 'Reference of current level';


--
-- TOC entry 6486 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN possible_upper_levels.level_upper_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.possible_upper_levels.level_upper_ref IS 'Reference of authorized parent level';


--
-- TOC entry 337 (class 1259 OID 4817150)
-- Name: possible_upper_levels_20180924_before_rmca_merge; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.possible_upper_levels_20180924_before_rmca_merge (
    level_ref integer,
    level_upper_ref integer
);


ALTER TABLE darwin2.possible_upper_levels_20180924_before_rmca_merge OWNER TO darwin2;

--
-- TOC entry 338 (class 1259 OID 4817153)
-- Name: preferences_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.preferences_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.preferences_id_seq OWNER TO darwin2;

--
-- TOC entry 339 (class 1259 OID 4817155)
-- Name: preferences; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.preferences (
    id integer DEFAULT nextval('darwin2.preferences_id_seq'::regclass) NOT NULL,
    user_ref integer NOT NULL,
    pref_key character varying NOT NULL,
    pref_value character varying NOT NULL
);


ALTER TABLE darwin2.preferences OWNER TO darwin2;

--
-- TOC entry 6488 (class 0 OID 0)
-- Dependencies: 339
-- Name: TABLE preferences; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.preferences IS 'Table to handle users preferences';


--
-- TOC entry 6489 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN preferences.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.preferences.user_ref IS 'The referenced user id';


--
-- TOC entry 6490 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN preferences.pref_key; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.preferences.pref_key IS 'The classification key of the preference. eg: color';


--
-- TOC entry 6491 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN preferences.pref_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.preferences.pref_value IS 'The value of the preference for this user eg: red';


--
-- TOC entry 340 (class 1259 OID 4817162)
-- Name: properties_bck20180731_fix_colmate_dates; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.properties_bck20180731_fix_colmate_dates (
    referenced_relation character varying,
    record_id integer,
    id integer,
    property_type character varying,
    applies_to character varying,
    applies_to_indexed character varying,
    date_from_mask integer,
    date_from timestamp without time zone,
    date_to_mask integer,
    date_to timestamp without time zone,
    is_quantitative boolean,
    property_unit character varying,
    method character varying,
    method_indexed character varying,
    lower_value character varying,
    lower_value_unified double precision,
    upper_value character varying,
    upper_value_unified double precision,
    property_accuracy character varying
);


ALTER TABLE darwin2.properties_bck20180731_fix_colmate_dates OWNER TO darwin2;

--
-- TOC entry 341 (class 1259 OID 4817168)
-- Name: properties_bck20181127; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.properties_bck20181127 (
    referenced_relation character varying,
    record_id integer,
    id integer,
    property_type character varying,
    applies_to character varying,
    applies_to_indexed character varying,
    date_from_mask integer,
    date_from timestamp without time zone,
    date_to_mask integer,
    date_to timestamp without time zone,
    is_quantitative boolean,
    property_unit character varying,
    method character varying,
    method_indexed character varying,
    lower_value character varying,
    lower_value_unified double precision,
    upper_value character varying,
    upper_value_unified double precision,
    property_accuracy character varying
);


ALTER TABLE darwin2.properties_bck20181127 OWNER TO darwin2;

--
-- TOC entry 342 (class 1259 OID 4817174)
-- Name: properties_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.properties_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.properties_id_seq OWNER TO darwin2;

--
-- TOC entry 6493 (class 0 OID 0)
-- Dependencies: 342
-- Name: properties_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.properties_id_seq OWNED BY darwin2.properties.id;


--
-- TOC entry 343 (class 1259 OID 4817176)
-- Name: properties_values_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.properties_values_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.properties_values_id_seq OWNER TO darwin2;

--
-- TOC entry 344 (class 1259 OID 4817178)
-- Name: ref_rec; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.ref_rec (
    id integer
);


ALTER TABLE darwin2.ref_rec OWNER TO darwin2;

--
-- TOC entry 345 (class 1259 OID 4817181)
-- Name: reports; Type: TABLE; Schema: darwin2; Owner: postgres
--

CREATE TABLE darwin2.reports (
    id integer NOT NULL,
    user_ref integer NOT NULL,
    name character varying NOT NULL,
    uri character varying,
    lang character(2) NOT NULL,
    format character varying DEFAULT 'csv'::character varying NOT NULL,
    comment character varying,
    parameters public.hstore
);


ALTER TABLE darwin2.reports OWNER TO postgres;

--
-- TOC entry 6495 (class 0 OID 0)
-- Dependencies: 345
-- Name: TABLE reports; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON TABLE darwin2.reports IS 'Table to handle users reports asking';


--
-- TOC entry 6496 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN reports.user_ref; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.reports.user_ref IS 'The referenced user id';


--
-- TOC entry 6497 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN reports.name; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.reports.name IS 'The report name';


--
-- TOC entry 6498 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN reports.uri; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.reports.uri IS 'The path where the report file is stored, if uri is not null then the report has already been launched';


--
-- TOC entry 6499 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN reports.lang; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.reports.lang IS 'The lang asked for this report';


--
-- TOC entry 6500 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN reports.format; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.reports.format IS 'The file type of the report file, generaly csv or xls';


--
-- TOC entry 6501 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN reports.comment; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.reports.comment IS 'A comment to add to the report, just in case.';


--
-- TOC entry 6502 (class 0 OID 0)
-- Dependencies: 345
-- Name: COLUMN reports.parameters; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.reports.parameters IS 'if the report requires some information (such as collection_ref), they are here';


--
-- TOC entry 346 (class 1259 OID 4817188)
-- Name: reports_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: postgres
--

CREATE SEQUENCE darwin2.reports_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.reports_id_seq OWNER TO postgres;

--
-- TOC entry 6504 (class 0 OID 0)
-- Dependencies: 346
-- Name: reports_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: postgres
--

ALTER SEQUENCE darwin2.reports_id_seq OWNED BY darwin2.reports.id;


--
-- TOC entry 347 (class 1259 OID 4817190)
-- Name: specimen_collecting_methods_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimen_collecting_methods_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimen_collecting_methods_id_seq OWNER TO darwin2;

--
-- TOC entry 348 (class 1259 OID 4817192)
-- Name: specimen_collecting_methods; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimen_collecting_methods (
    id integer DEFAULT nextval('darwin2.specimen_collecting_methods_id_seq'::regclass) NOT NULL,
    specimen_ref integer NOT NULL,
    collecting_method_ref integer NOT NULL
);


ALTER TABLE darwin2.specimen_collecting_methods OWNER TO darwin2;

--
-- TOC entry 6506 (class 0 OID 0)
-- Dependencies: 348
-- Name: TABLE specimen_collecting_methods; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.specimen_collecting_methods IS 'Association of collecting methods with specimens';


--
-- TOC entry 6507 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN specimen_collecting_methods.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_methods.id IS 'Unique identifier of an association';


--
-- TOC entry 6508 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN specimen_collecting_methods.specimen_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_methods.specimen_ref IS 'Identifier of a specimen - comes from specimens table (id field)';


--
-- TOC entry 6509 (class 0 OID 0)
-- Dependencies: 348
-- Name: COLUMN specimen_collecting_methods.collecting_method_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_methods.collecting_method_ref IS 'Identifier of a collecting method - comes from collecting_methods table (id field)';


--
-- TOC entry 349 (class 1259 OID 4817196)
-- Name: specimen_collecting_tools_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimen_collecting_tools_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimen_collecting_tools_id_seq OWNER TO darwin2;

--
-- TOC entry 350 (class 1259 OID 4817198)
-- Name: specimen_collecting_tools; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimen_collecting_tools (
    id integer DEFAULT nextval('darwin2.specimen_collecting_tools_id_seq'::regclass) NOT NULL,
    specimen_ref integer NOT NULL,
    collecting_tool_ref integer NOT NULL
);


ALTER TABLE darwin2.specimen_collecting_tools OWNER TO darwin2;

--
-- TOC entry 6511 (class 0 OID 0)
-- Dependencies: 350
-- Name: TABLE specimen_collecting_tools; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.specimen_collecting_tools IS 'Association of collecting tools with specimens';


--
-- TOC entry 6512 (class 0 OID 0)
-- Dependencies: 350
-- Name: COLUMN specimen_collecting_tools.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_tools.id IS 'Unique identifier of an association';


--
-- TOC entry 6513 (class 0 OID 0)
-- Dependencies: 350
-- Name: COLUMN specimen_collecting_tools.specimen_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_tools.specimen_ref IS 'Identifier of a specimen - comes from specimens table (id field)';


--
-- TOC entry 6514 (class 0 OID 0)
-- Dependencies: 350
-- Name: COLUMN specimen_collecting_tools.collecting_tool_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimen_collecting_tools.collecting_tool_ref IS 'Identifier of a collecting tool - comes from collecting_tools table (id field)';


--
-- TOC entry 352 (class 1259 OID 4817242)
-- Name: specimens_accompanying_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimens_accompanying_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimens_accompanying_id_seq OWNER TO darwin2;

--
-- TOC entry 353 (class 1259 OID 4817244)
-- Name: specimens_bck20181203; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimens_bck20181203 (
    id integer,
    category character varying,
    collection_ref integer,
    expedition_ref integer,
    gtu_ref integer,
    taxon_ref integer,
    litho_ref integer,
    chrono_ref integer,
    lithology_ref integer,
    mineral_ref integer,
    acquisition_category character varying,
    acquisition_date_mask integer,
    acquisition_date date,
    station_visible boolean,
    ig_ref integer,
    type character varying,
    type_group character varying,
    type_search character varying,
    sex character varying,
    stage character varying,
    state character varying,
    social_status character varying,
    rock_form character varying,
    specimen_part character varying,
    complete boolean,
    institution_ref integer,
    building character varying,
    floor character varying,
    room character varying,
    "row" character varying,
    shelf character varying,
    container character varying,
    sub_container character varying,
    container_type character varying,
    sub_container_type character varying,
    container_storage character varying,
    sub_container_storage character varying,
    surnumerary boolean,
    specimen_status character varying,
    specimen_count_min integer,
    specimen_count_max integer,
    object_name text,
    object_name_indexed text,
    spec_ident_ids integer[],
    spec_coll_ids integer[],
    spec_don_sel_ids integer[],
    collection_type character varying,
    collection_code character varying,
    collection_name character varying,
    collection_is_public boolean,
    collection_parent_ref integer,
    collection_path character varying,
    expedition_name character varying,
    expedition_name_indexed character varying,
    gtu_code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_tag_values_indexed character varying[],
    gtu_country_tag_value character varying,
    gtu_country_tag_indexed character varying[],
    gtu_province_tag_value character varying,
    gtu_province_tag_indexed character varying[],
    gtu_others_tag_value character varying,
    gtu_others_tag_indexed character varying[],
    gtu_elevation double precision,
    gtu_elevation_accuracy double precision,
    taxon_name character varying,
    taxon_name_indexed character varying,
    taxon_level_ref integer,
    taxon_level_name character varying,
    taxon_status character varying,
    taxon_path character varying,
    taxon_parent_ref integer,
    taxon_extinct boolean,
    litho_name character varying,
    litho_name_indexed character varying,
    litho_level_ref integer,
    litho_level_name character varying,
    litho_status character varying,
    litho_local boolean,
    litho_color character varying,
    litho_path character varying,
    litho_parent_ref integer,
    chrono_name character varying,
    chrono_name_indexed character varying,
    chrono_level_ref integer,
    chrono_level_name character varying,
    chrono_status character varying,
    chrono_local boolean,
    chrono_color character varying,
    chrono_path character varying,
    chrono_parent_ref integer,
    lithology_name character varying,
    lithology_name_indexed character varying,
    lithology_level_ref integer,
    lithology_level_name character varying,
    lithology_status character varying,
    lithology_local boolean,
    lithology_color character varying,
    lithology_path character varying,
    lithology_parent_ref integer,
    mineral_name character varying,
    mineral_name_indexed character varying,
    mineral_level_ref integer,
    mineral_level_name character varying,
    mineral_status character varying,
    mineral_local boolean,
    mineral_color character varying,
    mineral_path character varying,
    mineral_parent_ref integer,
    ig_num character varying,
    ig_num_indexed character varying,
    ig_date_mask integer,
    ig_date date,
    col text,
    gtu_location point,
    specimen_creation_date timestamp without time zone,
    import_ref integer,
    main_code_indexed character varying
);


ALTER TABLE darwin2.specimens_bck20181203 OWNER TO darwin2;

--
-- TOC entry 428 (class 1259 OID 5304987)
-- Name: specimens_bck20181213; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimens_bck20181213 (
    id integer,
    category character varying,
    collection_ref integer,
    expedition_ref integer,
    gtu_ref integer,
    taxon_ref integer,
    litho_ref integer,
    chrono_ref integer,
    lithology_ref integer,
    mineral_ref integer,
    acquisition_category character varying,
    acquisition_date_mask integer,
    acquisition_date date,
    station_visible boolean,
    ig_ref integer,
    type character varying,
    type_group character varying,
    type_search character varying,
    sex character varying,
    stage character varying,
    state character varying,
    social_status character varying,
    rock_form character varying,
    specimen_part character varying,
    complete boolean,
    institution_ref integer,
    building character varying,
    floor character varying,
    room character varying,
    "row" character varying,
    shelf character varying,
    container character varying,
    sub_container character varying,
    container_type character varying,
    sub_container_type character varying,
    container_storage character varying,
    sub_container_storage character varying,
    surnumerary boolean,
    specimen_status character varying,
    specimen_count_min integer,
    specimen_count_max integer,
    object_name text,
    object_name_indexed text,
    spec_ident_ids integer[],
    spec_coll_ids integer[],
    spec_don_sel_ids integer[],
    collection_type character varying,
    collection_code character varying,
    collection_name character varying,
    collection_is_public boolean,
    collection_parent_ref integer,
    collection_path character varying,
    expedition_name character varying,
    expedition_name_indexed character varying,
    gtu_code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_tag_values_indexed character varying[],
    gtu_country_tag_value character varying,
    gtu_country_tag_indexed character varying[],
    gtu_province_tag_value character varying,
    gtu_province_tag_indexed character varying[],
    gtu_others_tag_value character varying,
    gtu_others_tag_indexed character varying[],
    gtu_elevation double precision,
    gtu_elevation_accuracy double precision,
    taxon_name character varying,
    taxon_name_indexed character varying,
    taxon_level_ref integer,
    taxon_level_name character varying,
    taxon_status character varying,
    taxon_path character varying,
    taxon_parent_ref integer,
    taxon_extinct boolean,
    litho_name character varying,
    litho_name_indexed character varying,
    litho_level_ref integer,
    litho_level_name character varying,
    litho_status character varying,
    litho_local boolean,
    litho_color character varying,
    litho_path character varying,
    litho_parent_ref integer,
    chrono_name character varying,
    chrono_name_indexed character varying,
    chrono_level_ref integer,
    chrono_level_name character varying,
    chrono_status character varying,
    chrono_local boolean,
    chrono_color character varying,
    chrono_path character varying,
    chrono_parent_ref integer,
    lithology_name character varying,
    lithology_name_indexed character varying,
    lithology_level_ref integer,
    lithology_level_name character varying,
    lithology_status character varying,
    lithology_local boolean,
    lithology_color character varying,
    lithology_path character varying,
    lithology_parent_ref integer,
    mineral_name character varying,
    mineral_name_indexed character varying,
    mineral_level_ref integer,
    mineral_level_name character varying,
    mineral_status character varying,
    mineral_local boolean,
    mineral_color character varying,
    mineral_path character varying,
    mineral_parent_ref integer,
    ig_num character varying,
    ig_num_indexed character varying,
    ig_date_mask integer,
    ig_date date,
    col text,
    gtu_location point,
    specimen_creation_date timestamp without time zone,
    import_ref integer,
    main_code_indexed character varying
);


ALTER TABLE darwin2.specimens_bck20181213 OWNER TO darwin2;

--
-- TOC entry 354 (class 1259 OID 4817250)
-- Name: specimens_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimens_id_seq OWNER TO darwin2;

--
-- TOC entry 6516 (class 0 OID 0)
-- Dependencies: 354
-- Name: specimens_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.specimens_id_seq OWNED BY darwin2.specimens.id;


--
-- TOC entry 355 (class 1259 OID 4817252)
-- Name: specimens_maincodes; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.specimens_maincodes AS
 SELECT specimens.id,
    specimens.category,
    specimens.collection_ref,
    specimens.expedition_ref,
    specimens.gtu_ref,
    specimens.taxon_ref,
    specimens.litho_ref,
    specimens.chrono_ref,
    specimens.lithology_ref,
    specimens.mineral_ref,
    specimens.acquisition_category,
    specimens.acquisition_date_mask,
    specimens.acquisition_date,
    specimens.station_visible,
    specimens.ig_ref,
    specimens.type,
    specimens.type_group,
    specimens.type_search,
    specimens.sex,
    specimens.stage,
    specimens.state,
    specimens.social_status,
    specimens.rock_form,
    specimens.specimen_part,
    specimens.complete,
    specimens.institution_ref,
    specimens.building,
    specimens.floor,
    specimens.room,
    specimens."row",
    specimens.shelf,
    specimens.container,
    specimens.sub_container,
    specimens.container_type,
    specimens.sub_container_type,
    specimens.container_storage,
    specimens.sub_container_storage,
    specimens.surnumerary,
    specimens.specimen_status,
    specimens.specimen_count_min,
    specimens.specimen_count_max,
    specimens.object_name,
    specimens.object_name_indexed,
    specimens.spec_ident_ids,
    specimens.spec_coll_ids,
    specimens.spec_don_sel_ids,
    specimens.collection_type,
    specimens.collection_code,
    specimens.collection_name,
    specimens.collection_is_public,
    specimens.collection_parent_ref,
    specimens.collection_path,
    specimens.expedition_name,
    specimens.expedition_name_indexed,
    specimens.gtu_code,
    specimens.gtu_from_date_mask,
    specimens.gtu_from_date,
    specimens.gtu_to_date_mask,
    specimens.gtu_to_date,
    specimens.gtu_tag_values_indexed,
    specimens.gtu_country_tag_value,
    specimens.gtu_country_tag_indexed,
    specimens.gtu_province_tag_value,
    specimens.gtu_province_tag_indexed,
    specimens.gtu_others_tag_value,
    specimens.gtu_others_tag_indexed,
    specimens.gtu_elevation,
    specimens.gtu_elevation_accuracy,
    specimens.taxon_name,
    specimens.taxon_name_indexed,
    specimens.taxon_level_ref,
    specimens.taxon_level_name,
    specimens.taxon_status,
    specimens.taxon_path,
    specimens.taxon_parent_ref,
    specimens.taxon_extinct,
    specimens.litho_name,
    specimens.litho_name_indexed,
    specimens.litho_level_ref,
    specimens.litho_level_name,
    specimens.litho_status,
    specimens.litho_local,
    specimens.litho_color,
    specimens.litho_path,
    specimens.litho_parent_ref,
    specimens.chrono_name,
    specimens.chrono_name_indexed,
    specimens.chrono_level_ref,
    specimens.chrono_level_name,
    specimens.chrono_status,
    specimens.chrono_local,
    specimens.chrono_color,
    specimens.chrono_path,
    specimens.chrono_parent_ref,
    specimens.lithology_name,
    specimens.lithology_name_indexed,
    specimens.lithology_level_ref,
    specimens.lithology_level_name,
    specimens.lithology_status,
    specimens.lithology_local,
    specimens.lithology_color,
    specimens.lithology_path,
    specimens.lithology_parent_ref,
    specimens.mineral_name,
    specimens.mineral_name_indexed,
    specimens.mineral_level_ref,
    specimens.mineral_level_name,
    specimens.mineral_status,
    specimens.mineral_local,
    specimens.mineral_color,
    specimens.mineral_path,
    specimens.mineral_parent_ref,
    specimens.ig_num,
    specimens.ig_num_indexed,
    specimens.ig_date_mask,
    specimens.ig_date,
    specimens.col,
    specimens.gtu_location,
    specimens.specimen_creation_date,
    specimens.import_ref,
    btrim((((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text)) AS code_main
   FROM (darwin2.specimens
     LEFT JOIN darwin2.codes ON ((specimens.id = codes.record_id)))
  WHERE ((codes.code_category)::text = 'main'::text);


ALTER TABLE darwin2.specimens_maincodes OWNER TO darwin2;

--
-- TOC entry 356 (class 1259 OID 4817257)
-- Name: specimens_relationships; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.specimens_relationships (
    id integer NOT NULL,
    specimen_ref integer NOT NULL,
    relationship_type character varying DEFAULT 'host'::character varying NOT NULL,
    unit_type character varying DEFAULT 'specimens'::character varying NOT NULL,
    specimen_related_ref integer,
    taxon_ref integer,
    mineral_ref integer,
    institution_ref integer,
    source_name text,
    source_id text,
    quantity numeric(16,2),
    unit character varying DEFAULT '%'::character varying
);


ALTER TABLE darwin2.specimens_relationships OWNER TO darwin2;

--
-- TOC entry 6518 (class 0 OID 0)
-- Dependencies: 356
-- Name: TABLE specimens_relationships; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.specimens_relationships IS 'List all the objects/specimens related the current specimen';


--
-- TOC entry 6519 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN specimens_relationships.specimen_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.specimen_ref IS 'Reference of specimen concerned - id field of specimens table';


--
-- TOC entry 6520 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN specimens_relationships.relationship_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.relationship_type IS 'Type of relationship';


--
-- TOC entry 6521 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN specimens_relationships.unit_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.unit_type IS 'Type of the related unit : spec, taxo or mineralo';


--
-- TOC entry 6522 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN specimens_relationships.taxon_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.taxon_ref IS 'Reference of the related specimen';


--
-- TOC entry 6523 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN specimens_relationships.mineral_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.mineral_ref IS 'Reference of related mineral';


--
-- TOC entry 6524 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN specimens_relationships.institution_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.institution_ref IS 'External Specimen related institution';


--
-- TOC entry 6525 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN specimens_relationships.source_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.source_name IS 'External Specimen related  source DB';


--
-- TOC entry 6526 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN specimens_relationships.source_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.source_id IS 'External Specimen related id in the source';


--
-- TOC entry 6527 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN specimens_relationships.quantity; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.specimens_relationships.quantity IS 'Quantity of accompanying mineral';


--
-- TOC entry 357 (class 1259 OID 4817266)
-- Name: specimens_relationships_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.specimens_relationships_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.specimens_relationships_id_seq OWNER TO darwin2;

--
-- TOC entry 6529 (class 0 OID 0)
-- Dependencies: 357
-- Name: specimens_relationships_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.specimens_relationships_id_seq OWNED BY darwin2.specimens_relationships.id;


--
-- TOC entry 358 (class 1259 OID 4817268)
-- Name: staging_catalogue; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_catalogue (
    id integer NOT NULL,
    import_ref integer NOT NULL,
    name character varying NOT NULL,
    level_ref integer,
    parent_ref integer,
    catalogue_ref integer,
    parent_updated boolean DEFAULT false,
    is_reference_taxonomy boolean,
    source_taxonomy character varying,
    parent_ref_internal integer,
    hierarchical_conflict boolean DEFAULT false,
    name_cluster integer,
    imported boolean DEFAULT false NOT NULL,
    import_exception character varying,
    staging_hierarchy character varying,
    darwin_hierarchy character varying
);


ALTER TABLE darwin2.staging_catalogue OWNER TO darwin2;

--
-- TOC entry 6531 (class 0 OID 0)
-- Dependencies: 358
-- Name: TABLE staging_catalogue; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_catalogue IS 'Stores the catalogues hierarchy to be imported';


--
-- TOC entry 6532 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN staging_catalogue.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.id IS 'Unique identifier of a to be imported catalogue unit entry';


--
-- TOC entry 6533 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN staging_catalogue.import_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.import_ref IS 'Reference of import concerned - from table imports';


--
-- TOC entry 6534 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN staging_catalogue.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.name IS 'Name of unit to be imported/checked';


--
-- TOC entry 6535 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN staging_catalogue.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.level_ref IS 'Level of unit to be imported/checked';


--
-- TOC entry 6536 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN staging_catalogue.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.parent_ref IS 'ID of parent the unit is attached to. Right after the load of xml, it refers recursively to an entry in the same staging_catalogue table. During the import it is replaced by id of the parent from the concerned catalogue table.';


--
-- TOC entry 6537 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN staging_catalogue.catalogue_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.catalogue_ref IS 'ID of unit in concerned catalogue table - set during import process';


--
-- TOC entry 6538 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN staging_catalogue.parent_updated; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_catalogue.parent_updated IS 'During the catalogue import process, tells if the parent ref has already been updated with one catalogue entry or not';


--
-- TOC entry 359 (class 1259 OID 4817276)
-- Name: staging_catalogue_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_catalogue_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_catalogue_id_seq OWNER TO darwin2;

--
-- TOC entry 6540 (class 0 OID 0)
-- Dependencies: 359
-- Name: staging_catalogue_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_catalogue_id_seq OWNED BY darwin2.staging_catalogue.id;


--
-- TOC entry 360 (class 1259 OID 4817278)
-- Name: staging_collecting_methods; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_collecting_methods (
    id integer NOT NULL,
    staging_ref integer NOT NULL,
    collecting_method_ref integer NOT NULL
);


ALTER TABLE darwin2.staging_collecting_methods OWNER TO darwin2;

--
-- TOC entry 6542 (class 0 OID 0)
-- Dependencies: 360
-- Name: TABLE staging_collecting_methods; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_collecting_methods IS 'Association of collecting methods with staging';


--
-- TOC entry 6543 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN staging_collecting_methods.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_collecting_methods.id IS 'Unique identifier of an association';


--
-- TOC entry 6544 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN staging_collecting_methods.staging_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_collecting_methods.staging_ref IS 'Identifier of a specimen - comes from staging table (id field)';


--
-- TOC entry 6545 (class 0 OID 0)
-- Dependencies: 360
-- Name: COLUMN staging_collecting_methods.collecting_method_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_collecting_methods.collecting_method_ref IS 'Identifier of a collecting method - comes from collecting_methods table (id field)';


--
-- TOC entry 361 (class 1259 OID 4817281)
-- Name: staging_collecting_methods_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_collecting_methods_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_collecting_methods_id_seq OWNER TO darwin2;

--
-- TOC entry 6547 (class 0 OID 0)
-- Dependencies: 361
-- Name: staging_collecting_methods_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_collecting_methods_id_seq OWNED BY darwin2.staging_collecting_methods.id;


--
-- TOC entry 362 (class 1259 OID 4817283)
-- Name: staging_gtu_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_gtu_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_gtu_id_seq OWNER TO darwin2;

--
-- TOC entry 363 (class 1259 OID 4817285)
-- Name: staging_gtu; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_gtu (
    id integer DEFAULT nextval('darwin2.staging_gtu_id_seq'::regclass) NOT NULL,
    import_ref integer,
    status public.hstore DEFAULT ''::public.hstore NOT NULL,
    date_included boolean DEFAULT false NOT NULL,
    tags_merged boolean DEFAULT false NOT NULL,
    sensitive_information_withheld boolean DEFAULT false NOT NULL,
    gtu_ref integer,
    station_type character varying DEFAULT 'station'::character varying NOT NULL,
    sampling_code character varying NOT NULL,
    sampling_field_number character varying,
    event_cluster_code character varying,
    event_order integer,
    ig_num character varying,
    ig_num_indexed character varying,
    collections character varying[],
    collectors character varying[],
    expeditions character varying[],
    collection_refs integer[],
    collector_refs integer[],
    expedition_refs integer[],
    iso3166 character varying,
    iso3166_subdivision character varying,
    countries character varying[],
    tags character varying[],
    tags_indexed character varying[],
    locality_text character varying,
    locality_text_indexed character varying,
    ecology_text character varying,
    ecology_text_indexed character varying,
    coordinates_format character varying,
    latitude1 character varying,
    longitude1 character varying,
    latitude2 character varying,
    longitude2 character varying,
    gis_type character varying,
    coordinates_wkt character varying,
    coordinates_datum character varying,
    coordinates_proj_ref integer,
    coordinates_original character varying,
    coordinates_accuracy numeric(15,4),
    coordinates_accuracy_text character varying,
    station_baseline_elevation numeric(10,4),
    station_baseline_accuracy numeric(10,4),
    sampling_elevation_start numeric(10,4),
    sampling_elevation_end numeric(10,4),
    sampling_elevation_accuracy numeric(10,4),
    original_elevation_data character varying,
    sampling_depth_start numeric(10,4),
    sampling_depth_end numeric(10,4),
    sampling_depth_accuracy numeric(10,4),
    original_depth_data character varying,
    collecting_date_begin timestamp without time zone,
    collecting_date_begin_mask character varying,
    collecting_date_end timestamp without time zone,
    collecting_date_end_mask character varying,
    collecting_time_begin time without time zone,
    collecting_time_end time without time zone,
    sampling_method character varying,
    sampling_fixation character varying,
    imported boolean DEFAULT false,
    pos_in_file integer,
    import_exception character varying
);


ALTER TABLE darwin2.staging_gtu OWNER TO darwin2;

--
-- TOC entry 364 (class 1259 OID 4817298)
-- Name: staging_gtu_id_seq1; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_gtu_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_gtu_id_seq1 OWNER TO darwin2;

--
-- TOC entry 6548 (class 0 OID 0)
-- Dependencies: 364
-- Name: staging_gtu_id_seq1; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_gtu_id_seq1 OWNED BY darwin2.staging_gtu.id;


--
-- TOC entry 365 (class 1259 OID 4817300)
-- Name: staging_gtu_tag_groups; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_gtu_tag_groups (
    id integer NOT NULL,
    staging_gtu_ref integer NOT NULL,
    group_name character varying NOT NULL,
    sub_group_name character varying NOT NULL,
    tag_value character varying NOT NULL
);


ALTER TABLE darwin2.staging_gtu_tag_groups OWNER TO darwin2;

--
-- TOC entry 6549 (class 0 OID 0)
-- Dependencies: 365
-- Name: TABLE staging_gtu_tag_groups; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_gtu_tag_groups IS 'List of grouped tags for an imported row (copy of tag group)';


--
-- TOC entry 6550 (class 0 OID 0)
-- Dependencies: 365
-- Name: COLUMN staging_gtu_tag_groups.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.id IS 'Unique identifier of a grouped tag';


--
-- TOC entry 6551 (class 0 OID 0)
-- Dependencies: 365
-- Name: COLUMN staging_gtu_tag_groups.staging_gtu_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.staging_gtu_ref IS 'Ref of an imported line';


--
-- TOC entry 6552 (class 0 OID 0)
-- Dependencies: 365
-- Name: COLUMN staging_gtu_tag_groups.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.group_name IS 'Group name under which the tag is grouped: Administrative area, Topographic structure,...';


--
-- TOC entry 6553 (class 0 OID 0)
-- Dependencies: 365
-- Name: COLUMN staging_gtu_tag_groups.sub_group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.sub_group_name IS 'Sub-Group name under which the tag is grouped: Country, River, Mountain,...';


--
-- TOC entry 6554 (class 0 OID 0)
-- Dependencies: 365
-- Name: COLUMN staging_gtu_tag_groups.tag_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_gtu_tag_groups.tag_value IS 'Ensemble of Tags';


--
-- TOC entry 366 (class 1259 OID 4817306)
-- Name: staging_gtu_tag_groups_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_gtu_tag_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_gtu_tag_groups_id_seq OWNER TO darwin2;

--
-- TOC entry 6556 (class 0 OID 0)
-- Dependencies: 366
-- Name: staging_gtu_tag_groups_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_gtu_tag_groups_id_seq OWNED BY darwin2.staging_gtu_tag_groups.id;


--
-- TOC entry 367 (class 1259 OID 4817308)
-- Name: staging_info; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_info (
    id integer NOT NULL,
    staging_ref integer NOT NULL,
    referenced_relation character varying NOT NULL
);


ALTER TABLE darwin2.staging_info OWNER TO darwin2;

--
-- TOC entry 368 (class 1259 OID 4817314)
-- Name: staging_info_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_info_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_info_id_seq OWNER TO darwin2;

--
-- TOC entry 6558 (class 0 OID 0)
-- Dependencies: 368
-- Name: staging_info_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_info_id_seq OWNED BY darwin2.staging_info.id;


--
-- TOC entry 369 (class 1259 OID 4817316)
-- Name: staging_people_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_people_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_people_id_seq OWNER TO darwin2;

--
-- TOC entry 370 (class 1259 OID 4817318)
-- Name: staging_people; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_people (
    id integer DEFAULT nextval('darwin2.staging_people_id_seq'::regclass) NOT NULL,
    people_type character varying DEFAULT 'author'::character varying NOT NULL,
    people_sub_type character varying DEFAULT ''::character varying NOT NULL,
    order_by integer DEFAULT 1 NOT NULL,
    people_ref integer,
    formated_name character varying
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.staging_people OWNER TO darwin2;

--
-- TOC entry 6559 (class 0 OID 0)
-- Dependencies: 370
-- Name: TABLE staging_people; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_people IS 'List of people of staging units';


--
-- TOC entry 6560 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN staging_people.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.referenced_relation IS 'Identifier-Name of table the units come from';


--
-- TOC entry 6561 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN staging_people.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.record_id IS 'Identifier of record concerned in table concerned';


--
-- TOC entry 6562 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN staging_people.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.id IS 'Unique identifier of record';


--
-- TOC entry 6563 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN staging_people.people_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.people_type IS 'Type of "people" associated to the staging unit: authors, collectors, defined,  ...';


--
-- TOC entry 6564 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN staging_people.people_sub_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.people_sub_type IS 'Type of "people" associated to the staging unit: Main author, corrector, taking the sense from,...';


--
-- TOC entry 6565 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN staging_people.order_by; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.order_by IS 'Integer used to order the persons in a list';


--
-- TOC entry 6566 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN staging_people.people_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.people_ref IS 'Reference of person concerned - id field of people table';


--
-- TOC entry 6567 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN staging_people.formated_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_people.formated_name IS 'full name of the people';


--
-- TOC entry 371 (class 1259 OID 4817328)
-- Name: staging_relationship; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_relationship (
    id integer NOT NULL,
    record_id integer NOT NULL,
    referenced_relation character varying NOT NULL,
    relationship_type character varying,
    staging_related_ref integer,
    taxon_ref integer,
    mineral_ref integer,
    institution_ref integer,
    institution_name text,
    source_name text,
    source_id text,
    quantity numeric(16,2),
    unit character varying DEFAULT '%'::character varying,
    unit_type character varying DEFAULT 'specimens'::character varying NOT NULL
);


ALTER TABLE darwin2.staging_relationship OWNER TO darwin2;

--
-- TOC entry 6568 (class 0 OID 0)
-- Dependencies: 371
-- Name: COLUMN staging_relationship.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.record_id IS 'id of the orignial record';


--
-- TOC entry 6569 (class 0 OID 0)
-- Dependencies: 371
-- Name: COLUMN staging_relationship.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.referenced_relation IS 'where to find the record_id, referenced_relation is always staging but this field uis mandatory for addRelated php function';


--
-- TOC entry 6570 (class 0 OID 0)
-- Dependencies: 371
-- Name: COLUMN staging_relationship.relationship_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.relationship_type IS 'relation type (eg. host, parent, part of)';


--
-- TOC entry 6571 (class 0 OID 0)
-- Dependencies: 371
-- Name: COLUMN staging_relationship.staging_related_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.staging_related_ref IS 'the record id associated, this record id must be found in the same import file';


--
-- TOC entry 6572 (class 0 OID 0)
-- Dependencies: 371
-- Name: COLUMN staging_relationship.institution_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.institution_ref IS 'the institution id associated to this relationship';


--
-- TOC entry 6573 (class 0 OID 0)
-- Dependencies: 371
-- Name: COLUMN staging_relationship.institution_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.institution_name IS 'the institution name associated to this relationship, used to add to darwin institution if it dont exist';


--
-- TOC entry 6574 (class 0 OID 0)
-- Dependencies: 371
-- Name: COLUMN staging_relationship.source_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.source_name IS 'External Specimen related  source DB';


--
-- TOC entry 6575 (class 0 OID 0)
-- Dependencies: 371
-- Name: COLUMN staging_relationship.source_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_relationship.source_id IS 'External Specimen related id in the source';


--
-- TOC entry 372 (class 1259 OID 4817336)
-- Name: staging_relationship_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_relationship_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_relationship_id_seq OWNER TO darwin2;

--
-- TOC entry 6577 (class 0 OID 0)
-- Dependencies: 372
-- Name: staging_relationship_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.staging_relationship_id_seq OWNED BY darwin2.staging_relationship.id;


--
-- TOC entry 373 (class 1259 OID 4817338)
-- Name: staging_tag_groups_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.staging_tag_groups_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.staging_tag_groups_id_seq OWNER TO darwin2;

--
-- TOC entry 374 (class 1259 OID 4817340)
-- Name: staging_tag_groups; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.staging_tag_groups (
    id bigint DEFAULT nextval('darwin2.staging_tag_groups_id_seq'::regclass) NOT NULL,
    staging_ref integer NOT NULL,
    group_name character varying NOT NULL,
    sub_group_name character varying NOT NULL,
    tag_value character varying NOT NULL
);


ALTER TABLE darwin2.staging_tag_groups OWNER TO darwin2;

--
-- TOC entry 6578 (class 0 OID 0)
-- Dependencies: 374
-- Name: TABLE staging_tag_groups; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.staging_tag_groups IS 'List of grouped tags for an imported row (copy of tag group)';


--
-- TOC entry 6579 (class 0 OID 0)
-- Dependencies: 374
-- Name: COLUMN staging_tag_groups.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.id IS 'Unique identifier of a grouped tag';


--
-- TOC entry 6580 (class 0 OID 0)
-- Dependencies: 374
-- Name: COLUMN staging_tag_groups.staging_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.staging_ref IS 'Ref of an imported line';


--
-- TOC entry 6581 (class 0 OID 0)
-- Dependencies: 374
-- Name: COLUMN staging_tag_groups.group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.group_name IS 'Group name under which the tag is grouped: Administrative area, Topographic structure,...';


--
-- TOC entry 6582 (class 0 OID 0)
-- Dependencies: 374
-- Name: COLUMN staging_tag_groups.sub_group_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.sub_group_name IS 'Sub-Group name under which the tag is grouped: Country, River, Mountain,...';


--
-- TOC entry 6583 (class 0 OID 0)
-- Dependencies: 374
-- Name: COLUMN staging_tag_groups.tag_value; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.staging_tag_groups.tag_value IS 'Ensemble of Tags';


--
-- TOC entry 436 (class 1259 OID 5308575)
-- Name: tag_authority_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.tag_authority_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.tag_authority_id_seq OWNER TO darwin2;

--
-- TOC entry 6584 (class 0 OID 0)
-- Dependencies: 436
-- Name: tag_authority_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.tag_authority_id_seq OWNED BY darwin2.tag_authority.id;


--
-- TOC entry 432 (class 1259 OID 5308544)
-- Name: tag_group_distinct_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.tag_group_distinct_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.tag_group_distinct_id_seq OWNER TO darwin2;

--
-- TOC entry 6586 (class 0 OID 0)
-- Dependencies: 432
-- Name: tag_group_distinct_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.tag_group_distinct_id_seq OWNED BY darwin2.tag_group_distinct.id;


--
-- TOC entry 377 (class 1259 OID 4817358)
-- Name: tags; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tags (
    gtu_ref integer NOT NULL,
    group_ref integer NOT NULL,
    group_type character varying NOT NULL,
    sub_group_type character varying NOT NULL,
    tag character varying NOT NULL,
    tag_indexed character varying NOT NULL,
    id integer NOT NULL
);


ALTER TABLE darwin2.tags OWNER TO darwin2;

--
-- TOC entry 6588 (class 0 OID 0)
-- Dependencies: 377
-- Name: TABLE tags; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.tags IS 'List of calculated tags for a groups. This is only for query purpose (filled by triggers)';


--
-- TOC entry 6589 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN tags.gtu_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.gtu_ref IS 'Reference to a Gtu';


--
-- TOC entry 6590 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN tags.group_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.group_ref IS 'Reference of the Group name under which the tag is grouped';


--
-- TOC entry 6591 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN tags.group_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.group_type IS 'Indexed form of a group name';


--
-- TOC entry 6592 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN tags.sub_group_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.sub_group_type IS 'Indexed form of a sub-group name';


--
-- TOC entry 6593 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN tags.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.tag IS 'The readable version of the tag';


--
-- TOC entry 6594 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN tags.tag_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.tags.tag_indexed IS 'The indexed version of the tag';


--
-- TOC entry 378 (class 1259 OID 4817364)
-- Name: tags_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.tags_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.tags_id_seq OWNER TO darwin2;

--
-- TOC entry 6596 (class 0 OID 0)
-- Dependencies: 378
-- Name: tags_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.tags_id_seq OWNED BY darwin2.tags.id;


--
-- TOC entry 379 (class 1259 OID 4817366)
-- Name: taxonomy_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.taxonomy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.taxonomy_id_seq OWNER TO darwin2;

--
-- TOC entry 380 (class 1259 OID 4817368)
-- Name: taxonomy; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.taxonomy (
    id integer DEFAULT nextval('darwin2.taxonomy_id_seq'::regclass) NOT NULL,
    extinct boolean DEFAULT false NOT NULL,
    taxonomy_creation_date timestamp without time zone DEFAULT now(),
    import_ref integer,
    sensitive_info_withheld boolean,
    is_reference_taxonomy boolean DEFAULT true NOT NULL,
    metadata_ref integer NOT NULL,
    CONSTRAINT fct_chk_onceinpath_taxonomy CHECK (darwin2.fct_chk_onceinpath(((((COALESCE(path, ''::character varying))::text || '/'::text) || id))::character varying))
)
INHERITS (darwin2.template_classifications);


ALTER TABLE darwin2.taxonomy OWNER TO darwin2;

--
-- TOC entry 6597 (class 0 OID 0)
-- Dependencies: 380
-- Name: TABLE taxonomy; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.taxonomy IS 'Taxonomic classification table';


--
-- TOC entry 6598 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN taxonomy.name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.name IS 'Classification unit name';


--
-- TOC entry 6599 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN taxonomy.name_indexed; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.name_indexed IS 'Indexed form of name field';


--
-- TOC entry 6600 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN taxonomy.level_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.level_ref IS 'Reference of classification level the unit is encoded in';


--
-- TOC entry 6601 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN taxonomy.status; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.status IS 'Validitiy status: valid, invalid, in discussion';


--
-- TOC entry 6602 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN taxonomy.path; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.path IS 'Hierarchy path (/ for root)';


--
-- TOC entry 6603 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN taxonomy.parent_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.parent_ref IS 'Id of parent - id field from table itself';


--
-- TOC entry 6604 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN taxonomy.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.id IS 'Unique identifier of a classification unit';


--
-- TOC entry 6605 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN taxonomy.extinct; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.taxonomy.extinct IS 'Tells if taxonomy is extinct or not';


--
-- TOC entry 445 (class 1259 OID 5308736)
-- Name: taxonomy_authority; Type: TABLE; Schema: darwin2; Owner: postgres
--

CREATE TABLE darwin2.taxonomy_authority (
    id integer NOT NULL,
    taxonomy_ref integer NOT NULL,
    domain_ref bigint NOT NULL,
    url character varying NOT NULL,
    urn character varying,
    code character varying NOT NULL,
    pref_label character varying(255),
    profile public.hstore
);


ALTER TABLE darwin2.taxonomy_authority OWNER TO postgres;

--
-- TOC entry 444 (class 1259 OID 5308734)
-- Name: taxonomy_authority_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: postgres
--

CREATE SEQUENCE darwin2.taxonomy_authority_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.taxonomy_authority_id_seq OWNER TO postgres;

--
-- TOC entry 6608 (class 0 OID 0)
-- Dependencies: 444
-- Name: taxonomy_authority_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: postgres
--

ALTER SEQUENCE darwin2.taxonomy_authority_id_seq OWNED BY darwin2.taxonomy_authority.id;


--
-- TOC entry 381 (class 1259 OID 4817382)
-- Name: taxonomy_metadata; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.taxonomy_metadata (
    id integer NOT NULL,
    creation_date date NOT NULL,
    creation_date_mask integer,
    import_ref integer,
    taxonomy_name character varying NOT NULL,
    definition text,
    is_reference_taxonomy boolean NOT NULL,
    source character varying,
    url_website character varying,
    url_webservice character varying
);


ALTER TABLE darwin2.taxonomy_metadata OWNER TO darwin2;

--
-- TOC entry 382 (class 1259 OID 4817388)
-- Name: taxonomy_metadata_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.taxonomy_metadata_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.taxonomy_metadata_id_seq OWNER TO darwin2;

--
-- TOC entry 6610 (class 0 OID 0)
-- Dependencies: 382
-- Name: taxonomy_metadata_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.taxonomy_metadata_id_seq OWNED BY darwin2.taxonomy_metadata.id;


--
-- TOC entry 383 (class 1259 OID 4817390)
-- Name: temp_mineralogy; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.temp_mineralogy (
    code_variety text,
    name_variety text,
    formule text,
    class_name text,
    subclass_name text,
    series_name text,
    name_strunz text,
    code_serie_strunz text,
    code_subcla_strunz text,
    code_class_strunz text,
    name_engel text,
    code_serie_dana text,
    code_subcla_dana text,
    code_class_dana text
);


ALTER TABLE darwin2.temp_mineralogy OWNER TO darwin2;

--
-- TOC entry 426 (class 1259 OID 5304933)
-- Name: temporal_information_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.temporal_information_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.temporal_information_id_seq OWNER TO darwin2;

--
-- TOC entry 6611 (class 0 OID 0)
-- Dependencies: 426
-- Name: temporal_information_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: darwin2
--

ALTER SEQUENCE darwin2.temporal_information_id_seq OWNED BY darwin2.temporal_information.id;


--
-- TOC entry 384 (class 1259 OID 4817396)
-- Name: tv_reporting_count_all_specimens_by_collection_year_ig; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_reporting_count_all_specimens_by_collection_year_ig (
    collection_name character varying,
    collection_path character varying,
    collection_ref integer,
    year double precision,
    specimen_creation_date timestamp without time zone,
    nb_records bigint,
    specimen_count_min bigint,
    specimen_count_max bigint,
    ig_ref integer,
    ig_num character varying
);


ALTER TABLE darwin2.tv_reporting_count_all_specimens_by_collection_year_ig OWNER TO darwin2;

--
-- TOC entry 385 (class 1259 OID 4817402)
-- Name: tv_reporting_count_all_specimens_type_by_collection_ref_year_ig; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_reporting_count_all_specimens_type_by_collection_ref_year_ig (
    collection_path character varying,
    collection_name character varying,
    collection_ref integer,
    ig_ref integer,
    ig_num character varying,
    year double precision,
    specimen_creation_date timestamp without time zone,
    type text,
    nb_records bigint,
    specimen_count_min bigint,
    specimen_count_max bigint
);


ALTER TABLE darwin2.tv_reporting_count_all_specimens_type_by_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 386 (class 1259 OID 4817408)
-- Name: tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig (
    taxonomy_id integer,
    collection_path character varying,
    collection_ref integer,
    collection_name character varying,
    ig_ref integer,
    ig_num character varying,
    year double precision,
    creation_date timestamp without time zone,
    level_ref integer,
    level_name character varying,
    nb_records bigint,
    specimen_count_min bigint,
    specimen_count_max bigint
);


ALTER TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 389 (class 1259 OID 4817431)
-- Name: users_addresses_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_addresses_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_addresses_id_seq OWNER TO darwin2;

--
-- TOC entry 390 (class 1259 OID 4817433)
-- Name: users_addresses; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users_addresses (
    person_user_role character varying,
    id integer DEFAULT nextval('darwin2.users_addresses_id_seq'::regclass) NOT NULL,
    organization_unit character varying,
    tag character varying DEFAULT ''::character varying NOT NULL
)
INHERITS (darwin2.template_people_users_comm_common, darwin2.template_people_users_addr_common);


ALTER TABLE darwin2.users_addresses OWNER TO darwin2;

--
-- TOC entry 6617 (class 0 OID 0)
-- Dependencies: 390
-- Name: TABLE users_addresses; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users_addresses IS 'Users addresses';


--
-- TOC entry 6618 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.person_user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.person_user_ref IS 'Reference of the user concerned - id field of users table';


--
-- TOC entry 6619 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.entry; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.entry IS 'Street address';


--
-- TOC entry 6620 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.po_box; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.po_box IS 'PO Box';


--
-- TOC entry 6621 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.extended_address; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.extended_address IS 'Address extension: State, zip code suffix,...';


--
-- TOC entry 6622 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.locality; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.locality IS 'Locality';


--
-- TOC entry 6623 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.region; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.region IS 'Region';


--
-- TOC entry 6624 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.zip_code; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.zip_code IS 'Zip code';


--
-- TOC entry 6625 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.country; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.country IS 'Country';


--
-- TOC entry 6626 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.person_user_role; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.person_user_role IS 'User role in the organization referenced';


--
-- TOC entry 6627 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.id IS 'Unique identifier of a user address';


--
-- TOC entry 6628 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.organization_unit; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.organization_unit IS 'When a physical user is in relationship with a moral one, indicates the department or unit the user is related to';


--
-- TOC entry 6629 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN users_addresses.tag; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_addresses.tag IS 'List of descriptive tags: home, work,...';


--
-- TOC entry 393 (class 1259 OID 4817452)
-- Name: users_languages_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_languages_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_languages_id_seq OWNER TO darwin2;

--
-- TOC entry 394 (class 1259 OID 4817454)
-- Name: users_login_info_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_login_info_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_login_info_id_seq OWNER TO darwin2;

--
-- TOC entry 395 (class 1259 OID 4817456)
-- Name: users_login_infos; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users_login_infos (
    id integer DEFAULT nextval('darwin2.users_login_info_id_seq'::regclass) NOT NULL,
    user_ref integer NOT NULL,
    login_type character varying DEFAULT 'local'::character varying NOT NULL,
    user_name character varying,
    password character varying,
    login_system character varying,
    renew_hash character varying,
    last_seen timestamp without time zone
);


ALTER TABLE darwin2.users_login_infos OWNER TO darwin2;

--
-- TOC entry 6632 (class 0 OID 0)
-- Dependencies: 395
-- Name: TABLE users_login_infos; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users_login_infos IS 'Contains the login/password informations of DaRWIN 2 users';


--
-- TOC entry 6633 (class 0 OID 0)
-- Dependencies: 395
-- Name: COLUMN users_login_infos.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.user_ref IS 'Identifier of user - id field of users table';


--
-- TOC entry 6634 (class 0 OID 0)
-- Dependencies: 395
-- Name: COLUMN users_login_infos.login_type; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.login_type IS 'Type of identification system';


--
-- TOC entry 6635 (class 0 OID 0)
-- Dependencies: 395
-- Name: COLUMN users_login_infos.user_name; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.user_name IS 'For some system (local, ldap, kerberos,...) provides the username (encrypted form)';


--
-- TOC entry 6636 (class 0 OID 0)
-- Dependencies: 395
-- Name: COLUMN users_login_infos.password; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.password IS 'For some system (local, ldap, kerberos,...) provides the password (encrypted form)';


--
-- TOC entry 6637 (class 0 OID 0)
-- Dependencies: 395
-- Name: COLUMN users_login_infos.login_system; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.login_system IS 'For some system (shibbolet, openID,...) provides the user id';


--
-- TOC entry 6638 (class 0 OID 0)
-- Dependencies: 395
-- Name: COLUMN users_login_infos.renew_hash; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_login_infos.renew_hash IS 'Hashed key defined when asking to renew a password';


--
-- TOC entry 396 (class 1259 OID 4817464)
-- Name: users_tracking_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: darwin2
--

CREATE SEQUENCE darwin2.users_tracking_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.users_tracking_id_seq OWNER TO darwin2;

--
-- TOC entry 397 (class 1259 OID 4817466)
-- Name: users_tracking; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.users_tracking (
    id bigint DEFAULT nextval('darwin2.users_tracking_id_seq'::regclass) NOT NULL,
    referenced_relation character varying NOT NULL,
    record_id integer NOT NULL,
    user_ref integer NOT NULL,
    action character varying DEFAULT 'insert'::character varying NOT NULL,
    old_value public.hstore,
    new_value public.hstore,
    modification_date_time timestamp without time zone DEFAULT now() NOT NULL
);


ALTER TABLE darwin2.users_tracking OWNER TO darwin2;

--
-- TOC entry 6640 (class 0 OID 0)
-- Dependencies: 397
-- Name: TABLE users_tracking; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON TABLE darwin2.users_tracking IS 'Tracking of users actions on tables';


--
-- TOC entry 6641 (class 0 OID 0)
-- Dependencies: 397
-- Name: COLUMN users_tracking.id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.id IS 'Unique identifier of a table track entry';


--
-- TOC entry 6642 (class 0 OID 0)
-- Dependencies: 397
-- Name: COLUMN users_tracking.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.referenced_relation IS 'Reference-Name of table concerned';


--
-- TOC entry 6643 (class 0 OID 0)
-- Dependencies: 397
-- Name: COLUMN users_tracking.record_id; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.record_id IS 'ID of record concerned';


--
-- TOC entry 6644 (class 0 OID 0)
-- Dependencies: 397
-- Name: COLUMN users_tracking.user_ref; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.user_ref IS 'Reference of user having made an action - id field of users table';


--
-- TOC entry 6645 (class 0 OID 0)
-- Dependencies: 397
-- Name: COLUMN users_tracking.action; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.action IS 'Action done on table record: insert, update, delete';


--
-- TOC entry 6646 (class 0 OID 0)
-- Dependencies: 397
-- Name: COLUMN users_tracking.modification_date_time; Type: COMMENT; Schema: darwin2; Owner: darwin2
--

COMMENT ON COLUMN darwin2.users_tracking.modification_date_time IS 'Track date and time';


--
-- TOC entry 398 (class 1259 OID 4817475)
-- Name: v_darwin_ipt_rbins; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_ipt_rbins AS
SELECT
    NULL::text AS ids,
    NULL::text AS guid,
    NULL::integer AS collection_ref,
    NULL::character varying AS collection_code,
    NULL::character varying AS collection_name,
    NULL::integer AS collection_id,
    NULL::character varying AS collection_path,
    NULL::text AS cataloguenumber,
    NULL::text AS basisofrecord,
    NULL::text AS institutionid,
    NULL::text AS iso_country_institution,
    NULL::text AS bibliographic_citation,
    NULL::text AS license,
    NULL::text AS email,
    NULL::character varying AS type,
    NULL::character varying AS taxon_path,
    NULL::integer AS taxon_ref,
    NULL::character varying AS taxon_name,
    NULL::character varying AS family,
    NULL::character varying AS country,
    NULL::text AS location,
    NULL::character varying AS latitude,
    NULL::character varying AS longitude,
    NULL::double precision AS lat_long_accuracy,
    NULL::integer[] AS collector_ids,
    NULL::text AS collectors,
    NULL::integer[] AS donator_ids,
    NULL::text AS donators,
    NULL::integer[] AS identifiers_ids,
    NULL::text AS identifiers,
    NULL::timestamp without time zone AS gtu_from_date,
    NULL::integer AS gtu_from_date_mask,
    NULL::timestamp without time zone AS gtu_to_date,
    NULL::integer AS gtu_to_date_mask,
    NULL::text AS eventdate,
    NULL::character varying AS country_unnest,
    NULL::text AS identification_date,
    NULL::text AS history,
    NULL::integer AS gtu_ref;


ALTER TABLE darwin2.v_darwin_ipt_rbins OWNER TO darwin2;

--
-- TOC entry 399 (class 1259 OID 4817481)
-- Name: v_darwin_ipt_taxonomy; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_ipt_taxonomy AS
 SELECT taxonomy.id AS darwin_id,
    taxonomy.name AS scientificname,
    catalogue_levels.level_name AS taxonrank,
    catalogue_levels.level_name AS verbatimtaxonrank,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 2) AS kingdom,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 4) AS phylum,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 12) AS class,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 28) AS "order",
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 34) AS family,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 41) AS genus,
    replace((darwin2.fct_rmca_sort_taxon_path_alphabetically_not_indexed(taxonomy.path))::text, '/'::text, '|'::text) AS higherclassification,
    taxonomy.path,
    ((taxonomy.path)::text || ((taxonomy.id)::character varying)::text) AS full_path
   FROM (darwin2.taxonomy
     LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)));


ALTER TABLE darwin2.v_darwin_ipt_taxonomy OWNER TO darwin2;

--
-- TOC entry 400 (class 1259 OID 4817486)
-- Name: vernacular_names; Type: TABLE; Schema: darwin2; Owner: postgres
--

CREATE TABLE darwin2.vernacular_names (
    id integer NOT NULL,
    community character varying NOT NULL,
    community_indexed character varying NOT NULL,
    name character varying NOT NULL,
    name_indexed character varying NOT NULL
)
INHERITS (darwin2.template_table_record_ref);


ALTER TABLE darwin2.vernacular_names OWNER TO postgres;

--
-- TOC entry 6648 (class 0 OID 0)
-- Dependencies: 400
-- Name: TABLE vernacular_names; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON TABLE darwin2.vernacular_names IS 'List of vernacular names for a given unit and a given language community';


--
-- TOC entry 6649 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN vernacular_names.referenced_relation; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.vernacular_names.referenced_relation IS 'Reference of the unit table a vernacular name for a language community has to be defined - id field of table_list table';


--
-- TOC entry 6650 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN vernacular_names.record_id; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.vernacular_names.record_id IS 'Identifier of record a vernacular name for a language community has to be defined';


--
-- TOC entry 6651 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN vernacular_names.community; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.vernacular_names.community IS 'Language community, a unit translation is available for';


--
-- TOC entry 6652 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN vernacular_names.community_indexed; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.vernacular_names.community_indexed IS 'indexed version of the language community';


--
-- TOC entry 6653 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN vernacular_names.name; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.vernacular_names.name IS 'Vernacular name';


--
-- TOC entry 6654 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN vernacular_names.name_indexed; Type: COMMENT; Schema: darwin2; Owner: postgres
--

COMMENT ON COLUMN darwin2.vernacular_names.name_indexed IS 'Indexed form of vernacular name';


--
-- TOC entry 401 (class 1259 OID 4817492)
-- Name: v_darwin_ipt_taxonomy_vernacular; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_darwin_ipt_taxonomy_vernacular AS
 SELECT taxonomy.id AS darwin_id,
    taxonomy.name AS scientificname,
    catalogue_levels.level_name AS taxonrank,
    catalogue_levels.level_name AS verbatimtaxonrank,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 2) AS kingdom,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 4) AS phylum,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 12) AS class,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 28) AS "order",
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 34) AS family,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(taxonomy.id, 41) AS genus,
    replace((darwin2.fct_rmca_sort_taxon_path_alphabetically_not_indexed(taxonomy.path))::text, '/'::text, '|'::text) AS higherclassification,
    taxonomy.path,
    (((taxonomy.path)::text || '/'::text) || taxonomy.id) AS full_path,
    vernacular_names.community,
    vernacular_names.name
   FROM ((darwin2.taxonomy
     LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)))
     LEFT JOIN darwin2.vernacular_names ON ((((vernacular_names.referenced_relation)::text = 'taxonomy'::text) AND (vernacular_names.record_id = taxonomy.id))));


ALTER TABLE darwin2.v_darwin_ipt_taxonomy_vernacular OWNER TO darwin2;

--
-- TOC entry 402 (class 1259 OID 4817497)
-- Name: v_imports_encoded_xml_name; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_imports_encoded_xml_name AS
 SELECT (('uploaded_'::text || encode(public.digest(((imports.filename)::text || ((imports.created_at)::character varying)::text), 'sha1'::text), 'hex'::text)) || '.xml'::text) AS filename_encoded,
    imports.id,
    imports.user_ref,
    imports.format,
    imports.collection_ref,
    imports.filename,
    imports.state,
    imports.created_at,
    imports.updated_at,
    imports.initial_count,
    imports.is_finished,
    imports.errors_in_import,
    imports.template_version,
    imports.exclude_invalid_entries
   FROM darwin2.imports;


ALTER TABLE darwin2.v_imports_encoded_xml_name OWNER TO darwin2;

--
-- TOC entry 403 (class 1259 OID 4817502)
-- Name: v_normalize_gtu_without_date; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.v_normalize_gtu_without_date AS
 SELECT DISTINCT array_agg(a.gtu_id ORDER BY a.gtu_id) AS gtu_id,
    a.code,
    a.tag_values_indexed,
    a.latitude,
    a.longitude,
    a.lat_long_accuracy,
    a.location,
    a.elevation,
    a.elevation_accuracy,
    a.latitude_dms_degree,
    a.latitude_dms_minutes,
    a.latitude_dms_seconds,
    a.latitude_dms_direction,
    a.longitude_dms_degree,
    a.longitude_dms_minutes,
    a.longitude_dms_seconds,
    a.longitude_dms_direction,
    a.latitude_utm,
    a.longitude_utm,
    a.utm_zone,
    a.coordinates_source,
    a.gtu_creation_date,
    a.import_ref,
    a.comments,
    a.properties,
    a.ext_links,
    a.multimedias,
    a.tags,
    a.tag_groups
   FROM ( SELECT DISTINCT gtu.id AS gtu_id,
            gtu.code,
            gtu.tag_values_indexed,
            gtu.latitude,
            gtu.longitude,
            gtu.lat_long_accuracy,
            (gtu.location)::character varying AS location,
            gtu.elevation,
            gtu.elevation_accuracy,
            gtu.latitude_dms_degree,
            gtu.latitude_dms_minutes,
            gtu.latitude_dms_seconds,
            gtu.latitude_dms_direction,
            gtu.longitude_dms_degree,
            gtu.longitude_dms_minutes,
            gtu.longitude_dms_seconds,
            gtu.longitude_dms_direction,
            gtu.latitude_utm,
            gtu.longitude_utm,
            gtu.utm_zone,
            gtu.coordinates_source,
            gtu.gtu_creation_date,
            gtu.import_ref,
            array_agg(DISTINCT (((COALESCE(comments.notion_concerned, ''::character varying))::text || COALESCE(comments.comment, ''::text)) || COALESCE(comments.comment_indexed, ''::text)) ORDER BY (((COALESCE(comments.notion_concerned, ''::character varying))::text || COALESCE(comments.comment, ''::text)) || COALESCE(comments.comment_indexed, ''::text))) AS comments,
            array_agg(DISTINCT ((((((((((((((((COALESCE(properties.property_type, ''::character varying))::text || (COALESCE(properties.applies_to, ''::character varying))::text) || (COALESCE(properties.applies_to_indexed, ''::character varying))::text) || (COALESCE((properties.date_from_mask)::character varying, ''::character varying))::text) || (COALESCE((properties.date_from)::character varying, ''::character varying))::text) || (COALESCE((properties.date_to_mask)::character varying, ''::character varying))::text) || (COALESCE((properties.date_to)::character varying, ''::character varying))::text) || (COALESCE((properties.is_quantitative)::character varying, ''::character varying))::text) || (COALESCE(properties.property_unit, ''::character varying))::text) || (COALESCE(properties.method, ''::character varying))::text) || (COALESCE(properties.method_indexed, ''::character varying))::text) || (COALESCE(properties.lower_value, ''::character varying))::text) || (COALESCE((properties.lower_value_unified)::character varying, ''::character varying))::text) || (COALESCE(properties.upper_value, ''::character varying))::text) || (COALESCE((properties.upper_value_unified)::character varying, ''::character varying))::text) || (COALESCE(properties.property_accuracy, ''::character varying))::text) ORDER BY ((((((((((((((((COALESCE(properties.property_type, ''::character varying))::text || (COALESCE(properties.applies_to, ''::character varying))::text) || (COALESCE(properties.applies_to_indexed, ''::character varying))::text) || (COALESCE((properties.date_from_mask)::character varying, ''::character varying))::text) || (COALESCE((properties.date_from)::character varying, ''::character varying))::text) || (COALESCE((properties.date_to_mask)::character varying, ''::character varying))::text) || (COALESCE((properties.date_to)::character varying, ''::character varying))::text) || (COALESCE((properties.is_quantitative)::character varying, ''::character varying))::text) || (COALESCE(properties.property_unit, ''::character varying))::text) || (COALESCE(properties.method, ''::character varying))::text) || (COALESCE(properties.method_indexed, ''::character varying))::text) || (COALESCE(properties.lower_value, ''::character varying))::text) || (COALESCE((properties.lower_value_unified)::character varying, ''::character varying))::text) || (COALESCE(properties.upper_value, ''::character varying))::text) || (COALESCE((properties.upper_value_unified)::character varying, ''::character varying))::text) || (COALESCE(properties.property_accuracy, ''::character varying))::text)) AS properties,
            array_agg(DISTINCT ((((COALESCE(ext_links.url, ''::character varying))::text || COALESCE(ext_links.comment, ''::text)) || COALESCE(ext_links.comment_indexed, ''::text)) || COALESCE(ext_links.type, ''::text)) ORDER BY ((((COALESCE(ext_links.url, ''::character varying))::text || COALESCE(ext_links.comment, ''::text)) || COALESCE(ext_links.comment_indexed, ''::text)) || COALESCE(ext_links.type, ''::text))) AS ext_links,
            array_agg(DISTINCT ((((((((((((((COALESCE((multimedia.is_digital)::character varying, ''::character varying))::text || (COALESCE(multimedia.type, ''::character varying))::text) || (COALESCE(multimedia.sub_type, ''::character varying))::text) || (COALESCE(multimedia.title, ''::character varying))::text) || (COALESCE(multimedia.description, ''::character varying))::text) || (COALESCE(multimedia.uri, ''::character varying))::text) || (COALESCE(multimedia.filename, ''::character varying))::text) || COALESCE(multimedia.search_indexed, ''::text)) || (COALESCE((multimedia.creation_date)::character varying, ''::character varying))::text) || (COALESCE((multimedia.creation_date_mask)::character varying, ''::character varying))::text) || (COALESCE(multimedia.mime_type, ''::character varying))::text) || (COALESCE((multimedia.visible)::character varying, ''::character varying))::text) || (COALESCE((multimedia.publishable)::character varying, ''::character varying))::text) || COALESCE(multimedia.extracted_info, ''::text)) ORDER BY ((((((((((((((COALESCE((multimedia.is_digital)::character varying, ''::character varying))::text || (COALESCE(multimedia.type, ''::character varying))::text) || (COALESCE(multimedia.sub_type, ''::character varying))::text) || (COALESCE(multimedia.title, ''::character varying))::text) || (COALESCE(multimedia.description, ''::character varying))::text) || (COALESCE(multimedia.uri, ''::character varying))::text) || (COALESCE(multimedia.filename, ''::character varying))::text) || COALESCE(multimedia.search_indexed, ''::text)) || (COALESCE((multimedia.creation_date)::character varying, ''::character varying))::text) || (COALESCE((multimedia.creation_date_mask)::character varying, ''::character varying))::text) || (COALESCE(multimedia.mime_type, ''::character varying))::text) || (COALESCE((multimedia.visible)::character varying, ''::character varying))::text) || (COALESCE((multimedia.publishable)::character varying, ''::character varying))::text) || COALESCE(multimedia.extracted_info, ''::text))) AS multimedias,
            array_agg(DISTINCT ((((COALESCE(tags.group_type, ''::character varying))::text || (COALESCE(tags.sub_group_type, ''::character varying))::text) || (COALESCE(tags.tag, ''::character varying))::text) || (COALESCE(tags.tag_indexed, ''::character varying))::text) ORDER BY ((((COALESCE(tags.group_type, ''::character varying))::text || (COALESCE(tags.sub_group_type, ''::character varying))::text) || (COALESCE(tags.tag, ''::character varying))::text) || (COALESCE(tags.tag_indexed, ''::character varying))::text)) AS tags,
            array_agg(DISTINCT (((((((COALESCE(tag_groups.group_name, ''::character varying))::text || (COALESCE(tag_groups.group_name_indexed, ''::character varying))::text) || (COALESCE(tag_groups.sub_group_name, ''::character varying))::text) || (COALESCE(tag_groups.sub_group_name_indexed, ''::character varying))::text) || COALESCE(tag_groups.international_name, ''::text)) || (COALESCE(tag_groups.color, ''::character varying))::text) || (COALESCE(tag_groups.tag_value, ''::character varying))::text) ORDER BY (((((((COALESCE(tag_groups.group_name, ''::character varying))::text || (COALESCE(tag_groups.group_name_indexed, ''::character varying))::text) || (COALESCE(tag_groups.sub_group_name, ''::character varying))::text) || (COALESCE(tag_groups.sub_group_name_indexed, ''::character varying))::text) || COALESCE(tag_groups.international_name, ''::text)) || (COALESCE(tag_groups.color, ''::character varying))::text) || (COALESCE(tag_groups.tag_value, ''::character varying))::text)) AS tag_groups
           FROM ((((((darwin2.gtu
             LEFT JOIN darwin2.comments ON (((gtu.id = comments.record_id) AND ((comments.referenced_relation)::text = 'gtu'::text))))
             LEFT JOIN darwin2.properties ON (((gtu.id = properties.record_id) AND ((properties.referenced_relation)::text = 'gtu'::text))))
             LEFT JOIN darwin2.ext_links ON (((gtu.id = ext_links.record_id) AND ((ext_links.referenced_relation)::text = 'gtu'::text))))
             LEFT JOIN darwin2.multimedia ON (((gtu.id = multimedia.record_id) AND ((multimedia.referenced_relation)::text = 'gtu'::text))))
             LEFT JOIN darwin2.tags ON ((gtu.id = tags.gtu_ref)))
             LEFT JOIN darwin2.tag_groups ON ((gtu.id = tag_groups.gtu_ref)))
          GROUP BY gtu.id, gtu.code, gtu.tag_values_indexed, gtu.latitude, gtu.longitude, gtu.lat_long_accuracy, (gtu.location)::character varying, gtu.elevation, gtu.elevation_accuracy, gtu.latitude_dms_degree, gtu.latitude_dms_minutes, gtu.latitude_dms_seconds, gtu.latitude_dms_direction, gtu.longitude_dms_degree, gtu.longitude_dms_minutes, gtu.longitude_dms_seconds, gtu.longitude_dms_direction, gtu.latitude_utm, gtu.longitude_utm, gtu.utm_zone, gtu.coordinates_source, gtu.gtu_creation_date, gtu.import_ref) a
  GROUP BY a.code, a.tag_values_indexed, a.latitude, a.longitude, a.lat_long_accuracy, a.location, a.elevation, a.elevation_accuracy, a.latitude_dms_degree, a.latitude_dms_minutes, a.latitude_dms_seconds, a.latitude_dms_direction, a.longitude_dms_degree, a.longitude_dms_minutes, a.longitude_dms_seconds, a.longitude_dms_direction, a.latitude_utm, a.longitude_utm, a.utm_zone, a.coordinates_source, a.gtu_creation_date, a.import_ref, a.comments, a.properties, a.ext_links, a.multimedias, a.tags, a.tag_groups
  WITH NO DATA;


ALTER TABLE darwin2.v_normalize_gtu_without_date OWNER TO darwin2;

--
-- TOC entry 404 (class 1259 OID 4817510)
-- Name: v_normalize_gtu_without_date_no_code; Type: MATERIALIZED VIEW; Schema: darwin2; Owner: darwin2
--

CREATE MATERIALIZED VIEW darwin2.v_normalize_gtu_without_date_no_code AS
 SELECT DISTINCT array_agg(a.gtu_id ORDER BY a.gtu_id) AS gtu_id,
    a.tag_values_indexed,
    a.latitude,
    a.longitude,
    a.lat_long_accuracy,
    a.location,
    a.elevation,
    a.elevation_accuracy,
    a.latitude_dms_degree,
    a.latitude_dms_minutes,
    a.latitude_dms_seconds,
    a.latitude_dms_direction,
    a.longitude_dms_degree,
    a.longitude_dms_minutes,
    a.longitude_dms_seconds,
    a.longitude_dms_direction,
    a.latitude_utm,
    a.longitude_utm,
    a.utm_zone,
    a.coordinates_source,
    a.gtu_creation_date,
    a.import_ref,
    a.comments,
    a.properties,
    a.ext_links,
    a.multimedias,
    a.tags,
    a.tag_groups
   FROM ( SELECT DISTINCT gtu.id AS gtu_id,
            gtu.tag_values_indexed,
            gtu.latitude,
            gtu.longitude,
            gtu.lat_long_accuracy,
            (gtu.location)::character varying AS location,
            gtu.elevation,
            gtu.elevation_accuracy,
            gtu.latitude_dms_degree,
            gtu.latitude_dms_minutes,
            gtu.latitude_dms_seconds,
            gtu.latitude_dms_direction,
            gtu.longitude_dms_degree,
            gtu.longitude_dms_minutes,
            gtu.longitude_dms_seconds,
            gtu.longitude_dms_direction,
            gtu.latitude_utm,
            gtu.longitude_utm,
            gtu.utm_zone,
            gtu.coordinates_source,
            gtu.gtu_creation_date,
            gtu.import_ref,
            array_agg(DISTINCT (((COALESCE(comments.notion_concerned, ''::character varying))::text || COALESCE(comments.comment, ''::text)) || COALESCE(comments.comment_indexed, ''::text)) ORDER BY (((COALESCE(comments.notion_concerned, ''::character varying))::text || COALESCE(comments.comment, ''::text)) || COALESCE(comments.comment_indexed, ''::text))) AS comments,
            array_agg(DISTINCT ((((((((((((((((COALESCE(properties.property_type, ''::character varying))::text || (COALESCE(properties.applies_to, ''::character varying))::text) || (COALESCE(properties.applies_to_indexed, ''::character varying))::text) || (COALESCE((properties.date_from_mask)::character varying, ''::character varying))::text) || (COALESCE((properties.date_from)::character varying, ''::character varying))::text) || (COALESCE((properties.date_to_mask)::character varying, ''::character varying))::text) || (COALESCE((properties.date_to)::character varying, ''::character varying))::text) || (COALESCE((properties.is_quantitative)::character varying, ''::character varying))::text) || (COALESCE(properties.property_unit, ''::character varying))::text) || (COALESCE(properties.method, ''::character varying))::text) || (COALESCE(properties.method_indexed, ''::character varying))::text) || (COALESCE(properties.lower_value, ''::character varying))::text) || (COALESCE((properties.lower_value_unified)::character varying, ''::character varying))::text) || (COALESCE(properties.upper_value, ''::character varying))::text) || (COALESCE((properties.upper_value_unified)::character varying, ''::character varying))::text) || (COALESCE(properties.property_accuracy, ''::character varying))::text) ORDER BY ((((((((((((((((COALESCE(properties.property_type, ''::character varying))::text || (COALESCE(properties.applies_to, ''::character varying))::text) || (COALESCE(properties.applies_to_indexed, ''::character varying))::text) || (COALESCE((properties.date_from_mask)::character varying, ''::character varying))::text) || (COALESCE((properties.date_from)::character varying, ''::character varying))::text) || (COALESCE((properties.date_to_mask)::character varying, ''::character varying))::text) || (COALESCE((properties.date_to)::character varying, ''::character varying))::text) || (COALESCE((properties.is_quantitative)::character varying, ''::character varying))::text) || (COALESCE(properties.property_unit, ''::character varying))::text) || (COALESCE(properties.method, ''::character varying))::text) || (COALESCE(properties.method_indexed, ''::character varying))::text) || (COALESCE(properties.lower_value, ''::character varying))::text) || (COALESCE((properties.lower_value_unified)::character varying, ''::character varying))::text) || (COALESCE(properties.upper_value, ''::character varying))::text) || (COALESCE((properties.upper_value_unified)::character varying, ''::character varying))::text) || (COALESCE(properties.property_accuracy, ''::character varying))::text)) AS properties,
            array_agg(DISTINCT ((((COALESCE(ext_links.url, ''::character varying))::text || COALESCE(ext_links.comment, ''::text)) || COALESCE(ext_links.comment_indexed, ''::text)) || COALESCE(ext_links.type, ''::text)) ORDER BY ((((COALESCE(ext_links.url, ''::character varying))::text || COALESCE(ext_links.comment, ''::text)) || COALESCE(ext_links.comment_indexed, ''::text)) || COALESCE(ext_links.type, ''::text))) AS ext_links,
            array_agg(DISTINCT ((((((((((((((COALESCE((multimedia.is_digital)::character varying, ''::character varying))::text || (COALESCE(multimedia.type, ''::character varying))::text) || (COALESCE(multimedia.sub_type, ''::character varying))::text) || (COALESCE(multimedia.title, ''::character varying))::text) || (COALESCE(multimedia.description, ''::character varying))::text) || (COALESCE(multimedia.uri, ''::character varying))::text) || (COALESCE(multimedia.filename, ''::character varying))::text) || COALESCE(multimedia.search_indexed, ''::text)) || (COALESCE((multimedia.creation_date)::character varying, ''::character varying))::text) || (COALESCE((multimedia.creation_date_mask)::character varying, ''::character varying))::text) || (COALESCE(multimedia.mime_type, ''::character varying))::text) || (COALESCE((multimedia.visible)::character varying, ''::character varying))::text) || (COALESCE((multimedia.publishable)::character varying, ''::character varying))::text) || COALESCE(multimedia.extracted_info, ''::text)) ORDER BY ((((((((((((((COALESCE((multimedia.is_digital)::character varying, ''::character varying))::text || (COALESCE(multimedia.type, ''::character varying))::text) || (COALESCE(multimedia.sub_type, ''::character varying))::text) || (COALESCE(multimedia.title, ''::character varying))::text) || (COALESCE(multimedia.description, ''::character varying))::text) || (COALESCE(multimedia.uri, ''::character varying))::text) || (COALESCE(multimedia.filename, ''::character varying))::text) || COALESCE(multimedia.search_indexed, ''::text)) || (COALESCE((multimedia.creation_date)::character varying, ''::character varying))::text) || (COALESCE((multimedia.creation_date_mask)::character varying, ''::character varying))::text) || (COALESCE(multimedia.mime_type, ''::character varying))::text) || (COALESCE((multimedia.visible)::character varying, ''::character varying))::text) || (COALESCE((multimedia.publishable)::character varying, ''::character varying))::text) || COALESCE(multimedia.extracted_info, ''::text))) AS multimedias,
            array_agg(DISTINCT ((((COALESCE(tags.group_type, ''::character varying))::text || (COALESCE(tags.sub_group_type, ''::character varying))::text) || (COALESCE(tags.tag, ''::character varying))::text) || (COALESCE(tags.tag_indexed, ''::character varying))::text) ORDER BY ((((COALESCE(tags.group_type, ''::character varying))::text || (COALESCE(tags.sub_group_type, ''::character varying))::text) || (COALESCE(tags.tag, ''::character varying))::text) || (COALESCE(tags.tag_indexed, ''::character varying))::text)) AS tags,
            array_agg(DISTINCT (((((((COALESCE(tag_groups.group_name, ''::character varying))::text || (COALESCE(tag_groups.group_name_indexed, ''::character varying))::text) || (COALESCE(tag_groups.sub_group_name, ''::character varying))::text) || (COALESCE(tag_groups.sub_group_name_indexed, ''::character varying))::text) || COALESCE(tag_groups.international_name, ''::text)) || (COALESCE(tag_groups.color, ''::character varying))::text) || (COALESCE(tag_groups.tag_value, ''::character varying))::text) ORDER BY (((((((COALESCE(tag_groups.group_name, ''::character varying))::text || (COALESCE(tag_groups.group_name_indexed, ''::character varying))::text) || (COALESCE(tag_groups.sub_group_name, ''::character varying))::text) || (COALESCE(tag_groups.sub_group_name_indexed, ''::character varying))::text) || COALESCE(tag_groups.international_name, ''::text)) || (COALESCE(tag_groups.color, ''::character varying))::text) || (COALESCE(tag_groups.tag_value, ''::character varying))::text)) AS tag_groups
           FROM ((((((darwin2.gtu
             LEFT JOIN darwin2.comments ON (((gtu.id = comments.record_id) AND ((comments.referenced_relation)::text = 'gtu'::text))))
             LEFT JOIN darwin2.properties ON (((gtu.id = properties.record_id) AND ((properties.referenced_relation)::text = 'gtu'::text))))
             LEFT JOIN darwin2.ext_links ON (((gtu.id = ext_links.record_id) AND ((ext_links.referenced_relation)::text = 'gtu'::text))))
             LEFT JOIN darwin2.multimedia ON (((gtu.id = multimedia.record_id) AND ((multimedia.referenced_relation)::text = 'gtu'::text))))
             LEFT JOIN darwin2.tags ON ((gtu.id = tags.gtu_ref)))
             LEFT JOIN darwin2.tag_groups ON ((gtu.id = tag_groups.gtu_ref)))
          GROUP BY gtu.id, gtu.tag_values_indexed, gtu.latitude, gtu.longitude, gtu.lat_long_accuracy, (gtu.location)::character varying, gtu.elevation, gtu.elevation_accuracy, gtu.latitude_dms_degree, gtu.latitude_dms_minutes, gtu.latitude_dms_seconds, gtu.latitude_dms_direction, gtu.longitude_dms_degree, gtu.longitude_dms_minutes, gtu.longitude_dms_seconds, gtu.longitude_dms_direction, gtu.latitude_utm, gtu.longitude_utm, gtu.utm_zone, gtu.coordinates_source, gtu.gtu_creation_date, gtu.import_ref) a
  GROUP BY a.tag_values_indexed, a.latitude, a.longitude, a.lat_long_accuracy, a.location, a.elevation, a.elevation_accuracy, a.latitude_dms_degree, a.latitude_dms_minutes, a.latitude_dms_seconds, a.latitude_dms_direction, a.longitude_dms_degree, a.longitude_dms_minutes, a.longitude_dms_seconds, a.longitude_dms_direction, a.latitude_utm, a.longitude_utm, a.utm_zone, a.coordinates_source, a.gtu_creation_date, a.import_ref, a.comments, a.properties, a.ext_links, a.multimedias, a.tags, a.tag_groups
  WITH NO DATA;


ALTER TABLE darwin2.v_normalize_gtu_without_date_no_code OWNER TO darwin2;

--
-- TOC entry 431 (class 1259 OID 5307654)
-- Name: v_reindex_tag_spaces; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reindex_tag_spaces AS
SELECT
    NULL::bigint AS id,
    NULL::integer AS gtu_ref,
    NULL::text AS tag_value;


ALTER TABLE darwin2.v_reindex_tag_spaces OWNER TO darwin2;

--
-- TOC entry 405 (class 1259 OID 4817518)
-- Name: v_reporting_count_all_specimens; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens AS
 SELECT count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM darwin2.specimens;


ALTER TABLE darwin2.v_reporting_count_all_specimens OWNER TO darwin2;

--
-- TOC entry 406 (class 1259 OID 4817522)
-- Name: v_reporting_count_all_specimens_by_collection_year_ig; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_by_collection_year_ig AS
 SELECT DISTINCT specimens.collection_name,
    specimens.collection_path,
    specimens.collection_ref,
    date_part('year'::text, specimens.specimen_creation_date) AS year,
    specimens.specimen_creation_date,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max,
    specimens.ig_ref,
    specimens.ig_num
   FROM darwin2.specimens
  GROUP BY specimens.collection_ref, specimens.collection_name, specimens.collection_path, (date_part('year'::text, specimens.specimen_creation_date)), specimens.specimen_creation_date, specimens.ig_ref, specimens.ig_num;


ALTER TABLE darwin2.v_reporting_count_all_specimens_by_collection_year_ig OWNER TO darwin2;

--
-- TOC entry 407 (class 1259 OID 4817527)
-- Name: v_reporting_count_all_specimens_by_year; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_by_year AS
 SELECT DISTINCT date_part('year'::text, specimens.specimen_creation_date) AS year,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM darwin2.specimens
  GROUP BY (date_part('year'::text, specimens.specimen_creation_date));


ALTER TABLE darwin2.v_reporting_count_all_specimens_by_year OWNER TO darwin2;

--
-- TOC entry 408 (class 1259 OID 4817532)
-- Name: v_reporting_count_all_specimens_type; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_type AS
 SELECT btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&)'::text), '\d'::text, ''::text)) AS type,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM darwin2.specimens
  GROUP BY (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&)'::text), '\d'::text, ''::text)))
  ORDER BY (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&)'::text), '\d'::text, ''::text)));


ALTER TABLE darwin2.v_reporting_count_all_specimens_type OWNER TO darwin2;

--
-- TOC entry 409 (class 1259 OID 4817537)
-- Name: v_reporting_count_all_specimens_type_by_collection_ref_year_ig; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_type_by_collection_ref_year_ig AS
 SELECT DISTINCT specimens.collection_path,
    specimens.collection_name,
    specimens.collection_ref,
    specimens.ig_ref,
    specimens.ig_num,
    date_part('year'::text, specimens.specimen_creation_date) AS year,
    specimens.specimen_creation_date,
    btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&|\/|\s)'::text), '\d'::text, ''::text)) AS type,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM darwin2.specimens
  GROUP BY specimens.collection_path, specimens.collection_name, specimens.collection_ref, specimens.ig_ref, specimens.ig_num, specimens.specimen_creation_date, (date_part('year'::text, specimens.specimen_creation_date)), (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&|\/|\s)'::text), '\d'::text, ''::text)))
  ORDER BY (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&|\/|\s)'::text), '\d'::text, ''::text)));


ALTER TABLE darwin2.v_reporting_count_all_specimens_type_by_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 410 (class 1259 OID 4817542)
-- Name: v_reporting_count_all_specimens_type_by_year; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_count_all_specimens_type_by_year AS
 SELECT DISTINCT date_part('year'::text, specimens.specimen_creation_date) AS year,
    btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&)'::text), '\d'::text, ''::text)) AS type,
    count(*) AS nb_records,
    sum(specimens.specimen_count_min) AS specimen_count_min,
    sum(specimens.specimen_count_max) AS specimen_count_max
   FROM darwin2.specimens
  GROUP BY (date_part('year'::text, specimens.specimen_creation_date)), (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&)'::text), '\d'::text, ''::text)))
  ORDER BY (btrim(regexp_replace(regexp_split_to_table(replace(lower((specimens.type)::text), 'types'::text, 'type'::text), '(and|\+|&)'::text), '\d'::text, ''::text)));


ALTER TABLE darwin2.v_reporting_count_all_specimens_type_by_year OWNER TO darwin2;

--
-- TOC entry 411 (class 1259 OID 4817547)
-- Name: v_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig AS
 SELECT a.taxonomy_id,
    a.collection_path,
    a.collection_ref,
    a.collection_name,
    a.ig_ref,
    a.ig_num,
    a.year,
    a.creation_date,
    a.level_ref,
    a.level_name,
    count(*) AS nb_records,
    sum(a.specimen_count_min) AS specimen_count_min,
    sum(a.specimen_count_max) AS specimen_count_max
   FROM ( SELECT taxonomy.id AS taxonomy_id,
            specimens.collection_path,
            specimens.collection_ref,
            specimens.collection_name,
            taxonomy.id,
            date_part('year'::text, min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date))) AS year,
            min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date)) AS creation_date,
            taxonomy.level_ref,
            catalogue_levels.level_name,
            specimens.ig_ref,
            specimens.ig_num,
            specimens.specimen_count_min,
            specimens.specimen_count_max
           FROM ((darwin2.taxonomy
             JOIN darwin2.specimens ON ((taxonomy.id = specimens.taxon_ref)))
             LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)))
          GROUP BY taxonomy.id, specimens.collection_path, specimens.collection_name, specimens.collection_ref, taxonomy.level_ref, catalogue_levels.level_name, specimens.ig_ref, specimens.ig_num, specimens.specimen_count_min, specimens.specimen_count_max) a
  GROUP BY a.taxonomy_id, a.collection_path, a.collection_name, a.collection_ref, a.year, a.creation_date, a.level_ref, a.level_name, a.ig_ref, a.ig_num, a.specimen_count_min, a.specimen_count_max
  ORDER BY a.year, a.level_name DESC;


ALTER TABLE darwin2.v_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig OWNER TO darwin2;

--
-- TOC entry 412 (class 1259 OID 4817552)
-- Name: v_reporting_taxa_in_specimen_per_year; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_taxa_in_specimen_per_year AS
 SELECT a.year,
    count(*) AS count
   FROM ( SELECT taxonomy.id,
            date_part('year'::text, min(COALESCE(taxonomy.taxonomy_creation_date, specimens.specimen_creation_date))) AS year
           FROM (darwin2.taxonomy
             JOIN darwin2.specimens ON ((taxonomy.id = specimens.taxon_ref)))
          WHERE (taxonomy.taxonomy_creation_date IS NOT NULL)
          GROUP BY taxonomy.id) a
  GROUP BY a.year
  ORDER BY a.year DESC;


ALTER TABLE darwin2.v_reporting_taxa_in_specimen_per_year OWNER TO darwin2;

--
-- TOC entry 413 (class 1259 OID 4817557)
-- Name: v_reporting_taxonomy_general; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_taxonomy_general AS
 SELECT catalogue_levels.level_name,
    count(*) AS count
   FROM (darwin2.taxonomy
     LEFT JOIN darwin2.catalogue_levels ON ((taxonomy.level_ref = catalogue_levels.id)))
  GROUP BY catalogue_levels.level_name, taxonomy.level_ref
  ORDER BY taxonomy.level_ref;


ALTER TABLE darwin2.v_reporting_taxonomy_general OWNER TO darwin2;

--
-- TOC entry 414 (class 1259 OID 4817561)
-- Name: v_reporting_taxonomy_in_specimen; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_reporting_taxonomy_in_specimen AS
 SELECT specimens.taxon_level_name,
    count(DISTINCT specimens.taxon_name) AS count
   FROM darwin2.specimens
  GROUP BY specimens.taxon_level_ref, specimens.taxon_level_name
  ORDER BY specimens.taxon_level_ref;


ALTER TABLE darwin2.v_reporting_taxonomy_in_specimen OWNER TO darwin2;

--
-- TOC entry 415 (class 1259 OID 4817566)
-- Name: v_rmca_collections_path_as_text; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_collections_path_as_text AS
 SELECT DISTINCT a.id,
    a.collection_type,
    a.code,
    a.name,
    a.name_indexed,
    a.institution_ref,
    a.main_manager_ref,
    a.parent_ref,
    a.path,
    string_agg((( SELECT collections.name
           FROM darwin2.collections
          WHERE (collections.id = (a.id_path)::integer)))::text, '/'::text ORDER BY a.id_path) AS collection_path_text
   FROM ( SELECT DISTINCT collections.id,
            collections.collection_type,
            collections.code,
            collections.name,
            collections.name_indexed,
            collections.institution_ref,
            collections.main_manager_ref,
            collections.parent_ref,
            collections.path,
            unnest(string_to_array((collections.path)::text, '/'::text)) AS id_path,
            collections.code_auto_increment,
            collections.code_last_value,
            collections.code_prefix,
            collections.code_prefix_separator,
            collections.code_suffix,
            collections.code_suffix_separator,
            collections.is_public,
            collections.code_specimen_duplicate,
            collections.staff_ref,
            collections.code_auto_increment_for_insert_only,
            collections.code_mask,
            collections.allow_duplicates
           FROM darwin2.collections
          ORDER BY collections.id) a
  WHERE (length(a.id_path) > 0)
  GROUP BY a.id, a.collection_type, a.code, a.name, a.name_indexed, a.institution_ref, a.main_manager_ref, a.parent_ref, a.path
  ORDER BY a.id;


ALTER TABLE darwin2.v_rmca_collections_path_as_text OWNER TO darwin2;

--
-- TOC entry 416 (class 1259 OID 4817571)
-- Name: v_rmca_public_view; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_public_view AS
 SELECT DISTINCT specimens.id,
    specimens.code_display,
    specimens.taxon_path,
    specimens.taxon_ref,
    specimens.taxon_name,
    specimens.gtu_country_tag_value,
    specimens.gtu_others_tag_value,
    specimens.gtu_from_date,
    specimens.gtu_from_date_mask,
    specimens.gtu_to_date,
    specimens.gtu_to_date_mask,
    darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask) AS date_from_display,
    darwin2.fct_mask_date(specimens.gtu_to_date, specimens.gtu_to_date_mask) AS date_to_display,
    specimens.coll_type,
    specimens.longitude,
    specimens.latitude,
    count(*) OVER () AS full_count
   FROM ( SELECT specimens_1.id,
            (((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text) AS code_display,
            codes.full_code_indexed,
            specimens_1.taxon_path,
            specimens_1.taxon_ref,
            specimens_1.collection_ref,
            specimens_1.gtu_country_tag_indexed,
            specimens_1.gtu_country_tag_value,
            specimens_1.gtu_others_tag_indexed AS localities_indexed,
            specimens_1.gtu_others_tag_value,
            specimens_1.taxon_name,
            specimens_1.spec_coll_ids AS collector_ids,
            specimens_1.spec_don_sel_ids AS donator_ids,
            specimens_1.gtu_from_date,
            specimens_1.gtu_from_date_mask,
            specimens_1.gtu_to_date,
            specimens_1.gtu_to_date_mask,
            specimens_1.type AS coll_type,
                CASE
                    WHEN (specimens_1.gtu_country_tag_indexed IS NOT NULL) THEN unnest(specimens_1.gtu_country_tag_indexed)
                    ELSE NULL::character varying
                END AS country_unnest,
            ext_links.url,
            specimens_1.gtu_location[1] AS latitude,
            specimens_1.gtu_location[0] AS longitude
           FROM ((darwin2.specimens specimens_1
             LEFT JOIN darwin2.codes ON ((((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text) AND (specimens_1.id = codes.record_id))))
             LEFT JOIN darwin2.ext_links ON (((specimens_1.id = ext_links.record_id) AND ((ext_links.referenced_relation)::text = 'specimens'::text))))) specimens;


ALTER TABLE darwin2.v_rmca_public_view OWNER TO darwin2;

--
-- TOC entry 417 (class 1259 OID 4817576)
-- Name: v_rmca_taxo_detect_duplicate_hierarchies; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_taxo_detect_duplicate_hierarchies AS
 SELECT subquery.level_ref,
    catalogue_levels.level_name,
    subquery.canonical_name,
    array_length(subquery.names_list, 1) AS nb_canonical_homonyms,
    subquery.names_list,
    subquery.taxa_ids AS ids
   FROM (( SELECT darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(taxonomy.name) AS fct_rmca_taxonomy_try_to_isolate_from_author,
            count(DISTINCT taxonomy.id) AS canonical_homonyms,
            taxonomy.level_ref,
            array_agg(taxonomy.name ORDER BY taxonomy.id) AS names_list,
            array_agg(taxonomy.id ORDER BY taxonomy.id) AS taxa_ids,
            darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(taxonomy.name) AS canonical_name
           FROM darwin2.taxonomy
          GROUP BY (darwin2.fct_rmca_taxonomy_try_to_isolate_from_author(taxonomy.name)), taxonomy.level_ref
         HAVING (count(DISTINCT taxonomy.id) > 1)) subquery
     JOIN darwin2.catalogue_levels ON ((subquery.level_ref = catalogue_levels.id)))
  GROUP BY subquery.level_ref, catalogue_levels.level_name, subquery.names_list, subquery.taxa_ids, subquery.canonical_name
  ORDER BY subquery.level_ref, subquery.canonical_name;


ALTER TABLE darwin2.v_rmca_taxo_detect_duplicate_hierarchies OWNER TO darwin2;

--
-- TOC entry 418 (class 1259 OID 4817581)
-- Name: v_rmca_taxonomy_synonyms_with_name_and_specs; Type: VIEW; Schema: darwin2; Owner: darwin2
--

CREATE VIEW darwin2.v_rmca_taxonomy_synonyms_with_name_and_specs AS
SELECT
    NULL::character varying AS referenced_relation,
    NULL::integer[] AS records_ids,
    NULL::integer[] AS ids,
    NULL::integer AS group_id,
    NULL::character varying AS group_name,
    NULL::boolean[] AS basionyms,
    NULL::integer[] AS orders,
    NULL::text AS taxon_names,
    NULL::numeric AS count_specimens,
    NULL::public.hstore AS count_specimens_by_taxon;


ALTER TABLE darwin2.v_rmca_taxonomy_synonyms_with_name_and_specs OWNER TO darwin2;

--
-- TOC entry 419 (class 1259 OID 4817587)
-- Name: vernacular_names_id_seq; Type: SEQUENCE; Schema: darwin2; Owner: postgres
--

CREATE SEQUENCE darwin2.vernacular_names_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE darwin2.vernacular_names_id_seq OWNER TO postgres;

--
-- TOC entry 6656 (class 0 OID 0)
-- Dependencies: 419
-- Name: vernacular_names_id_seq; Type: SEQUENCE OWNED BY; Schema: darwin2; Owner: postgres
--

ALTER SEQUENCE darwin2.vernacular_names_id_seq OWNED BY darwin2.vernacular_names.id;


--
-- TOC entry 420 (class 1259 OID 4817589)
-- Name: zzz_franck_associate_file_to_record_march2018; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.zzz_franck_associate_file_to_record_march2018 (
    filename character varying,
    date_modified character varying,
    scientific_name character varying,
    unitid character varying,
    kindofunit character varying
);


ALTER TABLE darwin2.zzz_franck_associate_file_to_record_march2018 OWNER TO darwin2;

--
-- TOC entry 421 (class 1259 OID 4817595)
-- Name: zzz_rotifer_specimens; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.zzz_rotifer_specimens (
    id integer,
    category character varying,
    collection_ref integer,
    expedition_ref integer,
    gtu_ref integer,
    taxon_ref integer,
    litho_ref integer,
    chrono_ref integer,
    lithology_ref integer,
    mineral_ref integer,
    acquisition_category character varying,
    acquisition_date_mask integer,
    acquisition_date date,
    station_visible boolean,
    ig_ref integer,
    type character varying,
    type_group character varying,
    type_search character varying,
    sex character varying,
    stage character varying,
    state character varying,
    social_status character varying,
    rock_form character varying,
    specimen_part character varying,
    complete boolean,
    institution_ref integer,
    building character varying,
    floor character varying,
    room character varying,
    "row" character varying,
    shelf character varying,
    container character varying,
    sub_container character varying,
    container_type character varying,
    sub_container_type character varying,
    container_storage character varying,
    sub_container_storage character varying,
    surnumerary boolean,
    specimen_status character varying,
    specimen_count_min integer,
    specimen_count_max integer,
    object_name text,
    object_name_indexed text,
    spec_ident_ids integer[],
    spec_coll_ids integer[],
    spec_don_sel_ids integer[],
    collection_type character varying,
    collection_code character varying,
    collection_name character varying,
    collection_is_public boolean,
    collection_parent_ref integer,
    collection_path character varying,
    expedition_name character varying,
    expedition_name_indexed character varying,
    gtu_code character varying,
    gtu_from_date_mask integer,
    gtu_from_date timestamp without time zone,
    gtu_to_date_mask integer,
    gtu_to_date timestamp without time zone,
    gtu_tag_values_indexed character varying[],
    gtu_country_tag_value character varying,
    gtu_country_tag_indexed character varying[],
    gtu_province_tag_value character varying,
    gtu_province_tag_indexed character varying[],
    gtu_others_tag_value character varying,
    gtu_others_tag_indexed character varying[],
    gtu_elevation double precision,
    gtu_elevation_accuracy double precision,
    taxon_name character varying,
    taxon_name_indexed character varying,
    taxon_level_ref integer,
    taxon_level_name character varying,
    taxon_status character varying,
    taxon_path character varying,
    taxon_parent_ref integer,
    taxon_extinct boolean,
    litho_name character varying,
    litho_name_indexed character varying,
    litho_level_ref integer,
    litho_level_name character varying,
    litho_status character varying,
    litho_local boolean,
    litho_color character varying,
    litho_path character varying,
    litho_parent_ref integer,
    chrono_name character varying,
    chrono_name_indexed character varying,
    chrono_level_ref integer,
    chrono_level_name character varying,
    chrono_status character varying,
    chrono_local boolean,
    chrono_color character varying,
    chrono_path character varying,
    chrono_parent_ref integer,
    lithology_name character varying,
    lithology_name_indexed character varying,
    lithology_level_ref integer,
    lithology_level_name character varying,
    lithology_status character varying,
    lithology_local boolean,
    lithology_color character varying,
    lithology_path character varying,
    lithology_parent_ref integer,
    mineral_name character varying,
    mineral_name_indexed character varying,
    mineral_level_ref integer,
    mineral_level_name character varying,
    mineral_status character varying,
    mineral_local boolean,
    mineral_color character varying,
    mineral_path character varying,
    mineral_parent_ref integer,
    ig_num character varying,
    ig_num_indexed character varying,
    ig_date_mask integer,
    ig_date date,
    col text,
    gtu_location point
);


ALTER TABLE darwin2.zzz_rotifer_specimens OWNER TO darwin2;

--
-- TOC entry 422 (class 1259 OID 4817601)
-- Name: zzz_rotifer_taxa; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.zzz_rotifer_taxa (
    name character varying,
    name_indexed character varying,
    level_ref integer,
    status character varying,
    local_naming boolean,
    color character varying,
    path character varying,
    parent_ref integer,
    id integer,
    extinct boolean
);


ALTER TABLE darwin2.zzz_rotifer_taxa OWNER TO darwin2;

--
-- TOC entry 423 (class 1259 OID 4817607)
-- Name: zzz_taxa_imported_not_cleaned; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.zzz_taxa_imported_not_cleaned (
    taxon_ref integer,
    reason character varying
);


ALTER TABLE darwin2.zzz_taxa_imported_not_cleaned OWNER TO darwin2;

--
-- TOC entry 424 (class 1259 OID 4817613)
-- Name: zzz_users_tracking_archived; Type: TABLE; Schema: darwin2; Owner: darwin2
--

CREATE TABLE darwin2.zzz_users_tracking_archived (
    id bigint,
    referenced_relation character varying,
    record_id integer,
    user_ref integer,
    action character varying,
    old_value public.hstore,
    new_value public.hstore,
    modification_date_time timestamp without time zone,
    specimen_individual_ref bigint,
    specimen_ref bigint
);


ALTER TABLE darwin2.zzz_users_tracking_archived OWNER TO darwin2;

--
-- TOC entry 425 (class 1259 OID 4817619)
-- Name: labeling; Type: VIEW; Schema: public; Owner: darwin2
--

CREATE VIEW public.labeling AS
 SELECT df.id AS unique_id,
    df.collection_ref AS collection,
    df.collection_name,
    df.collection_path,
        CASE
            WHEN ((COALESCE(df.specimen_part, ''::character varying))::text = ANY (ARRAY[('specimen'::character varying)::text, ('animal'::character varying)::text, ('undefined'::character varying)::text, ('unknown'::character varying)::text, (''::character varying)::text])) THEN ''::character varying
            ELSE df.specimen_part
        END AS part_item,
        CASE
            WHEN ((df.sex)::text = ANY (ARRAY[('undefined'::character varying)::text, ('unknown'::character varying)::text, ('not stated'::character varying)::text, ('non applicable'::character varying)::text])) THEN ''::text
            ELSE ((df.sex)::text ||
            CASE
                WHEN ((df.state)::text = 'not applicable'::text) THEN ''::text
                ELSE (' '::text || (df.state)::text)
            END)
        END AS part_sex_state,
        CASE
            WHEN ((df.type)::text = 'specimen'::text) THEN ''::character varying
            ELSE df.type
        END AS part_type,
        CASE
            WHEN ((df.stage)::text = ANY (ARRAY[('undefined'::character varying)::text, ('unknown'::character varying)::text, ('not stated'::character varying)::text])) THEN ''::character varying
            ELSE df.stage
        END AS part_stage,
        CASE
            WHEN (df.sub_container IS NULL) THEN
            CASE
                WHEN ((COALESCE(df.container_storage, ''::character varying))::text = ANY (ARRAY[('unknown'::character varying)::text, ('/'::character varying)::text, (''::character varying)::text])) THEN ''::character varying
                ELSE df.container_storage
            END
            ELSE ''::character varying
        END AS part_container_storage,
        CASE
            WHEN ((COALESCE(df.sub_container_storage, ''::character varying))::text = ANY (ARRAY[('unknown'::character varying)::text, ('/'::character varying)::text, (''::character varying)::text])) THEN ''::character varying
            ELSE COALESCE(df.sub_container_storage, ''::character varying)
        END AS part_sub_container_storage,
    ARRAY[darwin2.fulltoindex(df.specimen_part)] AS part,
    ARRAY[darwin2.fulltoindex(df.type)] AS type,
    df.sex,
    df.stage,
    (array_to_string(darwin2.labeling_code_for_indexation(df.id), ';'::text))::character varying AS code,
    ( SELECT codes.code_num
           FROM darwin2.codes
          WHERE (((codes.referenced_relation)::text = 'specimens'::text) AND (codes.record_id = df.id) AND ((codes.code_category)::text = 'main'::text) AND (COALESCE(upper((codes.code_prefix)::text), ''::text) <> 'RBINS'::text) AND (codes.code_num IS NOT NULL))
         LIMIT 1) AS code_num,
    darwin2.labeling_code_for_indexation(df.id) AS code_array,
    df.taxon_ref,
    df.taxon_name,
    df.taxon_name_indexed,
    df.taxon_path,
    ( SELECT phyl.name
           FROM (( SELECT (x.id)::integer AS id
                   FROM ( SELECT regexp_split_to_table((taxphyls.path)::text, '/'::text) AS id
                           FROM darwin2.taxonomy taxphyls
                          WHERE (taxphyls.id = df.taxon_ref)) x
                  WHERE (x.id <> ''::text)) y
             JOIN darwin2.taxonomy phyl ON (((y.id = phyl.id) AND (phyl.level_ref = 4))))) AS phyl,
    ( SELECT clas.name
           FROM (( SELECT (x.id)::integer AS id
                   FROM ( SELECT regexp_split_to_table((taxclass.path)::text, '/'::text) AS id
                           FROM darwin2.taxonomy taxclass
                          WHERE (taxclass.id = df.taxon_ref)) x
                  WHERE (x.id <> ''::text)) y
             JOIN darwin2.taxonomy clas ON (((y.id = clas.id) AND (clas.level_ref = 12))))) AS clas,
    ( SELECT ordo.name
           FROM (( SELECT (x.id)::integer AS id
                   FROM ( SELECT regexp_split_to_table((taxord.path)::text, '/'::text) AS id
                           FROM darwin2.taxonomy taxord
                          WHERE (taxord.id = df.taxon_ref)) x
                  WHERE (x.id <> ''::text)) y
             JOIN darwin2.taxonomy ordo ON (((y.id = ordo.id) AND (ordo.level_ref = 28))))) AS ordo,
    ( SELECT fam.name
           FROM (( SELECT (x.id)::integer AS id
                   FROM ( SELECT regexp_split_to_table((taxfam.path)::text, '/'::text) AS id
                           FROM darwin2.taxonomy taxfam
                          WHERE (taxfam.id = df.taxon_ref)) x
                  WHERE (x.id <> ''::text)) y
             JOIN darwin2.taxonomy fam ON (((y.id = fam.id) AND (fam.level_ref = 34))))) AS family,
    (( SELECT array_to_string(array_agg(ct.name), ' - '::text) AS array_to_string
           FROM (darwin2.taxonomy ct
             JOIN darwin2.classification_synonymies cs ON ((((cs.referenced_relation)::text = 'taxonomy'::text) AND (cs.record_id = ct.id) AND (cs.is_basionym = true))))
          WHERE (cs.group_id = ( SELECT classification_synonymies.group_id
                   FROM darwin2.classification_synonymies
                  WHERE (((classification_synonymies.referenced_relation)::text = 'taxonomy'::text) AND (classification_synonymies.record_id = df.taxon_ref) AND ((classification_synonymies.group_name)::text = 'rename'::text))))))::character varying AS current_name,
        CASE
            WHEN ((df.acquisition_category IS NOT NULL) AND (btrim((df.acquisition_category)::text) <> ''::text)) THEN df.acquisition_category
            ELSE ''::character varying
        END AS acquisition_category,
    df.gtu_ref,
    df.gtu_country_tag_value AS countries,
    df.gtu_country_tag_indexed AS countries_array,
    df.gtu_province_tag_value AS provinces,
    df.gtu_province_tag_indexed AS provinces_array,
    df.gtu_others_tag_value AS location,
    df.gtu_others_tag_indexed AS location_array,
        CASE
            WHEN (btrim((df.gtu_code)::text) = ANY (ARRAY[''::text, '/'::text, '0'::text, '0/'::text])) THEN ''::text
            ELSE btrim((df.gtu_code)::text)
        END AS location_code,
    (
        CASE
            WHEN (df.gtu_from_date_mask >= 32) THEN to_char(df.gtu_from_date, 'DD/MM/YYYY'::text)
            ELSE ''::text
        END ||
        CASE
            WHEN (df.gtu_to_date_mask >= 32) THEN (' - '::text || to_char(df.gtu_to_date, 'DD/MM/YYYY'::text))
            ELSE ''::text
        END) AS gtu_date,
        CASE
            WHEN (df.gtu_location IS NOT NULL) THEN ((trunc((df.gtu_location[0])::numeric, 6) || '/'::text) || trunc((df.gtu_location[1])::numeric, 6))
            ELSE ''::text
        END AS lat_long,
        CASE
            WHEN (df.gtu_elevation IS NOT NULL) THEN ((trunc((df.gtu_elevation)::numeric, 2) || ' m'::text) ||
            CASE
                WHEN (df.gtu_elevation_accuracy IS NOT NULL) THEN ((' +- '::text || trunc((df.gtu_elevation_accuracy)::numeric, 2)) || ' m'::text)
                ELSE ''::text
            END)
            ELSE ''::text
        END AS elevation,
    (( SELECT
                CASE
                    WHEN (length(regexp_replace(y.coll, '[^,]+'::text, ''::text, 'g'::text)) > 2) THEN (substr(y.coll, 1, (strpos(y.coll, ','::text) - 1)) || ' & al.'::text)
                    ELSE y.coll
                END AS coll
           FROM ( SELECT array_to_string(array_agg(x.people_list), ', '::text) AS coll
                   FROM ( SELECT DISTINCT btrim((peo.family_name)::text) AS people_list,
                            cp.order_by
                           FROM (darwin2.catalogue_people cp
                             JOIN darwin2.people peo ON ((cp.people_ref = peo.id)))
                          WHERE (((cp.people_type)::text = 'collector'::text) AND ((cp.referenced_relation)::text = 'specimens'::text) AND (cp.record_id = df.id) AND ((peo.family_name)::text <> ALL (ARRAY[('Unknown'::character varying)::text, ('/'::character varying)::text])))
                          ORDER BY cp.order_by) x) y))::character varying AS collectors,
    (( SELECT (
                CASE
                    WHEN (length(regexp_replace(y.identi, '[^,]+'::text, ''::text, 'g'::text)) > 2) THEN (substr(y.identi, 1, (strpos(y.identi, ','::text) - 1)) || ' & al.'::text)
                    ELSE y.identi
                END || y.identi_year)
           FROM ( SELECT array_to_string(array_agg(x.people_list), ', '::text) AS identi,
                        CASE
                            WHEN (max(x.ident_date) IS NOT NULL) THEN (', '::text || max(x.ident_date))
                            ELSE ''::text
                        END AS identi_year
                   FROM ( SELECT DISTINCT btrim((peo.family_name)::text) AS people_list,
                            cp.order_by,
                                CASE
                                    WHEN (ident.notion_date_mask <> 0) THEN date_part('year'::text, ident.notion_date)
                                    ELSE NULL::double precision
                                END AS ident_date
                           FROM ((darwin2.catalogue_people cp
                             JOIN darwin2.people peo ON ((cp.people_ref = peo.id)))
                             JOIN darwin2.identifications ident ON (((cp.record_id = ident.id) AND ((cp.referenced_relation)::text = 'identifications'::text) AND ((cp.people_type)::text = 'identifier'::text))))
                          WHERE (((ident.referenced_relation)::text = 'specimens'::text) AND (ident.record_id = df.id) AND ((peo.family_name)::text <> ALL (ARRAY[('Unknown'::character varying)::text, ('/'::character varying)::text])) AND (ident.notion_date = ( SELECT max(idt.notion_date) AS max
                                   FROM darwin2.identifications idt
                                  WHERE (((idt.referenced_relation)::text = (ident.referenced_relation)::text) AND (idt.record_id = ident.record_id)))))
                          ORDER BY cp.order_by) x) y))::character varying AS identifiers,
    ''::character varying AS part_identifiers,
    (( SELECT
                CASE
                    WHEN (length(regexp_replace(y.coll, '[^,]+'::text, ''::text, 'g'::text)) > 2) THEN (substr(y.coll, 1, (strpos(y.coll, ','::text) - 1)) || ' & al.'::text)
                    ELSE y.coll
                END AS coll
           FROM ( SELECT array_to_string(array_agg(x.people_list), ', '::text) AS coll
                   FROM ( SELECT DISTINCT btrim((peo.family_name)::text) AS people_list,
                            cp.order_by
                           FROM (darwin2.catalogue_people cp
                             JOIN darwin2.people peo ON ((cp.people_ref = peo.id)))
                          WHERE (((cp.people_type)::text = 'donator'::text) AND ((cp.referenced_relation)::text = 'specimens'::text) AND (cp.record_id = df.id) AND ((peo.family_name)::text <> ALL (ARRAY[('Unknown'::character varying)::text, ('/'::character varying)::text])))
                          ORDER BY cp.order_by) x) y))::character varying AS donators,
    COALESCE(df.ig_num, '-'::character varying) AS ig_num,
    df.ig_num_indexed,
    darwin2.convert_to_integer(COALESCE(df.ig_num, '-'::character varying)) AS ig_numeric,
        CASE
            WHEN ((df.specimen_count_min <> df.specimen_count_max) AND (df.specimen_count_min IS NOT NULL) AND (df.specimen_count_max IS NOT NULL)) THEN ((df.specimen_count_min || ' - '::text) || df.specimen_count_max)
            ELSE
            CASE
                WHEN (df.specimen_count_min IS NOT NULL) THEN (df.specimen_count_min)::text
                ELSE ''::text
            END
        END AS specimen_number,
    df.specimen_count_max AS specimen_number_max,
    df.room AS part_room,
    df."row" AS part_row,
    df.shelf AS part_shelf,
    df.container AS part_container,
    df.sub_container AS part_sub_container,
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM darwin2.comments
              WHERE (((comments.referenced_relation)::text = 'specimens'::text) AND (comments.record_id = df.id)))) THEN 'Y'::text
            ELSE 'N'::text
        END AS comments
   FROM darwin2.specimens df;


ALTER TABLE public.labeling OWNER TO darwin2;

--
-- TOC entry 4889 (class 2604 OID 5308567)
-- Name: authority_domain id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.authority_domain ALTER COLUMN id SET DEFAULT nextval('darwin2.authority_domain_id_seq'::regclass);


--
-- TOC entry 4574 (class 2604 OID 4817624)
-- Name: bibliography id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.bibliography ALTER COLUMN id SET DEFAULT nextval('darwin2.bibliography_id_seq'::regclass);


--
-- TOC entry 4576 (class 2604 OID 4817625)
-- Name: catalogue_bibliography id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_bibliography ALTER COLUMN id SET DEFAULT nextval('darwin2.catalogue_bibliography_id_seq'::regclass);


--
-- TOC entry 4591 (class 2604 OID 4817626)
-- Name: chronostratigraphy status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 4592 (class 2604 OID 4817627)
-- Name: chronostratigraphy local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 4593 (class 2604 OID 4817628)
-- Name: chronostratigraphy path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 4683 (class 2604 OID 4817629)
-- Name: lithology status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 4684 (class 2604 OID 4817630)
-- Name: lithology local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 4685 (class 2604 OID 4817631)
-- Name: lithology path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 4688 (class 2604 OID 4817632)
-- Name: lithostratigraphy status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 4689 (class 2604 OID 4817633)
-- Name: lithostratigraphy local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 4690 (class 2604 OID 4817634)
-- Name: lithostratigraphy path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 4692 (class 2604 OID 4817635)
-- Name: loan_history id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_history ALTER COLUMN id SET DEFAULT nextval('darwin2.loan_history_id_seq'::regclass);


--
-- TOC entry 4708 (class 2604 OID 4817636)
-- Name: mineralogy status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 4709 (class 2604 OID 4817637)
-- Name: mineralogy local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 4710 (class 2604 OID 4817638)
-- Name: mineralogy path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 4720 (class 2604 OID 4817639)
-- Name: multimedia_todelete id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.multimedia_todelete ALTER COLUMN id SET DEFAULT nextval('darwin2.multimedia_todelete_id_seq'::regclass);


--
-- TOC entry 4764 (class 2604 OID 4817640)
-- Name: people is_physical; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people ALTER COLUMN is_physical SET DEFAULT true;


--
-- TOC entry 4765 (class 2604 OID 4817641)
-- Name: people title; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people ALTER COLUMN title SET DEFAULT ''::character varying;


--
-- TOC entry 4766 (class 2604 OID 4817642)
-- Name: people birth_date_mask; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people ALTER COLUMN birth_date_mask SET DEFAULT 0;


--
-- TOC entry 4767 (class 2604 OID 4817643)
-- Name: people birth_date; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people ALTER COLUMN birth_date SET DEFAULT '0001-01-01'::date;


--
-- TOC entry 4637 (class 2604 OID 4817644)
-- Name: properties id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.properties ALTER COLUMN id SET DEFAULT nextval('darwin2.properties_id_seq'::regclass);


--
-- TOC entry 4785 (class 2604 OID 4817645)
-- Name: reports id; Type: DEFAULT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.reports ALTER COLUMN id SET DEFAULT nextval('darwin2.reports_id_seq'::regclass);


--
-- TOC entry 4821 (class 2604 OID 4817646)
-- Name: specimens id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens ALTER COLUMN id SET DEFAULT nextval('darwin2.specimens_id_seq'::regclass);


--
-- TOC entry 4827 (class 2604 OID 4817647)
-- Name: specimens_relationships id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships ALTER COLUMN id SET DEFAULT nextval('darwin2.specimens_relationships_id_seq'::regclass);


--
-- TOC entry 4830 (class 2604 OID 4817648)
-- Name: staging_catalogue id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_catalogue ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_catalogue_id_seq'::regclass);


--
-- TOC entry 4832 (class 2604 OID 4817649)
-- Name: staging_collecting_methods id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_collecting_methods_id_seq'::regclass);


--
-- TOC entry 4840 (class 2604 OID 4817650)
-- Name: staging_gtu_tag_groups id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu_tag_groups ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_gtu_tag_groups_id_seq'::regclass);


--
-- TOC entry 4841 (class 2604 OID 4817651)
-- Name: staging_info id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_info ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_info_id_seq'::regclass);


--
-- TOC entry 4848 (class 2604 OID 4817652)
-- Name: staging_relationship id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship ALTER COLUMN id SET DEFAULT nextval('darwin2.staging_relationship_id_seq'::regclass);


--
-- TOC entry 4890 (class 2604 OID 5308580)
-- Name: tag_authority id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_authority ALTER COLUMN id SET DEFAULT nextval('darwin2.tag_authority_id_seq'::regclass);


--
-- TOC entry 4888 (class 2604 OID 5308549)
-- Name: tag_group_distinct id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_group_distinct ALTER COLUMN id SET DEFAULT nextval('darwin2.tag_group_distinct_id_seq'::regclass);


--
-- TOC entry 4853 (class 2604 OID 4817653)
-- Name: tags id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tags ALTER COLUMN id SET DEFAULT nextval('darwin2.tags_id_seq'::regclass);


--
-- TOC entry 4858 (class 2604 OID 4817654)
-- Name: taxonomy status; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy ALTER COLUMN status SET DEFAULT 'valid'::character varying;


--
-- TOC entry 4859 (class 2604 OID 4817655)
-- Name: taxonomy local_naming; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy ALTER COLUMN local_naming SET DEFAULT false;


--
-- TOC entry 4860 (class 2604 OID 4817656)
-- Name: taxonomy path; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy ALTER COLUMN path SET DEFAULT '/'::character varying;


--
-- TOC entry 4892 (class 2604 OID 5308739)
-- Name: taxonomy_authority id; Type: DEFAULT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.taxonomy_authority ALTER COLUMN id SET DEFAULT nextval('darwin2.taxonomy_authority_id_seq'::regclass);


--
-- TOC entry 4862 (class 2604 OID 4817657)
-- Name: taxonomy_metadata id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy_metadata ALTER COLUMN id SET DEFAULT nextval('darwin2.taxonomy_metadata_id_seq'::regclass);


--
-- TOC entry 4883 (class 2604 OID 5304938)
-- Name: temporal_information id; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.temporal_information ALTER COLUMN id SET DEFAULT nextval('darwin2.temporal_information_id_seq'::regclass);


--
-- TOC entry 4867 (class 2604 OID 4817658)
-- Name: users is_physical; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users ALTER COLUMN is_physical SET DEFAULT true;


--
-- TOC entry 4868 (class 2604 OID 4817659)
-- Name: users title; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users ALTER COLUMN title SET DEFAULT ''::character varying;


--
-- TOC entry 4869 (class 2604 OID 4817660)
-- Name: users birth_date_mask; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users ALTER COLUMN birth_date_mask SET DEFAULT 0;


--
-- TOC entry 4870 (class 2604 OID 4817661)
-- Name: users birth_date; Type: DEFAULT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users ALTER COLUMN birth_date SET DEFAULT '0001-01-01'::date;


--
-- TOC entry 4882 (class 2604 OID 4817662)
-- Name: vernacular_names id; Type: DEFAULT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.vernacular_names ALTER COLUMN id SET DEFAULT nextval('darwin2.vernacular_names_id_seq'::regclass);


--
-- TOC entry 5317 (class 2606 OID 5308572)
-- Name: authority_domain authority_domain_pk; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.authority_domain
    ADD CONSTRAINT authority_domain_pk PRIMARY KEY (id);


--
-- TOC entry 5319 (class 2606 OID 5308574)
-- Name: authority_domain authority_domain_uq; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.authority_domain
    ADD CONSTRAINT authority_domain_uq UNIQUE (name);


--
-- TOC entry 5309 (class 2606 OID 5304944)
-- Name: temporal_information dates_pkey; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.temporal_information
    ADD CONSTRAINT dates_pkey PRIMARY KEY (id);


--
-- TOC entry 5313 (class 2606 OID 5308554)
-- Name: tag_group_distinct id; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_group_distinct
    ADD CONSTRAINT id PRIMARY KEY (id);


--
-- TOC entry 4900 (class 2606 OID 5302430)
-- Name: bibliography pk_bibliography; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.bibliography
    ADD CONSTRAINT pk_bibliography PRIMARY KEY (id);


--
-- TOC entry 4905 (class 2606 OID 5302436)
-- Name: catalogue_bibliography pk_catalogue_bibliography; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_bibliography
    ADD CONSTRAINT pk_catalogue_bibliography PRIMARY KEY (id);


--
-- TOC entry 4909 (class 2606 OID 5302438)
-- Name: catalogue_levels pk_catalogue_levels; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_levels
    ADD CONSTRAINT pk_catalogue_levels PRIMARY KEY (id);


--
-- TOC entry 4918 (class 2606 OID 5302440)
-- Name: catalogue_people pk_catalogue_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_people
    ADD CONSTRAINT pk_catalogue_people PRIMARY KEY (id);


--
-- TOC entry 4932 (class 2606 OID 5302442)
-- Name: chronostratigraphy pk_chronostratigraphy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy
    ADD CONSTRAINT pk_chronostratigraphy PRIMARY KEY (id);


--
-- TOC entry 4937 (class 2606 OID 5302444)
-- Name: classification_keywords pk_classification_keywords_id; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.classification_keywords
    ADD CONSTRAINT pk_classification_keywords_id PRIMARY KEY (id);


--
-- TOC entry 4950 (class 2606 OID 5302446)
-- Name: codes pk_codes; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.codes
    ADD CONSTRAINT pk_codes PRIMARY KEY (id);


--
-- TOC entry 4956 (class 2606 OID 5302448)
-- Name: collecting_methods pk_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_methods
    ADD CONSTRAINT pk_collecting_methods PRIMARY KEY (id);


--
-- TOC entry 4962 (class 2606 OID 5302450)
-- Name: collecting_tools pk_collecting_tools; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_tools
    ADD CONSTRAINT pk_collecting_tools PRIMARY KEY (id);


--
-- TOC entry 4969 (class 2606 OID 5302452)
-- Name: collection_maintenance pk_collection_maintenance; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collection_maintenance
    ADD CONSTRAINT pk_collection_maintenance PRIMARY KEY (id);


--
-- TOC entry 4973 (class 2606 OID 5302454)
-- Name: collections pk_collections; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT pk_collections PRIMARY KEY (id);


--
-- TOC entry 4979 (class 2606 OID 5302456)
-- Name: collections_rights pk_collections_right; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections_rights
    ADD CONSTRAINT pk_collections_right PRIMARY KEY (id);


--
-- TOC entry 4987 (class 2606 OID 5302458)
-- Name: comments pk_comments; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.comments
    ADD CONSTRAINT pk_comments PRIMARY KEY (id);


--
-- TOC entry 5008 (class 2606 OID 5302460)
-- Name: expeditions pk_expeditions; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.expeditions
    ADD CONSTRAINT pk_expeditions PRIMARY KEY (id);


--
-- TOC entry 5013 (class 2606 OID 5302462)
-- Name: ext_links pk_ext_links; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.ext_links
    ADD CONSTRAINT pk_ext_links PRIMARY KEY (id);


--
-- TOC entry 5017 (class 2606 OID 5302464)
-- Name: flat_dict pk_flat_dict; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.flat_dict
    ADD CONSTRAINT pk_flat_dict PRIMARY KEY (id);


--
-- TOC entry 5025 (class 2606 OID 5302466)
-- Name: gtu pk_gtu; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.gtu
    ADD CONSTRAINT pk_gtu PRIMARY KEY (id);


--
-- TOC entry 5027 (class 2606 OID 5302468)
-- Name: gtu_bck20181123 pk_gtu_bck20181123; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.gtu_bck20181123
    ADD CONSTRAINT pk_gtu_bck20181123 PRIMARY KEY (id);


--
-- TOC entry 5001 (class 2606 OID 5302476)
-- Name: identifications pk_identifications; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.identifications
    ADD CONSTRAINT pk_identifications PRIMARY KEY (id);


--
-- TOC entry 5031 (class 2606 OID 5302490)
-- Name: igs pk_igs; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.igs
    ADD CONSTRAINT pk_igs PRIMARY KEY (id);


--
-- TOC entry 5035 (class 2606 OID 5302492)
-- Name: imports pk_import; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.imports
    ADD CONSTRAINT pk_import PRIMARY KEY (id);


--
-- TOC entry 5040 (class 2606 OID 5302494)
-- Name: informative_workflow pk_informative_workflow; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.informative_workflow
    ADD CONSTRAINT pk_informative_workflow PRIMARY KEY (id);


--
-- TOC entry 5045 (class 2606 OID 5302496)
-- Name: insurances pk_insurances; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.insurances
    ADD CONSTRAINT pk_insurances PRIMARY KEY (id);


--
-- TOC entry 5054 (class 2606 OID 5302498)
-- Name: lithology pk_lithology; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology
    ADD CONSTRAINT pk_lithology PRIMARY KEY (id);


--
-- TOC entry 5063 (class 2606 OID 5302500)
-- Name: lithostratigraphy pk_lithostratigraphy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy
    ADD CONSTRAINT pk_lithostratigraphy PRIMARY KEY (id);


--
-- TOC entry 5067 (class 2606 OID 5302502)
-- Name: loan_history pk_loan_history; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_history
    ADD CONSTRAINT pk_loan_history PRIMARY KEY (id);


--
-- TOC entry 5072 (class 2606 OID 5302504)
-- Name: loan_items pk_loan_items; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT pk_loan_items PRIMARY KEY (id);


--
-- TOC entry 5078 (class 2606 OID 5302506)
-- Name: loan_rights pk_loan_rights; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_rights
    ADD CONSTRAINT pk_loan_rights PRIMARY KEY (id);


--
-- TOC entry 5085 (class 2606 OID 5302508)
-- Name: loan_status pk_loan_status; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_status
    ADD CONSTRAINT pk_loan_status PRIMARY KEY (id);


--
-- TOC entry 5088 (class 2606 OID 5302510)
-- Name: loans pk_loans; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loans
    ADD CONSTRAINT pk_loans PRIMARY KEY (id);


--
-- TOC entry 5097 (class 2606 OID 5302512)
-- Name: mineralogy pk_mineralogy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy
    ADD CONSTRAINT pk_mineralogy PRIMARY KEY (id);


--
-- TOC entry 5103 (class 2606 OID 5302514)
-- Name: multimedia pk_multimedia; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.multimedia
    ADD CONSTRAINT pk_multimedia PRIMARY KEY (id);


--
-- TOC entry 5105 (class 2606 OID 5302516)
-- Name: multimedia_todelete pk_multimedia_todelete; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.multimedia_todelete
    ADD CONSTRAINT pk_multimedia_todelete PRIMARY KEY (id);


--
-- TOC entry 5107 (class 2606 OID 5302518)
-- Name: my_saved_searches pk_my_saved_searches; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_saved_searches
    ADD CONSTRAINT pk_my_saved_searches PRIMARY KEY (id);


--
-- TOC entry 5112 (class 2606 OID 5302520)
-- Name: my_widgets pk_my_widgets; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_widgets
    ADD CONSTRAINT pk_my_widgets PRIMARY KEY (id);


--
-- TOC entry 5121 (class 2606 OID 5302522)
-- Name: people pk_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people
    ADD CONSTRAINT pk_people PRIMARY KEY (id);


--
-- TOC entry 5127 (class 2606 OID 5302524)
-- Name: people_addresses pk_people_addresses; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_addresses
    ADD CONSTRAINT pk_people_addresses PRIMARY KEY (id);


--
-- TOC entry 5131 (class 2606 OID 5302526)
-- Name: people_comm pk_people_comm; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_comm
    ADD CONSTRAINT pk_people_comm PRIMARY KEY (id);


--
-- TOC entry 5134 (class 2606 OID 5302528)
-- Name: people_languages pk_people_languages; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_languages
    ADD CONSTRAINT pk_people_languages PRIMARY KEY (id);


--
-- TOC entry 5140 (class 2606 OID 5302530)
-- Name: people_relationships pk_people_relationships; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_relationships
    ADD CONSTRAINT pk_people_relationships PRIMARY KEY (id);


--
-- TOC entry 4996 (class 2606 OID 5302532)
-- Name: properties pk_properties; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.properties
    ADD CONSTRAINT pk_properties PRIMARY KEY (id);


--
-- TOC entry 5145 (class 2606 OID 5302534)
-- Name: reports pk_reports; Type: CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.reports
    ADD CONSTRAINT pk_reports PRIMARY KEY (id);


--
-- TOC entry 5148 (class 2606 OID 5302536)
-- Name: specimen_collecting_methods pk_specimen_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_methods
    ADD CONSTRAINT pk_specimen_collecting_methods PRIMARY KEY (id);


--
-- TOC entry 5153 (class 2606 OID 5302538)
-- Name: specimen_collecting_tools pk_specimen_collecting_tools; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_tools
    ADD CONSTRAINT pk_specimen_collecting_tools PRIMARY KEY (id);


--
-- TOC entry 5208 (class 2606 OID 5302540)
-- Name: specimens pk_specimens; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT pk_specimens PRIMARY KEY (id);


--
-- TOC entry 5214 (class 2606 OID 5302547)
-- Name: specimens_relationships pk_specimens_relationships; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT pk_specimens_relationships PRIMARY KEY (id);


--
-- TOC entry 4897 (class 2606 OID 5302549)
-- Name: staging pk_staging; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT pk_staging PRIMARY KEY (id);


--
-- TOC entry 5221 (class 2606 OID 5302551)
-- Name: staging_catalogue pk_staging_catalogue; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_catalogue
    ADD CONSTRAINT pk_staging_catalogue PRIMARY KEY (id);


--
-- TOC entry 5223 (class 2606 OID 5302553)
-- Name: staging_collecting_methods pk_staging_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods
    ADD CONSTRAINT pk_staging_collecting_methods PRIMARY KEY (id);


--
-- TOC entry 5231 (class 2606 OID 5302555)
-- Name: staging_gtu_tag_groups pk_staging_gtu_tag_groups; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu_tag_groups
    ADD CONSTRAINT pk_staging_gtu_tag_groups PRIMARY KEY (id);


--
-- TOC entry 5233 (class 2606 OID 5302557)
-- Name: staging_info pk_staging_info; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_info
    ADD CONSTRAINT pk_staging_info PRIMARY KEY (id);


--
-- TOC entry 5236 (class 2606 OID 5302559)
-- Name: staging_people pk_staging_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_people
    ADD CONSTRAINT pk_staging_people PRIMARY KEY (id);


--
-- TOC entry 5238 (class 2606 OID 5302561)
-- Name: staging_relationship pk_staging_relationship; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT pk_staging_relationship PRIMARY KEY (id);


--
-- TOC entry 5240 (class 2606 OID 5302563)
-- Name: staging_tag_groups pk_staging_tag_groups; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_tag_groups
    ADD CONSTRAINT pk_staging_tag_groups PRIMARY KEY (id);


--
-- TOC entry 4942 (class 2606 OID 5302565)
-- Name: classification_synonymies pk_synonym_id; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.classification_synonymies
    ADD CONSTRAINT pk_synonym_id PRIMARY KEY (id);


--
-- TOC entry 5247 (class 2606 OID 5302567)
-- Name: tag_groups pk_tag_groups; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_groups
    ADD CONSTRAINT pk_tag_groups PRIMARY KEY (id);


--
-- TOC entry 5263 (class 2606 OID 5302569)
-- Name: taxonomy pk_taxonomy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT pk_taxonomy PRIMARY KEY (id);


--
-- TOC entry 5272 (class 2606 OID 5302571)
-- Name: users pk_users; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users
    ADD CONSTRAINT pk_users PRIMARY KEY (id);


--
-- TOC entry 5278 (class 2606 OID 5302573)
-- Name: users_addresses pk_users_addresses; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_addresses
    ADD CONSTRAINT pk_users_addresses PRIMARY KEY (id);


--
-- TOC entry 5282 (class 2606 OID 5302575)
-- Name: users_comm pk_users_comm; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_comm
    ADD CONSTRAINT pk_users_comm PRIMARY KEY (id);


--
-- TOC entry 5284 (class 2606 OID 5302577)
-- Name: users_login_infos pk_users_login_infos; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_login_infos
    ADD CONSTRAINT pk_users_login_infos PRIMARY KEY (id);


--
-- TOC entry 5293 (class 2606 OID 5302579)
-- Name: users_tracking pk_users_tracking_pk; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_tracking
    ADD CONSTRAINT pk_users_tracking_pk PRIMARY KEY (id);


--
-- TOC entry 5298 (class 2606 OID 5302581)
-- Name: vernacular_names pk_vernacular_names; Type: CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.vernacular_names
    ADD CONSTRAINT pk_vernacular_names PRIMARY KEY (id);


--
-- TOC entry 5229 (class 2606 OID 5302583)
-- Name: staging_gtu staging_gtu_pkey1; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu
    ADD CONSTRAINT staging_gtu_pkey1 PRIMARY KEY (id);


--
-- TOC entry 5315 (class 2606 OID 5308556)
-- Name: tag_group_distinct subgroup_group_value_unique; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_group_distinct
    ADD CONSTRAINT subgroup_group_value_unique UNIQUE (tag_value, group_name_indexed, sub_group_name_indexed);


--
-- TOC entry 5322 (class 2606 OID 5308585)
-- Name: tag_authority tag_authority_pk; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_authority
    ADD CONSTRAINT tag_authority_pk PRIMARY KEY (id);


--
-- TOC entry 5324 (class 2606 OID 5308587)
-- Name: tag_authority tag_authority_uq; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_authority
    ADD CONSTRAINT tag_authority_uq UNIQUE (domain_ref, url);


--
-- TOC entry 5327 (class 2606 OID 5308633)
-- Name: tag_tag_authority tag_tag_authority_pk; Type: CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.tag_tag_authority
    ADD CONSTRAINT tag_tag_authority_pk PRIMARY KEY (tag_authority_ref, tag_group_distinct_ref);


--
-- TOC entry 5329 (class 2606 OID 5308744)
-- Name: taxonomy_authority taxonomy_authority_pk; Type: CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.taxonomy_authority
    ADD CONSTRAINT taxonomy_authority_pk PRIMARY KEY (id);


--
-- TOC entry 5269 (class 2606 OID 5302585)
-- Name: taxonomy_metadata taxonomy_metadata_pkey; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy_metadata
    ADD CONSTRAINT taxonomy_metadata_pkey PRIMARY KEY (id);


--
-- TOC entry 4902 (class 2606 OID 5302587)
-- Name: bibliography unq_bibliography; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.bibliography
    ADD CONSTRAINT unq_bibliography UNIQUE (title_indexed, type, year);


--
-- TOC entry 4907 (class 2606 OID 5302589)
-- Name: catalogue_bibliography unq_catalogue_bibliography; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_bibliography
    ADD CONSTRAINT unq_catalogue_bibliography UNIQUE (referenced_relation, record_id, bibliography_ref);


--
-- TOC entry 4911 (class 2606 OID 5302591)
-- Name: catalogue_levels unq_catalogue_levels; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_levels
    ADD CONSTRAINT unq_catalogue_levels UNIQUE (level_type, level_name);


--
-- TOC entry 4920 (class 2606 OID 5302593)
-- Name: catalogue_people unq_catalogue_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_people
    ADD CONSTRAINT unq_catalogue_people UNIQUE (referenced_relation, people_type, people_sub_type, record_id, people_ref);


--
-- TOC entry 4923 (class 2606 OID 5302595)
-- Name: catalogue_relationships unq_catalogue_relationships; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_relationships
    ADD CONSTRAINT unq_catalogue_relationships UNIQUE (referenced_relation, relationship_type, record_id_1, record_id_2);


--
-- TOC entry 4934 (class 2606 OID 5302597)
-- Name: chronostratigraphy unq_chronostratigraphy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy
    ADD CONSTRAINT unq_chronostratigraphy UNIQUE (path, name_indexed, level_ref);


--
-- TOC entry 4952 (class 2606 OID 5302599)
-- Name: codes unq_codes; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.codes
    ADD CONSTRAINT unq_codes UNIQUE (referenced_relation, record_id, full_code_indexed, code_category);


--
-- TOC entry 4958 (class 2606 OID 5302601)
-- Name: collecting_methods unq_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_methods
    ADD CONSTRAINT unq_collecting_methods UNIQUE (method_indexed);


--
-- TOC entry 4964 (class 2606 OID 5302603)
-- Name: collecting_tools unq_collecting_tools; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collecting_tools
    ADD CONSTRAINT unq_collecting_tools UNIQUE (tool_indexed);


--
-- TOC entry 4975 (class 2606 OID 5302605)
-- Name: collections unq_collections; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT unq_collections UNIQUE (institution_ref, path, code);


--
-- TOC entry 4981 (class 2606 OID 5302607)
-- Name: collections_rights unq_collections_rights; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections_rights
    ADD CONSTRAINT unq_collections_rights UNIQUE (collection_ref, user_ref);


--
-- TOC entry 5010 (class 2606 OID 5302609)
-- Name: expeditions unq_expeditions; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.expeditions
    ADD CONSTRAINT unq_expeditions UNIQUE (name_indexed, expedition_from_date, expedition_from_date_mask, expedition_to_date, expedition_to_date_mask);


--
-- TOC entry 5015 (class 2606 OID 5302611)
-- Name: ext_links unq_ext_links; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.ext_links
    ADD CONSTRAINT unq_ext_links UNIQUE (referenced_relation, record_id, url);


--
-- TOC entry 5019 (class 2606 OID 5302613)
-- Name: flat_dict unq_flat_dict; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.flat_dict
    ADD CONSTRAINT unq_flat_dict UNIQUE (dict_value, dict_field, referenced_relation, dict_depend);


--
-- TOC entry 5003 (class 2606 OID 5302615)
-- Name: identifications unq_identifications; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.identifications
    ADD CONSTRAINT unq_identifications UNIQUE (referenced_relation, record_id, notion_concerned, notion_date, value_defined_indexed);


--
-- TOC entry 5033 (class 2606 OID 5302617)
-- Name: igs unq_igs; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.igs
    ADD CONSTRAINT unq_igs UNIQUE (ig_num);


--
-- TOC entry 5056 (class 2606 OID 5302619)
-- Name: lithology unq_lithology; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology
    ADD CONSTRAINT unq_lithology UNIQUE (path, name_indexed, level_ref);


--
-- TOC entry 5065 (class 2606 OID 5302621)
-- Name: lithostratigraphy unq_lithostratigraphy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy
    ADD CONSTRAINT unq_lithostratigraphy UNIQUE (path, name_indexed, level_ref);


--
-- TOC entry 5074 (class 2606 OID 5302623)
-- Name: loan_items unq_loan_items; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT unq_loan_items UNIQUE (loan_ref, specimen_ref);


--
-- TOC entry 5080 (class 2606 OID 5302625)
-- Name: loan_rights unq_loan_rights; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_rights
    ADD CONSTRAINT unq_loan_rights UNIQUE (loan_ref, user_ref);


--
-- TOC entry 5099 (class 2606 OID 5302627)
-- Name: mineralogy unq_mineralogy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy
    ADD CONSTRAINT unq_mineralogy UNIQUE (path, name_indexed, level_ref, code);


--
-- TOC entry 5109 (class 2606 OID 5302629)
-- Name: my_saved_searches unq_my_saved_searches; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_saved_searches
    ADD CONSTRAINT unq_my_saved_searches UNIQUE (user_ref, name);


--
-- TOC entry 5114 (class 2606 OID 5302631)
-- Name: my_widgets unq_my_widgets; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_widgets
    ADD CONSTRAINT unq_my_widgets UNIQUE (user_ref, category, group_name);


--
-- TOC entry 5123 (class 2606 OID 5302633)
-- Name: people unq_people; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people
    ADD CONSTRAINT unq_people UNIQUE (is_physical, gender, formated_name_unique, birth_date, birth_date_mask, end_date, end_date_mask);


--
-- TOC entry 5136 (class 2606 OID 5302635)
-- Name: people_languages unq_people_languages; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_languages
    ADD CONSTRAINT unq_people_languages UNIQUE (people_ref, language_country);


--
-- TOC entry 5143 (class 2606 OID 5302637)
-- Name: possible_upper_levels unq_possible_upper_levels; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.possible_upper_levels
    ADD CONSTRAINT unq_possible_upper_levels UNIQUE (level_ref, level_upper_ref);


--
-- TOC entry 5150 (class 2606 OID 5302639)
-- Name: specimen_collecting_methods unq_specimen_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_methods
    ADD CONSTRAINT unq_specimen_collecting_methods UNIQUE (specimen_ref, collecting_method_ref);


--
-- TOC entry 5155 (class 2606 OID 5302641)
-- Name: specimen_collecting_tools unq_specimen_collecting_tools; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_tools
    ADD CONSTRAINT unq_specimen_collecting_tools UNIQUE (specimen_ref, collecting_tool_ref);


--
-- TOC entry 5047 (class 2606 OID 5302643)
-- Name: insurances unq_specimen_parts_insurances; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.insurances
    ADD CONSTRAINT unq_specimen_parts_insurances UNIQUE (referenced_relation, record_id, date_from, date_to, insurer_ref);


--
-- TOC entry 5225 (class 2606 OID 5302645)
-- Name: staging_collecting_methods unq_staging_collecting_methods; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods
    ADD CONSTRAINT unq_staging_collecting_methods UNIQUE (staging_ref, collecting_method_ref);


--
-- TOC entry 5242 (class 2606 OID 5302647)
-- Name: staging_tag_groups unq_staging_tag_groups; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_tag_groups
    ADD CONSTRAINT unq_staging_tag_groups UNIQUE (staging_ref, group_name, sub_group_name);


--
-- TOC entry 4944 (class 2606 OID 5302649)
-- Name: classification_synonymies unq_synonym; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.classification_synonymies
    ADD CONSTRAINT unq_synonym UNIQUE (referenced_relation, record_id, group_id);


--
-- TOC entry 5249 (class 2606 OID 5302651)
-- Name: tag_groups unq_tag_groups; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_groups
    ADD CONSTRAINT unq_tag_groups UNIQUE (gtu_ref, group_name_indexed, sub_group_name_indexed);


--
-- TOC entry 5265 (class 2606 OID 5309333)
-- Name: taxonomy unq_taxonomy; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT unq_taxonomy UNIQUE (path, name_indexed, level_ref, metadata_ref);


--
-- TOC entry 5332 (class 2606 OID 5308746)
-- Name: taxonomy_authority unq_taxonomy_authority; Type: CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.taxonomy_authority
    ADD CONSTRAINT unq_taxonomy_authority UNIQUE (url, taxonomy_ref);


--
-- TOC entry 5311 (class 2606 OID 5304946)
-- Name: temporal_information unq_temporal_information_specimen_ref; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.temporal_information
    ADD CONSTRAINT unq_temporal_information_specimen_ref UNIQUE (specimen_ref);


--
-- TOC entry 5274 (class 2606 OID 5302655)
-- Name: users unq_users; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users
    ADD CONSTRAINT unq_users UNIQUE (is_physical, gender, formated_name_unique, birth_date, birth_date_mask);


--
-- TOC entry 5286 (class 2606 OID 5302657)
-- Name: users_login_infos unq_users_login_infos; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_login_infos
    ADD CONSTRAINT unq_users_login_infos UNIQUE (user_ref, login_type);


--
-- TOC entry 5288 (class 2606 OID 5302659)
-- Name: users_login_infos unq_users_login_infos_user_name; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_login_infos
    ADD CONSTRAINT unq_users_login_infos_user_name UNIQUE (user_name, login_type);


--
-- TOC entry 5300 (class 2606 OID 5302661)
-- Name: vernacular_names unq_vernacular_names; Type: CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.vernacular_names
    ADD CONSTRAINT unq_vernacular_names UNIQUE (referenced_relation, record_id, community_indexed, name_indexed);


--
-- TOC entry 5267 (class 2606 OID 5308785)
-- Name: taxonomy uq_rcma_one_taxon_per_metadata; Type: CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT uq_rcma_one_taxon_per_metadata UNIQUE (metadata_ref, level_ref, name_indexed);


--
-- TOC entry 5226 (class 1259 OID 5302662)
-- Name: fki_to_gtu; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX fki_to_gtu ON darwin2.staging_gtu USING btree (gtu_ref);


--
-- TOC entry 5227 (class 1259 OID 5302663)
-- Name: fki_to_import; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX fki_to_import ON darwin2.staging_gtu USING btree (import_ref);


--
-- TOC entry 4898 (class 1259 OID 5302664)
-- Name: idx_bibliography_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_bibliography_type ON darwin2.bibliography USING btree (type);


--
-- TOC entry 4903 (class 1259 OID 5302665)
-- Name: idx_catalogue_bibliography_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_bibliography_referenced_record ON darwin2.catalogue_bibliography USING btree (referenced_relation, record_id);


--
-- TOC entry 4912 (class 1259 OID 5302666)
-- Name: idx_catalogue_people_people_order_by; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_people_order_by ON darwin2.catalogue_people USING btree (order_by);


--
-- TOC entry 4913 (class 1259 OID 5302667)
-- Name: idx_catalogue_people_people_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_people_ref ON darwin2.catalogue_people USING btree (people_ref);


--
-- TOC entry 4914 (class 1259 OID 5302668)
-- Name: idx_catalogue_people_people_sub_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_people_sub_type ON darwin2.catalogue_people USING btree (people_sub_type);


--
-- TOC entry 4915 (class 1259 OID 5302669)
-- Name: idx_catalogue_people_people_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_people_type ON darwin2.catalogue_people USING btree (people_type);


--
-- TOC entry 4916 (class 1259 OID 5302670)
-- Name: idx_catalogue_people_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_people_referenced_record ON darwin2.catalogue_people USING btree (referenced_relation, record_id);


--
-- TOC entry 4921 (class 1259 OID 5302671)
-- Name: idx_catalogue_relationships_relations; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_catalogue_relationships_relations ON darwin2.catalogue_relationships USING btree (referenced_relation, record_id_1, relationship_type);


--
-- TOC entry 4924 (class 1259 OID 5302672)
-- Name: idx_chronostratigraphy_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_chronostratigraphy_level_ref ON darwin2.chronostratigraphy USING btree (level_ref);


--
-- TOC entry 4925 (class 1259 OID 5302673)
-- Name: idx_chronostratigraphy_lower_bound; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_chronostratigraphy_lower_bound ON darwin2.chronostratigraphy USING btree ((COALESCE(lower_bound, ('-4600'::integer)::numeric)));


--
-- TOC entry 4926 (class 1259 OID 5302674)
-- Name: idx_chronostratigraphy_name_order_by_txt_op; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_chronostratigraphy_name_order_by_txt_op ON darwin2.chronostratigraphy USING btree (name_indexed text_pattern_ops);


--
-- TOC entry 4927 (class 1259 OID 5302675)
-- Name: idx_chronostratigraphy_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_chronostratigraphy_parent_ref ON darwin2.chronostratigraphy USING btree (parent_ref);


--
-- TOC entry 4928 (class 1259 OID 5302676)
-- Name: idx_chronostratigraphy_upper_bound; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_chronostratigraphy_upper_bound ON darwin2.chronostratigraphy USING btree ((COALESCE(upper_bound, (1)::numeric)));


--
-- TOC entry 4935 (class 1259 OID 5302677)
-- Name: idx_classification_keywords_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_classification_keywords_referenced_record ON darwin2.classification_keywords USING btree (referenced_relation, record_id);


--
-- TOC entry 4938 (class 1259 OID 5302678)
-- Name: idx_classification_synonymies_grouping; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_classification_synonymies_grouping ON darwin2.classification_synonymies USING btree (group_id, is_basionym);


--
-- TOC entry 4939 (class 1259 OID 5302679)
-- Name: idx_classification_synonymies_order_by; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_classification_synonymies_order_by ON darwin2.classification_synonymies USING btree (group_name, order_by);


--
-- TOC entry 4940 (class 1259 OID 5302680)
-- Name: idx_classification_synonymies_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_classification_synonymies_referenced_record ON darwin2.classification_synonymies USING btree (referenced_relation, record_id, group_id);


--
-- TOC entry 4945 (class 1259 OID 5302681)
-- Name: idx_codes_code; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_codes_code ON darwin2.codes USING btree (code_num) WHERE (NOT (code_num IS NULL));


--
-- TOC entry 4946 (class 1259 OID 5302682)
-- Name: idx_codes_full_code_indexed_btree; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_codes_full_code_indexed_btree ON darwin2.codes USING btree (full_code_indexed);


--
-- TOC entry 4947 (class 1259 OID 5302683)
-- Name: idx_codes_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_codes_referenced_record ON darwin2.codes USING btree (referenced_relation, record_id);


--
-- TOC entry 4953 (class 1259 OID 5302684)
-- Name: idx_collecting_methods_method_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collecting_methods_method_indexed ON darwin2.collecting_methods USING btree (method_indexed);


--
-- TOC entry 4959 (class 1259 OID 5302685)
-- Name: idx_collecting_tools_tool_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collecting_tools_tool_indexed ON darwin2.collecting_tools USING btree (tool_indexed);


--
-- TOC entry 4965 (class 1259 OID 5302686)
-- Name: idx_collection_maintenance_action; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collection_maintenance_action ON darwin2.collection_maintenance USING btree (action_observation);


--
-- TOC entry 4966 (class 1259 OID 5302687)
-- Name: idx_collection_maintenance_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collection_maintenance_referenced_record ON darwin2.collection_maintenance USING btree (referenced_relation, record_id);


--
-- TOC entry 4967 (class 1259 OID 5302688)
-- Name: idx_collection_maintenance_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collection_maintenance_user_ref ON darwin2.collection_maintenance USING btree (people_ref);


--
-- TOC entry 4970 (class 1259 OID 5302689)
-- Name: idx_collections_main_manager_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collections_main_manager_ref ON darwin2.collections USING btree (main_manager_ref);


--
-- TOC entry 4971 (class 1259 OID 5302690)
-- Name: idx_collections_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collections_parent_ref ON darwin2.collections USING btree (parent_ref);


--
-- TOC entry 4976 (class 1259 OID 5302691)
-- Name: idx_collections_rights_db_user_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collections_rights_db_user_type ON darwin2.collections_rights USING btree (db_user_type);


--
-- TOC entry 4977 (class 1259 OID 5302692)
-- Name: idx_collections_rights_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_collections_rights_user_ref ON darwin2.collections_rights USING btree (user_ref);


--
-- TOC entry 4982 (class 1259 OID 5302693)
-- Name: idx_comments_notion_concerned; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_comments_notion_concerned ON darwin2.comments USING btree (notion_concerned);


--
-- TOC entry 4983 (class 1259 OID 5302694)
-- Name: idx_comments_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_comments_referenced_record ON darwin2.comments USING btree (referenced_relation, record_id);


--
-- TOC entry 5156 (class 1259 OID 5302695)
-- Name: idx_darwin_flat_gtu_code; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_darwin_flat_gtu_code ON darwin2.specimens USING gin (gtu_code public.gin_trgm_ops);


--
-- TOC entry 5004 (class 1259 OID 5302696)
-- Name: idx_expeditions_expedition_from_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_expeditions_expedition_from_date ON darwin2.expeditions USING btree (expedition_from_date, expedition_from_date_mask);


--
-- TOC entry 5005 (class 1259 OID 5302697)
-- Name: idx_expeditions_expedition_to_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_expeditions_expedition_to_date ON darwin2.expeditions USING btree (expedition_to_date, expedition_to_date_mask);


--
-- TOC entry 5011 (class 1259 OID 5302698)
-- Name: idx_ext_links_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_ext_links_referenced_record ON darwin2.ext_links USING btree (referenced_relation, record_id);


--
-- TOC entry 4948 (class 1259 OID 5302699)
-- Name: idx_full_code_order_by; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_full_code_order_by ON darwin2.codes USING gin (full_code_indexed public.gin_trgm_ops);


--
-- TOC entry 5020 (class 1259 OID 5302700)
-- Name: idx_gin_gtu_tags_values; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_gtu_tags_values ON darwin2.gtu USING gin (tag_values_indexed);


--
-- TOC entry 5100 (class 1259 OID 5302701)
-- Name: idx_gin_multimedia_search_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_multimedia_search_indexed ON darwin2.multimedia USING gin (search_indexed public.gin_trgm_ops);


--
-- TOC entry 5157 (class 1259 OID 5302702)
-- Name: idx_gin_specimens_gtu_country_tag_indexed_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_gtu_country_tag_indexed_indexed ON darwin2.specimens USING gin (gtu_country_tag_indexed);


--
-- TOC entry 5158 (class 1259 OID 5302703)
-- Name: idx_gin_specimens_gtu_tag_values_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_gtu_tag_values_indexed ON darwin2.specimens USING gin (gtu_tag_values_indexed);


--
-- TOC entry 5159 (class 1259 OID 5302704)
-- Name: idx_gin_specimens_spec_coll_ids; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_spec_coll_ids ON darwin2.specimens USING gin (spec_coll_ids);


--
-- TOC entry 5160 (class 1259 OID 5302705)
-- Name: idx_gin_specimens_spec_don_sel_ids; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_spec_don_sel_ids ON darwin2.specimens USING gin (spec_don_sel_ids);


--
-- TOC entry 5161 (class 1259 OID 5302706)
-- Name: idx_gin_specimens_spec_ident_ids; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_specimens_spec_ident_ids ON darwin2.specimens USING gin (spec_ident_ids);


--
-- TOC entry 4929 (class 1259 OID 5302707)
-- Name: idx_gin_trgm_chronostratigraphy_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_chronostratigraphy_name_indexed ON darwin2.chronostratigraphy USING btree (name_indexed);


--
-- TOC entry 4930 (class 1259 OID 5302708)
-- Name: idx_gin_trgm_chronostratigraphy_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_chronostratigraphy_naming ON darwin2.chronostratigraphy USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 4984 (class 1259 OID 5302709)
-- Name: idx_gin_trgm_comments_comment; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_comments_comment ON darwin2.comments USING gin (comment public.gin_trgm_ops);


--
-- TOC entry 4985 (class 1259 OID 5302710)
-- Name: idx_gin_trgm_comments_comment_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_comments_comment_indexed ON darwin2.comments USING gin (comment_indexed public.gin_trgm_ops);


--
-- TOC entry 5006 (class 1259 OID 5302711)
-- Name: idx_gin_trgm_expeditions_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_expeditions_name ON darwin2.expeditions USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 5048 (class 1259 OID 5302712)
-- Name: idx_gin_trgm_lithology_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_lithology_name_indexed ON darwin2.lithology USING btree (name_indexed);


--
-- TOC entry 5049 (class 1259 OID 5302713)
-- Name: idx_gin_trgm_lithology_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_lithology_naming ON darwin2.lithology USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 5057 (class 1259 OID 5302714)
-- Name: idx_gin_trgm_lithostratigraphy_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_lithostratigraphy_name_indexed ON darwin2.lithostratigraphy USING btree (name_indexed);


--
-- TOC entry 5058 (class 1259 OID 5302715)
-- Name: idx_gin_trgm_lithostratigraphy_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_lithostratigraphy_naming ON darwin2.lithostratigraphy USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 5086 (class 1259 OID 5302716)
-- Name: idx_gin_trgm_loans_search; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_loans_search ON darwin2.loans USING gin (search_indexed public.gin_trgm_ops);


--
-- TOC entry 5089 (class 1259 OID 5302717)
-- Name: idx_gin_trgm_mineralogy_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_mineralogy_name_indexed ON darwin2.mineralogy USING btree (name_indexed);


--
-- TOC entry 5090 (class 1259 OID 5302718)
-- Name: idx_gin_trgm_mineralogy_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_mineralogy_naming ON darwin2.mineralogy USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 5117 (class 1259 OID 5302719)
-- Name: idx_gin_trgm_people_formated_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_people_formated_name ON darwin2.people USING gin (formated_name_indexed public.gin_trgm_ops);


--
-- TOC entry 5162 (class 1259 OID 5302720)
-- Name: idx_gin_trgm_specimens_expedition_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_specimens_expedition_name_indexed ON darwin2.specimens USING gin (expedition_name_indexed public.gin_trgm_ops);


--
-- TOC entry 5163 (class 1259 OID 5302721)
-- Name: idx_gin_trgm_specimens_ig_num; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_specimens_ig_num ON darwin2.specimens USING gin (ig_num_indexed public.gin_trgm_ops);


--
-- TOC entry 5164 (class 1259 OID 5302722)
-- Name: idx_gin_trgm_specimens_taxon_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_specimens_taxon_name_indexed ON darwin2.specimens USING gin (taxon_name_indexed public.gin_trgm_ops);


--
-- TOC entry 5165 (class 1259 OID 5302723)
-- Name: idx_gin_trgm_specimens_taxon_path; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_specimens_taxon_path ON darwin2.specimens USING gin (taxon_path public.gin_trgm_ops);


--
-- TOC entry 5257 (class 1259 OID 5302724)
-- Name: idx_gin_trgm_taxonomy_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_taxonomy_name_indexed ON darwin2.taxonomy USING btree (name_indexed text_pattern_ops);


--
-- TOC entry 5258 (class 1259 OID 5302725)
-- Name: idx_gin_trgm_taxonomy_naming; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_taxonomy_naming ON darwin2.taxonomy USING gin (name_indexed public.gin_trgm_ops);


--
-- TOC entry 5270 (class 1259 OID 5302726)
-- Name: idx_gin_trgm_users_formated_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gin_trgm_users_formated_name ON darwin2.users USING gin (formated_name_indexed public.gin_trgm_ops);


--
-- TOC entry 5166 (class 1259 OID 5302727)
-- Name: idx_gist_specimens_gtu_location; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gist_specimens_gtu_location ON darwin2.specimens USING gist (gtu_location);


--
-- TOC entry 5021 (class 1259 OID 5302728)
-- Name: idx_gtu_code; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gtu_code ON darwin2.gtu USING btree (code);


--
-- TOC entry 5022 (class 1259 OID 5302729)
-- Name: idx_gtu_code_search_for_import; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gtu_code_search_for_import ON darwin2.gtu USING btree ("position"((code)::text, 'import/'::text), (COALESCE(latitude, (0)::double precision)), (COALESCE(longitude, (0)::double precision)), (COALESCE(darwin2.fulltoindex(code), ''::character varying)));


--
-- TOC entry 5023 (class 1259 OID 5302730)
-- Name: idx_gtu_location; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_gtu_location ON darwin2.gtu USING gist (location);


--
-- TOC entry 4997 (class 1259 OID 5302731)
-- Name: idx_identifications_determination_status; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_identifications_determination_status ON darwin2.identifications USING btree (determination_status) WHERE ((determination_status)::text <> ''::text);


--
-- TOC entry 4998 (class 1259 OID 5302732)
-- Name: idx_identifications_notion_concerned; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_identifications_notion_concerned ON darwin2.identifications USING btree (notion_concerned);


--
-- TOC entry 4999 (class 1259 OID 5302733)
-- Name: idx_identifications_order_by; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_identifications_order_by ON darwin2.identifications USING btree (order_by);


--
-- TOC entry 5028 (class 1259 OID 5302734)
-- Name: idx_igs_ig_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_igs_ig_date ON darwin2.igs USING btree (ig_date, ig_date_mask);


--
-- TOC entry 5029 (class 1259 OID 5302735)
-- Name: idx_igs_ig_num_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_igs_ig_num_indexed ON darwin2.igs USING btree (ig_num_indexed text_pattern_ops);


--
-- TOC entry 5036 (class 1259 OID 5302736)
-- Name: idx_informative_workflow_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_informative_workflow_referenced_record ON darwin2.informative_workflow USING btree (referenced_relation, record_id);


--
-- TOC entry 5037 (class 1259 OID 5302737)
-- Name: idx_informative_workflow_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_informative_workflow_user_ref ON darwin2.informative_workflow USING btree (user_ref);


--
-- TOC entry 5038 (class 1259 OID 5302738)
-- Name: idx_informative_workflow_user_status; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_informative_workflow_user_status ON darwin2.informative_workflow USING btree (user_ref, status);


--
-- TOC entry 5041 (class 1259 OID 5302739)
-- Name: idx_insurances_contact_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_insurances_contact_ref ON darwin2.insurances USING btree (contact_ref);


--
-- TOC entry 5042 (class 1259 OID 5302740)
-- Name: idx_insurances_insurance_currency; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_insurances_insurance_currency ON darwin2.insurances USING btree (insurance_currency);


--
-- TOC entry 5043 (class 1259 OID 5302741)
-- Name: idx_insurances_insurer_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_insurances_insurer_ref ON darwin2.insurances USING btree (insurer_ref);


--
-- TOC entry 5167 (class 1259 OID 5302742)
-- Name: idx_labeling_ig_num_numeric; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_labeling_ig_num_numeric ON darwin2.specimens USING btree (darwin2.convert_to_integer(COALESCE(ig_num, '-'::character varying)));


--
-- TOC entry 5168 (class 1259 OID 5302743)
-- Name: idx_labeling_other_gtu; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_labeling_other_gtu ON darwin2.specimens USING gin (gtu_others_tag_indexed);


--
-- TOC entry 5169 (class 1259 OID 5302744)
-- Name: idx_labeling_province; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_labeling_province ON darwin2.specimens USING gin (gtu_province_tag_indexed);


--
-- TOC entry 5050 (class 1259 OID 5302745)
-- Name: idx_lithology_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithology_level_ref ON darwin2.lithology USING btree (level_ref);


--
-- TOC entry 5051 (class 1259 OID 5302746)
-- Name: idx_lithology_name_order_by_txt_op; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithology_name_order_by_txt_op ON darwin2.lithology USING btree (name_indexed text_pattern_ops);


--
-- TOC entry 5052 (class 1259 OID 5302747)
-- Name: idx_lithology_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithology_parent_ref ON darwin2.lithology USING btree (parent_ref);


--
-- TOC entry 5059 (class 1259 OID 5302748)
-- Name: idx_lithostratigraphy_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithostratigraphy_level_ref ON darwin2.lithostratigraphy USING btree (level_ref);


--
-- TOC entry 5060 (class 1259 OID 5302749)
-- Name: idx_lithostratigraphy_name_order_by_txt_op; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithostratigraphy_name_order_by_txt_op ON darwin2.lithostratigraphy USING btree (name_indexed text_pattern_ops);


--
-- TOC entry 5061 (class 1259 OID 5302750)
-- Name: idx_lithostratigraphy_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_lithostratigraphy_parent_ref ON darwin2.lithostratigraphy USING btree (parent_ref);


--
-- TOC entry 5068 (class 1259 OID 5302751)
-- Name: idx_loan_items_ig_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_items_ig_ref ON darwin2.loan_items USING btree (ig_ref);


--
-- TOC entry 5069 (class 1259 OID 5302752)
-- Name: idx_loan_items_loan_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_items_loan_ref ON darwin2.loan_items USING btree (loan_ref);


--
-- TOC entry 5070 (class 1259 OID 5302753)
-- Name: idx_loan_items_part_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_items_part_ref ON darwin2.loan_items USING btree (specimen_ref);


--
-- TOC entry 5075 (class 1259 OID 5302754)
-- Name: idx_loan_rights_ig_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_rights_ig_ref ON darwin2.loan_rights USING btree (loan_ref);


--
-- TOC entry 5076 (class 1259 OID 5302755)
-- Name: idx_loan_rights_part_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_rights_part_ref ON darwin2.loan_rights USING btree (user_ref);


--
-- TOC entry 5081 (class 1259 OID 5302756)
-- Name: idx_loan_status_loan_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_status_loan_ref ON darwin2.loan_status USING btree (loan_ref);


--
-- TOC entry 5082 (class 1259 OID 5302757)
-- Name: idx_loan_status_loan_ref_is_last; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_status_loan_ref_is_last ON darwin2.loan_status USING btree (loan_ref, is_last);


--
-- TOC entry 5083 (class 1259 OID 5302758)
-- Name: idx_loan_status_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_loan_status_user_ref ON darwin2.loan_status USING btree (user_ref);


--
-- TOC entry 4954 (class 1259 OID 5302759)
-- Name: idx_method_trgm; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_method_trgm ON darwin2.collecting_methods USING gin (method public.gin_trgm_ops);


--
-- TOC entry 5091 (class 1259 OID 5302760)
-- Name: idx_mineralogy_code; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_code ON darwin2.mineralogy USING btree (upper((code)::text));


--
-- TOC entry 5092 (class 1259 OID 5302761)
-- Name: idx_mineralogy_cristal_system; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_cristal_system ON darwin2.mineralogy USING btree (cristal_system) WHERE ((cristal_system)::text <> ''::text);


--
-- TOC entry 5093 (class 1259 OID 5302762)
-- Name: idx_mineralogy_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_level_ref ON darwin2.mineralogy USING btree (level_ref);


--
-- TOC entry 5094 (class 1259 OID 5302763)
-- Name: idx_mineralogy_name_order_by_txt_op; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_name_order_by_txt_op ON darwin2.mineralogy USING btree (name_indexed text_pattern_ops);


--
-- TOC entry 5095 (class 1259 OID 5302764)
-- Name: idx_mineralogy_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_mineralogy_parent_ref ON darwin2.mineralogy USING btree (parent_ref);


--
-- TOC entry 5115 (class 1259 OID 5302765)
-- Name: idx_multimedia_is_digital; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_multimedia_is_digital ON darwin2.old_multimedia USING btree (is_digital);


--
-- TOC entry 5101 (class 1259 OID 5302766)
-- Name: idx_multimedia_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_multimedia_referenced_record ON darwin2.multimedia USING btree (referenced_relation, record_id);


--
-- TOC entry 5116 (class 1259 OID 5302767)
-- Name: idx_multimedia_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_multimedia_type ON darwin2.old_multimedia USING btree (type);


--
-- TOC entry 5110 (class 1259 OID 5302768)
-- Name: idx_my_widgets_user_category; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_my_widgets_user_category ON darwin2.my_widgets USING btree (user_ref, category, group_name);


--
-- TOC entry 5124 (class 1259 OID 5302769)
-- Name: idx_people_addresses_country; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_addresses_country ON darwin2.people_addresses USING btree (country);


--
-- TOC entry 5125 (class 1259 OID 5302770)
-- Name: idx_people_addresses_person_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_addresses_person_user_ref ON darwin2.people_addresses USING btree (person_user_ref);


--
-- TOC entry 5128 (class 1259 OID 5302771)
-- Name: idx_people_comm_comm_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_comm_comm_type ON darwin2.people_comm USING btree (comm_type);


--
-- TOC entry 5129 (class 1259 OID 5302772)
-- Name: idx_people_comm_person_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_comm_person_user_ref ON darwin2.people_comm USING btree (person_user_ref);


--
-- TOC entry 5118 (class 1259 OID 5302773)
-- Name: idx_people_family_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_family_name ON darwin2.people USING btree (family_name);


--
-- TOC entry 5132 (class 1259 OID 5302774)
-- Name: idx_people_languages_language_country; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_languages_language_country ON darwin2.people_languages USING btree (language_country);


--
-- TOC entry 5137 (class 1259 OID 5302775)
-- Name: idx_people_relationships_person_1_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_relationships_person_1_ref ON darwin2.people_relationships USING btree (person_1_ref);


--
-- TOC entry 5138 (class 1259 OID 5302776)
-- Name: idx_people_relationships_person_2_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_relationships_person_2_ref ON darwin2.people_relationships USING btree (person_2_ref);


--
-- TOC entry 5119 (class 1259 OID 5302777)
-- Name: idx_people_sub_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_people_sub_type ON darwin2.people USING btree (sub_type) WHERE (NOT (sub_type IS NULL));


--
-- TOC entry 5141 (class 1259 OID 5302778)
-- Name: idx_possible_upper_levels_level_upper_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_possible_upper_levels_level_upper_ref ON darwin2.possible_upper_levels USING btree (level_upper_ref);


--
-- TOC entry 4988 (class 1259 OID 5302779)
-- Name: idx_properties_property_lower_value; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_lower_value ON darwin2.properties USING btree (lower_value);


--
-- TOC entry 4989 (class 1259 OID 5302780)
-- Name: idx_properties_property_lower_value_unified; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_lower_value_unified ON darwin2.properties USING btree (lower_value_unified);


--
-- TOC entry 4990 (class 1259 OID 5302781)
-- Name: idx_properties_property_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_type ON darwin2.properties USING btree (property_type);


--
-- TOC entry 4991 (class 1259 OID 5302782)
-- Name: idx_properties_property_unit; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_unit ON darwin2.properties USING btree (property_unit);


--
-- TOC entry 4992 (class 1259 OID 5302783)
-- Name: idx_properties_property_upper_value; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_upper_value ON darwin2.properties USING btree (upper_value);


--
-- TOC entry 4993 (class 1259 OID 5302784)
-- Name: idx_properties_property_upper_value_unified; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_property_upper_value_unified ON darwin2.properties USING btree (upper_value_unified);


--
-- TOC entry 4994 (class 1259 OID 5302785)
-- Name: idx_properties_referenced_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_properties_referenced_record ON darwin2.properties USING btree (referenced_relation, record_id);


--
-- TOC entry 5146 (class 1259 OID 5302786)
-- Name: idx_specimen_collecting_methods_method_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimen_collecting_methods_method_ref ON darwin2.specimen_collecting_methods USING btree (collecting_method_ref);


--
-- TOC entry 5151 (class 1259 OID 5302787)
-- Name: idx_specimen_collecting_tools_tool_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimen_collecting_tools_tool_ref ON darwin2.specimen_collecting_tools USING btree (collecting_tool_ref);


--
-- TOC entry 5170 (class 1259 OID 5302788)
-- Name: idx_specimen_rock_form; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimen_rock_form ON darwin2.specimens USING btree (rock_form);


--
-- TOC entry 5171 (class 1259 OID 5302789)
-- Name: idx_specimens_; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_ ON darwin2.specimens USING btree (specimen_part);


--
-- TOC entry 5172 (class 1259 OID 5302790)
-- Name: idx_specimens_category; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_category ON darwin2.specimens USING btree (category);


--
-- TOC entry 5173 (class 1259 OID 5302791)
-- Name: idx_specimens_chrono_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_chrono_ref ON darwin2.specimens USING btree (chrono_ref) WHERE (chrono_ref <> 0);


--
-- TOC entry 5174 (class 1259 OID 5302792)
-- Name: idx_specimens_collection_is_public; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_collection_is_public ON darwin2.specimens USING btree (collection_is_public);


--
-- TOC entry 5175 (class 1259 OID 5302793)
-- Name: idx_specimens_collection_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_collection_name ON darwin2.specimens USING btree (collection_name);


--
-- TOC entry 5176 (class 1259 OID 5302794)
-- Name: idx_specimens_container; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_container ON darwin2.specimens USING btree (container) WHERE (NOT (container IS NULL));


--
-- TOC entry 5177 (class 1259 OID 5302795)
-- Name: idx_specimens_container_storage; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_container_storage ON darwin2.specimens USING btree (container_storage);


--
-- TOC entry 5178 (class 1259 OID 5302796)
-- Name: idx_specimens_container_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_container_type ON darwin2.specimens USING btree (container_type);


--
-- TOC entry 5179 (class 1259 OID 5302797)
-- Name: idx_specimens_expedition_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_expedition_ref ON darwin2.specimens USING btree (expedition_ref) WHERE (expedition_ref <> 0);


--
-- TOC entry 5180 (class 1259 OID 5302798)
-- Name: idx_specimens_gtu_from_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_from_date ON darwin2.specimens USING btree (gtu_from_date);


--
-- TOC entry 5181 (class 1259 OID 5302799)
-- Name: idx_specimens_gtu_from_date_mask; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_from_date_mask ON darwin2.specimens USING btree (gtu_from_date_mask);


--
-- TOC entry 5182 (class 1259 OID 5302800)
-- Name: idx_specimens_gtu_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_ref ON darwin2.specimens USING btree (gtu_ref) WHERE (gtu_ref <> 0);


--
-- TOC entry 5183 (class 1259 OID 5302801)
-- Name: idx_specimens_gtu_to_date; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_to_date ON darwin2.specimens USING btree (gtu_to_date);


--
-- TOC entry 5184 (class 1259 OID 5302802)
-- Name: idx_specimens_gtu_to_date_mask; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_gtu_to_date_mask ON darwin2.specimens USING btree (gtu_to_date_mask);


--
-- TOC entry 5185 (class 1259 OID 5302803)
-- Name: idx_specimens_ig_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_ig_ref ON darwin2.specimens USING btree (ig_ref);


--
-- TOC entry 5186 (class 1259 OID 5302804)
-- Name: idx_specimens_institution_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_institution_ref ON darwin2.specimens USING btree (institution_ref);


--
-- TOC entry 5187 (class 1259 OID 5302805)
-- Name: idx_specimens_litho_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_litho_ref ON darwin2.specimens USING btree (litho_ref) WHERE (litho_ref <> 0);


--
-- TOC entry 5188 (class 1259 OID 5302806)
-- Name: idx_specimens_lithology_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_lithology_ref ON darwin2.specimens USING btree (lithology_ref) WHERE (lithology_ref <> 0);


--
-- TOC entry 5189 (class 1259 OID 5302807)
-- Name: idx_specimens_mineral_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_mineral_ref ON darwin2.specimens USING btree (mineral_ref) WHERE (mineral_ref <> 0);


--
-- TOC entry 5190 (class 1259 OID 5302808)
-- Name: idx_specimens_object_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_object_name_indexed ON darwin2.specimens USING btree (object_name_indexed);


--
-- TOC entry 5209 (class 1259 OID 5302809)
-- Name: idx_specimens_relationships_mineral_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_relationships_mineral_ref ON darwin2.specimens_relationships USING btree (mineral_ref);


--
-- TOC entry 5210 (class 1259 OID 5302810)
-- Name: idx_specimens_relationships_specimen_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_relationships_specimen_ref ON darwin2.specimens_relationships USING btree (specimen_ref);


--
-- TOC entry 5211 (class 1259 OID 5302811)
-- Name: idx_specimens_relationships_specimen_related_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_relationships_specimen_related_ref ON darwin2.specimens_relationships USING btree (specimen_related_ref);


--
-- TOC entry 5212 (class 1259 OID 5302812)
-- Name: idx_specimens_relationships_taxon_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_relationships_taxon_ref ON darwin2.specimens_relationships USING btree (taxon_ref);


--
-- TOC entry 5191 (class 1259 OID 5302813)
-- Name: idx_specimens_room; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_room ON darwin2.specimens USING btree (room) WHERE (NOT (room IS NULL));


--
-- TOC entry 5192 (class 1259 OID 5302814)
-- Name: idx_specimens_row; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_row ON darwin2.specimens USING btree ("row") WHERE (NOT ("row" IS NULL));


--
-- TOC entry 5193 (class 1259 OID 5302815)
-- Name: idx_specimens_sex; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_sex ON darwin2.specimens USING btree (sex) WHERE ((sex)::text <> ALL (ARRAY['undefined'::text, 'unknown'::text]));


--
-- TOC entry 5194 (class 1259 OID 5302816)
-- Name: idx_specimens_shelf; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_shelf ON darwin2.specimens USING btree (shelf) WHERE (NOT (shelf IS NULL));


--
-- TOC entry 5195 (class 1259 OID 5302817)
-- Name: idx_specimens_social_status; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_social_status ON darwin2.specimens USING btree (social_status) WHERE ((social_status)::text <> 'not applicable'::text);


--
-- TOC entry 5196 (class 1259 OID 5302818)
-- Name: idx_specimens_stage; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_stage ON darwin2.specimens USING btree (stage) WHERE ((stage)::text <> ALL (ARRAY['undefined'::text, 'unknown'::text]));


--
-- TOC entry 5197 (class 1259 OID 5302819)
-- Name: idx_specimens_state; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_state ON darwin2.specimens USING btree (state) WHERE ((state)::text <> 'not applicable'::text);


--
-- TOC entry 5198 (class 1259 OID 5302820)
-- Name: idx_specimens_station_visible; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_station_visible ON darwin2.specimens USING btree (station_visible);


--
-- TOC entry 5199 (class 1259 OID 5302821)
-- Name: idx_specimens_sub_container; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_sub_container ON darwin2.specimens USING btree (sub_container) WHERE (NOT (sub_container IS NULL));


--
-- TOC entry 5200 (class 1259 OID 5302822)
-- Name: idx_specimens_sub_container_storage; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_sub_container_storage ON darwin2.specimens USING btree (sub_container_storage);


--
-- TOC entry 5201 (class 1259 OID 5302823)
-- Name: idx_specimens_sub_container_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_sub_container_type ON darwin2.specimens USING btree (sub_container_type);


--
-- TOC entry 5202 (class 1259 OID 5302824)
-- Name: idx_specimens_taxon_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_taxon_name_indexed ON darwin2.specimens USING btree (taxon_name_indexed);


--
-- TOC entry 5203 (class 1259 OID 5302825)
-- Name: idx_specimens_taxon_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_taxon_ref ON darwin2.specimens USING btree (taxon_ref) WHERE (taxon_ref <> 0);


--
-- TOC entry 5204 (class 1259 OID 5302826)
-- Name: idx_specimens_type_search; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_specimens_type_search ON darwin2.specimens USING btree (type_search) WHERE ((type_search)::text <> 'specimen'::text);


--
-- TOC entry 5215 (class 1259 OID 5302827)
-- Name: idx_staging_catalogue; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_catalogue ON darwin2.staging_catalogue USING btree (level_ref, darwin2.fulltoindex(name));


--
-- TOC entry 5216 (class 1259 OID 5302828)
-- Name: idx_staging_catalogue_catalogue_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_catalogue_catalogue_ref ON darwin2.staging_catalogue USING btree (import_ref, parent_ref) WHERE (catalogue_ref IS NOT NULL);


--
-- TOC entry 5217 (class 1259 OID 5302829)
-- Name: idx_staging_catalogue_filter; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_catalogue_filter ON darwin2.staging_catalogue USING btree (import_ref, name, level_ref);


--
-- TOC entry 5218 (class 1259 OID 5302830)
-- Name: idx_staging_catalogue_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_catalogue_parent_ref ON darwin2.staging_catalogue USING btree (parent_ref) WHERE (parent_ref IS NOT NULL);


--
-- TOC entry 5219 (class 1259 OID 5302831)
-- Name: idx_staging_catalogue_parent_updated; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_catalogue_parent_updated ON darwin2.staging_catalogue USING btree (parent_updated);


--
-- TOC entry 4893 (class 1259 OID 5302832)
-- Name: idx_staging_gtu_code; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_gtu_code ON darwin2.staging USING btree (gtu_code) WHERE (gtu_code IS NOT NULL);


--
-- TOC entry 4894 (class 1259 OID 5302833)
-- Name: idx_staging_gtu_code_fulltoindex; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_gtu_code_fulltoindex ON darwin2.staging USING btree (darwin2.fulltoindex(gtu_code)) WHERE (gtu_code IS NOT NULL);


--
-- TOC entry 4895 (class 1259 OID 5302834)
-- Name: idx_staging_import_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_import_ref ON darwin2.staging USING btree (import_ref);


--
-- TOC entry 5234 (class 1259 OID 5302835)
-- Name: idx_staging_people_record; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_staging_people_record ON darwin2.staging_people USING btree (record_id, referenced_relation);


--
-- TOC entry 5243 (class 1259 OID 5302836)
-- Name: idx_tag_groups_group_name_indexed; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tag_groups_group_name_indexed ON darwin2.tag_groups USING btree (group_name_indexed);


--
-- TOC entry 5244 (class 1259 OID 5302837)
-- Name: idx_tag_groups_group_name_indexed_txt_op; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tag_groups_group_name_indexed_txt_op ON darwin2.tag_groups USING btree (group_name_indexed text_pattern_ops);


--
-- TOC entry 5245 (class 1259 OID 5302838)
-- Name: idx_tag_groups_sub_group_name; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tag_groups_sub_group_name ON darwin2.tag_groups USING btree (sub_group_name);


--
-- TOC entry 5250 (class 1259 OID 5302839)
-- Name: idx_tags_group_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_group_ref ON darwin2.tags USING btree (group_ref);


--
-- TOC entry 5251 (class 1259 OID 5302840)
-- Name: idx_tags_group_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_group_type ON darwin2.tags USING btree (group_type);


--
-- TOC entry 5252 (class 1259 OID 5302841)
-- Name: idx_tags_gtu_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_gtu_ref ON darwin2.tags USING btree (gtu_ref);


--
-- TOC entry 5253 (class 1259 OID 5307726)
-- Name: idx_tags_indexed_trgm; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_indexed_trgm ON darwin2.tags USING gin (tag_indexed public.gin_trgm_ops);


--
-- TOC entry 5254 (class 1259 OID 5307727)
-- Name: idx_tags_rmca_indexed_trgm; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_rmca_indexed_trgm ON darwin2.tags USING gin (tag_indexed public.gin_trgm_ops);


--
-- TOC entry 5255 (class 1259 OID 5302842)
-- Name: idx_tags_sub_group_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_sub_group_type ON darwin2.tags USING btree (sub_group_type);


--
-- TOC entry 5256 (class 1259 OID 5302844)
-- Name: idx_tags_trgm; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tags_trgm ON darwin2.tags USING gin (tag public.gin_trgm_ops);


--
-- TOC entry 5259 (class 1259 OID 5302845)
-- Name: idx_taxonomy_level_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_taxonomy_level_ref ON darwin2.taxonomy USING btree (level_ref);


--
-- TOC entry 5260 (class 1259 OID 5302846)
-- Name: idx_taxonomy_parent_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_taxonomy_parent_ref ON darwin2.taxonomy USING btree (parent_ref);


--
-- TOC entry 5261 (class 1259 OID 5302847)
-- Name: idx_taxonomy_path; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_taxonomy_path ON darwin2.taxonomy USING btree (path text_pattern_ops);


--
-- TOC entry 5205 (class 1259 OID 5307724)
-- Name: idx_test_1; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_test_1 ON darwin2.specimens USING gin (spec_coll_ids);


--
-- TOC entry 5206 (class 1259 OID 5307725)
-- Name: idx_test_2; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_test_2 ON darwin2.specimens USING gin (spec_ident_ids);


--
-- TOC entry 4960 (class 1259 OID 5302848)
-- Name: idx_tool_trgm; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_tool_trgm ON darwin2.collecting_tools USING gin (tool public.gin_trgm_ops);


--
-- TOC entry 5275 (class 1259 OID 5302849)
-- Name: idx_users_addresses_country; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_addresses_country ON darwin2.users_addresses USING btree (country);


--
-- TOC entry 5276 (class 1259 OID 5302850)
-- Name: idx_users_addresses_person_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_addresses_person_user_ref ON darwin2.users_addresses USING btree (person_user_ref);


--
-- TOC entry 5279 (class 1259 OID 5302851)
-- Name: idx_users_comm_comm_type; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_comm_comm_type ON darwin2.users_comm USING btree (comm_type);


--
-- TOC entry 5280 (class 1259 OID 5302852)
-- Name: idx_users_comm_person_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_comm_person_user_ref ON darwin2.users_comm USING btree (person_user_ref);


--
-- TOC entry 5289 (class 1259 OID 5302853)
-- Name: idx_users_tracking_action; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_tracking_action ON darwin2.users_tracking USING btree (action);


--
-- TOC entry 5290 (class 1259 OID 5302854)
-- Name: idx_users_tracking_date_time; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_tracking_date_time ON darwin2.users_tracking USING btree (modification_date_time DESC);


--
-- TOC entry 5291 (class 1259 OID 5302855)
-- Name: idx_users_tracking_user_ref_date_time; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX idx_users_tracking_user_ref_date_time ON darwin2.users_tracking USING btree (user_ref, modification_date_time DESC);


--
-- TOC entry 5294 (class 1259 OID 5302856)
-- Name: idx_vernacular_names_community_indexed; Type: INDEX; Schema: darwin2; Owner: postgres
--

CREATE INDEX idx_vernacular_names_community_indexed ON darwin2.vernacular_names USING btree (community_indexed);


--
-- TOC entry 5295 (class 1259 OID 5302857)
-- Name: idx_vernacular_names_name_indexed; Type: INDEX; Schema: darwin2; Owner: postgres
--

CREATE INDEX idx_vernacular_names_name_indexed ON darwin2.vernacular_names USING btree (name_indexed);


--
-- TOC entry 5296 (class 1259 OID 5302858)
-- Name: idx_vernacular_names_referenced_record; Type: INDEX; Schema: darwin2; Owner: postgres
--

CREATE INDEX idx_vernacular_names_referenced_record ON darwin2.vernacular_names USING btree (referenced_relation, record_id);


--
-- TOC entry 5320 (class 1259 OID 5308640)
-- Name: tag_authority_idx; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE UNIQUE INDEX tag_authority_idx ON darwin2.tag_authority USING btree (domain_ref, pref_label, url, code);


--
-- TOC entry 5325 (class 1259 OID 5308641)
-- Name: tag_tag_authority_idx; Type: INDEX; Schema: darwin2; Owner: postgres
--

CREATE INDEX tag_tag_authority_idx ON darwin2.tag_tag_authority USING btree (tag_authority_ref, tag_group_distinct_ref);


--
-- TOC entry 5330 (class 1259 OID 5308759)
-- Name: taxonomy_is_marine_authority_idx; Type: INDEX; Schema: darwin2; Owner: postgres
--

CREATE INDEX taxonomy_is_marine_authority_idx ON darwin2.taxonomy_authority USING btree (((profile OPERATOR(public.->) 'isMarine'::text)));


--
-- TOC entry 5301 (class 1259 OID 5302859)
-- Name: zzz_uta_id; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX zzz_uta_id ON darwin2.zzz_users_tracking_archived USING btree (id);


--
-- TOC entry 5302 (class 1259 OID 5302860)
-- Name: zzz_uta_modification_date_time; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX zzz_uta_modification_date_time ON darwin2.zzz_users_tracking_archived USING btree (modification_date_time);


--
-- TOC entry 5303 (class 1259 OID 5302861)
-- Name: zzz_uta_record_id; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX zzz_uta_record_id ON darwin2.zzz_users_tracking_archived USING btree (record_id);


--
-- TOC entry 5304 (class 1259 OID 5302862)
-- Name: zzz_uta_referenced_relation; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX zzz_uta_referenced_relation ON darwin2.zzz_users_tracking_archived USING btree (referenced_relation);


--
-- TOC entry 5305 (class 1259 OID 5302863)
-- Name: zzz_uta_specimen_individual_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX zzz_uta_specimen_individual_ref ON darwin2.zzz_users_tracking_archived USING btree (specimen_individual_ref);


--
-- TOC entry 5306 (class 1259 OID 5302864)
-- Name: zzz_uta_specimen_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX zzz_uta_specimen_ref ON darwin2.zzz_users_tracking_archived USING btree (specimen_ref);


--
-- TOC entry 5307 (class 1259 OID 5302865)
-- Name: zzz_uta_user_ref; Type: INDEX; Schema: darwin2; Owner: darwin2
--

CREATE INDEX zzz_uta_user_ref ON darwin2.zzz_users_tracking_archived USING btree (user_ref);


--
-- TOC entry 5778 (class 2618 OID 5302866)
-- Name: v_rmca_taxonomy_synonyms_with_name_and_specs _RETURN; Type: RULE; Schema: darwin2; Owner: darwin2
--

CREATE OR REPLACE VIEW darwin2.v_rmca_taxonomy_synonyms_with_name_and_specs AS
 SELECT a.referenced_relation,
    array_agg(a.record_id ORDER BY a.record_id) AS records_ids,
    array_agg(a.id ORDER BY a.record_id) AS ids,
    a.group_id,
    a.group_name,
    array_agg(a.is_basionym ORDER BY a.record_id) AS basionyms,
    array_agg(a.order_by ORDER BY a.record_id) AS orders,
    string_agg((a.name)::text, ';'::text ORDER BY a.record_id) AS taxon_names,
    sum(a.count_specimens ORDER BY a.record_id) AS count_specimens,
    public.hstore(((array_agg(a.record_id ORDER BY a.record_id))::character varying)::text, ((array_agg(a.count_specimens ORDER BY a.record_id))::character varying)::text) AS count_specimens_by_taxon
   FROM ( SELECT DISTINCT classification_synonymies.referenced_relation,
            classification_synonymies.record_id,
            classification_synonymies.id,
            classification_synonymies.group_id,
            classification_synonymies.group_name,
            classification_synonymies.is_basionym,
            classification_synonymies.order_by,
            taxonomy.name,
            count(specimens.id) AS count_specimens
           FROM ((darwin2.classification_synonymies
             LEFT JOIN darwin2.taxonomy ON ((classification_synonymies.record_id = taxonomy.id)))
             LEFT JOIN darwin2.specimens ON ((taxonomy.id = specimens.taxon_ref)))
          GROUP BY classification_synonymies.referenced_relation, classification_synonymies.group_id, classification_synonymies.group_name, classification_synonymies.id, classification_synonymies.order_by, taxonomy.name) a
  GROUP BY a.referenced_relation, a.group_id, a.group_name;


--
-- TOC entry 5779 (class 2618 OID 5302868)
-- Name: v_darwin_ipt_rbins _RETURN; Type: RULE; Schema: darwin2; Owner: darwin2
--

CREATE OR REPLACE VIEW darwin2.v_darwin_ipt_rbins AS
 SELECT DISTINCT string_agg(DISTINCT ((specimens.id)::character varying)::text, ','::text) AS ids,
    ('http://darwin.naturalsciences.be/public.php/search/view/id/'::text || ((specimens.id)::character varying)::text) AS guid,
    specimens.collection_ref,
    collections.code AS collection_code,
    collections.name AS collection_name,
    collections.id AS collection_id,
    collections.path AS collection_path,
    (((((COALESCE(codes.code_prefix, ''::character varying))::text || (COALESCE(codes.code_prefix_separator, ''::character varying))::text) || (COALESCE(codes.code, ''::character varying))::text) || (COALESCE(codes.code_suffix_separator, ''::character varying))::text) || (COALESCE(codes.code_suffix, ''::character varying))::text) AS cataloguenumber,
    'PreservedSpecimen'::text AS basisofrecord,
    'RMCA'::text AS institutionid,
    'BE-RMCA'::text AS iso_country_institution,
    'Please cite the soiurce database appropriatly'::text AS bibliographic_citation,
    'placeholder for CC licence'::text AS license,
    'patrick.semal@naturalsciences.be'::text AS email,
    specimens.type,
    specimens.taxon_path,
    specimens.taxon_ref,
    specimens.taxon_name,
    darwin2.fct_rmca_sort_taxon_get_parent_level_text(specimens.taxon_ref, 34) AS family,
    specimens.gtu_country_tag_value AS country,
    btrim(replace(replace((specimens.gtu_others_tag_value)::text, (specimens.gtu_country_tag_value)::text, ''::text), 'Africa'::text, ''::text), ';'::text) AS location,
    (specimens.gtu_location[1])::character varying AS latitude,
    (specimens.gtu_location[0])::character varying AS longitude,
    gtu.lat_long_accuracy,
    specimens.spec_coll_ids AS collector_ids,
    ( SELECT string_agg((people.formated_name)::text, ', '::text ORDER BY people.id) AS string_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens.spec_coll_ids))) AS collectors,
    specimens.spec_don_sel_ids AS donator_ids,
    ( SELECT string_agg((people.formated_name)::text, ', '::text ORDER BY people.id) AS string_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens.spec_don_sel_ids))) AS donators,
    specimens.spec_ident_ids AS identifiers_ids,
    ( SELECT string_agg((people.formated_name)::text, ', '::text ORDER BY people.id) AS string_agg
           FROM darwin2.people
          WHERE (people.id = ANY (specimens.spec_ident_ids))) AS identifiers,
    specimens.gtu_from_date,
    specimens.gtu_from_date_mask,
    specimens.gtu_to_date,
    specimens.gtu_to_date_mask,
    replace(replace((NULLIF(darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask), 'xxxx-xx-xx'::text) || COALESCE(('-'::text || NULLIF(darwin2.fct_mask_date(specimens.gtu_to_date, specimens.gtu_to_date_mask), 'xxxx-xx-xx'::text)), ''::text)), 'xxxx'::text, ''::text), '-xx'::text, ''::text) AS eventdate,
        CASE
            WHEN (specimens.gtu_country_tag_indexed IS NOT NULL) THEN unnest(specimens.gtu_country_tag_indexed)
            ELSE NULL::character varying
        END AS country_unnest,
    replace(replace((NULLIF(darwin2.fct_mask_date(specimens.gtu_from_date, specimens.gtu_from_date_mask), 'xxxx-xx-xx'::text) || COALESCE(('-'::text || NULLIF(darwin2.fct_mask_date(specimens.gtu_to_date, specimens.gtu_to_date_mask), 'xxxx-xx-xx'::text)), ''::text)), 'xxxx'::text, ''::text), '-xx'::text, ''::text) AS identification_date,
    (COALESCE((darwin2.fct_mask_date(identifications.notion_date, identifications.notion_date_mask) || ': '::text), ''::text) || (specimens.taxon_name)::text) AS history,
    specimens.gtu_ref
   FROM (((((darwin2.specimens
     LEFT JOIN darwin2.collections ON ((specimens.collection_ref = collections.id)))
     LEFT JOIN darwin2.codes ON ((((codes.referenced_relation)::text = 'specimens'::text) AND ((codes.code_category)::text = 'main'::text) AND (specimens.id = codes.record_id))))
     LEFT JOIN darwin2.identifications ON ((((identifications.referenced_relation)::text = 'specimens'::text) AND (specimens.id = identifications.record_id) AND ((identifications.notion_concerned)::text = 'taxonomy'::text))))
     LEFT JOIN darwin2.tags ON ((specimens.gtu_ref = tags.gtu_ref)))
     LEFT JOIN darwin2.gtu ON ((specimens.gtu_ref = gtu.id)))
  GROUP BY specimens.id, collections.id, collections.code, collections.name, codes.code_prefix, codes.code_prefix_separator, codes.code, codes.code_suffix, codes.code_suffix_separator, specimens.taxon_path, specimens.taxon_ref, specimens.collection_ref, specimens.gtu_country_tag_indexed, specimens.gtu_country_tag_value, (specimens.gtu_location[0])::character varying, (specimens.gtu_location[1])::character varying, specimens.spec_ident_ids, specimens.gtu_others_tag_indexed, specimens.gtu_others_tag_value, specimens.taxon_name, identifications.notion_date, identifications.notion_date_mask, specimens.gtu_ref, specimens.gtu_from_date, specimens.gtu_from_date_mask, specimens.gtu_to_date, specimens.gtu_to_date_mask, specimens.type, specimens.spec_coll_ids, specimens.spec_don_sel_ids, codes.full_code_indexed, gtu.lat_long_accuracy;


--
-- TOC entry 5781 (class 2618 OID 5307657)
-- Name: v_reindex_tag_spaces _RETURN; Type: RULE; Schema: darwin2; Owner: darwin2
--

CREATE OR REPLACE VIEW darwin2.v_reindex_tag_spaces AS
 SELECT a.id,
    a.gtu_ref,
    (a.value)::text AS tag_value
   FROM ( SELECT tag_groups.id,
            tag_groups.gtu_ref,
            darwin2.fulltoindex((unnest(string_to_array((tag_groups.tag_value)::text, ';'::text)))::character varying, true) AS value
           FROM darwin2.tag_groups
          WHERE ((tag_groups.tag_value)::text ~~ '%;%'::text)
          GROUP BY tag_groups.id) a
UNION
 SELECT tag_groups.id,
    tag_groups.gtu_ref,
    darwin2.fulltoindex(tag_groups.tag_value, true) AS tag_value
   FROM darwin2.tag_groups
  WHERE ((tag_groups.tag_value)::text !~~ '%;%'::text);


--
-- TOC entry 5471 (class 2620 OID 5302870)
-- Name: collections fct_chk_peopleismoral_collections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_chk_peopleismoral_collections AFTER INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_peopleismoral();


--
-- TOC entry 5456 (class 2620 OID 5302871)
-- Name: codes fct_cpy_trg_del_dict_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_codes AFTER DELETE OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5466 (class 2620 OID 5302872)
-- Name: collection_maintenance fct_cpy_trg_del_dict_collection_maintenance; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_collection_maintenance AFTER DELETE OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5494 (class 2620 OID 5302873)
-- Name: identifications fct_cpy_trg_del_dict_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_identifications AFTER DELETE OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5523 (class 2620 OID 5302874)
-- Name: insurances fct_cpy_trg_del_dict_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_insurances AFTER DELETE OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5545 (class 2620 OID 5302875)
-- Name: loan_status fct_cpy_trg_del_dict_loan_status; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_loan_status AFTER DELETE OR UPDATE ON darwin2.loan_status FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5553 (class 2620 OID 5302876)
-- Name: mineralogy fct_cpy_trg_del_dict_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_mineralogy AFTER DELETE OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5566 (class 2620 OID 5302877)
-- Name: people fct_cpy_trg_del_dict_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_people AFTER DELETE OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5572 (class 2620 OID 5302878)
-- Name: people_addresses fct_cpy_trg_del_dict_people_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_people_addresses AFTER DELETE OR UPDATE ON darwin2.people_addresses FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5488 (class 2620 OID 5302879)
-- Name: properties fct_cpy_trg_del_dict_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_properties AFTER DELETE OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5580 (class 2620 OID 5302880)
-- Name: specimens fct_cpy_trg_del_dict_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_specimens AFTER DELETE OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5595 (class 2620 OID 5302881)
-- Name: specimens_relationships fct_cpy_trg_del_dict_specimens_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_specimens_relationships AFTER DELETE OR UPDATE ON darwin2.specimens_relationships FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5608 (class 2620 OID 5302882)
-- Name: tag_groups fct_cpy_trg_del_dict_tag_groups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_tag_groups AFTER DELETE OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5624 (class 2620 OID 5302883)
-- Name: users fct_cpy_trg_del_dict_users; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_users AFTER DELETE OR UPDATE ON darwin2.users FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5629 (class 2620 OID 5302884)
-- Name: users_addresses fct_cpy_trg_del_dict_users_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_del_dict_users_addresses AFTER DELETE OR UPDATE ON darwin2.users_addresses FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_del_dict();


--
-- TOC entry 5457 (class 2620 OID 5302885)
-- Name: codes fct_cpy_trg_ins_update_dict_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_codes AFTER INSERT OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5467 (class 2620 OID 5302886)
-- Name: collection_maintenance fct_cpy_trg_ins_update_dict_collection_maintenance; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_collection_maintenance AFTER INSERT OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5495 (class 2620 OID 5302887)
-- Name: identifications fct_cpy_trg_ins_update_dict_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_identifications AFTER INSERT OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5524 (class 2620 OID 5302888)
-- Name: insurances fct_cpy_trg_ins_update_dict_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_insurances AFTER INSERT OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5546 (class 2620 OID 5302889)
-- Name: loan_status fct_cpy_trg_ins_update_dict_loan_status; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_loan_status AFTER INSERT OR UPDATE ON darwin2.loan_status FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5554 (class 2620 OID 5302890)
-- Name: mineralogy fct_cpy_trg_ins_update_dict_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_mineralogy AFTER INSERT OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5567 (class 2620 OID 5302891)
-- Name: people fct_cpy_trg_ins_update_dict_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_people AFTER INSERT OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5573 (class 2620 OID 5302892)
-- Name: people_addresses fct_cpy_trg_ins_update_dict_people_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_people_addresses AFTER INSERT OR UPDATE ON darwin2.people_addresses FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5489 (class 2620 OID 5302893)
-- Name: properties fct_cpy_trg_ins_update_dict_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_properties AFTER INSERT OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5581 (class 2620 OID 5302894)
-- Name: specimens fct_cpy_trg_ins_update_dict_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_specimens AFTER INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5596 (class 2620 OID 5302895)
-- Name: specimens_relationships fct_cpy_trg_ins_update_dict_specimens_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_specimens_relationships AFTER INSERT OR UPDATE ON darwin2.specimens_relationships FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5609 (class 2620 OID 5302896)
-- Name: tag_groups fct_cpy_trg_ins_update_dict_tag_groups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_tag_groups AFTER INSERT OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5625 (class 2620 OID 5302897)
-- Name: users fct_cpy_trg_ins_update_dict_users; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_users AFTER INSERT OR UPDATE ON darwin2.users FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5630 (class 2620 OID 5302898)
-- Name: users_addresses fct_cpy_trg_ins_update_dict_users_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_cpy_trg_ins_update_dict_users_addresses AFTER INSERT OR UPDATE ON darwin2.users_addresses FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_ins_update_dict();


--
-- TOC entry 5517 (class 2620 OID 5302899)
-- Name: imports fct_trg_rmca_del_import_related; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_trg_rmca_del_import_related BEFORE DELETE OR UPDATE ON darwin2.imports FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_rmca_del_import_related();


--
-- TOC entry 5518 (class 2620 OID 5302900)
-- Name: imports fct_trg_rmca_import_taxonomy_history; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER fct_trg_rmca_import_taxonomy_history BEFORE INSERT OR UPDATE ON darwin2.imports FOR EACH ROW EXECUTE PROCEDURE darwin2.trg_rmca_import_taxonomy_history();


--
-- TOC entry 5549 (class 2620 OID 5302901)
-- Name: loans trg_add_status_history; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_add_status_history AFTER INSERT ON darwin2.loans FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_auto_insert_status_history();


--
-- TOC entry 5599 (class 2620 OID 5302902)
-- Name: staging_catalogue trg_catalogue_import_keywords_update; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_catalogue_import_keywords_update AFTER INSERT OR DELETE OR UPDATE ON darwin2.staging_catalogue FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_catalogue_import_keywords_update();


--
-- TOC entry 5432 (class 2620 OID 5302903)
-- Name: staging trg_catalogue_import_keywords_update; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_catalogue_import_keywords_update AFTER INSERT OR DELETE OR UPDATE ON darwin2.staging FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_catalogue_import_keywords_update();


--
-- TOC entry 5481 (class 2620 OID 5302904)
-- Name: collections_rights trg_chk_canupdatecollectionsrights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_canupdatecollectionsrights BEFORE UPDATE ON darwin2.collections_rights FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_canupdatecollectionsrights();


--
-- TOC entry 5520 (class 2620 OID 5302905)
-- Name: informative_workflow trg_chk_is_last_informative_workflow; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_is_last_informative_workflow BEFORE INSERT ON darwin2.informative_workflow FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_remove_last_flag();


--
-- TOC entry 5547 (class 2620 OID 5302906)
-- Name: loan_status trg_chk_is_last_loan_status; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_is_last_loan_status BEFORE INSERT ON darwin2.loan_status FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_remove_last_flag_loan();


--
-- TOC entry 5472 (class 2620 OID 5302907)
-- Name: collections trg_chk_parentcollinstitution; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_parentcollinstitution BEFORE INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_parentcollinstitution();


--
-- TOC entry 5568 (class 2620 OID 5302908)
-- Name: people trg_chk_peopletype; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_peopletype AFTER UPDATE ON darwin2.people FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_peopletype();


--
-- TOC entry 5444 (class 2620 OID 5302909)
-- Name: chronostratigraphy trg_chk_possible_upper_level_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_chronostratigraphy AFTER INSERT OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 5528 (class 2620 OID 5302910)
-- Name: lithology trg_chk_possible_upper_level_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_lithology AFTER INSERT OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 5535 (class 2620 OID 5302911)
-- Name: lithostratigraphy trg_chk_possible_upper_level_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_lithostratigraphy AFTER INSERT OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 5555 (class 2620 OID 5302912)
-- Name: mineralogy trg_chk_possible_upper_level_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_mineralogy AFTER INSERT OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 5611 (class 2620 OID 5302913)
-- Name: taxonomy trg_chk_possible_upper_level_taxonomy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_possible_upper_level_taxonomy AFTER INSERT OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trg_chk_possible_upper_level();


--
-- TOC entry 5458 (class 2620 OID 5302914)
-- Name: codes trg_chk_ref_record_catalogue_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_catalogue_codes AFTER INSERT OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5439 (class 2620 OID 5302915)
-- Name: catalogue_people trg_chk_ref_record_catalogue_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_catalogue_people AFTER INSERT OR UPDATE ON darwin2.catalogue_people FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5453 (class 2620 OID 5302916)
-- Name: classification_synonymies trg_chk_ref_record_classification_synonymies; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_classification_synonymies AFTER INSERT OR UPDATE ON darwin2.classification_synonymies FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5468 (class 2620 OID 5302917)
-- Name: collection_maintenance trg_chk_ref_record_collection_maintenance; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_collection_maintenance AFTER INSERT OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5485 (class 2620 OID 5302918)
-- Name: comments trg_chk_ref_record_comments; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_comments AFTER INSERT OR UPDATE ON darwin2.comments FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5505 (class 2620 OID 5302919)
-- Name: ext_links trg_chk_ref_record_ext_links; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_ext_links AFTER INSERT OR UPDATE ON darwin2.ext_links FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5496 (class 2620 OID 5302920)
-- Name: identifications trg_chk_ref_record_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_identifications AFTER INSERT OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5521 (class 2620 OID 5302921)
-- Name: informative_workflow trg_chk_ref_record_informative_workflow; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_informative_workflow AFTER INSERT OR UPDATE ON darwin2.informative_workflow FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5525 (class 2620 OID 5302922)
-- Name: insurances trg_chk_ref_record_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_insurances AFTER INSERT OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5493 (class 2620 OID 5302923)
-- Name: properties trg_chk_ref_record_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_properties AFTER INSERT OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5441 (class 2620 OID 5302924)
-- Name: catalogue_relationships trg_chk_ref_record_relationship_catalogue_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_relationship_catalogue_relationships AFTER INSERT OR UPDATE ON darwin2.catalogue_relationships FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecordrelationship();


--
-- TOC entry 5438 (class 2620 OID 5302925)
-- Name: template_table_record_ref trg_chk_ref_record_template_table_record_ref; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_ref_record_template_table_record_ref AFTER INSERT OR UPDATE ON darwin2.template_table_record_ref FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5631 (class 2620 OID 5302926)
-- Name: vernacular_names trg_chk_ref_record_vernacular_names; Type: TRIGGER; Schema: darwin2; Owner: postgres
--

CREATE TRIGGER trg_chk_ref_record_vernacular_names AFTER INSERT OR UPDATE ON darwin2.vernacular_names FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_referencedrecord();


--
-- TOC entry 5582 (class 2620 OID 5302927)
-- Name: specimens trg_chk_specimencollectionallowed; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_specimencollectionallowed BEFORE INSERT OR DELETE OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_specimencollectionallowed();


--
-- TOC entry 5583 (class 2620 OID 5302928)
-- Name: specimens trg_chk_specimens_not_loaned; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_specimens_not_loaned BEFORE DELETE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.chk_specimens_not_loaned();


--
-- TOC entry 5445 (class 2620 OID 5302929)
-- Name: chronostratigraphy trg_chk_upper_level_for_childrens_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_chronostratigraphy AFTER UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 5529 (class 2620 OID 5302930)
-- Name: lithology trg_chk_upper_level_for_childrens_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_lithology AFTER UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 5536 (class 2620 OID 5302931)
-- Name: lithostratigraphy trg_chk_upper_level_for_childrens_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_lithostratigraphy AFTER UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 5556 (class 2620 OID 5302932)
-- Name: mineralogy trg_chk_upper_level_for_childrens_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_mineralogy AFTER UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 5612 (class 2620 OID 5302933)
-- Name: taxonomy trg_chk_upper_level_for_childrens_taxonomy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_chk_upper_level_for_childrens_taxonomy AFTER UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_chk_upper_level_for_childrens();


--
-- TOC entry 5497 (class 2620 OID 5302934)
-- Name: identifications trg_clr_identifiers_in_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_identifiers_in_flat BEFORE DELETE ON darwin2.identifications FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_identifiers_in_flat();


--
-- TOC entry 5435 (class 2620 OID 5302935)
-- Name: bibliography trg_clr_referencerecord_bibliography; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_bibliography AFTER DELETE OR UPDATE ON darwin2.bibliography FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5446 (class 2620 OID 5302936)
-- Name: chronostratigraphy trg_clr_referencerecord_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_chronostratigraphy AFTER DELETE OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5469 (class 2620 OID 5302937)
-- Name: collection_maintenance trg_clr_referencerecord_collectionmaintenance; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_collectionmaintenance AFTER DELETE OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5473 (class 2620 OID 5302938)
-- Name: collections trg_clr_referencerecord_collections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_collections AFTER DELETE OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5501 (class 2620 OID 5302939)
-- Name: expeditions trg_clr_referencerecord_expeditions; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_expeditions AFTER DELETE OR UPDATE ON darwin2.expeditions FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5508 (class 2620 OID 5302940)
-- Name: gtu trg_clr_referencerecord_gtu; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_gtu AFTER DELETE OR UPDATE ON darwin2.gtu FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5498 (class 2620 OID 5302941)
-- Name: identifications trg_clr_referencerecord_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_identifications AFTER DELETE OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5513 (class 2620 OID 5302942)
-- Name: igs trg_clr_referencerecord_igs; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_igs AFTER DELETE OR UPDATE ON darwin2.igs FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5526 (class 2620 OID 5302943)
-- Name: insurances trg_clr_referencerecord_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_insurances AFTER DELETE OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5530 (class 2620 OID 5302944)
-- Name: lithology trg_clr_referencerecord_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_lithology AFTER DELETE OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5537 (class 2620 OID 5302945)
-- Name: lithostratigraphy trg_clr_referencerecord_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_lithostratigraphy AFTER DELETE OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5542 (class 2620 OID 5302946)
-- Name: loan_items trg_clr_referencerecord_loan_items; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_loan_items AFTER DELETE OR UPDATE ON darwin2.loan_items FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5550 (class 2620 OID 5302947)
-- Name: loans trg_clr_referencerecord_loans; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_loans AFTER DELETE OR UPDATE ON darwin2.loans FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5557 (class 2620 OID 5302948)
-- Name: mineralogy trg_clr_referencerecord_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_mineralogy AFTER DELETE OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5562 (class 2620 OID 5302949)
-- Name: multimedia trg_clr_referencerecord_multimedia; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_multimedia AFTER DELETE OR UPDATE ON darwin2.multimedia FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5569 (class 2620 OID 5302950)
-- Name: people trg_clr_referencerecord_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_people AFTER DELETE OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5584 (class 2620 OID 5302951)
-- Name: specimens trg_clr_referencerecord_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_specimens AFTER DELETE OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5597 (class 2620 OID 5302952)
-- Name: specimens_relationships trg_clr_referencerecord_specimens_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_specimens_relationships AFTER DELETE OR UPDATE ON darwin2.specimens_relationships FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5433 (class 2620 OID 5302953)
-- Name: staging trg_clr_referencerecord_staging; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_staging AFTER DELETE OR UPDATE ON darwin2.staging FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5601 (class 2620 OID 5302954)
-- Name: staging_info trg_clr_referencerecord_staging_info; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_staging_info AFTER DELETE OR UPDATE ON darwin2.staging_info FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5613 (class 2620 OID 5302955)
-- Name: taxonomy trg_clr_referencerecord_taxa; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_taxa AFTER DELETE OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5626 (class 2620 OID 5302956)
-- Name: users trg_clr_referencerecord_users; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_referencerecord_users AFTER DELETE OR UPDATE ON darwin2.users FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5632 (class 2620 OID 5302957)
-- Name: vernacular_names trg_clr_referencerecord_vernacularnames; Type: TRIGGER; Schema: darwin2; Owner: postgres
--

CREATE TRIGGER trg_clr_referencerecord_vernacularnames AFTER DELETE OR UPDATE ON darwin2.vernacular_names FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clear_referencedrecord();


--
-- TOC entry 5585 (class 2620 OID 5302958)
-- Name: specimens trg_clr_specialstatus_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_clr_specialstatus_specimens BEFORE INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_clr_specialstatus();


--
-- TOC entry 5563 (class 2620 OID 5302959)
-- Name: multimedia trg_cpy_deleted_file; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_deleted_file AFTER DELETE ON darwin2.multimedia FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_deleted_file();


--
-- TOC entry 5570 (class 2620 OID 5302960)
-- Name: people trg_cpy_formattedname; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_formattedname BEFORE INSERT OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_formattedname();


--
-- TOC entry 5627 (class 2620 OID 5302961)
-- Name: users trg_cpy_formattedname; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_formattedname BEFORE INSERT OR UPDATE ON darwin2.users FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_formattedname();


--
-- TOC entry 5436 (class 2620 OID 5302962)
-- Name: bibliography trg_cpy_fulltoindex_bibliography; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_bibliography BEFORE INSERT OR UPDATE ON darwin2.bibliography FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5447 (class 2620 OID 5302963)
-- Name: chronostratigraphy trg_cpy_fulltoindex_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_chronostratigraphy BEFORE INSERT OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5451 (class 2620 OID 5302964)
-- Name: classification_keywords trg_cpy_fulltoindex_classification_keywords; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_classification_keywords BEFORE INSERT OR UPDATE ON darwin2.classification_keywords FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5459 (class 2620 OID 5302965)
-- Name: codes trg_cpy_fulltoindex_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_codes BEFORE INSERT OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5462 (class 2620 OID 5302966)
-- Name: collecting_methods trg_cpy_fulltoindex_collecting_methods; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_collecting_methods BEFORE INSERT OR UPDATE ON darwin2.collecting_methods FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5464 (class 2620 OID 5302967)
-- Name: collecting_tools trg_cpy_fulltoindex_collecting_tools; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_collecting_tools BEFORE INSERT OR UPDATE ON darwin2.collecting_tools FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5474 (class 2620 OID 5302968)
-- Name: collections trg_cpy_fulltoindex_collection; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_collection BEFORE INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5486 (class 2620 OID 5302969)
-- Name: comments trg_cpy_fulltoindex_comments; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_comments BEFORE INSERT OR UPDATE ON darwin2.comments FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5502 (class 2620 OID 5302970)
-- Name: expeditions trg_cpy_fulltoindex_expeditions; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_expeditions BEFORE INSERT OR UPDATE ON darwin2.expeditions FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5506 (class 2620 OID 5302971)
-- Name: ext_links trg_cpy_fulltoindex_ext_links; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_ext_links BEFORE INSERT OR UPDATE ON darwin2.ext_links FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5499 (class 2620 OID 5302972)
-- Name: identifications trg_cpy_fulltoindex_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_identifications BEFORE INSERT OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5514 (class 2620 OID 5302973)
-- Name: igs trg_cpy_fulltoindex_igs; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_igs BEFORE INSERT OR UPDATE ON darwin2.igs FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5531 (class 2620 OID 5302974)
-- Name: lithology trg_cpy_fulltoindex_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_lithology BEFORE INSERT OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5538 (class 2620 OID 5302975)
-- Name: lithostratigraphy trg_cpy_fulltoindex_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_lithostratigraphy BEFORE INSERT OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5551 (class 2620 OID 5302976)
-- Name: loans trg_cpy_fulltoindex_loans; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_loans BEFORE INSERT OR UPDATE ON darwin2.loans FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5558 (class 2620 OID 5302977)
-- Name: mineralogy trg_cpy_fulltoindex_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_mineralogy BEFORE INSERT OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5564 (class 2620 OID 5302978)
-- Name: multimedia trg_cpy_fulltoindex_multimedia; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_multimedia BEFORE INSERT OR UPDATE ON darwin2.multimedia FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5490 (class 2620 OID 5302979)
-- Name: properties trg_cpy_fulltoindex_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_properties BEFORE INSERT OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5586 (class 2620 OID 5302980)
-- Name: specimens trg_cpy_fulltoindex_s; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_s BEFORE INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5587 (class 2620 OID 5302981)
-- Name: specimens trg_cpy_fulltoindex_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_specimens BEFORE INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5610 (class 2620 OID 5302982)
-- Name: tag_groups trg_cpy_fulltoindex_taggroups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_taggroups BEFORE INSERT OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5614 (class 2620 OID 5302983)
-- Name: taxonomy trg_cpy_fulltoindex_taxa; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_fulltoindex_taxa BEFORE INSERT OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5633 (class 2620 OID 5302984)
-- Name: vernacular_names trg_cpy_fulltoindex_vernacularnames; Type: TRIGGER; Schema: darwin2; Owner: postgres
--

CREATE TRIGGER trg_cpy_fulltoindex_vernacularnames BEFORE INSERT OR UPDATE ON darwin2.vernacular_names FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_fulltoindex();


--
-- TOC entry 5605 (class 2620 OID 5302985)
-- Name: tag_groups trg_cpy_gtutags_taggroups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_gtutags_taggroups AFTER INSERT OR DELETE OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_gtutags();


--
-- TOC entry 5588 (class 2620 OID 5302986)
-- Name: specimens trg_cpy_ig_to_loan_items; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_ig_to_loan_items AFTER UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_ig_to_loan_items();


--
-- TOC entry 5509 (class 2620 OID 5302987)
-- Name: gtu trg_cpy_location; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_location BEFORE INSERT OR UPDATE ON darwin2.gtu FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_location();


--
-- TOC entry 5448 (class 2620 OID 5302988)
-- Name: chronostratigraphy trg_cpy_path_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_chronostratigraphy BEFORE INSERT OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 5475 (class 2620 OID 5302989)
-- Name: collections trg_cpy_path_collections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_collections BEFORE INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_path();


--
-- TOC entry 5532 (class 2620 OID 5302990)
-- Name: lithology trg_cpy_path_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_lithology BEFORE INSERT OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 5539 (class 2620 OID 5302991)
-- Name: lithostratigraphy trg_cpy_path_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_lithostratigraphy BEFORE INSERT OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 5559 (class 2620 OID 5302992)
-- Name: mineralogy trg_cpy_path_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_mineralogy BEFORE INSERT OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 5576 (class 2620 OID 5302993)
-- Name: people_relationships trg_cpy_path_peoplerelationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_peoplerelationships BEFORE INSERT OR UPDATE ON darwin2.people_relationships FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_path();


--
-- TOC entry 5615 (class 2620 OID 5302994)
-- Name: taxonomy trg_cpy_path_taxonomy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_path_taxonomy BEFORE INSERT OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_path_catalogs();


--
-- TOC entry 5604 (class 2620 OID 5308611)
-- Name: tag_groups trg_cpy_tags_to_distinct_bedic; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_tags_to_distinct_bedic AFTER INSERT OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_tags_to_distinct_bedic();


--
-- TOC entry 5491 (class 2620 OID 5302995)
-- Name: properties trg_cpy_unified_values; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_unified_values BEFORE INSERT OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_unified_values();


--
-- TOC entry 5476 (class 2620 OID 5302996)
-- Name: collections trg_cpy_updatecollectionrights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updatecollectionrights AFTER INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_updatecollectionrights();


--
-- TOC entry 5477 (class 2620 OID 5302997)
-- Name: collections trg_cpy_updatecollinstitutioncascade; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updatecollinstitutioncascade AFTER UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_updatecollinstitutioncascade();


--
-- TOC entry 5482 (class 2620 OID 5302998)
-- Name: collections_rights trg_cpy_updatemywidgetscollrights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updatemywidgetscollrights AFTER DELETE OR UPDATE ON darwin2.collections_rights FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_updatemywidgetscoll();


--
-- TOC entry 5483 (class 2620 OID 5302999)
-- Name: collections_rights trg_cpy_updateuserrights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updateuserrights AFTER INSERT OR DELETE OR UPDATE ON darwin2.collections_rights FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_updateuserrights();


--
-- TOC entry 5478 (class 2620 OID 5303000)
-- Name: collections trg_cpy_updateuserrightscollections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_cpy_updateuserrightscollections AFTER INSERT OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_cpy_updateuserrights();


--
-- TOC entry 5616 (class 2620 OID 5303001)
-- Name: taxonomy trg_fct_rmca_chk_is_already_reference_taxo; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_chk_is_already_reference_taxo BEFORE INSERT OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_rmca_chk_is_already_reference_taxo();


--
-- TOC entry 5622 (class 2620 OID 5309161)
-- Name: taxonomy_metadata trg_fct_rmca_chk_only_one_reference_taxo; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_chk_only_one_reference_taxo BEFORE INSERT OR UPDATE ON darwin2.taxonomy_metadata FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_rmca_chk_uniqueness_reference_taxo();


--
-- TOC entry 5623 (class 2620 OID 5309163)
-- Name: taxonomy_metadata trg_fct_rmca_chk_uniqueness_reference_taxo; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_chk_uniqueness_reference_taxo BEFORE INSERT OR UPDATE ON darwin2.taxonomy_metadata FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_rmca_chk_uniqueness_reference_taxo();


--
-- TOC entry 5600 (class 2620 OID 5308234)
-- Name: staging_catalogue trg_fct_rmca_keep_staging_catalogue_parent; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_keep_staging_catalogue_parent BEFORE INSERT OR UPDATE ON darwin2.staging_catalogue FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_rmca_keep_staging_catalogue_parent();


--
-- TOC entry 5617 (class 2620 OID 5303004)
-- Name: taxonomy trg_fct_rmca_update_child_of_taxon_protected; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_update_child_of_taxon_protected BEFORE UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_rmca_update_child_of_taxon_protected();


--
-- TOC entry 5620 (class 2620 OID 5303005)
-- Name: taxonomy_metadata trg_fct_rmca_update_reference_taxo; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_fct_rmca_update_reference_taxo AFTER UPDATE ON darwin2.taxonomy_metadata FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_rmca_update_reference_taxo();


--
-- TOC entry 5460 (class 2620 OID 5303006)
-- Name: codes trg_insert_auto_code; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_insert_auto_code AFTER INSERT OR DELETE OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE PROCEDURE darwin2.check_auto_increment_code_in_spec();


--
-- TOC entry 5442 (class 2620 OID 5303007)
-- Name: catalogue_relationships trg_nbr_in_relation; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_nbr_in_relation BEFORE INSERT OR UPDATE ON darwin2.catalogue_relationships FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_nbr_in_relation();


--
-- TOC entry 5454 (class 2620 OID 5303008)
-- Name: classification_synonymies trg_nbr_in_synonym; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_nbr_in_synonym AFTER INSERT OR UPDATE ON darwin2.classification_synonymies FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_nbr_in_synonym();


--
-- TOC entry 5522 (class 2620 OID 5303009)
-- Name: informative_workflow trg_reset_last_flag_informative_workflow; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_reset_last_flag_informative_workflow AFTER DELETE ON darwin2.informative_workflow FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_informative_reset_last_flag();


--
-- TOC entry 5512 (class 2620 OID 5304958)
-- Name: gtu trg_rmca_fct_clear_gtu_date; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_fct_clear_gtu_date BEFORE DELETE ON darwin2.gtu FOR EACH ROW EXECUTE PROCEDURE darwin2.rmca_fct_clear_gtu_date();


--
-- TOC entry 5594 (class 2620 OID 5304962)
-- Name: specimens trg_rmca_fct_clear_specimen_date; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_fct_clear_specimen_date BEFORE DELETE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.rmca_fct_clear_specimen_date();


--
-- TOC entry 5593 (class 2620 OID 5304960)
-- Name: specimens trg_rmca_fct_update_specimen_date; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_fct_update_specimen_date AFTER INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.rmca_fct_update_specimen_date();


--
-- TOC entry 5621 (class 2620 OID 5303010)
-- Name: taxonomy_metadata trg_rmca_trk_log_table_taxonomy_metadata; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_rmca_trk_log_table_taxonomy_metadata AFTER INSERT OR DELETE OR UPDATE ON darwin2.taxonomy_metadata FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5437 (class 2620 OID 5303011)
-- Name: bibliography trg_trk_log_table_bibliography; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_bibliography AFTER INSERT OR DELETE OR UPDATE ON darwin2.bibliography FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5443 (class 2620 OID 5303012)
-- Name: catalogue_relationships trg_trk_log_table_catalogue_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_catalogue_relationships AFTER INSERT OR DELETE OR UPDATE ON darwin2.catalogue_relationships FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5449 (class 2620 OID 5303013)
-- Name: chronostratigraphy trg_trk_log_table_chronostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_chronostratigraphy AFTER INSERT OR DELETE OR UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5452 (class 2620 OID 5303014)
-- Name: classification_keywords trg_trk_log_table_classification_keywords; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_classification_keywords AFTER INSERT OR DELETE OR UPDATE ON darwin2.classification_keywords FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5455 (class 2620 OID 5303015)
-- Name: classification_synonymies trg_trk_log_table_classification_synonymies; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_classification_synonymies AFTER INSERT OR DELETE OR UPDATE ON darwin2.classification_synonymies FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5461 (class 2620 OID 5303016)
-- Name: codes trg_trk_log_table_codes; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_codes AFTER INSERT OR DELETE OR UPDATE ON darwin2.codes FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5463 (class 2620 OID 5303017)
-- Name: collecting_methods trg_trk_log_table_collecting_methods; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collecting_methods AFTER INSERT OR DELETE OR UPDATE ON darwin2.collecting_methods FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5465 (class 2620 OID 5303018)
-- Name: collecting_tools trg_trk_log_table_collecting_tools; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collecting_tools AFTER INSERT OR DELETE OR UPDATE ON darwin2.collecting_tools FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5470 (class 2620 OID 5303019)
-- Name: collection_maintenance trg_trk_log_table_collection_maintenance; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collection_maintenance AFTER INSERT OR DELETE OR UPDATE ON darwin2.collection_maintenance FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5479 (class 2620 OID 5303020)
-- Name: collections trg_trk_log_table_collections; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collections AFTER INSERT OR DELETE OR UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5484 (class 2620 OID 5303021)
-- Name: collections_rights trg_trk_log_table_collections_rights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_collections_rights AFTER INSERT OR DELETE OR UPDATE ON darwin2.collections_rights FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5487 (class 2620 OID 5303022)
-- Name: comments trg_trk_log_table_comments; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_comments AFTER INSERT OR DELETE OR UPDATE ON darwin2.comments FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5503 (class 2620 OID 5303023)
-- Name: expeditions trg_trk_log_table_expeditions; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_expeditions AFTER INSERT OR DELETE OR UPDATE ON darwin2.expeditions FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5507 (class 2620 OID 5303024)
-- Name: ext_links trg_trk_log_table_ext_links; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_ext_links AFTER INSERT OR DELETE OR UPDATE ON darwin2.ext_links FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5510 (class 2620 OID 5303025)
-- Name: gtu trg_trk_log_table_gtu; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_gtu AFTER INSERT OR DELETE OR UPDATE ON darwin2.gtu FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5500 (class 2620 OID 5303026)
-- Name: identifications trg_trk_log_table_identifications; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_identifications AFTER INSERT OR DELETE OR UPDATE ON darwin2.identifications FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5515 (class 2620 OID 5303027)
-- Name: igs trg_trk_log_table_igs; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_igs AFTER INSERT OR DELETE OR UPDATE ON darwin2.igs FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5527 (class 2620 OID 5303028)
-- Name: insurances trg_trk_log_table_insurances; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_insurances AFTER INSERT OR DELETE OR UPDATE ON darwin2.insurances FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5533 (class 2620 OID 5303029)
-- Name: lithology trg_trk_log_table_lithology; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_lithology AFTER INSERT OR DELETE OR UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5540 (class 2620 OID 5303030)
-- Name: lithostratigraphy trg_trk_log_table_lithostratigraphy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_lithostratigraphy AFTER INSERT OR DELETE OR UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5543 (class 2620 OID 5303031)
-- Name: loan_items trg_trk_log_table_loan_items; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_loan_items AFTER INSERT OR DELETE OR UPDATE ON darwin2.loan_items FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5544 (class 2620 OID 5303032)
-- Name: loan_rights trg_trk_log_table_loan_rights; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_loan_rights AFTER INSERT OR DELETE OR UPDATE ON darwin2.loan_rights FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5548 (class 2620 OID 5303033)
-- Name: loan_status trg_trk_log_table_loan_status; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_loan_status AFTER INSERT OR DELETE OR UPDATE ON darwin2.loan_status FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5552 (class 2620 OID 5303034)
-- Name: loans trg_trk_log_table_loans; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_loans AFTER INSERT OR DELETE OR UPDATE ON darwin2.loans FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5560 (class 2620 OID 5303035)
-- Name: mineralogy trg_trk_log_table_mineralogy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_mineralogy AFTER INSERT OR DELETE OR UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5565 (class 2620 OID 5303036)
-- Name: multimedia trg_trk_log_table_multimedia; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_multimedia AFTER INSERT OR DELETE OR UPDATE ON darwin2.multimedia FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5571 (class 2620 OID 5303037)
-- Name: people trg_trk_log_table_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_people AFTER INSERT OR DELETE OR UPDATE ON darwin2.people FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5574 (class 2620 OID 5303038)
-- Name: people_addresses trg_trk_log_table_people_addresses; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_people_addresses AFTER INSERT OR DELETE OR UPDATE ON darwin2.people_addresses FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5575 (class 2620 OID 5303039)
-- Name: people_comm trg_trk_log_table_people_comm; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_people_comm AFTER INSERT OR DELETE OR UPDATE ON darwin2.people_comm FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5577 (class 2620 OID 5303040)
-- Name: people_relationships trg_trk_log_table_people_relationships; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_people_relationships AFTER INSERT OR DELETE OR UPDATE ON darwin2.people_relationships FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5492 (class 2620 OID 5303041)
-- Name: properties trg_trk_log_table_properties; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_properties AFTER INSERT OR DELETE OR UPDATE ON darwin2.properties FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5578 (class 2620 OID 5303042)
-- Name: specimen_collecting_methods trg_trk_log_table_specimen_collecting_methods; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_specimen_collecting_methods AFTER INSERT OR DELETE OR UPDATE ON darwin2.specimen_collecting_methods FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5579 (class 2620 OID 5303043)
-- Name: specimen_collecting_tools trg_trk_log_table_specimen_collecting_tools; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_specimen_collecting_tools AFTER INSERT OR DELETE OR UPDATE ON darwin2.specimen_collecting_tools FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5589 (class 2620 OID 5303044)
-- Name: specimens trg_trk_log_table_specimens; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_specimens AFTER INSERT OR DELETE OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5598 (class 2620 OID 5303045)
-- Name: specimens_relationships trg_trk_log_table_specimens_relationship; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_specimens_relationship AFTER INSERT OR DELETE OR UPDATE ON darwin2.specimens_relationships FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5606 (class 2620 OID 5303046)
-- Name: tag_groups trg_trk_log_table_tag_groups; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_tag_groups AFTER INSERT OR DELETE OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5618 (class 2620 OID 5303047)
-- Name: taxonomy trg_trk_log_table_taxonomy; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_trk_log_table_taxonomy AFTER INSERT OR DELETE OR UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5634 (class 2620 OID 5303048)
-- Name: vernacular_names trg_trk_log_table_vernacular_names; Type: TRIGGER; Schema: darwin2; Owner: postgres
--

CREATE TRIGGER trg_trk_log_table_vernacular_names AFTER INSERT OR DELETE OR UPDATE ON darwin2.vernacular_names FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_trk_log_table();


--
-- TOC entry 5628 (class 2620 OID 5303049)
-- Name: users trg_unpromotion_remove_cols; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_unpromotion_remove_cols AFTER UPDATE ON darwin2.users FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_unpromotion_impact_prefs();


--
-- TOC entry 5434 (class 2620 OID 5303050)
-- Name: staging trg_upd_fields_staging; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_upd_fields_staging AFTER UPDATE ON darwin2.staging FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_upd_staging_fields();


--
-- TOC entry 5603 (class 2620 OID 5303051)
-- Name: staging_relationship trg_upd_institution_staging_relationship; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_upd_institution_staging_relationship AFTER UPDATE ON darwin2.staging_relationship FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_upd_institution_staging_relationship();


--
-- TOC entry 5440 (class 2620 OID 5303052)
-- Name: catalogue_people trg_upd_people_in_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_upd_people_in_flat AFTER INSERT OR DELETE OR UPDATE ON darwin2.catalogue_people FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_upd_people_in_flat();


--
-- TOC entry 5602 (class 2620 OID 5303053)
-- Name: staging_people trg_upd_people_ref_staging_people; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_upd_people_ref_staging_people AFTER UPDATE ON darwin2.staging_people FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_upd_people_staging_fields();


--
-- TOC entry 5450 (class 2620 OID 5303054)
-- Name: chronostratigraphy trg_update_chronostratigraphy_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_chronostratigraphy_darwin_flat AFTER UPDATE ON darwin2.chronostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5590 (class 2620 OID 5303055)
-- Name: specimens trg_update_collections_code_last_val; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_collections_code_last_val AFTER UPDATE OF collection_ref ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.update_collections_code_last_val();


--
-- TOC entry 5591 (class 2620 OID 5303056)
-- Name: specimens trg_update_collections_code_last_val_after_spec_del; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_collections_code_last_val_after_spec_del AFTER DELETE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.update_collections_code_last_val_after_spec_del();


--
-- TOC entry 5480 (class 2620 OID 5303057)
-- Name: collections trg_update_collections_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_collections_darwin_flat AFTER UPDATE ON darwin2.collections FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5504 (class 2620 OID 5303058)
-- Name: expeditions trg_update_expeditions_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_expeditions_darwin_flat AFTER UPDATE ON darwin2.expeditions FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5511 (class 2620 OID 5303059)
-- Name: gtu trg_update_gtu_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_gtu_darwin_flat AFTER UPDATE ON darwin2.gtu FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5516 (class 2620 OID 5303060)
-- Name: igs trg_update_igs_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_igs_darwin_flat AFTER UPDATE ON darwin2.igs FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5519 (class 2620 OID 5303061)
-- Name: imports trg_update_import; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_import AFTER UPDATE ON darwin2.imports FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_import();


--
-- TOC entry 5534 (class 2620 OID 5303062)
-- Name: lithology trg_update_lithology_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_lithology_darwin_flat AFTER UPDATE ON darwin2.lithology FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5541 (class 2620 OID 5303063)
-- Name: lithostratigraphy trg_update_lithostratigraphy_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_lithostratigraphy_darwin_flat AFTER UPDATE ON darwin2.lithostratigraphy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5561 (class 2620 OID 5303064)
-- Name: mineralogy trg_update_mineralogy_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_mineralogy_darwin_flat AFTER UPDATE ON darwin2.mineralogy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5592 (class 2620 OID 5303065)
-- Name: specimens trg_update_specimens_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_specimens_darwin_flat BEFORE INSERT OR UPDATE ON darwin2.specimens FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimen_flat();


--
-- TOC entry 5607 (class 2620 OID 5303066)
-- Name: tag_groups trg_update_tag_groups_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_tag_groups_darwin_flat AFTER INSERT OR DELETE OR UPDATE ON darwin2.tag_groups FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5619 (class 2620 OID 5303067)
-- Name: taxonomy trg_update_taxonomy_darwin_flat; Type: TRIGGER; Schema: darwin2; Owner: darwin2
--

CREATE TRIGGER trg_update_taxonomy_darwin_flat AFTER UPDATE ON darwin2.taxonomy FOR EACH ROW EXECUTE PROCEDURE darwin2.fct_update_specimens_flat_related();


--
-- TOC entry 5425 (class 2606 OID 5304947)
-- Name: temporal_information dates_gtu_ref_fkey; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.temporal_information
    ADD CONSTRAINT dates_gtu_ref_fkey FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id);


--
-- TOC entry 5424 (class 2606 OID 5304952)
-- Name: temporal_information dates_specimen_ref_fkey; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.temporal_information
    ADD CONSTRAINT dates_specimen_ref_fkey FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id);


--
-- TOC entry 5428 (class 2606 OID 5308605)
-- Name: tag_tag_authority fk_authority; Type: FK CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.tag_tag_authority
    ADD CONSTRAINT fk_authority FOREIGN KEY (tag_authority_ref) REFERENCES darwin2.tag_authority(id);


--
-- TOC entry 5427 (class 2606 OID 5308588)
-- Name: tag_authority fk_authority_domain; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_authority
    ADD CONSTRAINT fk_authority_domain FOREIGN KEY (domain_ref) REFERENCES darwin2.authority_domain(id);


--
-- TOC entry 5339 (class 2606 OID 5303068)
-- Name: catalogue_bibliography fk_bibliography; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_bibliography
    ADD CONSTRAINT fk_bibliography FOREIGN KEY (bibliography_ref) REFERENCES darwin2.bibliography(id) ON DELETE CASCADE;


--
-- TOC entry 5341 (class 2606 OID 5303073)
-- Name: chronostratigraphy fk_chronostratigraphy_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy
    ADD CONSTRAINT fk_chronostratigraphy_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 5342 (class 2606 OID 5303078)
-- Name: chronostratigraphy fk_chronostratigraphy_parent_ref_chronostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.chronostratigraphy
    ADD CONSTRAINT fk_chronostratigraphy_parent_ref_chronostratigraphy FOREIGN KEY (parent_ref) REFERENCES darwin2.chronostratigraphy(id) ON DELETE CASCADE;


--
-- TOC entry 5343 (class 2606 OID 5303083)
-- Name: collection_maintenance fk_collection_maintenance_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collection_maintenance
    ADD CONSTRAINT fk_collection_maintenance_users FOREIGN KEY (people_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 5344 (class 2606 OID 5303088)
-- Name: collections fk_collections_collections; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT fk_collections_collections FOREIGN KEY (parent_ref) REFERENCES darwin2.collections(id) ON DELETE CASCADE;


--
-- TOC entry 5345 (class 2606 OID 5303093)
-- Name: collections fk_collections_institutions; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT fk_collections_institutions FOREIGN KEY (institution_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 5348 (class 2606 OID 5303098)
-- Name: collections_rights fk_collections_rights_collections; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections_rights
    ADD CONSTRAINT fk_collections_rights_collections FOREIGN KEY (collection_ref) REFERENCES darwin2.collections(id) ON DELETE CASCADE;


--
-- TOC entry 5349 (class 2606 OID 5303103)
-- Name: collections_rights fk_collections_rights_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections_rights
    ADD CONSTRAINT fk_collections_rights_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5346 (class 2606 OID 5303108)
-- Name: collections fk_collections_staff; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT fk_collections_staff FOREIGN KEY (staff_ref) REFERENCES darwin2.users(id) ON DELETE SET NULL;


--
-- TOC entry 5347 (class 2606 OID 5303113)
-- Name: collections fk_collections_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.collections
    ADD CONSTRAINT fk_collections_users FOREIGN KEY (main_manager_ref) REFERENCES darwin2.users(id);


--
-- TOC entry 5350 (class 2606 OID 5303118)
-- Name: imports fk_imports_collections; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.imports
    ADD CONSTRAINT fk_imports_collections FOREIGN KEY (collection_ref) REFERENCES darwin2.collections(id) ON DELETE CASCADE;


--
-- TOC entry 5351 (class 2606 OID 5303123)
-- Name: imports fk_imports_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.imports
    ADD CONSTRAINT fk_imports_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5352 (class 2606 OID 5303128)
-- Name: informative_workflow fk_informative_workflow_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.informative_workflow
    ADD CONSTRAINT fk_informative_workflow_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5355 (class 2606 OID 5303133)
-- Name: lithology fk_lithology_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology
    ADD CONSTRAINT fk_lithology_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 5356 (class 2606 OID 5303138)
-- Name: lithology fk_lithology_parent_ref_lithology; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithology
    ADD CONSTRAINT fk_lithology_parent_ref_lithology FOREIGN KEY (parent_ref) REFERENCES darwin2.lithology(id) ON DELETE CASCADE;


--
-- TOC entry 5357 (class 2606 OID 5303143)
-- Name: lithostratigraphy fk_lithostratigraphy_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy
    ADD CONSTRAINT fk_lithostratigraphy_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 5358 (class 2606 OID 5303148)
-- Name: lithostratigraphy fk_lithostratigraphy_parent_ref_lithostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.lithostratigraphy
    ADD CONSTRAINT fk_lithostratigraphy_parent_ref_lithostratigraphy FOREIGN KEY (parent_ref) REFERENCES darwin2.lithostratigraphy(id) ON DELETE CASCADE;


--
-- TOC entry 5359 (class 2606 OID 5303153)
-- Name: loan_history fk_loan_history_loan_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_history
    ADD CONSTRAINT fk_loan_history_loan_ref FOREIGN KEY (loan_ref) REFERENCES darwin2.loans(id) ON DELETE CASCADE;


--
-- TOC entry 5360 (class 2606 OID 5303158)
-- Name: loan_items fk_loan_items_ig; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT fk_loan_items_ig FOREIGN KEY (ig_ref) REFERENCES darwin2.igs(id);


--
-- TOC entry 5361 (class 2606 OID 5303163)
-- Name: loan_items fk_loan_items_loan_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT fk_loan_items_loan_ref FOREIGN KEY (loan_ref) REFERENCES darwin2.loans(id) ON DELETE CASCADE;


--
-- TOC entry 5362 (class 2606 OID 5303168)
-- Name: loan_items fk_loan_items_specimen_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_items
    ADD CONSTRAINT fk_loan_items_specimen_ref FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id) ON DELETE SET NULL;


--
-- TOC entry 5363 (class 2606 OID 5303173)
-- Name: loan_rights fk_loan_rights_loan_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_rights
    ADD CONSTRAINT fk_loan_rights_loan_ref FOREIGN KEY (loan_ref) REFERENCES darwin2.loans(id) ON DELETE CASCADE;


--
-- TOC entry 5364 (class 2606 OID 5303178)
-- Name: loan_rights fk_loan_rights_user_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_rights
    ADD CONSTRAINT fk_loan_rights_user_ref FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5365 (class 2606 OID 5303183)
-- Name: loan_status fk_loan_status_loan_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_status
    ADD CONSTRAINT fk_loan_status_loan_ref FOREIGN KEY (loan_ref) REFERENCES darwin2.loans(id) ON DELETE CASCADE;


--
-- TOC entry 5366 (class 2606 OID 5303188)
-- Name: loan_status fk_loan_status_user_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.loan_status
    ADD CONSTRAINT fk_loan_status_user_ref FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5367 (class 2606 OID 5303193)
-- Name: mineralogy fk_mineralogy_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy
    ADD CONSTRAINT fk_mineralogy_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 5368 (class 2606 OID 5303198)
-- Name: mineralogy fk_mineralogy_parent_ref_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.mineralogy
    ADD CONSTRAINT fk_mineralogy_parent_ref_mineralogy FOREIGN KEY (parent_ref) REFERENCES darwin2.mineralogy(id) ON DELETE CASCADE;


--
-- TOC entry 5369 (class 2606 OID 5303203)
-- Name: my_saved_searches fk_my_saved_searches_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_saved_searches
    ADD CONSTRAINT fk_my_saved_searches_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5370 (class 2606 OID 5303208)
-- Name: my_widgets fk_my_widgets_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.my_widgets
    ADD CONSTRAINT fk_my_widgets_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5371 (class 2606 OID 5303213)
-- Name: people_addresses fk_people_addresses_people; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_addresses
    ADD CONSTRAINT fk_people_addresses_people FOREIGN KEY (person_user_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 5372 (class 2606 OID 5303218)
-- Name: people_comm fk_people_comm_people; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_comm
    ADD CONSTRAINT fk_people_comm_people FOREIGN KEY (person_user_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 5373 (class 2606 OID 5303223)
-- Name: people_languages fk_people_languages_people; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_languages
    ADD CONSTRAINT fk_people_languages_people FOREIGN KEY (people_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 5340 (class 2606 OID 5303228)
-- Name: catalogue_people fk_people_list_person; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.catalogue_people
    ADD CONSTRAINT fk_people_list_person FOREIGN KEY (people_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 5374 (class 2606 OID 5303233)
-- Name: people_relationships fk_people_relationships_people_01; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_relationships
    ADD CONSTRAINT fk_people_relationships_people_01 FOREIGN KEY (person_1_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 5375 (class 2606 OID 5303238)
-- Name: people_relationships fk_people_relationships_people_02; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.people_relationships
    ADD CONSTRAINT fk_people_relationships_people_02 FOREIGN KEY (person_2_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 5376 (class 2606 OID 5303243)
-- Name: possible_upper_levels fk_possible_upper_levels_catalogue_levels_01; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.possible_upper_levels
    ADD CONSTRAINT fk_possible_upper_levels_catalogue_levels_01 FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id) ON DELETE CASCADE;


--
-- TOC entry 5377 (class 2606 OID 5303248)
-- Name: possible_upper_levels fk_possible_upper_levels_catalogue_levels_02; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.possible_upper_levels
    ADD CONSTRAINT fk_possible_upper_levels_catalogue_levels_02 FOREIGN KEY (level_upper_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 5408 (class 2606 OID 5303253)
-- Name: staging_relationship fk_record_id; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT fk_record_id FOREIGN KEY (record_id) REFERENCES darwin2.staging(id) ON DELETE CASCADE;


--
-- TOC entry 5379 (class 2606 OID 5303258)
-- Name: reports fk_reports_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.reports
    ADD CONSTRAINT fk_reports_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5380 (class 2606 OID 5303263)
-- Name: specimen_collecting_methods fk_specimen_collecting_methods_method; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_methods
    ADD CONSTRAINT fk_specimen_collecting_methods_method FOREIGN KEY (collecting_method_ref) REFERENCES darwin2.collecting_methods(id) ON DELETE CASCADE;


--
-- TOC entry 5381 (class 2606 OID 5303268)
-- Name: specimen_collecting_methods fk_specimen_collecting_methods_specimen; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_methods
    ADD CONSTRAINT fk_specimen_collecting_methods_specimen FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id) ON DELETE CASCADE;


--
-- TOC entry 5382 (class 2606 OID 5303273)
-- Name: specimen_collecting_tools fk_specimen_collecting_tools_specimen; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_tools
    ADD CONSTRAINT fk_specimen_collecting_tools_specimen FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id) ON DELETE CASCADE;


--
-- TOC entry 5383 (class 2606 OID 5303278)
-- Name: specimen_collecting_tools fk_specimen_collecting_tools_tool; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimen_collecting_tools
    ADD CONSTRAINT fk_specimen_collecting_tools_tool FOREIGN KEY (collecting_tool_ref) REFERENCES darwin2.collecting_tools(id) ON DELETE CASCADE;


--
-- TOC entry 5384 (class 2606 OID 5303283)
-- Name: specimens fk_specimen_institutions; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimen_institutions FOREIGN KEY (institution_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 5353 (class 2606 OID 5303288)
-- Name: insurances fk_specimen_parts_insurances_contact; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.insurances
    ADD CONSTRAINT fk_specimen_parts_insurances_contact FOREIGN KEY (contact_ref) REFERENCES darwin2.people(id) ON DELETE SET NULL;


--
-- TOC entry 5354 (class 2606 OID 5303293)
-- Name: insurances fk_specimen_parts_insurances_people; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.insurances
    ADD CONSTRAINT fk_specimen_parts_insurances_people FOREIGN KEY (insurer_ref) REFERENCES darwin2.people(id) ON DELETE SET NULL;


--
-- TOC entry 5385 (class 2606 OID 5303298)
-- Name: specimens fk_specimens_chronostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_chronostratigraphy FOREIGN KEY (chrono_ref) REFERENCES darwin2.chronostratigraphy(id);


--
-- TOC entry 5386 (class 2606 OID 5303303)
-- Name: specimens fk_specimens_collections; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_collections FOREIGN KEY (collection_ref) REFERENCES darwin2.collections(id);


--
-- TOC entry 5387 (class 2606 OID 5303308)
-- Name: specimens fk_specimens_expeditions; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_expeditions FOREIGN KEY (expedition_ref) REFERENCES darwin2.expeditions(id);


--
-- TOC entry 5388 (class 2606 OID 5303313)
-- Name: specimens fk_specimens_gtu; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_gtu FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id);


--
-- TOC entry 5389 (class 2606 OID 5303318)
-- Name: specimens fk_specimens_igs; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_igs FOREIGN KEY (ig_ref) REFERENCES darwin2.igs(id);


--
-- TOC entry 5390 (class 2606 OID 5303323)
-- Name: specimens fk_specimens_lithology; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_lithology FOREIGN KEY (lithology_ref) REFERENCES darwin2.lithology(id);


--
-- TOC entry 5391 (class 2606 OID 5303328)
-- Name: specimens fk_specimens_lithostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_lithostratigraphy FOREIGN KEY (litho_ref) REFERENCES darwin2.lithostratigraphy(id);


--
-- TOC entry 5392 (class 2606 OID 5303333)
-- Name: specimens fk_specimens_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_mineralogy FOREIGN KEY (mineral_ref) REFERENCES darwin2.mineralogy(id);


--
-- TOC entry 5394 (class 2606 OID 5303338)
-- Name: specimens_relationships fk_specimens_relationships_institution; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_institution FOREIGN KEY (institution_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 5409 (class 2606 OID 5303343)
-- Name: staging_relationship fk_specimens_relationships_institution; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT fk_specimens_relationships_institution FOREIGN KEY (institution_ref) REFERENCES darwin2.people(id);


--
-- TOC entry 5395 (class 2606 OID 5303348)
-- Name: specimens_relationships fk_specimens_relationships_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_mineralogy FOREIGN KEY (mineral_ref) REFERENCES darwin2.mineralogy(id);


--
-- TOC entry 5410 (class 2606 OID 5303353)
-- Name: staging_relationship fk_specimens_relationships_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT fk_specimens_relationships_mineralogy FOREIGN KEY (mineral_ref) REFERENCES darwin2.mineralogy(id);


--
-- TOC entry 5396 (class 2606 OID 5303358)
-- Name: specimens_relationships fk_specimens_relationships_specimens; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_specimens FOREIGN KEY (specimen_ref) REFERENCES darwin2.specimens(id) ON DELETE CASCADE;


--
-- TOC entry 5397 (class 2606 OID 5303363)
-- Name: specimens_relationships fk_specimens_relationships_specimens_related; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_specimens_related FOREIGN KEY (specimen_related_ref) REFERENCES darwin2.specimens(id) ON DELETE CASCADE;


--
-- TOC entry 5398 (class 2606 OID 5303368)
-- Name: specimens_relationships fk_specimens_relationships_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens_relationships
    ADD CONSTRAINT fk_specimens_relationships_taxonomy FOREIGN KEY (taxon_ref) REFERENCES darwin2.taxonomy(id);


--
-- TOC entry 5411 (class 2606 OID 5303373)
-- Name: staging_relationship fk_specimens_relationships_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_relationship
    ADD CONSTRAINT fk_specimens_relationships_taxonomy FOREIGN KEY (taxon_ref) REFERENCES darwin2.taxonomy(id);


--
-- TOC entry 5393 (class 2606 OID 5303378)
-- Name: specimens fk_specimens_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.specimens
    ADD CONSTRAINT fk_specimens_taxonomy FOREIGN KEY (taxon_ref) REFERENCES darwin2.taxonomy(id);


--
-- TOC entry 5333 (class 2606 OID 5303383)
-- Name: staging fk_staging_chronostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_chronostratigraphy FOREIGN KEY (chrono_ref) REFERENCES darwin2.chronostratigraphy(id) ON DELETE SET NULL;


--
-- TOC entry 5401 (class 2606 OID 5303388)
-- Name: staging_collecting_methods fk_staging_collecting_methods_method; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods
    ADD CONSTRAINT fk_staging_collecting_methods_method FOREIGN KEY (collecting_method_ref) REFERENCES darwin2.collecting_methods(id) ON DELETE CASCADE;


--
-- TOC entry 5402 (class 2606 OID 5303393)
-- Name: staging_collecting_methods fk_staging_collecting_methods_staging; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_collecting_methods
    ADD CONSTRAINT fk_staging_collecting_methods_staging FOREIGN KEY (staging_ref) REFERENCES darwin2.staging(id) ON DELETE CASCADE;


--
-- TOC entry 5334 (class 2606 OID 5303398)
-- Name: staging fk_staging_import; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_import FOREIGN KEY (import_ref) REFERENCES darwin2.imports(id) ON DELETE CASCADE;


--
-- TOC entry 5335 (class 2606 OID 5303403)
-- Name: staging fk_staging_lithology; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_lithology FOREIGN KEY (lithology_ref) REFERENCES darwin2.lithology(id) ON DELETE SET NULL;


--
-- TOC entry 5336 (class 2606 OID 5303408)
-- Name: staging fk_staging_lithostratigraphy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_lithostratigraphy FOREIGN KEY (litho_ref) REFERENCES darwin2.lithostratigraphy(id) ON DELETE SET NULL;


--
-- TOC entry 5337 (class 2606 OID 5303413)
-- Name: staging fk_staging_mineralogy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_mineralogy FOREIGN KEY (mineral_ref) REFERENCES darwin2.mineralogy(id) ON DELETE SET NULL;


--
-- TOC entry 5407 (class 2606 OID 5303418)
-- Name: staging_people fk_staging_people_list_person; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_people
    ADD CONSTRAINT fk_staging_people_list_person FOREIGN KEY (people_ref) REFERENCES darwin2.people(id) ON DELETE CASCADE;


--
-- TOC entry 5406 (class 2606 OID 5303423)
-- Name: staging_info fk_staging_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_info
    ADD CONSTRAINT fk_staging_ref FOREIGN KEY (staging_ref) REFERENCES darwin2.staging(id) ON DELETE CASCADE;


--
-- TOC entry 5412 (class 2606 OID 5303428)
-- Name: staging_tag_groups fk_staging_tag_groups; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_tag_groups
    ADD CONSTRAINT fk_staging_tag_groups FOREIGN KEY (staging_ref) REFERENCES darwin2.staging(id) ON DELETE CASCADE;


--
-- TOC entry 5338 (class 2606 OID 5303433)
-- Name: staging fk_staging_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging
    ADD CONSTRAINT fk_staging_taxonomy FOREIGN KEY (taxon_ref) REFERENCES darwin2.taxonomy(id) ON DELETE SET NULL;


--
-- TOC entry 5399 (class 2606 OID 5303438)
-- Name: staging_catalogue fk_stg_catalogue_import_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_catalogue
    ADD CONSTRAINT fk_stg_catalogue_import_ref FOREIGN KEY (import_ref) REFERENCES darwin2.imports(id) ON DELETE CASCADE;


--
-- TOC entry 5400 (class 2606 OID 5303443)
-- Name: staging_catalogue fk_stg_catalogue_level_ref; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_catalogue
    ADD CONSTRAINT fk_stg_catalogue_level_ref FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 5429 (class 2606 OID 5308600)
-- Name: tag_tag_authority fk_tag; Type: FK CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.tag_tag_authority
    ADD CONSTRAINT fk_tag FOREIGN KEY (tag_group_distinct_ref) REFERENCES darwin2.tag_group_distinct(id);


--
-- TOC entry 5414 (class 2606 OID 5308557)
-- Name: tag_groups fk_tag_group_distinct_id; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_groups
    ADD CONSTRAINT fk_tag_group_distinct_id FOREIGN KEY (tag_group_distinct_ref) REFERENCES darwin2.tag_group_distinct(id);


--
-- TOC entry 5413 (class 2606 OID 5303448)
-- Name: tag_groups fk_tag_groups_gtu; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_groups
    ADD CONSTRAINT fk_tag_groups_gtu FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id) ON DELETE CASCADE;


--
-- TOC entry 5416 (class 2606 OID 5303453)
-- Name: tags fk_tags_gtu; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tags
    ADD CONSTRAINT fk_tags_gtu FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id) ON DELETE CASCADE;


--
-- TOC entry 5415 (class 2606 OID 5303458)
-- Name: tags fk_tags_tag_groups; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tags
    ADD CONSTRAINT fk_tags_tag_groups FOREIGN KEY (group_ref) REFERENCES darwin2.tag_groups(id) ON DELETE CASCADE;


--
-- TOC entry 5431 (class 2606 OID 5308747)
-- Name: taxonomy_authority fk_taxon; Type: FK CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.taxonomy_authority
    ADD CONSTRAINT fk_taxon FOREIGN KEY (taxonomy_ref) REFERENCES darwin2.taxonomy(id);


--
-- TOC entry 5430 (class 2606 OID 5308752)
-- Name: taxonomy_authority fk_taxonomy_authority_domain_id; Type: FK CONSTRAINT; Schema: darwin2; Owner: postgres
--

ALTER TABLE ONLY darwin2.taxonomy_authority
    ADD CONSTRAINT fk_taxonomy_authority_domain_id FOREIGN KEY (domain_ref) REFERENCES darwin2.authority_domain(id);


--
-- TOC entry 5417 (class 2606 OID 5303463)
-- Name: taxonomy fk_taxonomy_level_ref_catalogue_levels; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT fk_taxonomy_level_ref_catalogue_levels FOREIGN KEY (level_ref) REFERENCES darwin2.catalogue_levels(id);


--
-- TOC entry 5418 (class 2606 OID 5303468)
-- Name: taxonomy fk_taxonomy_parent_ref_taxonomy; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.taxonomy
    ADD CONSTRAINT fk_taxonomy_parent_ref_taxonomy FOREIGN KEY (parent_ref) REFERENCES darwin2.taxonomy(id) ON DELETE CASCADE;


--
-- TOC entry 5403 (class 2606 OID 5303473)
-- Name: staging_gtu fk_to_gtu; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu
    ADD CONSTRAINT fk_to_gtu FOREIGN KEY (gtu_ref) REFERENCES darwin2.gtu(id);


--
-- TOC entry 5404 (class 2606 OID 5303478)
-- Name: staging_gtu fk_to_import; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu
    ADD CONSTRAINT fk_to_import FOREIGN KEY (import_ref) REFERENCES darwin2.imports(id);


--
-- TOC entry 5419 (class 2606 OID 5303483)
-- Name: users fk_user_people_id; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users
    ADD CONSTRAINT fk_user_people_id FOREIGN KEY (people_id) REFERENCES darwin2.people(id) ON DELETE SET NULL;


--
-- TOC entry 5420 (class 2606 OID 5303488)
-- Name: users_addresses fk_users_addresses_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_addresses
    ADD CONSTRAINT fk_users_addresses_users FOREIGN KEY (person_user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5421 (class 2606 OID 5303493)
-- Name: users_comm fk_users_comm_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_comm
    ADD CONSTRAINT fk_users_comm_users FOREIGN KEY (person_user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5422 (class 2606 OID 5303498)
-- Name: users_login_infos fk_users_login_infos_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_login_infos
    ADD CONSTRAINT fk_users_login_infos_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5378 (class 2606 OID 5303503)
-- Name: preferences fk_users_preferences; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.preferences
    ADD CONSTRAINT fk_users_preferences FOREIGN KEY (user_ref) REFERENCES darwin2.users(id) ON DELETE CASCADE;


--
-- TOC entry 5423 (class 2606 OID 5303508)
-- Name: users_tracking fk_users_tracking_users; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.users_tracking
    ADD CONSTRAINT fk_users_tracking_users FOREIGN KEY (user_ref) REFERENCES darwin2.users(id);


--
-- TOC entry 5405 (class 2606 OID 5303513)
-- Name: staging_gtu staging_gtu_import_ref_fkey; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.staging_gtu
    ADD CONSTRAINT staging_gtu_import_ref_fkey FOREIGN KEY (import_ref) REFERENCES darwin2.imports(id);


--
-- TOC entry 5426 (class 2606 OID 5308634)
-- Name: tag_authority tag_authority_tag_group_distinct_ref_fkey; Type: FK CONSTRAINT; Schema: darwin2; Owner: darwin2
--

ALTER TABLE ONLY darwin2.tag_authority
    ADD CONSTRAINT tag_authority_tag_group_distinct_ref_fkey FOREIGN KEY (tag_group_distinct_ref) REFERENCES darwin2.tag_group_distinct(id);


--
-- TOC entry 5792 (class 0 OID 0)
-- Dependencies: 15
-- Name: SCHEMA darwin2; Type: ACL; Schema: -; Owner: darwin2
--

REVOKE ALL ON SCHEMA darwin2 FROM PUBLIC;
REVOKE ALL ON SCHEMA darwin2 FROM darwin2;
GRANT ALL ON SCHEMA darwin2 TO darwin2;
GRANT USAGE ON SCHEMA darwin2 TO darwin1;
GRANT USAGE ON SCHEMA darwin2 TO d2viewer;
GRANT USAGE ON SCHEMA darwin2 TO nagios;


--
-- TOC entry 5793 (class 0 OID 0)
-- Dependencies: 13
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- TOC entry 5801 (class 0 OID 0)
-- Dependencies: 1706
-- Name: FUNCTION check_auto_increment_code_in_spec(); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.check_auto_increment_code_in_spec() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.check_auto_increment_code_in_spec() FROM postgres;
GRANT ALL ON FUNCTION darwin2.check_auto_increment_code_in_spec() TO postgres;
GRANT ALL ON FUNCTION darwin2.check_auto_increment_code_in_spec() TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.check_auto_increment_code_in_spec() TO darwin2;


--
-- TOC entry 5802 (class 0 OID 0)
-- Dependencies: 1707
-- Name: FUNCTION chk_specimens_not_loaned(); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.chk_specimens_not_loaned() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.chk_specimens_not_loaned() FROM postgres;
GRANT ALL ON FUNCTION darwin2.chk_specimens_not_loaned() TO postgres;
GRANT ALL ON FUNCTION darwin2.chk_specimens_not_loaned() TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.chk_specimens_not_loaned() TO darwin2;


--
-- TOC entry 5803 (class 0 OID 0)
-- Dependencies: 1894
-- Name: FUNCTION convert_to_unified(property character varying, property_unit character varying); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying) FROM postgres;
GRANT ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying) TO postgres;
GRANT ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying) TO darwin2;


--
-- TOC entry 5804 (class 0 OID 0)
-- Dependencies: 1713
-- Name: FUNCTION convert_to_unified(property character varying, property_unit character varying, property_type character varying); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying, property_type character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying, property_type character varying) FROM postgres;
GRANT ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying, property_type character varying) TO postgres;
GRANT ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying, property_type character varying) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.convert_to_unified(property character varying, property_unit character varying, property_type character varying) TO darwin2;


--
-- TOC entry 5805 (class 0 OID 0)
-- Dependencies: 1720
-- Name: FUNCTION fct_after_save_add_code(collectionid integer, specimenid integer); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_after_save_add_code(collectionid integer, specimenid integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_after_save_add_code(collectionid integer, specimenid integer) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_after_save_add_code(collectionid integer, specimenid integer) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_after_save_add_code(collectionid integer, specimenid integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_after_save_add_code(collectionid integer, specimenid integer) TO darwin2;


--
-- TOC entry 5806 (class 0 OID 0)
-- Dependencies: 1725
-- Name: FUNCTION fct_catalogue_import_keywords_update(); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_catalogue_import_keywords_update() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_catalogue_import_keywords_update() FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_catalogue_import_keywords_update() TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_catalogue_import_keywords_update() TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_catalogue_import_keywords_update() TO darwin2;


--
-- TOC entry 5807 (class 0 OID 0)
-- Dependencies: 1735
-- Name: FUNCTION fct_clean_staging_catalogue(importref integer); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_clean_staging_catalogue(importref integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_clean_staging_catalogue(importref integer) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_clean_staging_catalogue(importref integer) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_clean_staging_catalogue(importref integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_clean_staging_catalogue(importref integer) TO darwin2;


--
-- TOC entry 5808 (class 0 OID 0)
-- Dependencies: 1747
-- Name: FUNCTION fct_cpy_length_conversion(property real, property_unit text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit text) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_cpy_length_conversion(property real, property_unit text) TO darwin2;


--
-- TOC entry 5809 (class 0 OID 0)
-- Dependencies: 1895
-- Name: FUNCTION fct_cpy_speed_conversion(property real, property_unit text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit text) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_cpy_speed_conversion(property real, property_unit text) TO darwin2;


--
-- TOC entry 5810 (class 0 OID 0)
-- Dependencies: 1936
-- Name: FUNCTION fct_cpy_tags_to_distinct_bedic(); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.fct_cpy_tags_to_distinct_bedic() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_cpy_tags_to_distinct_bedic() FROM darwin2;
GRANT ALL ON FUNCTION darwin2.fct_cpy_tags_to_distinct_bedic() TO darwin2;
GRANT ALL ON FUNCTION darwin2.fct_cpy_tags_to_distinct_bedic() TO PUBLIC;


--
-- TOC entry 5811 (class 0 OID 0)
-- Dependencies: 1752
-- Name: FUNCTION fct_cpy_temperature_conversion(property real, property_unit text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit text) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_cpy_temperature_conversion(property real, property_unit text) TO darwin2;


--
-- TOC entry 5812 (class 0 OID 0)
-- Dependencies: 1759
-- Name: FUNCTION fct_cpy_time_conversion(property real, property_unit text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit text) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_cpy_time_conversion(property real, property_unit text) TO darwin2;


--
-- TOC entry 5813 (class 0 OID 0)
-- Dependencies: 1766
-- Name: FUNCTION fct_cpy_volume_conversion(property real, property_unit text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit text) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_cpy_volume_conversion(property real, property_unit text) TO darwin2;


--
-- TOC entry 5814 (class 0 OID 0)
-- Dependencies: 1767
-- Name: FUNCTION fct_cpy_weight_conversion(property real, property_unit text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit text) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_cpy_weight_conversion(property real, property_unit text) TO darwin2;


--
-- TOC entry 5815 (class 0 OID 0)
-- Dependencies: 1773
-- Name: FUNCTION fct_duplicate_loans(loan_id integer); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_duplicate_loans(loan_id integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_duplicate_loans(loan_id integer) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_duplicate_loans(loan_id integer) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_duplicate_loans(loan_id integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_duplicate_loans(loan_id integer) TO darwin2;


--
-- TOC entry 5816 (class 0 OID 0)
-- Dependencies: 1917
-- Name: FUNCTION fct_get_tax_hierarchy(start_id integer, levels integer[]); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.fct_get_tax_hierarchy(start_id integer, levels integer[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_get_tax_hierarchy(start_id integer, levels integer[]) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.fct_get_tax_hierarchy(start_id integer, levels integer[]) TO darwin2;
GRANT ALL ON FUNCTION darwin2.fct_get_tax_hierarchy(start_id integer, levels integer[]) TO PUBLIC;


--
-- TOC entry 5817 (class 0 OID 0)
-- Dependencies: 236
-- Name: TABLE staging; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.staging FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.staging FROM darwin2;
GRANT ALL ON TABLE darwin2.staging TO darwin2;
GRANT SELECT ON TABLE darwin2.staging TO d2viewer;


--
-- TOC entry 5818 (class 0 OID 0)
-- Dependencies: 1886
-- Name: FUNCTION fct_imp_checker_staging_info(line darwin2.staging, st_type text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info(line darwin2.staging, st_type text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info(line darwin2.staging, st_type text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info(line darwin2.staging, st_type text) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info(line darwin2.staging, st_type text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info(line darwin2.staging, st_type text) TO darwin2;


--
-- TOC entry 5819 (class 0 OID 0)
-- Dependencies: 1784
-- Name: FUNCTION fct_imp_checker_staging_info_comments(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_comments(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_comments(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_comments(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_comments(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_comments(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO darwin2;


--
-- TOC entry 5820 (class 0 OID 0)
-- Dependencies: 1785
-- Name: FUNCTION fct_imp_checker_staging_info_ext_links(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_ext_links(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_ext_links(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_ext_links(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_ext_links(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_ext_links(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO darwin2;


--
-- TOC entry 5821 (class 0 OID 0)
-- Dependencies: 1786
-- Name: FUNCTION fct_imp_checker_staging_info_insurances(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_insurances(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_insurances(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_insurances(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_insurances(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_insurances(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO darwin2;


--
-- TOC entry 5822 (class 0 OID 0)
-- Dependencies: 1787
-- Name: FUNCTION fct_imp_checker_staging_info_multimedia(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_multimedia(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_multimedia(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_multimedia(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_multimedia(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_multimedia(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO darwin2;


--
-- TOC entry 5823 (class 0 OID 0)
-- Dependencies: 1788
-- Name: FUNCTION fct_imp_checker_staging_info_properties(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_properties(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_properties(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_properties(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_properties(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_info_properties(targeted_referenced_relation character varying, targeted_record_id integer, new_referenced_relation character varying, new_record_id integer) TO darwin2;


--
-- TOC entry 5824 (class 0 OID 0)
-- Dependencies: 1896
-- Name: FUNCTION fct_imp_checker_staging_relationship(); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_relationship() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_imp_checker_staging_relationship() FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_relationship() TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_relationship() TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_imp_checker_staging_relationship() TO darwin2;


--
-- TOC entry 5825 (class 0 OID 0)
-- Dependencies: 1792
-- Name: FUNCTION fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_imp_create_catalogues_and_parents(line darwin2.staging, catalogue_table text, prefix text) TO darwin2;


--
-- TOC entry 5826 (class 0 OID 0)
-- Dependencies: 1926
-- Name: FUNCTION fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean) TO darwin2;
GRANT ALL ON FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_importer_catalogue(req_import_ref integer, referenced_relation text, exclude_invalid_entries boolean) TO postgres;


--
-- TOC entry 5827 (class 0 OID 0)
-- Dependencies: 1935
-- Name: FUNCTION fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) TO darwin2;
GRANT ALL ON FUNCTION darwin2.fct_importer_catalogue_reference_taxonomy_logic_reference(req_import_ref integer, var_metadata_ref integer, exclude_invalid_entries boolean) TO PUBLIC;


--
-- TOC entry 5828 (class 0 OID 0)
-- Dependencies: 1897
-- Name: FUNCTION fct_listing_botany(nbr_records integer, VARIADIC taxon_ids integer[]); Type: ACL; Schema: darwin2; Owner: cebmpad
--

REVOKE ALL ON FUNCTION darwin2.fct_listing_botany(nbr_records integer, VARIADIC taxon_ids integer[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_listing_botany(nbr_records integer, VARIADIC taxon_ids integer[]) FROM cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_botany(nbr_records integer, VARIADIC taxon_ids integer[]) TO cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_botany(nbr_records integer, VARIADIC taxon_ids integer[]) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_listing_botany(nbr_records integer, VARIADIC taxon_ids integer[]) TO d2viewer;


--
-- TOC entry 5829 (class 0 OID 0)
-- Dependencies: 1793
-- Name: FUNCTION fct_listing_chronostratigraphy(nbr_records integer, VARIADIC chrono_unit_ids integer[]); Type: ACL; Schema: darwin2; Owner: cebmpad
--

REVOKE ALL ON FUNCTION darwin2.fct_listing_chronostratigraphy(nbr_records integer, VARIADIC chrono_unit_ids integer[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_listing_chronostratigraphy(nbr_records integer, VARIADIC chrono_unit_ids integer[]) FROM cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_chronostratigraphy(nbr_records integer, VARIADIC chrono_unit_ids integer[]) TO cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_chronostratigraphy(nbr_records integer, VARIADIC chrono_unit_ids integer[]) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_listing_chronostratigraphy(nbr_records integer, VARIADIC chrono_unit_ids integer[]) TO d2viewer;


--
-- TOC entry 5830 (class 0 OID 0)
-- Dependencies: 1794
-- Name: FUNCTION fct_listing_lithology(nbr_records integer, VARIADIC litholo_unit_ids integer[]); Type: ACL; Schema: darwin2; Owner: cebmpad
--

REVOKE ALL ON FUNCTION darwin2.fct_listing_lithology(nbr_records integer, VARIADIC litholo_unit_ids integer[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_listing_lithology(nbr_records integer, VARIADIC litholo_unit_ids integer[]) FROM cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_lithology(nbr_records integer, VARIADIC litholo_unit_ids integer[]) TO cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_lithology(nbr_records integer, VARIADIC litholo_unit_ids integer[]) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_listing_lithology(nbr_records integer, VARIADIC litholo_unit_ids integer[]) TO d2viewer;


--
-- TOC entry 5831 (class 0 OID 0)
-- Dependencies: 1795
-- Name: FUNCTION fct_listing_lithostratigraphy(nbr_records integer, VARIADIC litho_unit_ids integer[]); Type: ACL; Schema: darwin2; Owner: cebmpad
--

REVOKE ALL ON FUNCTION darwin2.fct_listing_lithostratigraphy(nbr_records integer, VARIADIC litho_unit_ids integer[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_listing_lithostratigraphy(nbr_records integer, VARIADIC litho_unit_ids integer[]) FROM cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_lithostratigraphy(nbr_records integer, VARIADIC litho_unit_ids integer[]) TO cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_lithostratigraphy(nbr_records integer, VARIADIC litho_unit_ids integer[]) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_listing_lithostratigraphy(nbr_records integer, VARIADIC litho_unit_ids integer[]) TO d2viewer;


--
-- TOC entry 5832 (class 0 OID 0)
-- Dependencies: 1796
-- Name: FUNCTION fct_listing_mineralogy(nbr_records integer, VARIADIC mineralo_unit_ids integer[]); Type: ACL; Schema: darwin2; Owner: cebmpad
--

REVOKE ALL ON FUNCTION darwin2.fct_listing_mineralogy(nbr_records integer, VARIADIC mineralo_unit_ids integer[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_listing_mineralogy(nbr_records integer, VARIADIC mineralo_unit_ids integer[]) FROM cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_mineralogy(nbr_records integer, VARIADIC mineralo_unit_ids integer[]) TO cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_mineralogy(nbr_records integer, VARIADIC mineralo_unit_ids integer[]) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_listing_mineralogy(nbr_records integer, VARIADIC mineralo_unit_ids integer[]) TO d2viewer;


--
-- TOC entry 5833 (class 0 OID 0)
-- Dependencies: 1790
-- Name: FUNCTION fct_listing_taxonomy(nbr_records integer, VARIADIC taxon_ids integer[]); Type: ACL; Schema: darwin2; Owner: cebmpad
--

REVOKE ALL ON FUNCTION darwin2.fct_listing_taxonomy(nbr_records integer, VARIADIC taxon_ids integer[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_listing_taxonomy(nbr_records integer, VARIADIC taxon_ids integer[]) FROM cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_taxonomy(nbr_records integer, VARIADIC taxon_ids integer[]) TO cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_taxonomy(nbr_records integer, VARIADIC taxon_ids integer[]) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_listing_taxonomy(nbr_records integer, VARIADIC taxon_ids integer[]) TO d2viewer;


--
-- TOC entry 5834 (class 0 OID 0)
-- Dependencies: 1800
-- Name: FUNCTION fct_listing_zoology(nbr_records integer, VARIADIC taxon_ids integer[]); Type: ACL; Schema: darwin2; Owner: cebmpad
--

REVOKE ALL ON FUNCTION darwin2.fct_listing_zoology(nbr_records integer, VARIADIC taxon_ids integer[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_listing_zoology(nbr_records integer, VARIADIC taxon_ids integer[]) FROM cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_zoology(nbr_records integer, VARIADIC taxon_ids integer[]) TO cebmpad;
GRANT ALL ON FUNCTION darwin2.fct_listing_zoology(nbr_records integer, VARIADIC taxon_ids integer[]) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_listing_zoology(nbr_records integer, VARIADIC taxon_ids integer[]) TO d2viewer;


--
-- TOC entry 5835 (class 0 OID 0)
-- Dependencies: 1898
-- Name: FUNCTION fct_rmca_abbreviate_names(given_name character varying); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_rmca_abbreviate_names(given_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_rmca_abbreviate_names(given_name character varying) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_rmca_abbreviate_names(given_name character varying) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_rmca_abbreviate_names(given_name character varying) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_rmca_abbreviate_names(given_name character varying) TO darwin2;


--
-- TOC entry 5836 (class 0 OID 0)
-- Dependencies: 1931
-- Name: FUNCTION fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean, is_indexed boolean, match_invalid_taxonomies boolean); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean, is_indexed boolean, match_invalid_taxonomies boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean, is_indexed boolean, match_invalid_taxonomies boolean) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean, is_indexed boolean, match_invalid_taxonomies boolean) TO darwin2;
GRANT ALL ON FUNCTION darwin2.fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean, is_indexed boolean, match_invalid_taxonomies boolean) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_rmca_document_taxonomy_staging_darwin_reference(req_import_ref integer, with_rank boolean, is_indexed boolean, match_invalid_taxonomies boolean) TO postgres;


--
-- TOC entry 5837 (class 0 OID 0)
-- Dependencies: 1913
-- Name: FUNCTION fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, import boolean); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, import boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, import boolean) FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, import boolean) TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, import boolean) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_rmca_imp_checker_gtu_search_code(line darwin2.staging, import boolean) TO darwin2;


--
-- TOC entry 5838 (class 0 OID 0)
-- Dependencies: 1825
-- Name: FUNCTION fct_upd_institution_staging_relationship(); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_upd_institution_staging_relationship() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_upd_institution_staging_relationship() FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_upd_institution_staging_relationship() TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_upd_institution_staging_relationship() TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_upd_institution_staging_relationship() TO darwin2;


--
-- TOC entry 5839 (class 0 OID 0)
-- Dependencies: 1843
-- Name: FUNCTION fct_update_import(); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.fct_update_import() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.fct_update_import() FROM postgres;
GRANT ALL ON FUNCTION darwin2.fct_update_import() TO postgres;
GRANT ALL ON FUNCTION darwin2.fct_update_import() TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.fct_update_import() TO darwin2;


--
-- TOC entry 5840 (class 0 OID 0)
-- Dependencies: 1899
-- Name: FUNCTION is_property_unit_in_group(searched_unit text, property_unit text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.is_property_unit_in_group(searched_unit text, property_unit text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.is_property_unit_in_group(searched_unit text, property_unit text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.is_property_unit_in_group(searched_unit text, property_unit text) TO postgres;
GRANT ALL ON FUNCTION darwin2.is_property_unit_in_group(searched_unit text, property_unit text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.is_property_unit_in_group(searched_unit text, property_unit text) TO darwin2;


--
-- TOC entry 5841 (class 0 OID 0)
-- Dependencies: 1855
-- Name: FUNCTION isnumeric(text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.isnumeric(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.isnumeric(text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.isnumeric(text) TO postgres;
GRANT ALL ON FUNCTION darwin2.isnumeric(text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.isnumeric(text) TO darwin2;


--
-- TOC entry 5842 (class 0 OID 0)
-- Dependencies: 1857
-- Name: FUNCTION labeling_code_for_indexation(part_ref integer); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.labeling_code_for_indexation(part_ref integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.labeling_code_for_indexation(part_ref integer) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.labeling_code_for_indexation(part_ref integer) TO darwin2;
GRANT ALL ON FUNCTION darwin2.labeling_code_for_indexation(part_ref integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.labeling_code_for_indexation(part_ref integer) TO d2viewer;
GRANT ALL ON FUNCTION darwin2.labeling_code_for_indexation(part_ref integer) TO cebmpad;


--
-- TOC entry 5843 (class 0 OID 0)
-- Dependencies: 1856
-- Name: FUNCTION labeling_individual_type_for_indexation(individual_type character varying); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.labeling_individual_type_for_indexation(individual_type character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.labeling_individual_type_for_indexation(individual_type character varying) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.labeling_individual_type_for_indexation(individual_type character varying) TO darwin2;
GRANT ALL ON FUNCTION darwin2.labeling_individual_type_for_indexation(individual_type character varying) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.labeling_individual_type_for_indexation(individual_type character varying) TO d2viewer;
GRANT ALL ON FUNCTION darwin2.labeling_individual_type_for_indexation(individual_type character varying) TO cebmpad;


--
-- TOC entry 5844 (class 0 OID 0)
-- Dependencies: 1858
-- Name: FUNCTION labeling_part_for_indexation(part character varying); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.labeling_part_for_indexation(part character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.labeling_part_for_indexation(part character varying) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.labeling_part_for_indexation(part character varying) TO darwin2;
GRANT ALL ON FUNCTION darwin2.labeling_part_for_indexation(part character varying) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.labeling_part_for_indexation(part character varying) TO d2viewer;
GRANT ALL ON FUNCTION darwin2.labeling_part_for_indexation(part character varying) TO cebmpad;


--
-- TOC entry 5845 (class 0 OID 0)
-- Dependencies: 1850
-- Name: FUNCTION labeling_type_for_indexation(individual_type character varying); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.labeling_type_for_indexation(individual_type character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.labeling_type_for_indexation(individual_type character varying) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.labeling_type_for_indexation(individual_type character varying) TO darwin2;
GRANT ALL ON FUNCTION darwin2.labeling_type_for_indexation(individual_type character varying) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.labeling_type_for_indexation(individual_type character varying) TO d2viewer;
GRANT ALL ON FUNCTION darwin2.labeling_type_for_indexation(individual_type character varying) TO cebmpad;


--
-- TOC entry 5846 (class 0 OID 0)
-- Dependencies: 1851
-- Name: FUNCTION point_equal(point, point); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.point_equal(point, point) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.point_equal(point, point) FROM postgres;
GRANT ALL ON FUNCTION darwin2.point_equal(point, point) TO postgres;
GRANT ALL ON FUNCTION darwin2.point_equal(point, point) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.point_equal(point, point) TO darwin2;


--
-- TOC entry 5847 (class 0 OID 0)
-- Dependencies: 1932
-- Name: FUNCTION rmca_dmscheck_syntax(coord_dms character varying); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) TO darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.rmca_dmscheck_syntax(coord_dms character varying) TO postgres;


--
-- TOC entry 5848 (class 0 OID 0)
-- Dependencies: 1903
-- Name: FUNCTION rmca_fct_clear_gtu_date(); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.rmca_fct_clear_gtu_date() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.rmca_fct_clear_gtu_date() FROM darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_fct_clear_gtu_date() TO darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_fct_clear_gtu_date() TO PUBLIC;


--
-- TOC entry 5849 (class 0 OID 0)
-- Dependencies: 1904
-- Name: FUNCTION rmca_fct_clear_specimen_date(); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.rmca_fct_clear_specimen_date() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.rmca_fct_clear_specimen_date() FROM darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_fct_clear_specimen_date() TO darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_fct_clear_specimen_date() TO PUBLIC;


--
-- TOC entry 5850 (class 0 OID 0)
-- Dependencies: 1905
-- Name: FUNCTION rmca_fct_update_specimen_date(); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.rmca_fct_update_specimen_date() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.rmca_fct_update_specimen_date() FROM darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_fct_update_specimen_date() TO darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_fct_update_specimen_date() TO PUBLIC;


--
-- TOC entry 5851 (class 0 OID 0)
-- Dependencies: 1868
-- Name: FUNCTION rmca_import_gtu_in_darwin_fast(p_import_ref integer); Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) FROM darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) TO darwin2;
GRANT ALL ON FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.rmca_import_gtu_in_darwin_fast(p_import_ref integer) TO postgres;


--
-- TOC entry 5853 (class 0 OID 0)
-- Dependencies: 1869
-- Name: FUNCTION stats_collections_encoding(integer, text, text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.stats_collections_encoding(integer, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.stats_collections_encoding(integer, text, text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding(integer, text, text) TO postgres;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding(integer, text, text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding(integer, text, text) TO darwin2;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding(integer, text, text) TO d2viewer;


--
-- TOC entry 5855 (class 0 OID 0)
-- Dependencies: 1864
-- Name: FUNCTION stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone) FROM postgres;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone) TO postgres;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding(integer, timestamp without time zone, timestamp without time zone) TO darwin2;


--
-- TOC entry 5857 (class 0 OID 0)
-- Dependencies: 1870
-- Name: FUNCTION stats_collections_encoding_optimistics(integer, text, text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, text, text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, text, text) TO postgres;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, text, text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, text, text) TO darwin2;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, text, text) TO d2viewer;


--
-- TOC entry 5859 (class 0 OID 0)
-- Dependencies: 1887
-- Name: FUNCTION stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone) FROM postgres;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone) TO postgres;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone) TO darwin2;
GRANT ALL ON FUNCTION darwin2.stats_collections_encoding_optimistics(integer, timestamp without time zone, timestamp without time zone) TO d2viewer;


--
-- TOC entry 5861 (class 0 OID 0)
-- Dependencies: 1871
-- Name: FUNCTION stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text) TO postgres;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text) TO darwin2;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date text, to_date text) TO d2viewer;


--
-- TOC entry 5863 (class 0 OID 0)
-- Dependencies: 1900
-- Name: FUNCTION stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) FROM postgres;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) TO postgres;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) TO darwin2;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) TO d2viewer;


--
-- TOC entry 5865 (class 0 OID 0)
-- Dependencies: 1875
-- Name: FUNCTION stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text) FROM postgres;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text) TO postgres;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text) TO darwin2;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date text, to_date text) TO d2viewer;


--
-- TOC entry 5867 (class 0 OID 0)
-- Dependencies: 1901
-- Name: FUNCTION stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) FROM postgres;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) TO postgres;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) TO darwin2;
GRANT ALL ON FUNCTION darwin2.stats_encoders_encoding_optimistics(top_collection integer, users_array text, from_date timestamp without time zone, to_date timestamp without time zone) TO d2viewer;


--
-- TOC entry 5868 (class 0 OID 0)
-- Dependencies: 1880
-- Name: FUNCTION update_collections_code_last_val(); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.update_collections_code_last_val() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.update_collections_code_last_val() FROM postgres;
GRANT ALL ON FUNCTION darwin2.update_collections_code_last_val() TO postgres;
GRANT ALL ON FUNCTION darwin2.update_collections_code_last_val() TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.update_collections_code_last_val() TO darwin2;


--
-- TOC entry 5869 (class 0 OID 0)
-- Dependencies: 1902
-- Name: FUNCTION update_collections_code_last_val_after_spec_del(); Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON FUNCTION darwin2.update_collections_code_last_val_after_spec_del() FROM PUBLIC;
REVOKE ALL ON FUNCTION darwin2.update_collections_code_last_val_after_spec_del() FROM postgres;
GRANT ALL ON FUNCTION darwin2.update_collections_code_last_val_after_spec_del() TO postgres;
GRANT ALL ON FUNCTION darwin2.update_collections_code_last_val_after_spec_del() TO PUBLIC;
GRANT ALL ON FUNCTION darwin2.update_collections_code_last_val_after_spec_del() TO darwin2;


--
-- TOC entry 5876 (class 0 OID 0)
-- Dependencies: 435
-- Name: TABLE authority_domain; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.authority_domain FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.authority_domain FROM darwin2;
GRANT ALL ON TABLE darwin2.authority_domain TO darwin2;


--
-- TOC entry 5878 (class 0 OID 0)
-- Dependencies: 434
-- Name: SEQUENCE authority_domain_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.authority_domain_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.authority_domain_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.authority_domain_id_seq TO darwin2;


--
-- TOC entry 5886 (class 0 OID 0)
-- Dependencies: 237
-- Name: TABLE bibliography; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.bibliography FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.bibliography FROM darwin2;
GRANT ALL ON TABLE darwin2.bibliography TO darwin2;
GRANT SELECT ON TABLE darwin2.bibliography TO d2viewer;


--
-- TOC entry 5891 (class 0 OID 0)
-- Dependencies: 239
-- Name: TABLE template_table_record_ref; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.template_table_record_ref FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.template_table_record_ref FROM darwin2;
GRANT ALL ON TABLE darwin2.template_table_record_ref TO darwin2;
GRANT SELECT ON TABLE darwin2.template_table_record_ref TO d2viewer;


--
-- TOC entry 5897 (class 0 OID 0)
-- Dependencies: 240
-- Name: TABLE catalogue_bibliography; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.catalogue_bibliography FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.catalogue_bibliography FROM darwin2;
GRANT ALL ON TABLE darwin2.catalogue_bibliography TO darwin2;
GRANT SELECT ON TABLE darwin2.catalogue_bibliography TO d2viewer;


--
-- TOC entry 5905 (class 0 OID 0)
-- Dependencies: 243
-- Name: TABLE catalogue_levels; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.catalogue_levels FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.catalogue_levels FROM darwin2;
GRANT ALL ON TABLE darwin2.catalogue_levels TO darwin2;
GRANT SELECT ON TABLE darwin2.catalogue_levels TO d2viewer;


--
-- TOC entry 5914 (class 0 OID 0)
-- Dependencies: 245
-- Name: TABLE catalogue_people; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.catalogue_people FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.catalogue_people FROM darwin2;
GRANT ALL ON TABLE darwin2.catalogue_people TO darwin2;
GRANT SELECT ON TABLE darwin2.catalogue_people TO d2viewer;


--
-- TOC entry 5920 (class 0 OID 0)
-- Dependencies: 248
-- Name: TABLE catalogue_relationships; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.catalogue_relationships FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.catalogue_relationships FROM darwin2;
GRANT ALL ON TABLE darwin2.catalogue_relationships TO darwin2;
GRANT SELECT ON TABLE darwin2.catalogue_relationships TO d2viewer;


--
-- TOC entry 5930 (class 0 OID 0)
-- Dependencies: 250
-- Name: TABLE template_classifications; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.template_classifications FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.template_classifications FROM darwin2;
GRANT ALL ON TABLE darwin2.template_classifications TO darwin2;
GRANT SELECT ON TABLE darwin2.template_classifications TO d2viewer;


--
-- TOC entry 5941 (class 0 OID 0)
-- Dependencies: 251
-- Name: TABLE chronostratigraphy; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.chronostratigraphy FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.chronostratigraphy FROM darwin2;
GRANT ALL ON TABLE darwin2.chronostratigraphy TO darwin2;
GRANT SELECT ON TABLE darwin2.chronostratigraphy TO d2viewer;


--
-- TOC entry 5947 (class 0 OID 0)
-- Dependencies: 254
-- Name: TABLE classification_keywords; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.classification_keywords FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.classification_keywords FROM darwin2;
GRANT ALL ON TABLE darwin2.classification_keywords TO darwin2;
GRANT SELECT ON TABLE darwin2.classification_keywords TO d2viewer;


--
-- TOC entry 5955 (class 0 OID 0)
-- Dependencies: 256
-- Name: TABLE classification_synonymies; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.classification_synonymies FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.classification_synonymies FROM darwin2;
GRANT ALL ON TABLE darwin2.classification_synonymies TO darwin2;
GRANT SELECT ON TABLE darwin2.classification_synonymies TO d2viewer;


--
-- TOC entry 5969 (class 0 OID 0)
-- Dependencies: 259
-- Name: TABLE codes; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.codes FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.codes FROM darwin2;
GRANT ALL ON TABLE darwin2.codes TO darwin2;
GRANT SELECT ON TABLE darwin2.codes TO d2viewer;


--
-- TOC entry 5974 (class 0 OID 0)
-- Dependencies: 261
-- Name: TABLE collecting_methods; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.collecting_methods FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.collecting_methods FROM darwin2;
GRANT ALL ON TABLE darwin2.collecting_methods TO darwin2;
GRANT SELECT ON TABLE darwin2.collecting_methods TO d2viewer;


--
-- TOC entry 5979 (class 0 OID 0)
-- Dependencies: 263
-- Name: TABLE collecting_tools; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.collecting_tools FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.collecting_tools FROM darwin2;
GRANT ALL ON TABLE darwin2.collecting_tools TO darwin2;
GRANT SELECT ON TABLE darwin2.collecting_tools TO d2viewer;


--
-- TOC entry 5990 (class 0 OID 0)
-- Dependencies: 265
-- Name: TABLE collection_maintenance; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.collection_maintenance FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.collection_maintenance FROM darwin2;
GRANT ALL ON TABLE darwin2.collection_maintenance TO darwin2;
GRANT SELECT ON TABLE darwin2.collection_maintenance TO d2viewer;


--
-- TOC entry 6012 (class 0 OID 0)
-- Dependencies: 267
-- Name: TABLE collections; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.collections FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.collections FROM darwin2;
GRANT ALL ON TABLE darwin2.collections TO darwin2;
GRANT SELECT ON TABLE darwin2.collections TO d2viewer;


--
-- TOC entry 6018 (class 0 OID 0)
-- Dependencies: 269
-- Name: TABLE collections_rights; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.collections_rights FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.collections_rights FROM darwin2;
GRANT ALL ON TABLE darwin2.collections_rights TO darwin2;
GRANT SELECT ON TABLE darwin2.collections_rights TO d2viewer;


--
-- TOC entry 6026 (class 0 OID 0)
-- Dependencies: 271
-- Name: TABLE comments; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.comments FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.comments FROM darwin2;
GRANT ALL ON TABLE darwin2.comments TO darwin2;
GRANT SELECT ON TABLE darwin2.comments TO d2viewer;


--
-- TOC entry 6046 (class 0 OID 0)
-- Dependencies: 274
-- Name: TABLE properties; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.properties FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.properties FROM darwin2;
GRANT ALL ON TABLE darwin2.properties TO darwin2;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.properties TO cebmpad;
GRANT SELECT ON TABLE darwin2.properties TO d2viewer;


--
-- TOC entry 6058 (class 0 OID 0)
-- Dependencies: 277
-- Name: TABLE identifications; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.identifications FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.identifications FROM darwin2;
GRANT ALL ON TABLE darwin2.identifications TO darwin2;
GRANT SELECT ON TABLE darwin2.identifications TO d2viewer;


--
-- TOC entry 6072 (class 0 OID 0)
-- Dependencies: 286
-- Name: TABLE gtu; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.gtu FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.gtu FROM darwin2;
GRANT ALL ON TABLE darwin2.gtu TO darwin2;
GRANT SELECT ON TABLE darwin2.gtu TO d2viewer;


--
-- TOC entry 6077 (class 0 OID 0)
-- Dependencies: 427
-- Name: TABLE temporal_information; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.temporal_information FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.temporal_information FROM darwin2;
GRANT ALL ON TABLE darwin2.temporal_information TO darwin2;


--
-- TOC entry 6086 (class 0 OID 0)
-- Dependencies: 280
-- Name: TABLE expeditions; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.expeditions FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.expeditions FROM darwin2;
GRANT ALL ON TABLE darwin2.expeditions TO darwin2;
GRANT SELECT ON TABLE darwin2.expeditions TO d2viewer;


--
-- TOC entry 6095 (class 0 OID 0)
-- Dependencies: 282
-- Name: TABLE ext_links; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.ext_links FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.ext_links FROM darwin2;
GRANT ALL ON TABLE darwin2.ext_links TO darwin2;
GRANT SELECT ON TABLE darwin2.ext_links TO d2viewer;


--
-- TOC entry 6100 (class 0 OID 0)
-- Dependencies: 284
-- Name: TABLE flat_dict; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.flat_dict FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.flat_dict FROM darwin2;
GRANT ALL ON TABLE darwin2.flat_dict TO darwin2;
GRANT SELECT,INSERT ON TABLE darwin2.flat_dict TO d2viewer;


--
-- TOC entry 6106 (class 0 OID 0)
-- Dependencies: 291
-- Name: TABLE igs; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.igs FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.igs FROM darwin2;
GRANT ALL ON TABLE darwin2.igs TO darwin2;
GRANT SELECT ON TABLE darwin2.igs TO d2viewer;


--
-- TOC entry 6118 (class 0 OID 0)
-- Dependencies: 294
-- Name: SEQUENCE informative_workflow_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.informative_workflow_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.informative_workflow_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.informative_workflow_id_seq TO darwin2;
GRANT SELECT,USAGE ON SEQUENCE darwin2.informative_workflow_id_seq TO d2viewer;


--
-- TOC entry 6128 (class 0 OID 0)
-- Dependencies: 295
-- Name: TABLE informative_workflow; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.informative_workflow FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.informative_workflow FROM darwin2;
GRANT ALL ON TABLE darwin2.informative_workflow TO darwin2;
GRANT SELECT,INSERT,UPDATE ON TABLE darwin2.informative_workflow TO d2viewer;


--
-- TOC entry 6135 (class 0 OID 0)
-- Dependencies: 297
-- Name: TABLE insurances; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.insurances FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.insurances FROM darwin2;
GRANT ALL ON TABLE darwin2.insurances TO darwin2;
GRANT SELECT ON TABLE darwin2.insurances TO d2viewer;


--
-- TOC entry 6144 (class 0 OID 0)
-- Dependencies: 299
-- Name: TABLE lithology; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.lithology FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.lithology FROM darwin2;
GRANT ALL ON TABLE darwin2.lithology TO darwin2;
GRANT SELECT ON TABLE darwin2.lithology TO d2viewer;


--
-- TOC entry 6153 (class 0 OID 0)
-- Dependencies: 301
-- Name: TABLE lithostratigraphy; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.lithostratigraphy FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.lithostratigraphy FROM darwin2;
GRANT ALL ON TABLE darwin2.lithostratigraphy TO darwin2;
GRANT SELECT ON TABLE darwin2.lithostratigraphy TO d2viewer;


--
-- TOC entry 6159 (class 0 OID 0)
-- Dependencies: 302
-- Name: TABLE loan_history; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.loan_history FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.loan_history FROM darwin2;
GRANT ALL ON TABLE darwin2.loan_history TO darwin2;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.loan_history TO cebmpad;
GRANT SELECT ON TABLE darwin2.loan_history TO d2viewer;


--
-- TOC entry 6161 (class 0 OID 0)
-- Dependencies: 303
-- Name: SEQUENCE loan_history_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.loan_history_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.loan_history_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.loan_history_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.loan_history_id_seq TO cebmpad;


--
-- TOC entry 6162 (class 0 OID 0)
-- Dependencies: 304
-- Name: SEQUENCE loan_items_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.loan_items_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.loan_items_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.loan_items_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.loan_items_id_seq TO cebmpad;


--
-- TOC entry 6171 (class 0 OID 0)
-- Dependencies: 305
-- Name: TABLE loan_items; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.loan_items FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.loan_items FROM darwin2;
GRANT ALL ON TABLE darwin2.loan_items TO darwin2;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.loan_items TO cebmpad;
GRANT SELECT ON TABLE darwin2.loan_items TO d2viewer;


--
-- TOC entry 6172 (class 0 OID 0)
-- Dependencies: 306
-- Name: SEQUENCE loan_rights_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.loan_rights_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.loan_rights_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.loan_rights_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.loan_rights_id_seq TO cebmpad;


--
-- TOC entry 6178 (class 0 OID 0)
-- Dependencies: 307
-- Name: TABLE loan_rights; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.loan_rights FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.loan_rights FROM darwin2;
GRANT ALL ON TABLE darwin2.loan_rights TO darwin2;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.loan_rights TO cebmpad;
GRANT SELECT ON TABLE darwin2.loan_rights TO d2viewer;


--
-- TOC entry 6179 (class 0 OID 0)
-- Dependencies: 308
-- Name: SEQUENCE loan_status_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.loan_status_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.loan_status_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.loan_status_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.loan_status_id_seq TO cebmpad;


--
-- TOC entry 6188 (class 0 OID 0)
-- Dependencies: 309
-- Name: TABLE loan_status; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.loan_status FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.loan_status FROM darwin2;
GRANT ALL ON TABLE darwin2.loan_status TO darwin2;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.loan_status TO cebmpad;
GRANT SELECT ON TABLE darwin2.loan_status TO d2viewer;


--
-- TOC entry 6189 (class 0 OID 0)
-- Dependencies: 310
-- Name: SEQUENCE loans_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.loans_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.loans_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.loans_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.loans_id_seq TO cebmpad;


--
-- TOC entry 6197 (class 0 OID 0)
-- Dependencies: 311
-- Name: TABLE loans; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.loans FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.loans FROM darwin2;
GRANT ALL ON TABLE darwin2.loans TO darwin2;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.loans TO cebmpad;
GRANT SELECT ON TABLE darwin2.loans TO d2viewer;


--
-- TOC entry 6211 (class 0 OID 0)
-- Dependencies: 313
-- Name: TABLE mineralogy; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.mineralogy FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.mineralogy FROM darwin2;
GRANT ALL ON TABLE darwin2.mineralogy TO darwin2;
GRANT SELECT ON TABLE darwin2.mineralogy TO d2viewer;


--
-- TOC entry 6212 (class 0 OID 0)
-- Dependencies: 314
-- Name: SEQUENCE multimedia_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.multimedia_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.multimedia_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.multimedia_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.multimedia_id_seq TO cebmpad;


--
-- TOC entry 6230 (class 0 OID 0)
-- Dependencies: 315
-- Name: TABLE multimedia; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.multimedia FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.multimedia FROM darwin2;
GRANT ALL ON TABLE darwin2.multimedia TO darwin2;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.multimedia TO cebmpad;
GRANT SELECT ON TABLE darwin2.multimedia TO d2viewer;


--
-- TOC entry 6233 (class 0 OID 0)
-- Dependencies: 316
-- Name: TABLE multimedia_todelete; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.multimedia_todelete FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.multimedia_todelete FROM darwin2;
GRANT ALL ON TABLE darwin2.multimedia_todelete TO darwin2;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.multimedia_todelete TO cebmpad;


--
-- TOC entry 6235 (class 0 OID 0)
-- Dependencies: 317
-- Name: SEQUENCE multimedia_todelete_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.multimedia_todelete_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.multimedia_todelete_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.multimedia_todelete_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.multimedia_todelete_id_seq TO cebmpad;


--
-- TOC entry 6249 (class 0 OID 0)
-- Dependencies: 437
-- Name: TABLE tag_authority; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.tag_authority FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.tag_authority FROM darwin2;
GRANT ALL ON TABLE darwin2.tag_authority TO darwin2;


--
-- TOC entry 6255 (class 0 OID 0)
-- Dependencies: 433
-- Name: TABLE tag_group_distinct; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.tag_group_distinct FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.tag_group_distinct FROM darwin2;
GRANT ALL ON TABLE darwin2.tag_group_distinct TO darwin2;


--
-- TOC entry 6266 (class 0 OID 0)
-- Dependencies: 376
-- Name: TABLE tag_groups; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.tag_groups FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.tag_groups FROM darwin2;
GRANT ALL ON TABLE darwin2.tag_groups TO darwin2;
GRANT SELECT ON TABLE darwin2.tag_groups TO d2viewer;


--
-- TOC entry 6271 (class 0 OID 0)
-- Dependencies: 438
-- Name: TABLE tag_tag_authority; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON TABLE darwin2.tag_tag_authority FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.tag_tag_authority FROM postgres;
GRANT ALL ON TABLE darwin2.tag_tag_authority TO postgres;
GRANT ALL ON TABLE darwin2.tag_tag_authority TO darwin2;


--
-- TOC entry 6272 (class 0 OID 0)
-- Dependencies: 439
-- Name: TABLE mv_tag_to_country; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON TABLE darwin2.mv_tag_to_country FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.mv_tag_to_country FROM postgres;
GRANT ALL ON TABLE darwin2.mv_tag_to_country TO postgres;
GRANT ALL ON TABLE darwin2.mv_tag_to_country TO darwin2;


--
-- TOC entry 6318 (class 0 OID 0)
-- Dependencies: 351
-- Name: TABLE specimens; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.specimens FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.specimens FROM darwin2;
GRANT ALL ON TABLE darwin2.specimens TO darwin2;
GRANT SELECT ON TABLE darwin2.specimens TO d2viewer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.specimens TO cebmpad;


--
-- TOC entry 6332 (class 0 OID 0)
-- Dependencies: 324
-- Name: TABLE template_people; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.template_people FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.template_people FROM darwin2;
GRANT ALL ON TABLE darwin2.template_people TO darwin2;
GRANT SELECT ON TABLE darwin2.template_people TO d2viewer;


--
-- TOC entry 6336 (class 0 OID 0)
-- Dependencies: 328
-- Name: TABLE template_people_users_comm_common; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.template_people_users_comm_common FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.template_people_users_comm_common FROM darwin2;
GRANT ALL ON TABLE darwin2.template_people_users_comm_common TO darwin2;
GRANT SELECT ON TABLE darwin2.template_people_users_comm_common TO d2viewer;


--
-- TOC entry 6337 (class 0 OID 0)
-- Dependencies: 387
-- Name: SEQUENCE users_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.users_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.users_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.users_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.users_id_seq TO d2viewer;


--
-- TOC entry 6355 (class 0 OID 0)
-- Dependencies: 388
-- Name: TABLE users; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.users FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.users FROM darwin2;
GRANT ALL ON TABLE darwin2.users TO darwin2;
GRANT SELECT,INSERT ON TABLE darwin2.users TO d2viewer;


--
-- TOC entry 6356 (class 0 OID 0)
-- Dependencies: 391
-- Name: SEQUENCE users_comm_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.users_comm_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.users_comm_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.users_comm_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.users_comm_id_seq TO d2viewer;


--
-- TOC entry 6363 (class 0 OID 0)
-- Dependencies: 392
-- Name: TABLE users_comm; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.users_comm FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.users_comm FROM darwin2;
GRANT ALL ON TABLE darwin2.users_comm TO darwin2;
GRANT SELECT,INSERT ON TABLE darwin2.users_comm TO d2viewer;


--
-- TOC entry 6364 (class 0 OID 0)
-- Dependencies: 441
-- Name: TABLE mv_eml; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON TABLE darwin2.mv_eml FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.mv_eml FROM postgres;
GRANT ALL ON TABLE darwin2.mv_eml TO postgres;
GRANT ALL ON TABLE darwin2.mv_eml TO darwin2;


--
-- TOC entry 6365 (class 0 OID 0)
-- Dependencies: 442
-- Name: TABLE mv_eml_marine; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.mv_eml_marine FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.mv_eml_marine FROM darwin2;
GRANT ALL ON TABLE darwin2.mv_eml_marine TO darwin2;


--
-- TOC entry 6366 (class 0 OID 0)
-- Dependencies: 443
-- Name: TABLE mv_spatial; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.mv_spatial FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.mv_spatial FROM darwin2;
GRANT ALL ON TABLE darwin2.mv_spatial TO darwin2;


--
-- TOC entry 6367 (class 0 OID 0)
-- Dependencies: 440
-- Name: TABLE mv_tag_to_locations; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON TABLE darwin2.mv_tag_to_locations FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.mv_tag_to_locations FROM postgres;
GRANT ALL ON TABLE darwin2.mv_tag_to_locations TO postgres;
GRANT ALL ON TABLE darwin2.mv_tag_to_locations TO darwin2;


--
-- TOC entry 6376 (class 0 OID 0)
-- Dependencies: 319
-- Name: TABLE my_saved_searches; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.my_saved_searches FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.my_saved_searches FROM darwin2;
GRANT ALL ON TABLE darwin2.my_saved_searches TO darwin2;
GRANT SELECT ON TABLE darwin2.my_saved_searches TO d2viewer;


--
-- TOC entry 6377 (class 0 OID 0)
-- Dependencies: 320
-- Name: SEQUENCE my_widgets_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.my_widgets_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.my_widgets_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.my_widgets_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.my_widgets_id_seq TO d2viewer;


--
-- TOC entry 6393 (class 0 OID 0)
-- Dependencies: 321
-- Name: TABLE my_widgets; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.my_widgets FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.my_widgets FROM darwin2;
GRANT ALL ON TABLE darwin2.my_widgets TO darwin2;
GRANT SELECT,INSERT ON TABLE darwin2.my_widgets TO d2viewer;


--
-- TOC entry 6418 (class 0 OID 0)
-- Dependencies: 322
-- Name: TABLE old_multimedia; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.old_multimedia FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.old_multimedia FROM darwin2;
GRANT ALL ON TABLE darwin2.old_multimedia TO darwin2;
GRANT SELECT ON TABLE darwin2.old_multimedia TO d2viewer;


--
-- TOC entry 6439 (class 0 OID 0)
-- Dependencies: 325
-- Name: TABLE people; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.people FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.people FROM darwin2;
GRANT ALL ON TABLE darwin2.people TO darwin2;
GRANT SELECT ON TABLE darwin2.people TO d2viewer;


--
-- TOC entry 6447 (class 0 OID 0)
-- Dependencies: 327
-- Name: TABLE template_people_users_addr_common; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.template_people_users_addr_common FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.template_people_users_addr_common FROM darwin2;
GRANT ALL ON TABLE darwin2.template_people_users_addr_common TO darwin2;
GRANT SELECT ON TABLE darwin2.template_people_users_addr_common TO d2viewer;


--
-- TOC entry 6459 (class 0 OID 0)
-- Dependencies: 329
-- Name: TABLE people_addresses; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.people_addresses FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.people_addresses FROM darwin2;
GRANT ALL ON TABLE darwin2.people_addresses TO darwin2;
GRANT SELECT ON TABLE darwin2.people_addresses TO d2viewer;


--
-- TOC entry 6466 (class 0 OID 0)
-- Dependencies: 331
-- Name: TABLE people_comm; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.people_comm FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.people_comm FROM darwin2;
GRANT ALL ON TABLE darwin2.people_comm TO darwin2;
GRANT SELECT ON TABLE darwin2.people_comm TO d2viewer;


--
-- TOC entry 6472 (class 0 OID 0)
-- Dependencies: 333
-- Name: TABLE people_languages; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.people_languages FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.people_languages FROM darwin2;
GRANT ALL ON TABLE darwin2.people_languages TO darwin2;
GRANT SELECT ON TABLE darwin2.people_languages TO d2viewer;


--
-- TOC entry 6483 (class 0 OID 0)
-- Dependencies: 335
-- Name: TABLE people_relationships; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.people_relationships FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.people_relationships FROM darwin2;
GRANT ALL ON TABLE darwin2.people_relationships TO darwin2;
GRANT SELECT ON TABLE darwin2.people_relationships TO d2viewer;


--
-- TOC entry 6487 (class 0 OID 0)
-- Dependencies: 336
-- Name: TABLE possible_upper_levels; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.possible_upper_levels FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.possible_upper_levels FROM darwin2;
GRANT ALL ON TABLE darwin2.possible_upper_levels TO darwin2;
GRANT SELECT ON TABLE darwin2.possible_upper_levels TO d2viewer;


--
-- TOC entry 6492 (class 0 OID 0)
-- Dependencies: 339
-- Name: TABLE preferences; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.preferences FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.preferences FROM darwin2;
GRANT ALL ON TABLE darwin2.preferences TO darwin2;
GRANT SELECT ON TABLE darwin2.preferences TO d2viewer;


--
-- TOC entry 6494 (class 0 OID 0)
-- Dependencies: 342
-- Name: SEQUENCE properties_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.properties_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.properties_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.properties_id_seq TO darwin2;
GRANT SELECT,USAGE ON SEQUENCE darwin2.properties_id_seq TO cebmpad;
GRANT USAGE ON SEQUENCE darwin2.properties_id_seq TO d2viewer;


--
-- TOC entry 6503 (class 0 OID 0)
-- Dependencies: 345
-- Name: TABLE reports; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON TABLE darwin2.reports FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.reports FROM postgres;
GRANT ALL ON TABLE darwin2.reports TO postgres;
GRANT ALL ON TABLE darwin2.reports TO darwin2;


--
-- TOC entry 6505 (class 0 OID 0)
-- Dependencies: 346
-- Name: SEQUENCE reports_id_seq; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON SEQUENCE darwin2.reports_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.reports_id_seq FROM postgres;
GRANT ALL ON SEQUENCE darwin2.reports_id_seq TO postgres;
GRANT ALL ON SEQUENCE darwin2.reports_id_seq TO darwin2;


--
-- TOC entry 6510 (class 0 OID 0)
-- Dependencies: 348
-- Name: TABLE specimen_collecting_methods; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.specimen_collecting_methods FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.specimen_collecting_methods FROM darwin2;
GRANT ALL ON TABLE darwin2.specimen_collecting_methods TO darwin2;
GRANT SELECT ON TABLE darwin2.specimen_collecting_methods TO d2viewer;


--
-- TOC entry 6515 (class 0 OID 0)
-- Dependencies: 350
-- Name: TABLE specimen_collecting_tools; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.specimen_collecting_tools FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.specimen_collecting_tools FROM darwin2;
GRANT ALL ON TABLE darwin2.specimen_collecting_tools TO darwin2;
GRANT SELECT ON TABLE darwin2.specimen_collecting_tools TO d2viewer;


--
-- TOC entry 6517 (class 0 OID 0)
-- Dependencies: 354
-- Name: SEQUENCE specimens_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.specimens_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.specimens_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.specimens_id_seq TO darwin2;
GRANT SELECT,USAGE ON SEQUENCE darwin2.specimens_id_seq TO cebmpad;


--
-- TOC entry 6528 (class 0 OID 0)
-- Dependencies: 356
-- Name: TABLE specimens_relationships; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.specimens_relationships FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.specimens_relationships FROM darwin2;
GRANT ALL ON TABLE darwin2.specimens_relationships TO darwin2;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.specimens_relationships TO cebmpad;
GRANT SELECT ON TABLE darwin2.specimens_relationships TO d2viewer;


--
-- TOC entry 6530 (class 0 OID 0)
-- Dependencies: 357
-- Name: SEQUENCE specimens_relationships_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.specimens_relationships_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.specimens_relationships_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.specimens_relationships_id_seq TO darwin2;
GRANT SELECT,USAGE ON SEQUENCE darwin2.specimens_relationships_id_seq TO cebmpad;
GRANT USAGE ON SEQUENCE darwin2.specimens_relationships_id_seq TO d2viewer;


--
-- TOC entry 6539 (class 0 OID 0)
-- Dependencies: 358
-- Name: TABLE staging_catalogue; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.staging_catalogue FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.staging_catalogue FROM darwin2;
GRANT ALL ON TABLE darwin2.staging_catalogue TO darwin2;


--
-- TOC entry 6541 (class 0 OID 0)
-- Dependencies: 359
-- Name: SEQUENCE staging_catalogue_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.staging_catalogue_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.staging_catalogue_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.staging_catalogue_id_seq TO darwin2;


--
-- TOC entry 6546 (class 0 OID 0)
-- Dependencies: 360
-- Name: TABLE staging_collecting_methods; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.staging_collecting_methods FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.staging_collecting_methods FROM darwin2;
GRANT ALL ON TABLE darwin2.staging_collecting_methods TO darwin2;
GRANT SELECT ON TABLE darwin2.staging_collecting_methods TO d2viewer;


--
-- TOC entry 6555 (class 0 OID 0)
-- Dependencies: 365
-- Name: TABLE staging_gtu_tag_groups; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.staging_gtu_tag_groups FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.staging_gtu_tag_groups FROM darwin2;
GRANT ALL ON TABLE darwin2.staging_gtu_tag_groups TO darwin2;
GRANT SELECT ON TABLE darwin2.staging_gtu_tag_groups TO d2viewer;


--
-- TOC entry 6557 (class 0 OID 0)
-- Dependencies: 367
-- Name: TABLE staging_info; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.staging_info FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.staging_info FROM darwin2;
GRANT ALL ON TABLE darwin2.staging_info TO darwin2;
GRANT SELECT ON TABLE darwin2.staging_info TO d2viewer;


--
-- TOC entry 6576 (class 0 OID 0)
-- Dependencies: 371
-- Name: TABLE staging_relationship; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.staging_relationship FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.staging_relationship FROM darwin2;
GRANT ALL ON TABLE darwin2.staging_relationship TO darwin2;
GRANT SELECT ON TABLE darwin2.staging_relationship TO d2viewer;


--
-- TOC entry 6585 (class 0 OID 0)
-- Dependencies: 436
-- Name: SEQUENCE tag_authority_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.tag_authority_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.tag_authority_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.tag_authority_id_seq TO darwin2;


--
-- TOC entry 6587 (class 0 OID 0)
-- Dependencies: 432
-- Name: SEQUENCE tag_group_distinct_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.tag_group_distinct_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.tag_group_distinct_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.tag_group_distinct_id_seq TO darwin2;


--
-- TOC entry 6595 (class 0 OID 0)
-- Dependencies: 377
-- Name: TABLE tags; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.tags FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.tags FROM darwin2;
GRANT ALL ON TABLE darwin2.tags TO darwin2;
GRANT SELECT ON TABLE darwin2.tags TO d2viewer;


--
-- TOC entry 6606 (class 0 OID 0)
-- Dependencies: 380
-- Name: TABLE taxonomy; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.taxonomy FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.taxonomy FROM darwin2;
GRANT ALL ON TABLE darwin2.taxonomy TO darwin2;
GRANT SELECT ON TABLE darwin2.taxonomy TO d2viewer;


--
-- TOC entry 6607 (class 0 OID 0)
-- Dependencies: 445
-- Name: TABLE taxonomy_authority; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON TABLE darwin2.taxonomy_authority FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.taxonomy_authority FROM postgres;
GRANT ALL ON TABLE darwin2.taxonomy_authority TO postgres;
GRANT ALL ON TABLE darwin2.taxonomy_authority TO darwin2;


--
-- TOC entry 6609 (class 0 OID 0)
-- Dependencies: 444
-- Name: SEQUENCE taxonomy_authority_id_seq; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON SEQUENCE darwin2.taxonomy_authority_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.taxonomy_authority_id_seq FROM postgres;
GRANT ALL ON SEQUENCE darwin2.taxonomy_authority_id_seq TO postgres;
GRANT ALL ON SEQUENCE darwin2.taxonomy_authority_id_seq TO darwin2;


--
-- TOC entry 6612 (class 0 OID 0)
-- Dependencies: 426
-- Name: SEQUENCE temporal_information_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.temporal_information_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.temporal_information_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.temporal_information_id_seq TO darwin2;


--
-- TOC entry 6613 (class 0 OID 0)
-- Dependencies: 384
-- Name: TABLE tv_reporting_count_all_specimens_by_collection_year_ig; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.tv_reporting_count_all_specimens_by_collection_year_ig FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.tv_reporting_count_all_specimens_by_collection_year_ig FROM darwin2;
GRANT ALL ON TABLE darwin2.tv_reporting_count_all_specimens_by_collection_year_ig TO darwin2;
GRANT SELECT ON TABLE darwin2.tv_reporting_count_all_specimens_by_collection_year_ig TO d2viewer;


--
-- TOC entry 6614 (class 0 OID 0)
-- Dependencies: 385
-- Name: TABLE tv_reporting_count_all_specimens_type_by_collection_ref_year_ig; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.tv_reporting_count_all_specimens_type_by_collection_ref_year_ig FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.tv_reporting_count_all_specimens_type_by_collection_ref_year_ig FROM darwin2;
GRANT ALL ON TABLE darwin2.tv_reporting_count_all_specimens_type_by_collection_ref_year_ig TO darwin2;
GRANT SELECT ON TABLE darwin2.tv_reporting_count_all_specimens_type_by_collection_ref_year_ig TO d2viewer;


--
-- TOC entry 6615 (class 0 OID 0)
-- Dependencies: 386
-- Name: TABLE tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig FROM darwin2;
GRANT ALL ON TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig TO darwin2;
GRANT SELECT ON TABLE darwin2.tv_reporting_taxa_in_specimen_per_rank_collection_ref_year_ig TO d2viewer;


--
-- TOC entry 6616 (class 0 OID 0)
-- Dependencies: 389
-- Name: SEQUENCE users_addresses_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.users_addresses_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.users_addresses_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.users_addresses_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.users_addresses_id_seq TO d2viewer;


--
-- TOC entry 6630 (class 0 OID 0)
-- Dependencies: 390
-- Name: TABLE users_addresses; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.users_addresses FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.users_addresses FROM darwin2;
GRANT ALL ON TABLE darwin2.users_addresses TO darwin2;
GRANT SELECT,INSERT ON TABLE darwin2.users_addresses TO d2viewer;


--
-- TOC entry 6631 (class 0 OID 0)
-- Dependencies: 394
-- Name: SEQUENCE users_login_info_id_seq; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON SEQUENCE darwin2.users_login_info_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.users_login_info_id_seq FROM darwin2;
GRANT ALL ON SEQUENCE darwin2.users_login_info_id_seq TO darwin2;
GRANT USAGE ON SEQUENCE darwin2.users_login_info_id_seq TO d2viewer;


--
-- TOC entry 6639 (class 0 OID 0)
-- Dependencies: 395
-- Name: TABLE users_login_infos; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.users_login_infos FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.users_login_infos FROM darwin2;
GRANT ALL ON TABLE darwin2.users_login_infos TO darwin2;
GRANT SELECT,INSERT ON TABLE darwin2.users_login_infos TO d2viewer;


--
-- TOC entry 6647 (class 0 OID 0)
-- Dependencies: 397
-- Name: TABLE users_tracking; Type: ACL; Schema: darwin2; Owner: darwin2
--

REVOKE ALL ON TABLE darwin2.users_tracking FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.users_tracking FROM darwin2;
GRANT ALL ON TABLE darwin2.users_tracking TO darwin2;
GRANT SELECT ON TABLE darwin2.users_tracking TO d2viewer;


--
-- TOC entry 6655 (class 0 OID 0)
-- Dependencies: 400
-- Name: TABLE vernacular_names; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON TABLE darwin2.vernacular_names FROM PUBLIC;
REVOKE ALL ON TABLE darwin2.vernacular_names FROM postgres;
GRANT ALL ON TABLE darwin2.vernacular_names TO postgres;
GRANT SELECT ON TABLE darwin2.vernacular_names TO d2viewer;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.vernacular_names TO cebmpad;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE darwin2.vernacular_names TO darwin2;


--
-- TOC entry 6657 (class 0 OID 0)
-- Dependencies: 419
-- Name: SEQUENCE vernacular_names_id_seq; Type: ACL; Schema: darwin2; Owner: postgres
--

REVOKE ALL ON SEQUENCE darwin2.vernacular_names_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE darwin2.vernacular_names_id_seq FROM postgres;
GRANT ALL ON SEQUENCE darwin2.vernacular_names_id_seq TO postgres;
GRANT SELECT,USAGE ON SEQUENCE darwin2.vernacular_names_id_seq TO cebmpad;
GRANT SELECT,USAGE ON SEQUENCE darwin2.vernacular_names_id_seq TO darwin2;


--
-- TOC entry 6658 (class 0 OID 0)
-- Dependencies: 425
-- Name: TABLE labeling; Type: ACL; Schema: public; Owner: darwin2
--

REVOKE ALL ON TABLE public.labeling FROM PUBLIC;
REVOKE ALL ON TABLE public.labeling FROM darwin2;
GRANT ALL ON TABLE public.labeling TO darwin2;
GRANT SELECT ON TABLE public.labeling TO d2viewer;


--
-- TOC entry 4184 (class 826 OID 5303521)
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: darwin2; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA darwin2 REVOKE ALL ON SEQUENCES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA darwin2 REVOKE ALL ON SEQUENCES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA darwin2 GRANT ALL ON SEQUENCES  TO darwin2;


--
-- TOC entry 4185 (class 826 OID 5303522)
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: darwin2; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA darwin2 REVOKE ALL ON FUNCTIONS  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA darwin2 REVOKE ALL ON FUNCTIONS  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA darwin2 GRANT ALL ON FUNCTIONS  TO darwin2;


--
-- TOC entry 4186 (class 826 OID 5303523)
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: darwin2; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA darwin2 REVOKE ALL ON TABLES  FROM PUBLIC;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA darwin2 REVOKE ALL ON TABLES  FROM postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA darwin2 GRANT ALL ON TABLES  TO darwin2;


-- Completed on 2019-02-28 19:49:52

--
-- PostgreSQL database dump complete
--

